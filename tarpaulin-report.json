{"files":[{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","attrs.rs"],"content":"use crate::util::ExpectLit;\nuse syn::{punctuated::Punctuated, spanned::Spanned as _, Attribute, LitStr, Meta, Token};\n\n#[derive(Default)]\npub(super) struct ContainerAttributes {\n\tpub(super) rename: Option<LitStr>,\n\tpub(super) rename_all: Option<LitStr>,\n\tpub(super) tag: Option<LitStr>,\n\tpub(super) content: Option<LitStr>,\n\tpub(super) untagged: bool\n}\n\npub(super) fn parse_container_attrs(\n\tinput: &Attribute,\n\tattrs: &mut ContainerAttributes,\n\terror_on_unknown: bool\n) -> syn::Result<()> {\n\tlet tokens: Punctuated<Meta, Token![,]> = input.parse_args_with(Punctuated::parse_terminated)?;\n\tfor token in tokens {\n\t\tmatch token {\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"rename\") => {\n\t\t\t\tattrs.rename = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"rename_all\") => {\n\t\t\t\tattrs.rename_all = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"tag\") => {\n\t\t\t\tattrs.tag = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"content\") => {\n\t\t\t\tattrs.content = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::Path(path) if path.is_ident(\"untagged\") => {\n\t\t\t\tattrs.untagged = true;\n\t\t\t},\n\n\t\t\tMeta::Path(path) if error_on_unknown => return Err(syn::Error::new(path.span(), \"Unexpected token\")),\n\t\t\tMeta::List(list) if error_on_unknown => return Err(syn::Error::new(list.span(), \"Unexpected token\")),\n\t\t\tMeta::NameValue(kv) if error_on_unknown => return Err(syn::Error::new(kv.path.span(), \"Unexpected token\")),\n\t\t\t_ => {}\n\t\t}\n\t}\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","codegen.rs"],"content":"use crate::parser::{ParseData, ParseDataType};\nuse proc_macro2::TokenStream;\nuse quote::quote;\nuse syn::LitStr;\n\nimpl ParseData {\n\tpub(super) fn gen_schema(&self) -> TokenStream {\n\t\tmatch self {\n\t\t\tSelf::Struct(fields) => gen_struct(fields),\n\t\t\tSelf::Enum(variants) => gen_enum(variants),\n\t\t\tSelf::Alternatives(alt) => gen_alt(alt),\n\t\t\tSelf::Unit => gen_unit()\n\t\t}\n\t}\n}\n\nfn gen_struct(fields: &[(LitStr, ParseDataType)]) -> TokenStream {\n\tlet field_name = fields.iter().map(|(name, _)| name);\n\tlet field_schema = fields.iter().map(|(_, ty)| match ty {\n\t\tParseDataType::Type(ty) => {\n\t\t\tquote!(<#ty as ::openapi_type::OpenapiType>::schema())\n\t\t},\n\t\tParseDataType::Inline(data) => {\n\t\t\tlet code = data.gen_schema();\n\t\t\tquote!(::openapi_type::OpenapiSchema::new(#code))\n\t\t}\n\t});\n\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t{\n\t\t\tlet mut properties = <::openapi_type::indexmap::IndexMap<\n\t\t\t\t::std::string::String,\n\t\t\t\t#openapi::ReferenceOr<::std::boxed::Box<#openapi::Schema>>\n\t\t\t>>::new();\n\t\t\tlet mut required = <::std::vec::Vec<::std::string::String>>::new();\n\n\t\t\t#({\n\t\t\t\t\tconst FIELD_NAME: &::core::primitive::str = #field_name;\n\t\t\t\t\tlet mut field_schema = #field_schema;\n\t\t\t\t\t::openapi_type::private::add_dependencies(\n\t\t\t\t\t\t&mut dependencies,\n\t\t\t\t\t\t&mut field_schema.dependencies\n\t\t\t\t\t);\n\n\t\t\t\t\t// fields in OpenAPI are nullable by default\n\t\t\t\t\tmatch field_schema.nullable {\n\t\t\t\t\t\ttrue => field_schema.nullable = false,\n\t\t\t\t\t\tfalse => required.push(::std::string::String::from(FIELD_NAME))\n\t\t\t\t\t};\n\n\t\t\t\t\tmatch field_schema.name.as_ref() {\n\t\t\t\t\t\t// include the field schema as reference\n\t\t\t\t\t\t::std::option::Option::Some(schema_name) => {\n\t\t\t\t\t\t\tlet mut reference = ::std::string::String::from(\"#/components/schemas/\");\n\t\t\t\t\t\t\treference.push_str(schema_name);\n\t\t\t\t\t\t\tproperties.insert(\n\t\t\t\t\t\t\t\t::std::string::String::from(FIELD_NAME),\n\t\t\t\t\t\t\t\t#openapi::ReferenceOr::Reference { reference }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdependencies.insert(\n\t\t\t\t\t\t\t\t::std::string::String::from(schema_name),\n\t\t\t\t\t\t\t\tfield_schema\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t// inline the field schema\n\t\t\t\t\t\t::std::option::Option::None => {\n\t\t\t\t\t\t\tproperties.insert(\n\t\t\t\t\t\t\t\t::std::string::String::from(FIELD_NAME),\n\t\t\t\t\t\t\t\t#openapi::ReferenceOr::Item(\n\t\t\t\t\t\t\t\t\t::std::boxed::Box::new(\n\t\t\t\t\t\t\t\t\t\tfield_schema.into_schema()\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t})*\n\n\t\t\t#openapi::SchemaKind::Type(\n\t\t\t\t#openapi::Type::Object(\n\t\t\t\t\t#openapi::ObjectType {\n\t\t\t\t\t\tproperties,\n\t\t\t\t\t\trequired,\n\t\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}\n}\n\nfn gen_enum(variants: &[LitStr]) -> TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t{\n\t\t\tlet mut enumeration = <::std::vec::Vec<::std::string::String>>::new();\n\t\t\t#(enumeration.push(::std::string::String::from(#variants));)*\n\t\t\t#openapi::SchemaKind::Type(\n\t\t\t\t#openapi::Type::String(\n\t\t\t\t\t#openapi::StringType {\n\t\t\t\t\t\tenumeration,\n\t\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}\n}\n\nfn gen_alt(alt: &[ParseData]) -> TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tlet schema = alt.iter().map(|data| data.gen_schema());\n\tquote! {\n\t\t{\n\t\t\tlet mut alternatives = <::std::vec::Vec<\n\t\t\t\t#openapi::ReferenceOr<#openapi::Schema>\n\t\t\t>>::new();\n\t\t\t#(alternatives.push(#openapi::ReferenceOr::Item(\n\t\t\t\t::openapi_type::OpenapiSchema::new(#schema).into_schema()\n\t\t\t));)*\n\t\t\t#openapi::SchemaKind::OneOf {\n\t\t\t\tone_of: alternatives\n\t\t\t}\n\t\t}\n\t}\n}\n\nfn gen_unit() -> TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t#openapi::SchemaKind::Type(\n\t\t\t#openapi::Type::Object(\n\t\t\t\t#openapi::ObjectType {\n\t\t\t\t\tadditional_properties: ::std::option::Option::Some(\n\t\t\t\t\t\t#openapi::AdditionalProperties::Any(false)\n\t\t\t\t\t),\n\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t}\n\t\t\t)\n\t\t)\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms)]\n#![deny(broken_intra_doc_links)]\n#![forbid(unsafe_code)]\n//! This crate defines the macros for `#[derive(OpenapiType)]`.\n\nuse proc_macro::TokenStream;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::quote;\nuse syn::{parse_macro_input, Data, DeriveInput, LitStr, TraitBound, TraitBoundModifier, TypeParamBound};\n\n// unfortunately, the serde_derive_internals crate does not make\n// `case::RenameRule` available\nmod serde_derive_internals;\n\n#[macro_use]\nmod util;\n\nmod attrs;\nuse attrs::*;\nmod codegen;\nmod parser;\nuse parser::*;\n\n/// The derive macro for [OpenapiType](https://docs.rs/openapi_type/*/openapi_type/trait.OpenapiType.html).\n#[proc_macro_derive(OpenapiType, attributes(openapi))]\npub fn derive_openapi_type(input: TokenStream) -> TokenStream {\n\tlet input = parse_macro_input!(input);\n\texpand_openapi_type(input).unwrap_or_else(|err| err.to_compile_error()).into()\n}\n\nfn expand_openapi_type(mut input: DeriveInput) -> syn::Result<TokenStream2> {\n\t// parse #[serde] and #[openapi] attributes\n\tlet mut attrs = ContainerAttributes::default();\n\tfor attr in &input.attrs {\n\t\tif attr.path.is_ident(\"serde\") {\n\t\t\tparse_container_attrs(attr, &mut attrs, false)?;\n\t\t}\n\t}\n\tfor attr in &input.attrs {\n\t\tif attr.path.is_ident(\"openapi\") {\n\t\t\tparse_container_attrs(attr, &mut attrs, true)?;\n\t\t}\n\t}\n\n\t// prepare impl block for codegen\n\tlet ident = &input.ident;\n\tlet name = ident.to_string();\n\tlet mut name = LitStr::new(&name, ident.span());\n\tif let Some(rename) = &attrs.rename {\n\t\tname = rename.clone();\n\t}\n\n\t// prepare the generics - all impl generics will get `OpenapiType` requirement\n\tlet (impl_generics, ty_generics, where_clause) = {\n\t\tlet generics = &mut input.generics;\n\t\tgenerics.type_params_mut().for_each(|param| {\n\t\t\tparam.colon_token.get_or_insert_with(Default::default);\n\t\t\tparam.bounds.push(TypeParamBound::Trait(TraitBound {\n\t\t\t\tparen_token: None,\n\t\t\t\tmodifier: TraitBoundModifier::None,\n\t\t\t\tlifetimes: None,\n\t\t\t\tpath: path!(::openapi_type::OpenapiType)\n\t\t\t}));\n\t\t});\n\t\tgenerics.split_for_impl()\n\t};\n\n\t// parse the input data\n\tlet parsed = match &input.data {\n\t\tData::Struct(strukt) => parse_struct(strukt, &attrs)?,\n\t\tData::Enum(inum) => parse_enum(inum, &attrs)?,\n\t\tData::Union(union) => parse_union(union)?\n\t};\n\n\t// run the codegen\n\tlet schema_code = parsed.gen_schema();\n\n\t// put the code together\n\tOk(quote! {\n\t\t#[allow(unused_mut)]\n\t\timpl #impl_generics ::openapi_type::OpenapiType for #ident #ty_generics #where_clause {\n\t\t\tfn schema() -> ::openapi_type::OpenapiSchema {\n\t\t\t\t// prepare the dependencies\n\t\t\t\tlet mut dependencies = ::openapi_type::private::Dependencies::new();\n\n\t\t\t\t// create the schema\n\t\t\t\tlet schema = #schema_code;\n\n\t\t\t\t// return everything\n\t\t\t\tconst NAME: &::core::primitive::str = #name;\n\t\t\t\t::openapi_type::OpenapiSchema {\n\t\t\t\t\tname: ::std::option::Option::Some(::std::string::String::from(NAME)),\n\t\t\t\t\tnullable: false,\n\t\t\t\t\tschema,\n\t\t\t\t\tdependencies\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","parser.rs"],"content":"use crate::{attrs::ContainerAttributes, serde_derive_internals::case::RenameRule, util::ToLitStr};\nuse proc_macro2::Span;\nuse syn::{spanned::Spanned as _, DataEnum, DataStruct, DataUnion, Fields, FieldsNamed, LitStr, Type};\n\npub(super) enum ParseDataType {\n\tType(Type),\n\tInline(ParseData)\n}\n\n#[allow(dead_code)]\npub(super) enum ParseData {\n\tStruct(Vec<(LitStr, ParseDataType)>),\n\tEnum(Vec<LitStr>),\n\tAlternatives(Vec<ParseData>),\n\tUnit\n}\n\nfn parse_named_fields(named_fields: &FieldsNamed, rename_all: Option<&LitStr>) -> syn::Result<ParseData> {\n\tlet mut fields: Vec<(LitStr, ParseDataType)> = Vec::new();\n\tfor f in &named_fields.named {\n\t\tlet ident = f\n\t\t\t.ident\n\t\t\t.as_ref()\n\t\t\t.ok_or_else(|| syn::Error::new(f.span(), \"#[derive(OpenapiType)] does not support fields without an ident\"))?;\n\t\tlet mut name = ident.to_lit_str();\n\t\tif let Some(rename_all) = rename_all {\n\t\t\tlet rule: RenameRule = rename_all\n\t\t\t\t.value()\n\t\t\t\t.parse()\n\t\t\t\t.map_err(|_| syn::Error::new(rename_all.span(), \"Unknown rename_all rule\"))?;\n\t\t\tlet rename = rule.apply_to_field(&name.value());\n\t\t\tname = LitStr::new(&rename, name.span());\n\t\t}\n\t\tlet ty = f.ty.to_owned();\n\t\tfields.push((name, ParseDataType::Type(ty)));\n\t}\n\tOk(ParseData::Struct(fields))\n}\n\npub(super) fn parse_struct(strukt: &DataStruct, attrs: &ContainerAttributes) -> syn::Result<ParseData> {\n\tmatch &strukt.fields {\n\t\tFields::Named(named_fields) => parse_named_fields(named_fields, attrs.rename_all.as_ref()),\n\t\tFields::Unnamed(unnamed_fields) => Err(syn::Error::new(\n\t\t\tunnamed_fields.span(),\n\t\t\t\"#[derive(OpenapiType)] does not support tuple structs\"\n\t\t)),\n\t\tFields::Unit => Ok(ParseData::Unit)\n\t}\n}\n\npub(super) fn parse_enum(inum: &DataEnum, attrs: &ContainerAttributes) -> syn::Result<ParseData> {\n\tlet mut strings: Vec<LitStr> = Vec::new();\n\tlet mut types: Vec<(LitStr, ParseData)> = Vec::new();\n\n\tfor v in &inum.variants {\n\t\tlet name = v.ident.to_lit_str();\n\t\tmatch &v.fields {\n\t\t\tFields::Named(named_fields) => {\n\t\t\t\ttypes.push((name, parse_named_fields(named_fields, attrs.rename_all.as_ref())?));\n\t\t\t},\n\t\t\tFields::Unnamed(unnamed_fields) => {\n\t\t\t\treturn Err(syn::Error::new(\n\t\t\t\t\tunnamed_fields.span(),\n\t\t\t\t\t\"#[derive(OpenapiType)] does not support tuple variants\"\n\t\t\t\t))\n\t\t\t},\n\t\t\tFields::Unit => strings.push(name)\n\t\t}\n\t}\n\n\tlet data_strings = if strings.is_empty() {\n\t\tNone\n\t} else {\n\t\tmatch (&attrs.tag, &attrs.content, attrs.untagged) {\n\t\t\t// externally tagged (default)\n\t\t\t(None, None, false) => Some(ParseData::Enum(strings)),\n\t\t\t// internally tagged or adjacently tagged\n\t\t\t(Some(tag), _, false) => Some(ParseData::Struct(vec![(\n\t\t\t\ttag.clone(),\n\t\t\t\tParseDataType::Inline(ParseData::Enum(strings))\n\t\t\t)])),\n\t\t\t// untagged\n\t\t\t(None, None, true) => Some(ParseData::Unit),\n\t\t\t// unknown\n\t\t\t_ => return Err(syn::Error::new(Span::call_site(), \"Unknown enum representation\"))\n\t\t}\n\t};\n\n\tlet data_types =\n\t\tif types.is_empty() {\n\t\t\tNone\n\t\t} else {\n\t\t\tSome(ParseData::Alternatives(\n\t\t\t\ttypes\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|(name, mut data)| {\n\t\t\t\t\t\tOk(match (&attrs.tag, &attrs.content, attrs.untagged) {\n\t\t\t\t\t\t\t// externally tagged (default)\n\t\t\t\t\t\t\t(None, None, false) => ParseData::Struct(vec![(name, ParseDataType::Inline(data))]),\n\t\t\t\t\t\t\t// internally tagged\n\t\t\t\t\t\t\t(Some(tag), None, false) => {\n\t\t\t\t\t\t\t\tmatch &mut data {\n\t\t\t\t\t\t\t\t\tParseData::Struct(fields) => {\n\t\t\t\t\t\t\t\t\t\tfields.push((tag.clone(), ParseDataType::Inline(ParseData::Enum(vec![name]))))\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t_ => return Err(syn::Error::new(\n\t\t\t\t\t\t\t\t\t\ttag.span(),\n\t\t\t\t\t\t\t\t\t\t\"#[derive(OpenapiType)] does not support tuple variants on internally tagged enums\"\n\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t// adjacently tagged\n\t\t\t\t\t\t\t(Some(tag), Some(content), false) => ParseData::Struct(vec![\n\t\t\t\t\t\t\t\t(tag.clone(), ParseDataType::Inline(ParseData::Enum(vec![name]))),\n\t\t\t\t\t\t\t\t(content.clone(), ParseDataType::Inline(data)),\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t// untagged\n\t\t\t\t\t\t\t(None, None, true) => data,\n\t\t\t\t\t\t\t// unknown\n\t\t\t\t\t\t\t_ => return Err(syn::Error::new(Span::call_site(), \"Unknown enum representation\"))\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t\t.collect::<syn::Result<Vec<_>>>()?\n\t\t\t))\n\t\t};\n\n\tmatch (data_strings, data_types) {\n\t\t// only variants without fields\n\t\t(Some(data), None) => Ok(data),\n\t\t// only one variant with fields\n\t\t(None, Some(ParseData::Alternatives(mut alt))) if alt.len() == 1 => Ok(alt.remove(0)),\n\t\t// only variants with fields\n\t\t(None, Some(data)) => Ok(data),\n\t\t// variants with and without fields\n\t\t(Some(data), Some(ParseData::Alternatives(mut alt))) => {\n\t\t\talt.push(data);\n\t\t\tOk(ParseData::Alternatives(alt))\n\t\t},\n\t\t// no variants\n\t\t(None, None) => Err(syn::Error::new(\n\t\t\tinum.brace_token.span,\n\t\t\t\"#[derive(OpenapiType)] does not support enums with no variants\"\n\t\t)),\n\t\t// data_types always produces Alternatives\n\t\t_ => unreachable!()\n\t}\n}\n\npub(super) fn parse_union(union: &DataUnion) -> syn::Result<ParseData> {\n\tErr(syn::Error::new(\n\t\tunion.union_token.span(),\n\t\t\"#[derive(OpenapiType)] cannot be used on unions\"\n\t))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","serde_derive_internals","case.rs"],"content":"//! Code to convert the Rust-styled field/variant (e.g. `my_field`, `MyType`) to the\n//! case of the source (e.g. `my-field`, `MY_FIELD`).\n\n// See https://users.rust-lang.org/t/psa-dealing-with-warning-unused-import-std-ascii-asciiext-in-today-s-nightly/13726\n#[allow(deprecated, unused_imports)]\nuse std::ascii::AsciiExt;\n\nuse std::str::FromStr;\n\nuse self::RenameRule::*;\n\n/// The different possible ways to change case of fields in a struct, or variants in an enum.\n#[derive(Copy, Clone, PartialEq)]\npub enum RenameRule {\n    /// Don't apply a default rename rule.\n    None,\n    /// Rename direct children to \"lowercase\" style.\n    LowerCase,\n    /// Rename direct children to \"UPPERCASE\" style.\n    UPPERCASE,\n    /// Rename direct children to \"PascalCase\" style, as typically used for\n    /// enum variants.\n    PascalCase,\n    /// Rename direct children to \"camelCase\" style.\n    CamelCase,\n    /// Rename direct children to \"snake_case\" style, as commonly used for\n    /// fields.\n    SnakeCase,\n    /// Rename direct children to \"SCREAMING_SNAKE_CASE\" style, as commonly\n    /// used for constants.\n    ScreamingSnakeCase,\n    /// Rename direct children to \"kebab-case\" style.\n    KebabCase,\n    /// Rename direct children to \"SCREAMING-KEBAB-CASE\" style.\n    ScreamingKebabCase,\n}\n\nimpl RenameRule {\n    /// Apply a renaming rule to an enum variant, returning the version expected in the source.\n    pub fn apply_to_variant(&self, variant: &str) -> String {\n        match *self {\n            None | PascalCase => variant.to_owned(),\n            LowerCase => variant.to_ascii_lowercase(),\n            UPPERCASE => variant.to_ascii_uppercase(),\n            CamelCase => variant[..1].to_ascii_lowercase() + &variant[1..],\n            SnakeCase => {\n                let mut snake = String::new();\n                for (i, ch) in variant.char_indices() {\n                    if i > 0 && ch.is_uppercase() {\n                        snake.push('_');\n                    }\n                    snake.push(ch.to_ascii_lowercase());\n                }\n                snake\n            }\n            ScreamingSnakeCase => SnakeCase.apply_to_variant(variant).to_ascii_uppercase(),\n            KebabCase => SnakeCase.apply_to_variant(variant).replace('_', \"-\"),\n            ScreamingKebabCase => ScreamingSnakeCase\n                .apply_to_variant(variant)\n                .replace('_', \"-\"),\n        }\n    }\n\n    /// Apply a renaming rule to a struct field, returning the version expected in the source.\n    pub fn apply_to_field(&self, field: &str) -> String {\n        match *self {\n            None | LowerCase | SnakeCase => field.to_owned(),\n            UPPERCASE => field.to_ascii_uppercase(),\n            PascalCase => {\n                let mut pascal = String::new();\n                let mut capitalize = true;\n                for ch in field.chars() {\n                    if ch == '_' {\n                        capitalize = true;\n                    } else if capitalize {\n                        pascal.push(ch.to_ascii_uppercase());\n                        capitalize = false;\n                    } else {\n                        pascal.push(ch);\n                    }\n                }\n                pascal\n            }\n            CamelCase => {\n                let pascal = PascalCase.apply_to_field(field);\n                pascal[..1].to_ascii_lowercase() + &pascal[1..]\n            }\n            ScreamingSnakeCase => field.to_ascii_uppercase(),\n            KebabCase => field.replace('_', \"-\"),\n            ScreamingKebabCase => ScreamingSnakeCase.apply_to_field(field).replace('_', \"-\"),\n        }\n    }\n}\n\nimpl FromStr for RenameRule {\n    type Err = ();\n\n    fn from_str(rename_all_str: &str) -> Result<Self, Self::Err> {\n        match rename_all_str {\n            \"lowercase\" => Ok(LowerCase),\n            \"UPPERCASE\" => Ok(UPPERCASE),\n            \"PascalCase\" => Ok(PascalCase),\n            \"camelCase\" => Ok(CamelCase),\n            \"snake_case\" => Ok(SnakeCase),\n            \"SCREAMING_SNAKE_CASE\" => Ok(ScreamingSnakeCase),\n            \"kebab-case\" => Ok(KebabCase),\n            \"SCREAMING-KEBAB-CASE\" => Ok(ScreamingKebabCase),\n            _ => Err(()),\n        }\n    }\n}\n\n#[test]\nfn rename_variants() {\n    for &(original, lower, upper, camel, snake, screaming, kebab, screaming_kebab) in &[\n        (\n            \"Outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"OUTCOME\",\n        ),\n        (\n            \"VeryTasty\",\n            \"verytasty\",\n            \"VERYTASTY\",\n            \"veryTasty\",\n            \"very_tasty\",\n            \"VERY_TASTY\",\n            \"very-tasty\",\n            \"VERY-TASTY\",\n        ),\n        (\"A\", \"a\", \"A\", \"a\", \"a\", \"A\", \"a\", \"A\"),\n        (\"Z42\", \"z42\", \"Z42\", \"z42\", \"z42\", \"Z42\", \"z42\", \"Z42\"),\n    ] {\n        assert_eq!(None.apply_to_variant(original), original);\n        assert_eq!(LowerCase.apply_to_variant(original), lower);\n        assert_eq!(UPPERCASE.apply_to_variant(original), upper);\n        assert_eq!(PascalCase.apply_to_variant(original), original);\n        assert_eq!(CamelCase.apply_to_variant(original), camel);\n        assert_eq!(SnakeCase.apply_to_variant(original), snake);\n        assert_eq!(ScreamingSnakeCase.apply_to_variant(original), screaming);\n        assert_eq!(KebabCase.apply_to_variant(original), kebab);\n        assert_eq!(\n            ScreamingKebabCase.apply_to_variant(original),\n            screaming_kebab\n        );\n    }\n}\n\n#[test]\nfn rename_fields() {\n    for &(original, upper, pascal, camel, screaming, kebab, screaming_kebab) in &[\n        (\n            \"outcome\", \"OUTCOME\", \"Outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"OUTCOME\",\n        ),\n        (\n            \"very_tasty\",\n            \"VERY_TASTY\",\n            \"VeryTasty\",\n            \"veryTasty\",\n            \"VERY_TASTY\",\n            \"very-tasty\",\n            \"VERY-TASTY\",\n        ),\n        (\"a\", \"A\", \"A\", \"a\", \"A\", \"a\", \"A\"),\n        (\"z42\", \"Z42\", \"Z42\", \"z42\", \"Z42\", \"z42\", \"Z42\"),\n    ] {\n        assert_eq!(None.apply_to_field(original), original);\n        assert_eq!(UPPERCASE.apply_to_field(original), upper);\n        assert_eq!(PascalCase.apply_to_field(original), pascal);\n        assert_eq!(CamelCase.apply_to_field(original), camel);\n        assert_eq!(SnakeCase.apply_to_field(original), original);\n        assert_eq!(ScreamingSnakeCase.apply_to_field(original), screaming);\n        assert_eq!(KebabCase.apply_to_field(original), kebab);\n        assert_eq!(ScreamingKebabCase.apply_to_field(original), screaming_kebab);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","serde_derive_internals","mod.rs"],"content":"#[allow(dead_code)]\npub(super) mod case;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","util.rs"],"content":"use proc_macro2::Ident;\nuse syn::{Lit, LitStr};\n\n/// Convert any literal path into a [syn::Path].\nmacro_rules! path {\n\t(:: $($segment:ident)::*) => {\n\t\tpath!(@private Some(Default::default()), $($segment),*)\n\t};\n\t($($segment:ident)::*) => {\n\t\tpath!(@private None, $($segment),*)\n\t};\n\t(@private $leading_colon:expr, $($segment:ident),*) => {\n\t\t{\n\t\t\t#[allow(unused_mut)]\n\t\t\tlet mut segments: ::syn::punctuated::Punctuated<::syn::PathSegment, _> = Default::default();\n\t\t\t$(\n\t\t\t\tsegments.push(::syn::PathSegment {\n\t\t\t\t\tident: ::proc_macro2::Ident::new(stringify!($segment), ::proc_macro2::Span::call_site()),\n\t\t\t\t\targuments: Default::default()\n\t\t\t\t});\n\t\t\t)*\n\t\t\t::syn::Path {\n\t\t\t\tleading_colon: $leading_colon,\n\t\t\t\tsegments\n\t\t\t}\n\t\t}\n\t};\n}\n\n/// Convert any [Ident] into a [LitStr]. Basically `stringify!`.\npub(super) trait ToLitStr {\n\tfn to_lit_str(&self) -> LitStr;\n}\nimpl ToLitStr for Ident {\n\tfn to_lit_str(&self) -> LitStr {\n\t\tLitStr::new(&self.to_string(), self.span())\n\t}\n}\n\n/// Convert a [Lit] to one specific literal type.\npub(crate) trait ExpectLit {\n\tfn expect_str(self) -> syn::Result<LitStr>;\n}\n\nimpl ExpectLit for Lit {\n\tfn expect_str(self) -> syn::Result<LitStr> {\n\t\tmatch self {\n\t\t\tSelf::Str(str) => Ok(str),\n\t\t\t_ => Err(syn::Error::new(self.span(), \"Expected string literal\"))\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","build.rs"],"content":"use std::env;\nuse std::process::Command;\nuse std::str::{self, FromStr};\n\n// The rustc-cfg strings below are *not* public API. Please let us know by\n// opening a GitHub issue if your build environment requires some way to enable\n// these cfgs other than by executing our build script.\nfn main() {\n    let minor = match rustc_minor_version() {\n        Some(minor) => minor,\n        None => return,\n    };\n\n    let target = env::var(\"TARGET\").unwrap();\n    let emscripten = target == \"asmjs-unknown-emscripten\" || target == \"wasm32-unknown-emscripten\";\n\n    // std::collections::Bound was stabilized in Rust 1.17\n    // but it was moved to core::ops later in Rust 1.26:\n    // https://doc.rust-lang.org/core/ops/enum.Bound.html\n    if minor >= 26 {\n        println!(\"cargo:rustc-cfg=ops_bound\");\n    } else if minor >= 17 && cfg!(feature = \"std\") {\n        println!(\"cargo:rustc-cfg=collections_bound\");\n    }\n\n    // core::cmp::Reverse stabilized in Rust 1.19:\n    // https://doc.rust-lang.org/stable/core/cmp/struct.Reverse.html\n    if minor >= 19 {\n        println!(\"cargo:rustc-cfg=core_reverse\");\n    }\n\n    // CString::into_boxed_c_str stabilized in Rust 1.20:\n    // https://doc.rust-lang.org/std/ffi/struct.CString.html#method.into_boxed_c_str\n    if minor >= 20 {\n        println!(\"cargo:rustc-cfg=de_boxed_c_str\");\n    }\n\n    // From<Box<T>> for Rc<T> / Arc<T> stabilized in Rust 1.21:\n    // https://doc.rust-lang.org/std/rc/struct.Rc.html#impl-From<Box<T>>\n    // https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-From<Box<T>>\n    if minor >= 21 {\n        println!(\"cargo:rustc-cfg=de_rc_dst\");\n    }\n\n    // Duration available in core since Rust 1.25:\n    // https://blog.rust-lang.org/2018/03/29/Rust-1.25.html#library-stabilizations\n    if minor >= 25 {\n        println!(\"cargo:rustc-cfg=core_duration\");\n    }\n\n    // 128-bit integers stabilized in Rust 1.26:\n    // https://blog.rust-lang.org/2018/05/10/Rust-1.26.html\n    //\n    // Disabled on Emscripten targets as Emscripten doesn't\n    // currently support integers larger than 64 bits.\n    if minor >= 26 && !emscripten {\n        println!(\"cargo:rustc-cfg=integer128\");\n    }\n\n    // Inclusive ranges methods stabilized in Rust 1.27:\n    // https://github.com/rust-lang/rust/pull/50758\n    if minor >= 27 {\n        println!(\"cargo:rustc-cfg=range_inclusive\");\n    }\n\n    // Non-zero integers stabilized in Rust 1.28:\n    // https://github.com/rust-lang/rust/pull/50808\n    if minor >= 28 {\n        println!(\"cargo:rustc-cfg=num_nonzero\");\n    }\n\n    // TryFrom, Atomic types, and non-zero signed integers stabilized in Rust 1.34:\n    // https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#tryfrom-and-tryinto\n    // https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#library-stabilizations\n    if minor >= 34 {\n        println!(\"cargo:rustc-cfg=core_try_from\");\n        println!(\"cargo:rustc-cfg=num_nonzero_signed\");\n\n        // Whitelist of archs that support std::sync::atomic module. Ideally we\n        // would use #[cfg(target_has_atomic = \"...\")] but it is not stable yet.\n        // Instead this is based on rustc's src/librustc_target/spec/*.rs.\n        let has_atomic64 = target.starts_with(\"x86_64\")\n            || target.starts_with(\"i686\")\n            || target.starts_with(\"aarch64\")\n            || target.starts_with(\"powerpc64\")\n            || target.starts_with(\"sparc64\")\n            || target.starts_with(\"mips64el\");\n        let has_atomic32 = has_atomic64 || emscripten;\n        if has_atomic64 {\n            println!(\"cargo:rustc-cfg=std_atomic64\");\n        }\n        if has_atomic32 {\n            println!(\"cargo:rustc-cfg=std_atomic\");\n        }\n    }\n}\n\nfn rustc_minor_version() -> Option<u32> {\n    let rustc = match env::var_os(\"RUSTC\") {\n        Some(rustc) => rustc,\n        None => return None,\n    };\n\n    let output = match Command::new(rustc).arg(\"--version\").output() {\n        Ok(output) => output,\n        Err(_) => return None,\n    };\n\n    let version = match str::from_utf8(&output.stdout) {\n        Ok(version) => version,\n        Err(_) => return None,\n    };\n\n    let mut pieces = version.split('.');\n    if pieces.next() != Some(\"rustc 1\") {\n        return None;\n    }\n\n    let next = match pieces.next() {\n        Some(next) => next,\n        None => return None,\n    };\n\n    u32::from_str(next).ok()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","from_primitive.rs"],"content":"use lib::*;\n\nmacro_rules! int_to_int {\n    ($dst:ident, $n:ident) => {\n        if $dst::min_value() as i64 <= $n as i64 && $n as i64 <= $dst::max_value() as i64 {\n            Some($n as $dst)\n        } else {\n            None\n        }\n    };\n}\n\nmacro_rules! int_to_uint {\n    ($dst:ident, $n:ident) => {\n        if 0 <= $n && $n as u64 <= $dst::max_value() as u64 {\n            Some($n as $dst)\n        } else {\n            None\n        }\n    };\n}\n\nmacro_rules! uint_to {\n    ($dst:ident, $n:ident) => {\n        if $n as u64 <= $dst::max_value() as u64 {\n            Some($n as $dst)\n        } else {\n            None\n        }\n    };\n}\n\npub trait FromPrimitive: Sized {\n    fn from_i8(n: i8) -> Option<Self>;\n    fn from_i16(n: i16) -> Option<Self>;\n    fn from_i32(n: i32) -> Option<Self>;\n    fn from_i64(n: i64) -> Option<Self>;\n    fn from_u8(n: u8) -> Option<Self>;\n    fn from_u16(n: u16) -> Option<Self>;\n    fn from_u32(n: u32) -> Option<Self>;\n    fn from_u64(n: u64) -> Option<Self>;\n}\n\nmacro_rules! impl_from_primitive_for_int {\n    ($t:ident) => {\n        impl FromPrimitive for $t {\n            #[inline]\n            fn from_i8(n: i8) -> Option<Self> {\n                int_to_int!($t, n)\n            }\n            #[inline]\n            fn from_i16(n: i16) -> Option<Self> {\n                int_to_int!($t, n)\n            }\n            #[inline]\n            fn from_i32(n: i32) -> Option<Self> {\n                int_to_int!($t, n)\n            }\n            #[inline]\n            fn from_i64(n: i64) -> Option<Self> {\n                int_to_int!($t, n)\n            }\n            #[inline]\n            fn from_u8(n: u8) -> Option<Self> {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u16(n: u16) -> Option<Self> {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u32(n: u32) -> Option<Self> {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u64(n: u64) -> Option<Self> {\n                uint_to!($t, n)\n            }\n        }\n    };\n}\n\nmacro_rules! impl_from_primitive_for_uint {\n    ($t:ident) => {\n        impl FromPrimitive for $t {\n            #[inline]\n            fn from_i8(n: i8) -> Option<Self> {\n                int_to_uint!($t, n)\n            }\n            #[inline]\n            fn from_i16(n: i16) -> Option<Self> {\n                int_to_uint!($t, n)\n            }\n            #[inline]\n            fn from_i32(n: i32) -> Option<Self> {\n                int_to_uint!($t, n)\n            }\n            #[inline]\n            fn from_i64(n: i64) -> Option<Self> {\n                int_to_uint!($t, n)\n            }\n            #[inline]\n            fn from_u8(n: u8) -> Option<Self> {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u16(n: u16) -> Option<Self> {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u32(n: u32) -> Option<Self> {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u64(n: u64) -> Option<Self> {\n                uint_to!($t, n)\n            }\n        }\n    };\n}\n\nmacro_rules! impl_from_primitive_for_float {\n    ($t:ident) => {\n        impl FromPrimitive for $t {\n            #[inline]\n            fn from_i8(n: i8) -> Option<Self> {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_i16(n: i16) -> Option<Self> {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_i32(n: i32) -> Option<Self> {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_i64(n: i64) -> Option<Self> {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_u8(n: u8) -> Option<Self> {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_u16(n: u16) -> Option<Self> {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_u32(n: u32) -> Option<Self> {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_u64(n: u64) -> Option<Self> {\n                Some(n as Self)\n            }\n        }\n    };\n}\n\nimpl_from_primitive_for_int!(isize);\nimpl_from_primitive_for_int!(i8);\nimpl_from_primitive_for_int!(i16);\nimpl_from_primitive_for_int!(i32);\nimpl_from_primitive_for_int!(i64);\nimpl_from_primitive_for_uint!(usize);\nimpl_from_primitive_for_uint!(u8);\nimpl_from_primitive_for_uint!(u16);\nimpl_from_primitive_for_uint!(u32);\nimpl_from_primitive_for_uint!(u64);\nimpl_from_primitive_for_float!(f32);\nimpl_from_primitive_for_float!(f64);\n\nserde_if_integer128! {\n    impl FromPrimitive for i128 {\n        #[inline]\n        fn from_i8(n: i8) -> Option<Self> {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_i16(n: i16) -> Option<Self> {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_i32(n: i32) -> Option<Self> {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_i64(n: i64) -> Option<Self> {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_u8(n: u8) -> Option<Self> {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_u16(n: u16) -> Option<Self> {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_u32(n: u32) -> Option<Self> {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_u64(n: u64) -> Option<Self> {\n            Some(n as i128)\n        }\n    }\n\n    impl FromPrimitive for u128 {\n        #[inline]\n        fn from_i8(n: i8) -> Option<Self> {\n            if n >= 0 {\n                Some(n as u128)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn from_i16(n: i16) -> Option<Self> {\n            if n >= 0 {\n                Some(n as u128)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn from_i32(n: i32) -> Option<Self> {\n            if n >= 0 {\n                Some(n as u128)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn from_i64(n: i64) -> Option<Self> {\n            if n >= 0 {\n                Some(n as u128)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn from_u8(n: u8) -> Option<Self> {\n            Some(n as u128)\n        }\n        #[inline]\n        fn from_u16(n: u16) -> Option<Self> {\n            Some(n as u128)\n        }\n        #[inline]\n        fn from_u32(n: u32) -> Option<Self> {\n            Some(n as u128)\n        }\n        #[inline]\n        fn from_u64(n: u64) -> Option<Self> {\n            Some(n as u128)\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","ignored_any.rs"],"content":"use lib::*;\n\nuse de::{\n    Deserialize, Deserializer, EnumAccess, Error, MapAccess, SeqAccess, VariantAccess, Visitor,\n};\n\n/// An efficient way of discarding data from a deserializer.\n///\n/// Think of this like `serde_json::Value` in that it can be deserialized from\n/// any type, except that it does not store any information about the data that\n/// gets deserialized.\n///\n/// ```edition2018\n/// use std::fmt;\n/// use std::marker::PhantomData;\n///\n/// use serde::de::{\n///     self, Deserialize, DeserializeSeed, Deserializer, IgnoredAny, SeqAccess, Visitor,\n/// };\n///\n/// /// A seed that can be used to deserialize only the `n`th element of a sequence\n/// /// while efficiently discarding elements of any type before or after index `n`.\n/// ///\n/// /// For example to deserialize only the element at index 3:\n/// ///\n/// /// ```\n/// /// NthElement::new(3).deserialize(deserializer)\n/// /// ```\n/// pub struct NthElement<T> {\n///     n: usize,\n///     marker: PhantomData<T>,\n/// }\n///\n/// impl<T> NthElement<T> {\n///     pub fn new(n: usize) -> Self {\n///         NthElement {\n///             n: n,\n///             marker: PhantomData,\n///         }\n///     }\n/// }\n///\n/// impl<'de, T> Visitor<'de> for NthElement<T>\n/// where\n///     T: Deserialize<'de>,\n/// {\n///     type Value = T;\n///\n///     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n///         write!(\n///             formatter,\n///             \"a sequence in which we care about element {}\",\n///             self.n\n///         )\n///     }\n///\n///     fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n///     where\n///         A: SeqAccess<'de>,\n///     {\n///         // Skip over the first `n` elements.\n///         for i in 0..self.n {\n///             // It is an error if the sequence ends before we get to element `n`.\n///             if seq.next_element::<IgnoredAny>()?.is_none() {\n///                 return Err(de::Error::invalid_length(i, &self));\n///             }\n///         }\n///\n///         // Deserialize the one we care about.\n///         let nth = match seq.next_element()? {\n///             Some(nth) => nth,\n///             None => {\n///                 return Err(de::Error::invalid_length(self.n, &self));\n///             }\n///         };\n///\n///         // Skip over any remaining elements in the sequence after `n`.\n///         while let Some(IgnoredAny) = seq.next_element()? {\n///             // ignore\n///         }\n///\n///         Ok(nth)\n///     }\n/// }\n///\n/// impl<'de, T> DeserializeSeed<'de> for NthElement<T>\n/// where\n///     T: Deserialize<'de>,\n/// {\n///     type Value = T;\n///\n///     fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n///     where\n///         D: Deserializer<'de>,\n///     {\n///         deserializer.deserialize_seq(self)\n///     }\n/// }\n///\n/// # fn example<'de, D>(deserializer: D) -> Result<(), D::Error>\n/// # where\n/// #     D: Deserializer<'de>,\n/// # {\n/// // Deserialize only the sequence element at index 3 from this deserializer.\n/// // The element at index 3 is required to be a string. Elements before and\n/// // after index 3 are allowed to be of any type.\n/// let s: String = NthElement::new(3).deserialize(deserializer)?;\n/// #     Ok(())\n/// # }\n/// ```\n#[derive(Copy, Clone, Debug, Default)]\npub struct IgnoredAny;\n\nimpl<'de> Visitor<'de> for IgnoredAny {\n    type Value = IgnoredAny;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"anything at all\")\n    }\n\n    #[inline]\n    fn visit_bool<E>(self, x: bool) -> Result<Self::Value, E> {\n        let _ = x;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_i64<E>(self, x: i64) -> Result<Self::Value, E> {\n        let _ = x;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_u64<E>(self, x: u64) -> Result<Self::Value, E> {\n        let _ = x;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_f64<E>(self, x: f64) -> Result<Self::Value, E> {\n        let _ = x;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        let _ = s;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_none<E>(self) -> Result<Self::Value, E> {\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        IgnoredAny::deserialize(deserializer)\n    }\n\n    #[inline]\n    fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        IgnoredAny::deserialize(deserializer)\n    }\n\n    #[inline]\n    fn visit_unit<E>(self) -> Result<Self::Value, E> {\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n    where\n        A: SeqAccess<'de>,\n    {\n        while let Some(IgnoredAny) = try!(seq.next_element()) {\n            // Gobble\n        }\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n    where\n        A: MapAccess<'de>,\n    {\n        while let Some((IgnoredAny, IgnoredAny)) = try!(map.next_entry()) {\n            // Gobble\n        }\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_bytes<E>(self, bytes: &[u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        let _ = bytes;\n        Ok(IgnoredAny)\n    }\n\n    fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n    where\n        A: EnumAccess<'de>,\n    {\n        data.variant::<IgnoredAny>()?.1.newtype_variant()\n    }\n}\n\nimpl<'de> Deserialize<'de> for IgnoredAny {\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<IgnoredAny, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_ignored_any(IgnoredAny)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","impls.rs"],"content":"use lib::*;\n\nuse de::{\n    Deserialize, Deserializer, EnumAccess, Error, SeqAccess, Unexpected, VariantAccess, Visitor,\n};\n\n#[cfg(any(core_duration, feature = \"std\", feature = \"alloc\"))]\nuse de::MapAccess;\n\nuse de::from_primitive::FromPrimitive;\nuse private::de::InPlaceSeed;\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse private::de::size_hint;\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct UnitVisitor;\n\nimpl<'de> Visitor<'de> for UnitVisitor {\n    type Value = ();\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"unit\")\n    }\n\n    fn visit_unit<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(())\n    }\n}\n\nimpl<'de> Deserialize<'de> for () {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_unit(UnitVisitor)\n    }\n}\n\n#[cfg(feature = \"unstable\")]\nimpl<'de> Deserialize<'de> for ! {\n    fn deserialize<D>(_deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        Err(Error::custom(\"cannot deserialize `!`\"))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct BoolVisitor;\n\nimpl<'de> Visitor<'de> for BoolVisitor {\n    type Value = bool;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a boolean\")\n    }\n\n    fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n}\n\nimpl<'de> Deserialize<'de> for bool {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_bool(BoolVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! visit_integer_method {\n    ($src_ty:ident, $method:ident, $from_method:ident, $group:ident, $group_ty:ident) => {\n        #[inline]\n        fn $method<E>(self, v: $src_ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            match FromPrimitive::$from_method(v) {\n                Some(v) => Ok(v),\n                None => Err(Error::invalid_value(Unexpected::$group(v as $group_ty), &self)),\n            }\n        }\n    }\n}\n\nmacro_rules! visit_float_method {\n    ($src_ty:ident, $method:ident) => {\n        #[inline]\n        fn $method<E>(self, v: $src_ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(v as Self::Value)\n        }\n    }\n}\n\nmacro_rules! impl_deserialize_num {\n    ($ty:ident, $method:ident, $($visit:ident),*) => {\n        impl<'de> Deserialize<'de> for $ty {\n            #[inline]\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct PrimitiveVisitor;\n\n                impl<'de> Visitor<'de> for PrimitiveVisitor {\n                    type Value = $ty;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(stringify!($ty))\n                    }\n\n                    $(\n                        impl_deserialize_num!($visit $ty);\n                    )*\n                }\n\n                deserializer.$method(PrimitiveVisitor)\n            }\n        }\n    };\n\n    (integer $ty:ident) => {\n        visit_integer_method!(i8, visit_i8, from_i8, Signed, i64);\n        visit_integer_method!(i16, visit_i16, from_i16, Signed, i64);\n        visit_integer_method!(i32, visit_i32, from_i32, Signed, i64);\n        visit_integer_method!(i64, visit_i64, from_i64, Signed, i64);\n\n        visit_integer_method!(u8, visit_u8, from_u8, Unsigned, u64);\n        visit_integer_method!(u16, visit_u16, from_u16, Unsigned, u64);\n        visit_integer_method!(u32, visit_u32, from_u32, Unsigned, u64);\n        visit_integer_method!(u64, visit_u64, from_u64, Unsigned, u64);\n    };\n\n    (float $ty:ident) => {\n        visit_float_method!(f32, visit_f32);\n        visit_float_method!(f64, visit_f64);\n    };\n}\n\nimpl_deserialize_num!(i8, deserialize_i8, integer);\nimpl_deserialize_num!(i16, deserialize_i16, integer);\nimpl_deserialize_num!(i32, deserialize_i32, integer);\nimpl_deserialize_num!(i64, deserialize_i64, integer);\nimpl_deserialize_num!(isize, deserialize_i64, integer);\n\nimpl_deserialize_num!(u8, deserialize_u8, integer);\nimpl_deserialize_num!(u16, deserialize_u16, integer);\nimpl_deserialize_num!(u32, deserialize_u32, integer);\nimpl_deserialize_num!(u64, deserialize_u64, integer);\nimpl_deserialize_num!(usize, deserialize_u64, integer);\n\nimpl_deserialize_num!(f32, deserialize_f32, integer, float);\nimpl_deserialize_num!(f64, deserialize_f64, integer, float);\n\nserde_if_integer128! {\n    impl<'de> Deserialize<'de> for i128 {\n        #[inline]\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            struct PrimitiveVisitor;\n\n            impl<'de> Visitor<'de> for PrimitiveVisitor {\n                type Value = i128;\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(\"i128\")\n                }\n\n                impl_deserialize_num!(integer i128);\n\n                #[inline]\n                fn visit_i128<E>(self, v: i128) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    Ok(v)\n                }\n\n                #[inline]\n                fn visit_u128<E>(self, v: u128) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    if v <= i128::max_value() as u128 {\n                        Ok(v as i128)\n                    } else {\n                        Err(Error::invalid_value(Unexpected::Other(\"u128\"), &self))\n                    }\n                }\n            }\n\n            deserializer.deserialize_i128(PrimitiveVisitor)\n        }\n    }\n\n    impl<'de> Deserialize<'de> for u128 {\n        #[inline]\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            struct PrimitiveVisitor;\n\n            impl<'de> Visitor<'de> for PrimitiveVisitor {\n                type Value = u128;\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(\"u128\")\n                }\n\n                impl_deserialize_num!(integer u128);\n\n                #[inline]\n                fn visit_i128<E>(self, v: i128) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    if v >= 0 {\n                        Ok(v as u128)\n                    } else {\n                        Err(Error::invalid_value(Unexpected::Other(\"i128\"), &self))\n                    }\n                }\n\n                #[inline]\n                fn visit_u128<E>(self, v: u128) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    Ok(v)\n                }\n            }\n\n            deserializer.deserialize_u128(PrimitiveVisitor)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct CharVisitor;\n\nimpl<'de> Visitor<'de> for CharVisitor {\n    type Value = char;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a character\")\n    }\n\n    #[inline]\n    fn visit_char<E>(self, v: char) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    #[inline]\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        let mut iter = v.chars();\n        match (iter.next(), iter.next()) {\n            (Some(c), None) => Ok(c),\n            _ => Err(Error::invalid_value(Unexpected::Str(v), &self)),\n        }\n    }\n}\n\nimpl<'de> Deserialize<'de> for char {\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_char(CharVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nstruct StringVisitor;\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nstruct StringInPlaceVisitor<'a>(&'a mut String);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de> Visitor<'de> for StringVisitor {\n    type Value = String;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a string\")\n    }\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v.to_owned())\n    }\n\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        match str::from_utf8(v) {\n            Ok(s) => Ok(s.to_owned()),\n            Err(_) => Err(Error::invalid_value(Unexpected::Bytes(v), &self)),\n        }\n    }\n\n    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        match String::from_utf8(v) {\n            Ok(s) => Ok(s),\n            Err(e) => Err(Error::invalid_value(\n                Unexpected::Bytes(&e.into_bytes()),\n                &self,\n            )),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, 'de> Visitor<'de> for StringInPlaceVisitor<'a> {\n    type Value = ();\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a string\")\n    }\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.0.clear();\n        self.0.push_str(v);\n        Ok(())\n    }\n\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        *self.0 = v;\n        Ok(())\n    }\n\n    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        match str::from_utf8(v) {\n            Ok(s) => {\n                self.0.clear();\n                self.0.push_str(s);\n                Ok(())\n            }\n            Err(_) => Err(Error::invalid_value(Unexpected::Bytes(v), &self)),\n        }\n    }\n\n    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        match String::from_utf8(v) {\n            Ok(s) => {\n                *self.0 = s;\n                Ok(())\n            }\n            Err(e) => Err(Error::invalid_value(\n                Unexpected::Bytes(&e.into_bytes()),\n                &self,\n            )),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de> Deserialize<'de> for String {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_string(StringVisitor)\n    }\n\n    fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_string(StringInPlaceVisitor(place))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct StrVisitor;\n\nimpl<'a> Visitor<'a> for StrVisitor {\n    type Value = &'a str;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a borrowed string\")\n    }\n\n    fn visit_borrowed_str<E>(self, v: &'a str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v) // so easy\n    }\n\n    fn visit_borrowed_bytes<E>(self, v: &'a [u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        str::from_utf8(v).map_err(|_| Error::invalid_value(Unexpected::Bytes(v), &self))\n    }\n}\n\nimpl<'de: 'a, 'a> Deserialize<'de> for &'a str {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_str(StrVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct BytesVisitor;\n\nimpl<'a> Visitor<'a> for BytesVisitor {\n    type Value = &'a [u8];\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a borrowed byte array\")\n    }\n\n    fn visit_borrowed_bytes<E>(self, v: &'a [u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    fn visit_borrowed_str<E>(self, v: &'a str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v.as_bytes())\n    }\n}\n\nimpl<'de: 'a, 'a> Deserialize<'de> for &'a [u8] {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_bytes(BytesVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nstruct CStringVisitor;\n\n#[cfg(feature = \"std\")]\nimpl<'de> Visitor<'de> for CStringVisitor {\n    type Value = CString;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"byte array\")\n    }\n\n    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n    where\n        A: SeqAccess<'de>,\n    {\n        let len = size_hint::cautious(seq.size_hint());\n        let mut values = Vec::with_capacity(len);\n\n        while let Some(value) = try!(seq.next_element()) {\n            values.push(value);\n        }\n\n        CString::new(values).map_err(Error::custom)\n    }\n\n    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n\n    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl<'de> Deserialize<'de> for CString {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_byte_buf(CStringVisitor)\n    }\n}\n\nmacro_rules! forwarded_impl {\n    (\n        $(#[doc = $doc:tt])*\n        ( $($id: ident),* ), $ty: ty, $func: expr\n    ) => {\n        $(#[doc = $doc])*\n        impl<'de $(, $id : Deserialize<'de>,)*> Deserialize<'de> for $ty {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                Deserialize::deserialize(deserializer).map($func)\n            }\n        }\n    }\n}\n\n#[cfg(all(feature = \"std\", de_boxed_c_str))]\nforwarded_impl!((), Box<CStr>, CString::into_boxed_c_str);\n\n#[cfg(core_reverse)]\nforwarded_impl!((T), Reverse<T>, Reverse);\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct OptionVisitor<T> {\n    marker: PhantomData<T>,\n}\n\nimpl<'de, T> Visitor<'de> for OptionVisitor<T>\nwhere\n    T: Deserialize<'de>,\n{\n    type Value = Option<T>;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"option\")\n    }\n\n    #[inline]\n    fn visit_unit<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(None)\n    }\n\n    #[inline]\n    fn visit_none<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(None)\n    }\n\n    #[inline]\n    fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Some)\n    }\n\n    #[doc(hidden)]\n    fn __private_visit_untagged_option<D>(self, deserializer: D) -> Result<Self::Value, ()>\n    where\n        D: Deserializer<'de>,\n    {\n        Ok(T::deserialize(deserializer).ok())\n    }\n}\n\nimpl<'de, T> Deserialize<'de> for Option<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_option(OptionVisitor {\n            marker: PhantomData,\n        })\n    }\n\n    // The Some variant's repr is opaque, so we can't play cute tricks with its\n    // tag to have deserialize_in_place build the content in place unconditionally.\n    //\n    // FIXME: investigate whether branching on the old value being Some to\n    // deserialize_in_place the value is profitable (probably data-dependent?)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct PhantomDataVisitor<T: ?Sized> {\n    marker: PhantomData<T>,\n}\n\nimpl<'de, T: ?Sized> Visitor<'de> for PhantomDataVisitor<T> {\n    type Value = PhantomData<T>;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"unit\")\n    }\n\n    #[inline]\n    fn visit_unit<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(PhantomData)\n    }\n}\n\nimpl<'de, T: ?Sized> Deserialize<'de> for PhantomData<T> {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let visitor = PhantomDataVisitor {\n            marker: PhantomData,\n        };\n        deserializer.deserialize_unit_struct(\"PhantomData\", visitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! seq_impl {\n    (\n        $ty:ident < T $(: $tbound1:ident $(+ $tbound2:ident)*)* $(, $typaram:ident : $bound1:ident $(+ $bound2:ident)*)* >,\n        $access:ident,\n        $clear:expr,\n        $with_capacity:expr,\n        $reserve:expr,\n        $insert:expr\n    ) => {\n        impl<'de, T $(, $typaram)*> Deserialize<'de> for $ty<T $(, $typaram)*>\n        where\n            T: Deserialize<'de> $(+ $tbound1 $(+ $tbound2)*)*,\n            $($typaram: $bound1 $(+ $bound2)*,)*\n        {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct SeqVisitor<T $(, $typaram)*> {\n                    marker: PhantomData<$ty<T $(, $typaram)*>>,\n                }\n\n                impl<'de, T $(, $typaram)*> Visitor<'de> for SeqVisitor<T $(, $typaram)*>\n                where\n                    T: Deserialize<'de> $(+ $tbound1 $(+ $tbound2)*)*,\n                    $($typaram: $bound1 $(+ $bound2)*,)*\n                {\n                    type Value = $ty<T $(, $typaram)*>;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"a sequence\")\n                    }\n\n                    #[inline]\n                    fn visit_seq<A>(self, mut $access: A) -> Result<Self::Value, A::Error>\n                    where\n                        A: SeqAccess<'de>,\n                    {\n                        let mut values = $with_capacity;\n\n                        while let Some(value) = try!($access.next_element()) {\n                            $insert(&mut values, value);\n                        }\n\n                        Ok(values)\n                    }\n                }\n\n                let visitor = SeqVisitor { marker: PhantomData };\n                deserializer.deserialize_seq(visitor)\n            }\n\n            fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct SeqInPlaceVisitor<'a, T: 'a $(, $typaram: 'a)*>(&'a mut $ty<T $(, $typaram)*>);\n\n                impl<'a, 'de, T $(, $typaram)*> Visitor<'de> for SeqInPlaceVisitor<'a, T $(, $typaram)*>\n                where\n                    T: Deserialize<'de> $(+ $tbound1 $(+ $tbound2)*)*,\n                    $($typaram: $bound1 $(+ $bound2)*,)*\n                {\n                    type Value = ();\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"a sequence\")\n                    }\n\n                    #[inline]\n                    fn visit_seq<A>(mut self, mut $access: A) -> Result<Self::Value, A::Error>\n                    where\n                        A: SeqAccess<'de>,\n                    {\n                        $clear(&mut self.0);\n                        $reserve(&mut self.0, size_hint::cautious($access.size_hint()));\n\n                        // FIXME: try to overwrite old values here? (Vec, VecDeque, LinkedList)\n                        while let Some(value) = try!($access.next_element()) {\n                            $insert(&mut self.0, value);\n                        }\n\n                        Ok(())\n                    }\n                }\n\n                deserializer.deserialize_seq(SeqInPlaceVisitor(place))\n            }\n        }\n    }\n}\n\n// Dummy impl of reserve\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nfn nop_reserve<T>(_seq: T, _n: usize) {}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(\n    BinaryHeap<T: Ord>,\n    seq,\n    BinaryHeap::clear,\n    BinaryHeap::with_capacity(size_hint::cautious(seq.size_hint())),\n    BinaryHeap::reserve,\n    BinaryHeap::push\n);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(\n    BTreeSet<T: Eq + Ord>,\n    seq,\n    BTreeSet::clear,\n    BTreeSet::new(),\n    nop_reserve,\n    BTreeSet::insert\n);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(\n    LinkedList<T>,\n    seq,\n    LinkedList::clear,\n    LinkedList::new(),\n    nop_reserve,\n    LinkedList::push_back\n);\n\n#[cfg(feature = \"std\")]\nseq_impl!(\n    HashSet<T: Eq + Hash, S: BuildHasher + Default>,\n    seq,\n    HashSet::clear,\n    HashSet::with_capacity_and_hasher(size_hint::cautious(seq.size_hint()), S::default()),\n    HashSet::reserve,\n    HashSet::insert);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(\n    VecDeque<T>,\n    seq,\n    VecDeque::clear,\n    VecDeque::with_capacity(size_hint::cautious(seq.size_hint())),\n    VecDeque::reserve,\n    VecDeque::push_back\n);\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de, T> Deserialize<'de> for Vec<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct VecVisitor<T> {\n            marker: PhantomData<T>,\n        }\n\n        impl<'de, T> Visitor<'de> for VecVisitor<T>\n        where\n            T: Deserialize<'de>,\n        {\n            type Value = Vec<T>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a sequence\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n            where\n                A: SeqAccess<'de>,\n            {\n                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));\n\n                while let Some(value) = try!(seq.next_element()) {\n                    values.push(value);\n                }\n\n                Ok(values)\n            }\n        }\n\n        let visitor = VecVisitor {\n            marker: PhantomData,\n        };\n        deserializer.deserialize_seq(visitor)\n    }\n\n    fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct VecInPlaceVisitor<'a, T: 'a>(&'a mut Vec<T>);\n\n        impl<'a, 'de, T> Visitor<'de> for VecInPlaceVisitor<'a, T>\n        where\n            T: Deserialize<'de>,\n        {\n            type Value = ();\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a sequence\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n            where\n                A: SeqAccess<'de>,\n            {\n                let hint = size_hint::cautious(seq.size_hint());\n                if let Some(additional) = hint.checked_sub(self.0.len()) {\n                    self.0.reserve(additional);\n                }\n\n                for i in 0..self.0.len() {\n                    let next = {\n                        let next_place = InPlaceSeed(&mut self.0[i]);\n                        try!(seq.next_element_seed(next_place))\n                    };\n                    if next.is_none() {\n                        self.0.truncate(i);\n                        return Ok(());\n                    }\n                }\n\n                while let Some(value) = try!(seq.next_element()) {\n                    self.0.push(value);\n                }\n\n                Ok(())\n            }\n        }\n\n        deserializer.deserialize_seq(VecInPlaceVisitor(place))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct ArrayVisitor<A> {\n    marker: PhantomData<A>,\n}\nstruct ArrayInPlaceVisitor<'a, A: 'a>(&'a mut A);\n\nimpl<A> ArrayVisitor<A> {\n    fn new() -> Self {\n        ArrayVisitor {\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<'de, T> Visitor<'de> for ArrayVisitor<[T; 0]> {\n    type Value = [T; 0];\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"an empty array\")\n    }\n\n    #[inline]\n    fn visit_seq<A>(self, _: A) -> Result<Self::Value, A::Error>\n    where\n        A: SeqAccess<'de>,\n    {\n        Ok([])\n    }\n}\n\n// Does not require T: Deserialize<'de>.\nimpl<'de, T> Deserialize<'de> for [T; 0] {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_tuple(0, ArrayVisitor::<[T; 0]>::new())\n    }\n}\n\nmacro_rules! array_impls {\n    ($($len:expr => ($($n:tt)+))+) => {\n        $(\n            impl<'de, T> Visitor<'de> for ArrayVisitor<[T; $len]>\n            where\n                T: Deserialize<'de>,\n            {\n                type Value = [T; $len];\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(concat!(\"an array of length \", $len))\n                }\n\n                #[inline]\n                fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n                where\n                    A: SeqAccess<'de>,\n                {\n                    Ok([$(\n                        match try!(seq.next_element()) {\n                            Some(val) => val,\n                            None => return Err(Error::invalid_length($n, &self)),\n                        }\n                    ),+])\n                }\n            }\n\n            impl<'a, 'de, T> Visitor<'de> for ArrayInPlaceVisitor<'a, [T; $len]>\n            where\n                T: Deserialize<'de>,\n            {\n                type Value = ();\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(concat!(\"an array of length \", $len))\n                }\n\n                #[inline]\n                fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n                where\n                    A: SeqAccess<'de>,\n                {\n                    let mut fail_idx = None;\n                    for (idx, dest) in self.0[..].iter_mut().enumerate() {\n                        if try!(seq.next_element_seed(InPlaceSeed(dest))).is_none() {\n                            fail_idx = Some(idx);\n                            break;\n                        }\n                    }\n                    if let Some(idx) = fail_idx {\n                        return Err(Error::invalid_length(idx, &self));\n                    }\n                    Ok(())\n                }\n            }\n\n            impl<'de, T> Deserialize<'de> for [T; $len]\n            where\n                T: Deserialize<'de>,\n            {\n                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n                where\n                    D: Deserializer<'de>,\n                {\n                    deserializer.deserialize_tuple($len, ArrayVisitor::<[T; $len]>::new())\n                }\n\n                fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n                where\n                    D: Deserializer<'de>,\n                {\n                    deserializer.deserialize_tuple($len, ArrayInPlaceVisitor(place))\n                }\n            }\n        )+\n    }\n}\n\narray_impls! {\n    1 => (0)\n    2 => (0 1)\n    3 => (0 1 2)\n    4 => (0 1 2 3)\n    5 => (0 1 2 3 4)\n    6 => (0 1 2 3 4 5)\n    7 => (0 1 2 3 4 5 6)\n    8 => (0 1 2 3 4 5 6 7)\n    9 => (0 1 2 3 4 5 6 7 8)\n    10 => (0 1 2 3 4 5 6 7 8 9)\n    11 => (0 1 2 3 4 5 6 7 8 9 10)\n    12 => (0 1 2 3 4 5 6 7 8 9 10 11)\n    13 => (0 1 2 3 4 5 6 7 8 9 10 11 12)\n    14 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13)\n    15 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14)\n    16 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)\n    17 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16)\n    18 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17)\n    19 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18)\n    20 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19)\n    21 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)\n    22 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21)\n    23 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22)\n    24 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23)\n    25 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24)\n    26 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25)\n    27 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26)\n    28 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27)\n    29 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28)\n    30 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29)\n    31 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)\n    32 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! tuple_impls {\n    ($($len:tt => ($($n:tt $name:ident)+))+) => {\n        $(\n            impl<'de, $($name: Deserialize<'de>),+> Deserialize<'de> for ($($name,)+) {\n                #[inline]\n                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n                where\n                    D: Deserializer<'de>,\n                {\n                    struct TupleVisitor<$($name,)+> {\n                        marker: PhantomData<($($name,)+)>,\n                    }\n\n                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {\n                        type Value = ($($name,)+);\n\n                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                            formatter.write_str(concat!(\"a tuple of size \", $len))\n                        }\n\n                        #[inline]\n                        #[allow(non_snake_case)]\n                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n                        where\n                            A: SeqAccess<'de>,\n                        {\n                            $(\n                                let $name = match try!(seq.next_element()) {\n                                    Some(value) => value,\n                                    None => return Err(Error::invalid_length($n, &self)),\n                                };\n                            )+\n\n                            Ok(($($name,)+))\n                        }\n                    }\n\n                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })\n                }\n\n                #[inline]\n                fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n                where\n                    D: Deserializer<'de>,\n                {\n                    struct TupleInPlaceVisitor<'a, $($name: 'a,)+>(&'a mut ($($name,)+));\n\n                    impl<'a, 'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleInPlaceVisitor<'a, $($name,)+> {\n                        type Value = ();\n\n                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                            formatter.write_str(concat!(\"a tuple of size \", $len))\n                        }\n\n                        #[inline]\n                        #[allow(non_snake_case)]\n                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n                        where\n                            A: SeqAccess<'de>,\n                        {\n                            $(\n                                if try!(seq.next_element_seed(InPlaceSeed(&mut (self.0).$n))).is_none() {\n                                    return Err(Error::invalid_length($n, &self));\n                                }\n                            )+\n\n                            Ok(())\n                        }\n                    }\n\n                    deserializer.deserialize_tuple($len, TupleInPlaceVisitor(place))\n                }\n            }\n        )+\n    }\n}\n\ntuple_impls! {\n    1  => (0 T0)\n    2  => (0 T0 1 T1)\n    3  => (0 T0 1 T1 2 T2)\n    4  => (0 T0 1 T1 2 T2 3 T3)\n    5  => (0 T0 1 T1 2 T2 3 T3 4 T4)\n    6  => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5)\n    7  => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6)\n    8  => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7)\n    9  => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8)\n    10 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9)\n    11 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10)\n    12 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11)\n    13 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12)\n    14 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13)\n    15 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14)\n    16 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! map_impl {\n    (\n        $ty:ident < K $(: $kbound1:ident $(+ $kbound2:ident)*)*, V $(, $typaram:ident : $bound1:ident $(+ $bound2:ident)*)* >,\n        $access:ident,\n        $with_capacity:expr\n    ) => {\n        impl<'de, K, V $(, $typaram)*> Deserialize<'de> for $ty<K, V $(, $typaram)*>\n        where\n            K: Deserialize<'de> $(+ $kbound1 $(+ $kbound2)*)*,\n            V: Deserialize<'de>,\n            $($typaram: $bound1 $(+ $bound2)*),*\n        {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct MapVisitor<K, V $(, $typaram)*> {\n                    marker: PhantomData<$ty<K, V $(, $typaram)*>>,\n                }\n\n                impl<'de, K, V $(, $typaram)*> Visitor<'de> for MapVisitor<K, V $(, $typaram)*>\n                where\n                    K: Deserialize<'de> $(+ $kbound1 $(+ $kbound2)*)*,\n                    V: Deserialize<'de>,\n                    $($typaram: $bound1 $(+ $bound2)*),*\n                {\n                    type Value = $ty<K, V $(, $typaram)*>;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"a map\")\n                    }\n\n                    #[inline]\n                    fn visit_map<A>(self, mut $access: A) -> Result<Self::Value, A::Error>\n                    where\n                        A: MapAccess<'de>,\n                    {\n                        let mut values = $with_capacity;\n\n                        while let Some((key, value)) = try!($access.next_entry()) {\n                            values.insert(key, value);\n                        }\n\n                        Ok(values)\n                    }\n                }\n\n                let visitor = MapVisitor { marker: PhantomData };\n                deserializer.deserialize_map(visitor)\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmap_impl!(\n    BTreeMap<K: Ord, V>,\n    map,\n    BTreeMap::new());\n\n#[cfg(feature = \"std\")]\nmap_impl!(\n    HashMap<K: Eq + Hash, V, S: BuildHasher + Default>,\n    map,\n    HashMap::with_capacity_and_hasher(size_hint::cautious(map.size_hint()), S::default()));\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nmacro_rules! parse_ip_impl {\n    ($expecting:tt $ty:ty; $size:tt) => {\n        impl<'de> Deserialize<'de> for $ty {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                if deserializer.is_human_readable() {\n                    struct IpAddrVisitor;\n\n                    impl<'de> Visitor<'de> for IpAddrVisitor {\n                        type Value = $ty;\n\n                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                            formatter.write_str($expecting)\n                        }\n\n                        fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n                        where\n                            E: Error,\n                        {\n                            s.parse().map_err(Error::custom)\n                        }\n                    }\n\n                    deserializer.deserialize_str(IpAddrVisitor)\n                } else {\n                    <[u8; $size]>::deserialize(deserializer).map(<$ty>::from)\n                }\n            }\n        }\n    };\n}\n\n#[cfg(feature = \"std\")]\nmacro_rules! variant_identifier {\n    (\n        $name_kind: ident ( $($variant: ident; $bytes: expr; $index: expr),* )\n        $expecting_message: expr,\n        $variants_name: ident\n    ) => {\n        enum $name_kind {\n            $( $variant ),*\n        }\n\n        static $variants_name: &'static [&'static str] = &[ $( stringify!($variant) ),*];\n\n        impl<'de> Deserialize<'de> for $name_kind {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct KindVisitor;\n\n                impl<'de> Visitor<'de> for KindVisitor {\n                    type Value = $name_kind;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str($expecting_message)\n                    }\n\n                    fn visit_u32<E>(self, value: u32) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            $(\n                                $index => Ok($name_kind :: $variant),\n                            )*\n                            _ => Err(Error::invalid_value(Unexpected::Unsigned(value as u64), &self),),\n                        }\n                    }\n\n                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            $(\n                                stringify!($variant) => Ok($name_kind :: $variant),\n                            )*\n                            _ => Err(Error::unknown_variant(value, $variants_name)),\n                        }\n                    }\n\n                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            $(\n                                $bytes => Ok($name_kind :: $variant),\n                            )*\n                            _ => {\n                                match str::from_utf8(value) {\n                                    Ok(value) => Err(Error::unknown_variant(value, $variants_name)),\n                                    Err(_) => Err(Error::invalid_value(Unexpected::Bytes(value), &self)),\n                                }\n                            }\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(KindVisitor)\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nmacro_rules! deserialize_enum {\n    (\n        $name: ident $name_kind: ident ( $($variant: ident; $bytes: expr; $index: expr),* )\n        $expecting_message: expr,\n        $deserializer: expr\n    ) => {\n        variant_identifier!{\n            $name_kind ( $($variant; $bytes; $index),* )\n            $expecting_message,\n            VARIANTS\n        }\n\n        struct EnumVisitor;\n        impl<'de> Visitor<'de> for EnumVisitor {\n            type Value = $name;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(concat!(\"a \", stringify!($name)))\n            }\n\n\n            fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n            where\n                A: EnumAccess<'de>,\n            {\n                match try!(data.variant()) {\n                    $(\n                        ($name_kind :: $variant, v) => v.newtype_variant().map($name :: $variant),\n                    )*\n                }\n            }\n        }\n        $deserializer.deserialize_enum(stringify!($name), VARIANTS, EnumVisitor)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl<'de> Deserialize<'de> for net::IpAddr {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        if deserializer.is_human_readable() {\n            struct IpAddrVisitor;\n\n            impl<'de> Visitor<'de> for IpAddrVisitor {\n                type Value = net::IpAddr;\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(\"IP address\")\n                }\n\n                fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    s.parse().map_err(Error::custom)\n                }\n            }\n\n            deserializer.deserialize_str(IpAddrVisitor)\n        } else {\n            use lib::net::IpAddr;\n            deserialize_enum! {\n                IpAddr IpAddrKind (V4; b\"V4\"; 0, V6; b\"V6\"; 1)\n                \"`V4` or `V6`\",\n                deserializer\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nparse_ip_impl!(\"IPv4 address\" net::Ipv4Addr; 4);\n\n#[cfg(feature = \"std\")]\nparse_ip_impl!(\"IPv6 address\" net::Ipv6Addr; 16);\n\n#[cfg(feature = \"std\")]\nmacro_rules! parse_socket_impl {\n    ($expecting:tt $ty:ty, $new:expr) => {\n        impl<'de> Deserialize<'de> for $ty {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                if deserializer.is_human_readable() {\n                    struct SocketAddrVisitor;\n\n                    impl<'de> Visitor<'de> for SocketAddrVisitor {\n                        type Value = $ty;\n\n                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                            formatter.write_str($expecting)\n                        }\n\n                        fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n                        where\n                            E: Error,\n                        {\n                            s.parse().map_err(Error::custom)\n                        }\n                    }\n\n                    deserializer.deserialize_str(SocketAddrVisitor)\n                } else {\n                    <(_, u16)>::deserialize(deserializer).map(|(ip, port)| $new(ip, port))\n                }\n            }\n        }\n    };\n}\n\n#[cfg(feature = \"std\")]\nimpl<'de> Deserialize<'de> for net::SocketAddr {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        if deserializer.is_human_readable() {\n            struct SocketAddrVisitor;\n\n            impl<'de> Visitor<'de> for SocketAddrVisitor {\n                type Value = net::SocketAddr;\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(\"socket address\")\n                }\n\n                fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    s.parse().map_err(Error::custom)\n                }\n            }\n\n            deserializer.deserialize_str(SocketAddrVisitor)\n        } else {\n            use lib::net::SocketAddr;\n            deserialize_enum! {\n                SocketAddr SocketAddrKind (V4; b\"V4\"; 0, V6; b\"V6\"; 1)\n                \"`V4` or `V6`\",\n                deserializer\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nparse_socket_impl!(\"IPv4 socket address\" net::SocketAddrV4, net::SocketAddrV4::new);\n\n#[cfg(feature = \"std\")]\nparse_socket_impl!(\"IPv6 socket address\" net::SocketAddrV6, |ip, port| net::SocketAddrV6::new(\n    ip, port, 0, 0\n));\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nstruct PathVisitor;\n\n#[cfg(feature = \"std\")]\nimpl<'a> Visitor<'a> for PathVisitor {\n    type Value = &'a Path;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a borrowed path\")\n    }\n\n    fn visit_borrowed_str<E>(self, v: &'a str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v.as_ref())\n    }\n\n    fn visit_borrowed_bytes<E>(self, v: &'a [u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        str::from_utf8(v)\n            .map(AsRef::as_ref)\n            .map_err(|_| Error::invalid_value(Unexpected::Bytes(v), &self))\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl<'de: 'a, 'a> Deserialize<'de> for &'a Path {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_str(PathVisitor)\n    }\n}\n\n#[cfg(feature = \"std\")]\nstruct PathBufVisitor;\n\n#[cfg(feature = \"std\")]\nimpl<'de> Visitor<'de> for PathBufVisitor {\n    type Value = PathBuf;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"path string\")\n    }\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(From::from(v))\n    }\n\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(From::from(v))\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl<'de> Deserialize<'de> for PathBuf {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_string(PathBufVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// If this were outside of the serde crate, it would just use:\n//\n//    #[derive(Deserialize)]\n//    #[serde(variant_identifier)]\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nvariant_identifier! {\n    OsStringKind (Unix; b\"Unix\"; 0, Windows; b\"Windows\"; 1)\n    \"`Unix` or `Windows`\",\n    OSSTR_VARIANTS\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nstruct OsStringVisitor;\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl<'de> Visitor<'de> for OsStringVisitor {\n    type Value = OsString;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"os string\")\n    }\n\n    #[cfg(unix)]\n    fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n    where\n        A: EnumAccess<'de>,\n    {\n        use std::os::unix::ffi::OsStringExt;\n\n        match try!(data.variant()) {\n            (OsStringKind::Unix, v) => v.newtype_variant().map(OsString::from_vec),\n            (OsStringKind::Windows, _) => Err(Error::custom(\n                \"cannot deserialize Windows OS string on Unix\",\n            )),\n        }\n    }\n\n    #[cfg(windows)]\n    fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n    where\n        A: EnumAccess<'de>,\n    {\n        use std::os::windows::ffi::OsStringExt;\n\n        match try!(data.variant()) {\n            (OsStringKind::Windows, v) => v\n                .newtype_variant::<Vec<u16>>()\n                .map(|vec| OsString::from_wide(&vec)),\n            (OsStringKind::Unix, _) => Err(Error::custom(\n                \"cannot deserialize Unix OS string on Windows\",\n            )),\n        }\n    }\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl<'de> Deserialize<'de> for OsString {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_enum(\"OsString\", OSSTR_VARIANTS, OsStringVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nforwarded_impl!((T), Box<T>, Box::new);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nforwarded_impl!((T), Box<[T]>, Vec::into_boxed_slice);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nforwarded_impl!((), Box<str>, String::into_boxed_str);\n\n#[cfg(all(\n    not(de_rc_dst),\n    feature = \"rc\",\n    any(feature = \"std\", feature = \"alloc\")\n))]\nforwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Arc` will not attempt to\n    /// deduplicate `Arc` references to the same data. Every deserialized `Arc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    (T), Arc<T>, Arc::new\n}\n\n#[cfg(all(\n    not(de_rc_dst),\n    feature = \"rc\",\n    any(feature = \"std\", feature = \"alloc\")\n))]\nforwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Rc` will not attempt to\n    /// deduplicate `Rc` references to the same data. Every deserialized `Rc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    (T), Rc<T>, Rc::new\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de, 'a, T: ?Sized> Deserialize<'de> for Cow<'a, T>\nwhere\n    T: ToOwned,\n    T::Owned: Deserialize<'de>,\n{\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        T::Owned::deserialize(deserializer).map(Cow::Owned)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde. The resulting\n/// `Weak<T>` has a reference count of 0 and cannot be upgraded.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nimpl<'de, T: ?Sized> Deserialize<'de> for RcWeak<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        try!(Option::<T>::deserialize(deserializer));\n        Ok(RcWeak::new())\n    }\n}\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde. The resulting\n/// `Weak<T>` has a reference count of 0 and cannot be upgraded.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nimpl<'de, T: ?Sized> Deserialize<'de> for ArcWeak<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        try!(Option::<T>::deserialize(deserializer));\n        Ok(ArcWeak::new())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(all(de_rc_dst, feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nmacro_rules! box_forwarded_impl {\n    (\n        $(#[doc = $doc:tt])*\n        $t:ident\n    ) => {\n        $(#[doc = $doc])*\n        impl<'de, T: ?Sized> Deserialize<'de> for $t<T>\n        where\n            Box<T>: Deserialize<'de>,\n        {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                Box::deserialize(deserializer).map(Into::into)\n            }\n        }\n    };\n}\n\n#[cfg(all(de_rc_dst, feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nbox_forwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Rc` will not attempt to\n    /// deduplicate `Rc` references to the same data. Every deserialized `Rc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    Rc\n}\n\n#[cfg(all(de_rc_dst, feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nbox_forwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Arc` will not attempt to\n    /// deduplicate `Arc` references to the same data. Every deserialized `Arc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    Arc\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<'de, T> Deserialize<'de> for Cell<T>\nwhere\n    T: Deserialize<'de> + Copy,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Cell::new)\n    }\n}\n\nforwarded_impl!((T), RefCell<T>, RefCell::new);\n\n#[cfg(feature = \"std\")]\nforwarded_impl!((T), Mutex<T>, Mutex::new);\n\n#[cfg(feature = \"std\")]\nforwarded_impl!((T), RwLock<T>, RwLock::new);\n\n////////////////////////////////////////////////////////////////////////////////\n\n// This is a cleaned-up version of the impl generated by:\n//\n//     #[derive(Deserialize)]\n//     #[serde(deny_unknown_fields)]\n//     struct Duration {\n//         secs: u64,\n//         nanos: u32,\n//     }\n#[cfg(any(core_duration, feature = \"std\"))]\nimpl<'de> Deserialize<'de> for Duration {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        // If this were outside of the serde crate, it would just use:\n        //\n        //    #[derive(Deserialize)]\n        //    #[serde(field_identifier, rename_all = \"lowercase\")]\n        enum Field {\n            Secs,\n            Nanos,\n        };\n\n        impl<'de> Deserialize<'de> for Field {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct FieldVisitor;\n\n                impl<'de> Visitor<'de> for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"`secs` or `nanos`\")\n                    }\n\n                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"secs\" => Ok(Field::Secs),\n                            \"nanos\" => Ok(Field::Nanos),\n                            _ => Err(Error::unknown_field(value, FIELDS)),\n                        }\n                    }\n\n                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"secs\" => Ok(Field::Secs),\n                            b\"nanos\" => Ok(Field::Nanos),\n                            _ => {\n                                let value = ::export::from_utf8_lossy(value);\n                                Err(Error::unknown_field(&value, FIELDS))\n                            }\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct DurationVisitor;\n\n        impl<'de> Visitor<'de> for DurationVisitor {\n            type Value = Duration;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"struct Duration\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n            where\n                A: SeqAccess<'de>,\n            {\n                let secs: u64 = match try!(seq.next_element()) {\n                    Some(value) => value,\n                    None => {\n                        return Err(Error::invalid_length(0, &self));\n                    }\n                };\n                let nanos: u32 = match try!(seq.next_element()) {\n                    Some(value) => value,\n                    None => {\n                        return Err(Error::invalid_length(1, &self));\n                    }\n                };\n                Ok(Duration::new(secs, nanos))\n            }\n\n            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n            where\n                A: MapAccess<'de>,\n            {\n                let mut secs: Option<u64> = None;\n                let mut nanos: Option<u32> = None;\n                while let Some(key) = try!(map.next_key()) {\n                    match key {\n                        Field::Secs => {\n                            if secs.is_some() {\n                                return Err(<A::Error as Error>::duplicate_field(\"secs\"));\n                            }\n                            secs = Some(try!(map.next_value()));\n                        }\n                        Field::Nanos => {\n                            if nanos.is_some() {\n                                return Err(<A::Error as Error>::duplicate_field(\"nanos\"));\n                            }\n                            nanos = Some(try!(map.next_value()));\n                        }\n                    }\n                }\n                let secs = match secs {\n                    Some(secs) => secs,\n                    None => return Err(<A::Error as Error>::missing_field(\"secs\")),\n                };\n                let nanos = match nanos {\n                    Some(nanos) => nanos,\n                    None => return Err(<A::Error as Error>::missing_field(\"nanos\")),\n                };\n                Ok(Duration::new(secs, nanos))\n            }\n        }\n\n        const FIELDS: &'static [&'static str] = &[\"secs\", \"nanos\"];\n        deserializer.deserialize_struct(\"Duration\", FIELDS, DurationVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl<'de> Deserialize<'de> for SystemTime {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        // Reuse duration\n        enum Field {\n            Secs,\n            Nanos,\n        };\n\n        impl<'de> Deserialize<'de> for Field {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct FieldVisitor;\n\n                impl<'de> Visitor<'de> for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"`secs_since_epoch` or `nanos_since_epoch`\")\n                    }\n\n                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"secs_since_epoch\" => Ok(Field::Secs),\n                            \"nanos_since_epoch\" => Ok(Field::Nanos),\n                            _ => Err(Error::unknown_field(value, FIELDS)),\n                        }\n                    }\n\n                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"secs_since_epoch\" => Ok(Field::Secs),\n                            b\"nanos_since_epoch\" => Ok(Field::Nanos),\n                            _ => {\n                                let value = String::from_utf8_lossy(value);\n                                Err(Error::unknown_field(&value, FIELDS))\n                            }\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct DurationVisitor;\n\n        impl<'de> Visitor<'de> for DurationVisitor {\n            type Value = Duration;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"struct SystemTime\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n            where\n                A: SeqAccess<'de>,\n            {\n                let secs: u64 = match try!(seq.next_element()) {\n                    Some(value) => value,\n                    None => {\n                        return Err(Error::invalid_length(0, &self));\n                    }\n                };\n                let nanos: u32 = match try!(seq.next_element()) {\n                    Some(value) => value,\n                    None => {\n                        return Err(Error::invalid_length(1, &self));\n                    }\n                };\n                Ok(Duration::new(secs, nanos))\n            }\n\n            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n            where\n                A: MapAccess<'de>,\n            {\n                let mut secs: Option<u64> = None;\n                let mut nanos: Option<u32> = None;\n                while let Some(key) = try!(map.next_key()) {\n                    match key {\n                        Field::Secs => {\n                            if secs.is_some() {\n                                return Err(<A::Error as Error>::duplicate_field(\n                                    \"secs_since_epoch\",\n                                ));\n                            }\n                            secs = Some(try!(map.next_value()));\n                        }\n                        Field::Nanos => {\n                            if nanos.is_some() {\n                                return Err(<A::Error as Error>::duplicate_field(\n                                    \"nanos_since_epoch\",\n                                ));\n                            }\n                            nanos = Some(try!(map.next_value()));\n                        }\n                    }\n                }\n                let secs = match secs {\n                    Some(secs) => secs,\n                    None => return Err(<A::Error as Error>::missing_field(\"secs_since_epoch\")),\n                };\n                let nanos = match nanos {\n                    Some(nanos) => nanos,\n                    None => return Err(<A::Error as Error>::missing_field(\"nanos_since_epoch\")),\n                };\n                Ok(Duration::new(secs, nanos))\n            }\n        }\n\n        const FIELDS: &'static [&'static str] = &[\"secs_since_epoch\", \"nanos_since_epoch\"];\n        let duration = try!(deserializer.deserialize_struct(\"SystemTime\", FIELDS, DurationVisitor));\n        Ok(UNIX_EPOCH + duration)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Similar to:\n//\n//     #[derive(Deserialize)]\n//     #[serde(deny_unknown_fields)]\n//     struct Range {\n//         start: u64,\n//         end: u32,\n//     }\nimpl<'de, Idx> Deserialize<'de> for Range<Idx>\nwhere\n    Idx: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let (start, end) = deserializer.deserialize_struct(\n            \"Range\",\n            range::FIELDS,\n            range::RangeVisitor {\n                expecting: \"struct Range\",\n                phantom: PhantomData,\n            },\n        )?;\n        Ok(start..end)\n    }\n}\n\n#[cfg(range_inclusive)]\nimpl<'de, Idx> Deserialize<'de> for RangeInclusive<Idx>\nwhere\n    Idx: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let (start, end) = deserializer.deserialize_struct(\n            \"RangeInclusive\",\n            range::FIELDS,\n            range::RangeVisitor {\n                expecting: \"struct RangeInclusive\",\n                phantom: PhantomData,\n            },\n        )?;\n        Ok(RangeInclusive::new(start, end))\n    }\n}\n\nmod range {\n    use lib::*;\n\n    use de::{Deserialize, Deserializer, Error, MapAccess, SeqAccess, Visitor};\n\n    pub const FIELDS: &'static [&'static str] = &[\"start\", \"end\"];\n\n    // If this were outside of the serde crate, it would just use:\n    //\n    //    #[derive(Deserialize)]\n    //    #[serde(field_identifier, rename_all = \"lowercase\")]\n    enum Field {\n        Start,\n        End,\n    }\n\n    impl<'de> Deserialize<'de> for Field {\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            struct FieldVisitor;\n\n            impl<'de> Visitor<'de> for FieldVisitor {\n                type Value = Field;\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(\"`start` or `end`\")\n                }\n\n                fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    match value {\n                        \"start\" => Ok(Field::Start),\n                        \"end\" => Ok(Field::End),\n                        _ => Err(Error::unknown_field(value, FIELDS)),\n                    }\n                }\n\n                fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    match value {\n                        b\"start\" => Ok(Field::Start),\n                        b\"end\" => Ok(Field::End),\n                        _ => {\n                            let value = ::export::from_utf8_lossy(value);\n                            Err(Error::unknown_field(&value, FIELDS))\n                        }\n                    }\n                }\n            }\n\n            deserializer.deserialize_identifier(FieldVisitor)\n        }\n    }\n\n    pub struct RangeVisitor<Idx> {\n        pub expecting: &'static str,\n        pub phantom: PhantomData<Idx>,\n    }\n\n    impl<'de, Idx> Visitor<'de> for RangeVisitor<Idx>\n    where\n        Idx: Deserialize<'de>,\n    {\n        type Value = (Idx, Idx);\n\n        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n            formatter.write_str(self.expecting)\n        }\n\n        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n        where\n            A: SeqAccess<'de>,\n        {\n            let start: Idx = match try!(seq.next_element()) {\n                Some(value) => value,\n                None => {\n                    return Err(Error::invalid_length(0, &self));\n                }\n            };\n            let end: Idx = match try!(seq.next_element()) {\n                Some(value) => value,\n                None => {\n                    return Err(Error::invalid_length(1, &self));\n                }\n            };\n            Ok((start, end))\n        }\n\n        fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n        where\n            A: MapAccess<'de>,\n        {\n            let mut start: Option<Idx> = None;\n            let mut end: Option<Idx> = None;\n            while let Some(key) = try!(map.next_key()) {\n                match key {\n                    Field::Start => {\n                        if start.is_some() {\n                            return Err(<A::Error as Error>::duplicate_field(\"start\"));\n                        }\n                        start = Some(try!(map.next_value()));\n                    }\n                    Field::End => {\n                        if end.is_some() {\n                            return Err(<A::Error as Error>::duplicate_field(\"end\"));\n                        }\n                        end = Some(try!(map.next_value()));\n                    }\n                }\n            }\n            let start = match start {\n                Some(start) => start,\n                None => return Err(<A::Error as Error>::missing_field(\"start\")),\n            };\n            let end = match end {\n                Some(end) => end,\n                None => return Err(<A::Error as Error>::missing_field(\"end\")),\n            };\n            Ok((start, end))\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(ops_bound, collections_bound))]\nimpl<'de, T> Deserialize<'de> for Bound<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        enum Field {\n            Unbounded,\n            Included,\n            Excluded,\n        }\n\n        impl<'de> Deserialize<'de> for Field {\n            #[inline]\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct FieldVisitor;\n\n                impl<'de> Visitor<'de> for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"`Unbounded`, `Included` or `Excluded`\")\n                    }\n\n                    fn visit_u32<E>(self, value: u32) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            0 => Ok(Field::Unbounded),\n                            1 => Ok(Field::Included),\n                            2 => Ok(Field::Excluded),\n                            _ => Err(Error::invalid_value(\n                                Unexpected::Unsigned(value as u64),\n                                &self,\n                            )),\n                        }\n                    }\n\n                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"Unbounded\" => Ok(Field::Unbounded),\n                            \"Included\" => Ok(Field::Included),\n                            \"Excluded\" => Ok(Field::Excluded),\n                            _ => Err(Error::unknown_variant(value, VARIANTS)),\n                        }\n                    }\n\n                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"Unbounded\" => Ok(Field::Unbounded),\n                            b\"Included\" => Ok(Field::Included),\n                            b\"Excluded\" => Ok(Field::Excluded),\n                            _ => match str::from_utf8(value) {\n                                Ok(value) => Err(Error::unknown_variant(value, VARIANTS)),\n                                Err(_) => {\n                                    Err(Error::invalid_value(Unexpected::Bytes(value), &self))\n                                }\n                            },\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct BoundVisitor<T>(PhantomData<Bound<T>>);\n\n        impl<'de, T> Visitor<'de> for BoundVisitor<T>\n        where\n            T: Deserialize<'de>,\n        {\n            type Value = Bound<T>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"enum Bound\")\n            }\n\n            fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n            where\n                A: EnumAccess<'de>,\n            {\n                match try!(data.variant()) {\n                    (Field::Unbounded, v) => v.unit_variant().map(|()| Bound::Unbounded),\n                    (Field::Included, v) => v.newtype_variant().map(Bound::Included),\n                    (Field::Excluded, v) => v.newtype_variant().map(Bound::Excluded),\n                }\n            }\n        }\n\n        const VARIANTS: &'static [&'static str] = &[\"Unbounded\", \"Included\", \"Excluded\"];\n\n        deserializer.deserialize_enum(\"Bound\", VARIANTS, BoundVisitor(PhantomData))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! nonzero_integers {\n    ( $( $T: ident, )+ ) => {\n        $(\n            #[cfg(num_nonzero)]\n            impl<'de> Deserialize<'de> for num::$T {\n                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n                where\n                    D: Deserializer<'de>,\n                {\n                    let value = try!(Deserialize::deserialize(deserializer));\n                    match <num::$T>::new(value) {\n                        Some(nonzero) => Ok(nonzero),\n                        None => Err(Error::custom(\"expected a non-zero value\")),\n                    }\n                }\n            }\n        )+\n    };\n}\n\nnonzero_integers! {\n    NonZeroU8,\n    NonZeroU16,\n    NonZeroU32,\n    NonZeroU64,\n    NonZeroUsize,\n}\n\n#[cfg(num_nonzero_signed)]\nnonzero_integers! {\n    NonZeroI8,\n    NonZeroI16,\n    NonZeroI32,\n    NonZeroI64,\n    NonZeroIsize,\n}\n\n// Currently 128-bit integers do not work on Emscripten targets so we need an\n// additional `#[cfg]`\nserde_if_integer128! {\n    nonzero_integers! {\n        NonZeroU128,\n    }\n\n    #[cfg(num_nonzero_signed)]\n    nonzero_integers! {\n        NonZeroI128,\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<'de, T, E> Deserialize<'de> for Result<T, E>\nwhere\n    T: Deserialize<'de>,\n    E: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        // If this were outside of the serde crate, it would just use:\n        //\n        //    #[derive(Deserialize)]\n        //    #[serde(variant_identifier)]\n        enum Field {\n            Ok,\n            Err,\n        }\n\n        impl<'de> Deserialize<'de> for Field {\n            #[inline]\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct FieldVisitor;\n\n                impl<'de> Visitor<'de> for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"`Ok` or `Err`\")\n                    }\n\n                    fn visit_u32<E>(self, value: u32) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            0 => Ok(Field::Ok),\n                            1 => Ok(Field::Err),\n                            _ => Err(Error::invalid_value(\n                                Unexpected::Unsigned(value as u64),\n                                &self,\n                            )),\n                        }\n                    }\n\n                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"Ok\" => Ok(Field::Ok),\n                            \"Err\" => Ok(Field::Err),\n                            _ => Err(Error::unknown_variant(value, VARIANTS)),\n                        }\n                    }\n\n                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"Ok\" => Ok(Field::Ok),\n                            b\"Err\" => Ok(Field::Err),\n                            _ => match str::from_utf8(value) {\n                                Ok(value) => Err(Error::unknown_variant(value, VARIANTS)),\n                                Err(_) => {\n                                    Err(Error::invalid_value(Unexpected::Bytes(value), &self))\n                                }\n                            },\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct ResultVisitor<T, E>(PhantomData<Result<T, E>>);\n\n        impl<'de, T, E> Visitor<'de> for ResultVisitor<T, E>\n        where\n            T: Deserialize<'de>,\n            E: Deserialize<'de>,\n        {\n            type Value = Result<T, E>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"enum Result\")\n            }\n\n            fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n            where\n                A: EnumAccess<'de>,\n            {\n                match try!(data.variant()) {\n                    (Field::Ok, v) => v.newtype_variant().map(Ok),\n                    (Field::Err, v) => v.newtype_variant().map(Err),\n                }\n            }\n        }\n\n        const VARIANTS: &'static [&'static str] = &[\"Ok\", \"Err\"];\n\n        deserializer.deserialize_enum(\"Result\", VARIANTS, ResultVisitor(PhantomData))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl<'de, T> Deserialize<'de> for Wrapping<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        Deserialize::deserialize(deserializer).map(Wrapping)\n    }\n}\n\n#[cfg(all(feature = \"std\", std_atomic))]\nmacro_rules! atomic_impl {\n    ($($ty:ident)*) => {\n        $(\n            impl<'de> Deserialize<'de> for $ty {\n                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n                where\n                    D: Deserializer<'de>,\n                {\n                    Deserialize::deserialize(deserializer).map(Self::new)\n                }\n            }\n        )*\n    };\n}\n\n#[cfg(all(feature = \"std\", std_atomic))]\natomic_impl! {\n    AtomicBool\n    AtomicI8 AtomicI16 AtomicI32 AtomicIsize\n    AtomicU8 AtomicU16 AtomicU32 AtomicUsize\n}\n\n#[cfg(all(feature = \"std\", std_atomic64))]\natomic_impl! {\n    AtomicI64 AtomicU64\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","mod.rs"],"content":"//! Generic data structure deserialization framework.\n//!\n//! The two most important traits in this module are [`Deserialize`] and\n//! [`Deserializer`].\n//!\n//!  - **A type that implements `Deserialize` is a data structure** that can be\n//!    deserialized from any data format supported by Serde, and conversely\n//!  - **A type that implements `Deserializer` is a data format** that can\n//!    deserialize any data structure supported by Serde.\n//!\n//! # The Deserialize trait\n//!\n//! Serde provides [`Deserialize`] implementations for many Rust primitive and\n//! standard library types. The complete list is below. All of these can be\n//! deserialized using Serde out of the box.\n//!\n//! Additionally, Serde provides a procedural macro called [`serde_derive`] to\n//! automatically generate [`Deserialize`] implementations for structs and enums\n//! in your program. See the [derive section of the manual] for how to use this.\n//!\n//! In rare cases it may be necessary to implement [`Deserialize`] manually for\n//! some type in your program. See the [Implementing `Deserialize`] section of\n//! the manual for more about this.\n//!\n//! Third-party crates may provide [`Deserialize`] implementations for types\n//! that they expose. For example the [`linked-hash-map`] crate provides a\n//! [`LinkedHashMap<K, V>`] type that is deserializable by Serde because the\n//! crate provides an implementation of [`Deserialize`] for it.\n//!\n//! # The Deserializer trait\n//!\n//! [`Deserializer`] implementations are provided by third-party crates, for\n//! example [`serde_json`], [`serde_yaml`] and [`bincode`].\n//!\n//! A partial list of well-maintained formats is given on the [Serde\n//! website][data formats].\n//!\n//! # Implementations of Deserialize provided by Serde\n//!\n//! This is a slightly different set of types than what is supported for\n//! serialization. Some types can be serialized by Serde but not deserialized.\n//! One example is `OsStr`.\n//!\n//!  - **Primitive types**:\n//!    - bool\n//!    - i8, i16, i32, i64, i128, isize\n//!    - u8, u16, u32, u64, u128, usize\n//!    - f32, f64\n//!    - char\n//!  - **Compound types**:\n//!    - \\[T; 0\\] through \\[T; 32\\]\n//!    - tuples up to size 16\n//!  - **Common standard library types**:\n//!    - String\n//!    - Option\\<T\\>\n//!    - Result\\<T, E\\>\n//!    - PhantomData\\<T\\>\n//!  - **Wrapper types**:\n//!    - Box\\<T\\>\n//!    - Box\\<\\[T\\]\\>\n//!    - Box\\<str\\>\n//!    - Cow\\<'a, T\\>\n//!    - Cell\\<T\\>\n//!    - RefCell\\<T\\>\n//!    - Mutex\\<T\\>\n//!    - RwLock\\<T\\>\n//!    - Rc\\<T\\>&emsp;*(if* features = [\"rc\"] *is enabled)*\n//!    - Arc\\<T\\>&emsp;*(if* features = [\"rc\"] *is enabled)*\n//!  - **Collection types**:\n//!    - BTreeMap\\<K, V\\>\n//!    - BTreeSet\\<T\\>\n//!    - BinaryHeap\\<T\\>\n//!    - HashMap\\<K, V, H\\>\n//!    - HashSet\\<T, H\\>\n//!    - LinkedList\\<T\\>\n//!    - VecDeque\\<T\\>\n//!    - Vec\\<T\\>\n//!  - **Zero-copy types**:\n//!    - &str\n//!    - &\\[u8\\]\n//!  - **FFI types**:\n//!    - CString\n//!    - Box\\<CStr\\>\n//!    - OsString\n//!  - **Miscellaneous standard library types**:\n//!    - Duration\n//!    - SystemTime\n//!    - Path\n//!    - PathBuf\n//!    - Range\\<T\\>\n//!    - RangeInclusive\\<T\\>\n//!    - Bound\\<T\\>\n//!    - num::NonZero*\n//!    - `!` *(unstable)*\n//!  - **Net types**:\n//!    - IpAddr\n//!    - Ipv4Addr\n//!    - Ipv6Addr\n//!    - SocketAddr\n//!    - SocketAddrV4\n//!    - SocketAddrV6\n//!\n//! [Implementing `Deserialize`]: https://serde.rs/impl-deserialize.html\n//! [`Deserialize`]: ../trait.Deserialize.html\n//! [`Deserializer`]: ../trait.Deserializer.html\n//! [`LinkedHashMap<K, V>`]: https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html\n//! [`bincode`]: https://github.com/TyOverby/bincode\n//! [`linked-hash-map`]: https://crates.io/crates/linked-hash-map\n//! [`serde_derive`]: https://crates.io/crates/serde_derive\n//! [`serde_json`]: https://github.com/serde-rs/json\n//! [`serde_yaml`]: https://github.com/dtolnay/serde-yaml\n//! [derive section of the manual]: https://serde.rs/derive.html\n//! [data formats]: https://serde.rs/#data-formats\n\nuse lib::*;\n\n////////////////////////////////////////////////////////////////////////////////\n\npub mod value;\n\nmod from_primitive;\nmod ignored_any;\nmod impls;\nmod utf8;\n\npub use self::ignored_any::IgnoredAny;\n\n#[cfg(feature = \"std\")]\n#[doc(no_inline)]\npub use std::error::Error as StdError;\n#[cfg(not(feature = \"std\"))]\n#[doc(no_inline)]\npub use std_error::Error as StdError;\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! declare_error_trait {\n    (Error: Sized $(+ $($supertrait:ident)::+)*) => {\n        /// The `Error` trait allows `Deserialize` implementations to create descriptive\n        /// error messages belonging to the `Deserializer` against which they are\n        /// currently running.\n        ///\n        /// Every `Deserializer` declares an `Error` type that encompasses both\n        /// general-purpose deserialization errors as well as errors specific to the\n        /// particular deserialization format. For example the `Error` type of\n        /// `serde_json` can represent errors like an invalid JSON escape sequence or an\n        /// unterminated string literal, in addition to the error cases that are part of\n        /// this trait.\n        ///\n        /// Most deserializers should only need to provide the `Error::custom` method\n        /// and inherit the default behavior for the other methods.\n        ///\n        /// # Example implementation\n        ///\n        /// The [example data format] presented on the website shows an error\n        /// type appropriate for a basic JSON data format.\n        ///\n        /// [example data format]: https://serde.rs/data-format.html\n        pub trait Error: Sized $(+ $($supertrait)::+)* {\n            /// Raised when there is general error when deserializing a type.\n            ///\n            /// The message should not be capitalized and should not end with a period.\n            ///\n            /// ```edition2018\n            /// # use std::str::FromStr;\n            /// #\n            /// # struct IpAddr;\n            /// #\n            /// # impl FromStr for IpAddr {\n            /// #     type Err = String;\n            /// #\n            /// #     fn from_str(_: &str) -> Result<Self, String> {\n            /// #         unimplemented!()\n            /// #     }\n            /// # }\n            /// #\n            /// use serde::de::{self, Deserialize, Deserializer};\n            ///\n            /// impl<'de> Deserialize<'de> for IpAddr {\n            ///     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            ///     where\n            ///         D: Deserializer<'de>,\n            ///     {\n            ///         let s = String::deserialize(deserializer)?;\n            ///         s.parse().map_err(de::Error::custom)\n            ///     }\n            /// }\n            /// ```\n            fn custom<T>(msg: T) -> Self\n            where\n                T: Display;\n\n            /// Raised when a `Deserialize` receives a type different from what it was\n            /// expecting.\n            ///\n            /// The `unexp` argument provides information about what type was received.\n            /// This is the type that was present in the input file or other source data\n            /// of the Deserializer.\n            ///\n            /// The `exp` argument provides information about what type was being\n            /// expected. This is the type that is written in the program.\n            ///\n            /// For example if we try to deserialize a String out of a JSON file\n            /// containing an integer, the unexpected type is the integer and the\n            /// expected type is the string.\n            #[cold]\n            fn invalid_type(unexp: Unexpected, exp: &Expected) -> Self {\n                Error::custom(format_args!(\"invalid type: {}, expected {}\", unexp, exp))\n            }\n\n            /// Raised when a `Deserialize` receives a value of the right type but that\n            /// is wrong for some other reason.\n            ///\n            /// The `unexp` argument provides information about what value was received.\n            /// This is the value that was present in the input file or other source\n            /// data of the Deserializer.\n            ///\n            /// The `exp` argument provides information about what value was being\n            /// expected. This is the type that is written in the program.\n            ///\n            /// For example if we try to deserialize a String out of some binary data\n            /// that is not valid UTF-8, the unexpected value is the bytes and the\n            /// expected value is a string.\n            #[cold]\n            fn invalid_value(unexp: Unexpected, exp: &Expected) -> Self {\n                Error::custom(format_args!(\"invalid value: {}, expected {}\", unexp, exp))\n            }\n\n            /// Raised when deserializing a sequence or map and the input data contains\n            /// too many or too few elements.\n            ///\n            /// The `len` argument is the number of elements encountered. The sequence\n            /// or map may have expected more arguments or fewer arguments.\n            ///\n            /// The `exp` argument provides information about what data was being\n            /// expected. For example `exp` might say that a tuple of size 6 was\n            /// expected.\n            #[cold]\n            fn invalid_length(len: usize, exp: &Expected) -> Self {\n                Error::custom(format_args!(\"invalid length {}, expected {}\", len, exp))\n            }\n\n            /// Raised when a `Deserialize` enum type received a variant with an\n            /// unrecognized name.\n            #[cold]\n            fn unknown_variant(variant: &str, expected: &'static [&'static str]) -> Self {\n                if expected.is_empty() {\n                    Error::custom(format_args!(\n                        \"unknown variant `{}`, there are no variants\",\n                        variant\n                    ))\n                } else {\n                    Error::custom(format_args!(\n                        \"unknown variant `{}`, expected {}\",\n                        variant,\n                        OneOf { names: expected }\n                    ))\n                }\n            }\n\n            /// Raised when a `Deserialize` struct type received a field with an\n            /// unrecognized name.\n            #[cold]\n            fn unknown_field(field: &str, expected: &'static [&'static str]) -> Self {\n                if expected.is_empty() {\n                    Error::custom(format_args!(\n                        \"unknown field `{}`, there are no fields\",\n                        field\n                    ))\n                } else {\n                    Error::custom(format_args!(\n                        \"unknown field `{}`, expected {}\",\n                        field,\n                        OneOf { names: expected }\n                    ))\n                }\n            }\n\n            /// Raised when a `Deserialize` struct type expected to receive a required\n            /// field with a particular name but that field was not present in the\n            /// input.\n            #[cold]\n            fn missing_field(field: &'static str) -> Self {\n                Error::custom(format_args!(\"missing field `{}`\", field))\n            }\n\n            /// Raised when a `Deserialize` struct type received more than one of the\n            /// same field.\n            #[cold]\n            fn duplicate_field(field: &'static str) -> Self {\n                Error::custom(format_args!(\"duplicate field `{}`\", field))\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\ndeclare_error_trait!(Error: Sized + StdError);\n\n#[cfg(not(feature = \"std\"))]\ndeclare_error_trait!(Error: Sized + Debug + Display);\n\n/// `Unexpected` represents an unexpected invocation of any one of the `Visitor`\n/// trait methods.\n///\n/// This is used as an argument to the `invalid_type`, `invalid_value`, and\n/// `invalid_length` methods of the `Error` trait to build error messages.\n///\n/// ```edition2018\n/// # use std::fmt;\n/// #\n/// # use serde::de::{self, Unexpected, Visitor};\n/// #\n/// # struct Example;\n/// #\n/// # impl<'de> Visitor<'de> for Example {\n/// #     type Value = ();\n/// #\n/// #     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n/// #         write!(formatter, \"definitely not a boolean\")\n/// #     }\n/// #\n/// fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n/// where\n///     E: de::Error,\n/// {\n///     Err(de::Error::invalid_type(Unexpected::Bool(v), &self))\n/// }\n/// # }\n/// ```\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum Unexpected<'a> {\n    /// The input contained a boolean value that was not expected.\n    Bool(bool),\n\n    /// The input contained an unsigned integer `u8`, `u16`, `u32` or `u64` that\n    /// was not expected.\n    Unsigned(u64),\n\n    /// The input contained a signed integer `i8`, `i16`, `i32` or `i64` that\n    /// was not expected.\n    Signed(i64),\n\n    /// The input contained a floating point `f32` or `f64` that was not\n    /// expected.\n    Float(f64),\n\n    /// The input contained a `char` that was not expected.\n    Char(char),\n\n    /// The input contained a `&str` or `String` that was not expected.\n    Str(&'a str),\n\n    /// The input contained a `&[u8]` or `Vec<u8>` that was not expected.\n    Bytes(&'a [u8]),\n\n    /// The input contained a unit `()` that was not expected.\n    Unit,\n\n    /// The input contained an `Option<T>` that was not expected.\n    Option,\n\n    /// The input contained a newtype struct that was not expected.\n    NewtypeStruct,\n\n    /// The input contained a sequence that was not expected.\n    Seq,\n\n    /// The input contained a map that was not expected.\n    Map,\n\n    /// The input contained an enum that was not expected.\n    Enum,\n\n    /// The input contained a unit variant that was not expected.\n    UnitVariant,\n\n    /// The input contained a newtype variant that was not expected.\n    NewtypeVariant,\n\n    /// The input contained a tuple variant that was not expected.\n    TupleVariant,\n\n    /// The input contained a struct variant that was not expected.\n    StructVariant,\n\n    /// A message stating what uncategorized thing the input contained that was\n    /// not expected.\n    ///\n    /// The message should be a noun or noun phrase, not capitalized and without\n    /// a period. An example message is \"unoriginal superhero\".\n    Other(&'a str),\n}\n\nimpl<'a> fmt::Display for Unexpected<'a> {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        use self::Unexpected::*;\n        match *self {\n            Bool(b) => write!(formatter, \"boolean `{}`\", b),\n            Unsigned(i) => write!(formatter, \"integer `{}`\", i),\n            Signed(i) => write!(formatter, \"integer `{}`\", i),\n            Float(f) => write!(formatter, \"floating point `{}`\", f),\n            Char(c) => write!(formatter, \"character `{}`\", c),\n            Str(s) => write!(formatter, \"string {:?}\", s),\n            Bytes(_) => write!(formatter, \"byte array\"),\n            Unit => write!(formatter, \"unit value\"),\n            Option => write!(formatter, \"Option value\"),\n            NewtypeStruct => write!(formatter, \"newtype struct\"),\n            Seq => write!(formatter, \"sequence\"),\n            Map => write!(formatter, \"map\"),\n            Enum => write!(formatter, \"enum\"),\n            UnitVariant => write!(formatter, \"unit variant\"),\n            NewtypeVariant => write!(formatter, \"newtype variant\"),\n            TupleVariant => write!(formatter, \"tuple variant\"),\n            StructVariant => write!(formatter, \"struct variant\"),\n            Other(other) => formatter.write_str(other),\n        }\n    }\n}\n\n/// `Expected` represents an explanation of what data a `Visitor` was expecting\n/// to receive.\n///\n/// This is used as an argument to the `invalid_type`, `invalid_value`, and\n/// `invalid_length` methods of the `Error` trait to build error messages. The\n/// message should be a noun or noun phrase that completes the sentence \"This\n/// Visitor expects to receive ...\", for example the message could be \"an\n/// integer between 0 and 64\". The message should not be capitalized and should\n/// not end with a period.\n///\n/// Within the context of a `Visitor` implementation, the `Visitor` itself\n/// (`&self`) is an implementation of this trait.\n///\n/// ```edition2018\n/// # use std::fmt;\n/// #\n/// # use serde::de::{self, Unexpected, Visitor};\n/// #\n/// # struct Example;\n/// #\n/// # impl<'de> Visitor<'de> for Example {\n/// #     type Value = ();\n/// #\n/// #     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n/// #         write!(formatter, \"definitely not a boolean\")\n/// #     }\n/// #\n/// fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n/// where\n///     E: de::Error,\n/// {\n///     Err(de::Error::invalid_type(Unexpected::Bool(v), &self))\n/// }\n/// # }\n/// ```\n///\n/// Outside of a `Visitor`, `&\"...\"` can be used.\n///\n/// ```edition2018\n/// # use serde::de::{self, Unexpected};\n/// #\n/// # fn example<E>() -> Result<(), E>\n/// # where\n/// #     E: de::Error,\n/// # {\n/// #     let v = true;\n/// return Err(de::Error::invalid_type(Unexpected::Bool(v), &\"a negative integer\"));\n/// # }\n/// ```\npub trait Expected {\n    /// Format an explanation of what data was being expected. Same signature as\n    /// the `Display` and `Debug` traits.\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result;\n}\n\nimpl<'de, T> Expected for T\nwhere\n    T: Visitor<'de>,\n{\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        self.expecting(formatter)\n    }\n}\n\nimpl<'a> Expected for &'a str {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(self)\n    }\n}\n\nimpl<'a> Display for Expected + 'a {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        Expected::fmt(self, formatter)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A **data structure** that can be deserialized from any data format supported\n/// by Serde.\n///\n/// Serde provides `Deserialize` implementations for many Rust primitive and\n/// standard library types. The complete list is [here][de]. All of these can\n/// be deserialized using Serde out of the box.\n///\n/// Additionally, Serde provides a procedural macro called `serde_derive` to\n/// automatically generate `Deserialize` implementations for structs and enums\n/// in your program. See the [derive section of the manual][derive] for how to\n/// use this.\n///\n/// In rare cases it may be necessary to implement `Deserialize` manually for\n/// some type in your program. See the [Implementing\n/// `Deserialize`][impl-deserialize] section of the manual for more about this.\n///\n/// Third-party crates may provide `Deserialize` implementations for types that\n/// they expose. For example the `linked-hash-map` crate provides a\n/// `LinkedHashMap<K, V>` type that is deserializable by Serde because the crate\n/// provides an implementation of `Deserialize` for it.\n///\n/// [de]: https://docs.serde.rs/serde/de/index.html\n/// [derive]: https://serde.rs/derive.html\n/// [impl-deserialize]: https://serde.rs/impl-deserialize.html\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by `Self` when deserialized. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\npub trait Deserialize<'de>: Sized {\n    /// Deserialize this value from the given Serde deserializer.\n    ///\n    /// See the [Implementing `Deserialize`][impl-deserialize] section of the\n    /// manual for more information about how to implement this method.\n    ///\n    /// [impl-deserialize]: https://serde.rs/impl-deserialize.html\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>;\n\n    /// Deserializes a value into `self` from the given Deserializer.\n    ///\n    /// The purpose of this method is to allow the deserializer to reuse\n    /// resources and avoid copies. As such, if this method returns an error,\n    /// `self` will be in an indeterminate state where some parts of the struct\n    /// have been overwritten. Although whatever state that is will be\n    /// memory-safe.\n    ///\n    /// This is generally useful when repeatedly deserializing values that\n    /// are processed one at a time, where the value of `self` doesn't matter\n    /// when the next deserialization occurs.\n    ///\n    /// If you manually implement this, your recursive deserializations should\n    /// use `deserialize_in_place`.\n    ///\n    /// This method is stable and an official public API, but hidden from the\n    /// documentation because it is almost never what newbies are looking for.\n    /// Showing it in rustdoc would cause it to be featured more prominently\n    /// than it deserves.\n    #[doc(hidden)]\n    fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        // Default implementation just delegates to `deserialize` impl.\n        *place = Deserialize::deserialize(deserializer)?;\n        Ok(())\n    }\n}\n\n/// A data structure that can be deserialized without borrowing any data from\n/// the deserializer.\n///\n/// This is primarily useful for trait bounds on functions. For example a\n/// `from_str` function may be able to deserialize a data structure that borrows\n/// from the input string, but a `from_reader` function may only deserialize\n/// owned data.\n///\n/// ```edition2018\n/// # use serde::de::{Deserialize, DeserializeOwned};\n/// # use std::io::{Read, Result};\n/// #\n/// # trait Ignore {\n/// fn from_str<'a, T>(s: &'a str) -> Result<T>\n/// where\n///     T: Deserialize<'a>;\n///\n/// fn from_reader<R, T>(rdr: R) -> Result<T>\n/// where\n///     R: Read,\n///     T: DeserializeOwned;\n/// # }\n/// ```\n///\n/// # Lifetime\n///\n/// The relationship between `Deserialize` and `DeserializeOwned` in trait\n/// bounds is explained in more detail on the page [Understanding deserializer\n/// lifetimes].\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\npub trait DeserializeOwned: for<'de> Deserialize<'de> {}\nimpl<T> DeserializeOwned for T where T: for<'de> Deserialize<'de> {}\n\n/// `DeserializeSeed` is the stateful form of the `Deserialize` trait. If you\n/// ever find yourself looking for a way to pass data into a `Deserialize` impl,\n/// this trait is the way to do it.\n///\n/// As one example of stateful deserialization consider deserializing a JSON\n/// array into an existing buffer. Using the `Deserialize` trait we could\n/// deserialize a JSON array into a `Vec<T>` but it would be a freshly allocated\n/// `Vec<T>`; there is no way for `Deserialize` to reuse a previously allocated\n/// buffer. Using `DeserializeSeed` instead makes this possible as in the\n/// example code below.\n///\n/// The canonical API for stateless deserialization looks like this:\n///\n/// ```edition2018\n/// # use serde::Deserialize;\n/// #\n/// # enum Error {}\n/// #\n/// fn func<'de, T: Deserialize<'de>>() -> Result<T, Error>\n/// # {\n/// #     unimplemented!()\n/// # }\n/// ```\n///\n/// Adjusting an API like this to support stateful deserialization is a matter\n/// of accepting a seed as input:\n///\n/// ```edition2018\n/// # use serde::de::DeserializeSeed;\n/// #\n/// # enum Error {}\n/// #\n/// fn func_seed<'de, T: DeserializeSeed<'de>>(seed: T) -> Result<T::Value, Error>\n/// # {\n/// #     let _ = seed;\n/// #     unimplemented!()\n/// # }\n/// ```\n///\n/// In practice the majority of deserialization is stateless. An API expecting a\n/// seed can be appeased by passing `std::marker::PhantomData` as a seed in the\n/// case of stateless deserialization.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by `Self::Value` when deserialized. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example\n///\n/// Suppose we have JSON that looks like `[[1, 2], [3, 4, 5], [6]]` and we need\n/// to deserialize it into a flat representation like `vec![1, 2, 3, 4, 5, 6]`.\n/// Allocating a brand new `Vec<T>` for each subarray would be slow. Instead we\n/// would like to allocate a single `Vec<T>` and then deserialize each subarray\n/// into it. This requires stateful deserialization using the `DeserializeSeed`\n/// trait.\n///\n/// ```edition2018\n/// use std::fmt;\n/// use std::marker::PhantomData;\n///\n/// use serde::de::{Deserialize, DeserializeSeed, Deserializer, SeqAccess, Visitor};\n///\n/// // A DeserializeSeed implementation that uses stateful deserialization to\n/// // append array elements onto the end of an existing vector. The preexisting\n/// // state (\"seed\") in this case is the Vec<T>. The `deserialize` method of\n/// // `ExtendVec` will be traversing the inner arrays of the JSON input and\n/// // appending each integer into the existing Vec.\n/// struct ExtendVec<'a, T: 'a>(&'a mut Vec<T>);\n///\n/// impl<'de, 'a, T> DeserializeSeed<'de> for ExtendVec<'a, T>\n/// where\n///     T: Deserialize<'de>,\n/// {\n///     // The return type of the `deserialize` method. This implementation\n///     // appends onto an existing vector but does not create any new data\n///     // structure, so the return type is ().\n///     type Value = ();\n///\n///     fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n///     where\n///         D: Deserializer<'de>,\n///     {\n///         // Visitor implementation that will walk an inner array of the JSON\n///         // input.\n///         struct ExtendVecVisitor<'a, T: 'a>(&'a mut Vec<T>);\n///\n///         impl<'de, 'a, T> Visitor<'de> for ExtendVecVisitor<'a, T>\n///         where\n///             T: Deserialize<'de>,\n///         {\n///             type Value = ();\n///\n///             fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n///                 write!(formatter, \"an array of integers\")\n///             }\n///\n///             fn visit_seq<A>(self, mut seq: A) -> Result<(), A::Error>\n///             where\n///                 A: SeqAccess<'de>,\n///             {\n///                 // Visit each element in the inner array and push it onto\n///                 // the existing vector.\n///                 while let Some(elem) = seq.next_element()? {\n///                     self.0.push(elem);\n///                 }\n///                 Ok(())\n///             }\n///         }\n///\n///         deserializer.deserialize_seq(ExtendVecVisitor(self.0))\n///     }\n/// }\n///\n/// // Visitor implementation that will walk the outer array of the JSON input.\n/// struct FlattenedVecVisitor<T>(PhantomData<T>);\n///\n/// impl<'de, T> Visitor<'de> for FlattenedVecVisitor<T>\n/// where\n///     T: Deserialize<'de>,\n/// {\n///     // This Visitor constructs a single Vec<T> to hold the flattened\n///     // contents of the inner arrays.\n///     type Value = Vec<T>;\n///\n///     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n///         write!(formatter, \"an array of arrays\")\n///     }\n///\n///     fn visit_seq<A>(self, mut seq: A) -> Result<Vec<T>, A::Error>\n///     where\n///         A: SeqAccess<'de>,\n///     {\n///         // Create a single Vec to hold the flattened contents.\n///         let mut vec = Vec::new();\n///\n///         // Each iteration through this loop is one inner array.\n///         while let Some(()) = seq.next_element_seed(ExtendVec(&mut vec))? {\n///             // Nothing to do; inner array has been appended into `vec`.\n///         }\n///\n///         // Return the finished vec.\n///         Ok(vec)\n///     }\n/// }\n///\n/// # fn example<'de, D>(deserializer: D) -> Result<(), D::Error>\n/// # where\n/// #     D: Deserializer<'de>,\n/// # {\n/// let visitor = FlattenedVecVisitor(PhantomData);\n/// let flattened: Vec<u64> = deserializer.deserialize_seq(visitor)?;\n/// #     Ok(())\n/// # }\n/// ```\npub trait DeserializeSeed<'de>: Sized {\n    /// The type produced by using this seed.\n    type Value;\n\n    /// Equivalent to the more common `Deserialize::deserialize` method, except\n    /// with some initial piece of data (the seed) passed in.\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>;\n}\n\nimpl<'de, T> DeserializeSeed<'de> for PhantomData<T>\nwhere\n    T: Deserialize<'de>,\n{\n    type Value = T;\n\n    #[inline]\n    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        T::deserialize(deserializer)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A **data format** that can deserialize any data structure supported by\n/// Serde.\n///\n/// The role of this trait is to define the deserialization half of the [Serde\n/// data model], which is a way to categorize every Rust data type into one of\n/// 29 possible types. Each method of the `Deserializer` trait corresponds to one\n/// of the types of the data model.\n///\n/// Implementations of `Deserialize` map themselves into this data model by\n/// passing to the `Deserializer` a `Visitor` implementation that can receive\n/// these various types.\n///\n/// The types that make up the Serde data model are:\n///\n///  - **14 primitive types**\n///    - bool\n///    - i8, i16, i32, i64, i128\n///    - u8, u16, u32, u64, u128\n///    - f32, f64\n///    - char\n///  - **string**\n///    - UTF-8 bytes with a length and no null terminator.\n///    - When serializing, all strings are handled equally. When deserializing,\n///      there are three flavors of strings: transient, owned, and borrowed.\n///  - **byte array** - \\[u8\\]\n///    - Similar to strings, during deserialization byte arrays can be\n///      transient, owned, or borrowed.\n///  - **option**\n///    - Either none or some value.\n///  - **unit**\n///    - The type of `()` in Rust. It represents an anonymous value containing\n///      no data.\n///  - **unit_struct**\n///    - For example `struct Unit` or `PhantomData<T>`. It represents a named\n///      value containing no data.\n///  - **unit_variant**\n///    - For example the `E::A` and `E::B` in `enum E { A, B }`.\n///  - **newtype_struct**\n///    - For example `struct Millimeters(u8)`.\n///  - **newtype_variant**\n///    - For example the `E::N` in `enum E { N(u8) }`.\n///  - **seq**\n///    - A variably sized heterogeneous sequence of values, for example `Vec<T>`\n///      or `HashSet<T>`. When serializing, the length may or may not be known\n///      before iterating through all the data. When deserializing, the length\n///      is determined by looking at the serialized data.\n///  - **tuple**\n///    - A statically sized heterogeneous sequence of values for which the\n///      length will be known at deserialization time without looking at the\n///      serialized data, for example `(u8,)` or `(String, u64, Vec<T>)` or\n///      `[u64; 10]`.\n///  - **tuple_struct**\n///    - A named tuple, for example `struct Rgb(u8, u8, u8)`.\n///  - **tuple_variant**\n///    - For example the `E::T` in `enum E { T(u8, u8) }`.\n///  - **map**\n///    - A heterogeneous key-value pairing, for example `BTreeMap<K, V>`.\n///  - **struct**\n///    - A heterogeneous key-value pairing in which the keys are strings and\n///      will be known at deserialization time without looking at the serialized\n///      data, for example `struct S { r: u8, g: u8, b: u8 }`.\n///  - **struct_variant**\n///    - For example the `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`.\n///\n/// The `Deserializer` trait supports two entry point styles which enables\n/// different kinds of deserialization.\n///\n/// 1. The `deserialize` method. Self-describing data formats like JSON are able\n///    to look at the serialized data and tell what it represents. For example\n///    the JSON deserializer may see an opening curly brace (`{`) and know that\n///    it is seeing a map. If the data format supports\n///    `Deserializer::deserialize_any`, it will drive the Visitor using whatever\n///    type it sees in the input. JSON uses this approach when deserializing\n///    `serde_json::Value` which is an enum that can represent any JSON\n///    document. Without knowing what is in a JSON document, we can deserialize\n///    it to `serde_json::Value` by going through\n///    `Deserializer::deserialize_any`.\n///\n/// 2. The various `deserialize_*` methods. Non-self-describing formats like\n///    Bincode need to be told what is in the input in order to deserialize it.\n///    The `deserialize_*` methods are hints to the deserializer for how to\n///    interpret the next piece of input. Non-self-describing formats are not\n///    able to deserialize something like `serde_json::Value` which relies on\n///    `Deserializer::deserialize_any`.\n///\n/// When implementing `Deserialize`, you should avoid relying on\n/// `Deserializer::deserialize_any` unless you need to be told by the\n/// Deserializer what type is in the input. Know that relying on\n/// `Deserializer::deserialize_any` means your data type will be able to\n/// deserialize from self-describing formats only, ruling out Bincode and many\n/// others.\n///\n/// [Serde data model]: https://serde.rs/data-model.html\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed from the input when deserializing. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website contains example code for\n/// a basic JSON `Deserializer`.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait Deserializer<'de>: Sized {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization.\n    type Error: Error;\n\n    /// Require the `Deserializer` to figure out how to drive the visitor based\n    /// on what data type is in the input.\n    ///\n    /// When implementing `Deserialize`, you should avoid relying on\n    /// `Deserializer::deserialize_any` unless you need to be told by the\n    /// Deserializer what type is in the input. Know that relying on\n    /// `Deserializer::deserialize_any` means your data type will be able to\n    /// deserialize from self-describing formats only, ruling out Bincode and\n    /// many others.\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a `bool` value.\n    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting an `i8` value.\n    fn deserialize_i8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting an `i16` value.\n    fn deserialize_i16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting an `i32` value.\n    fn deserialize_i32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting an `i64` value.\n    fn deserialize_i64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    serde_if_integer128! {\n        /// Hint that the `Deserialize` type is expecting an `i128` value.\n        ///\n        /// This method is available only on Rust compiler versions >=1.26. The\n        /// default behavior unconditionally returns an error.\n        fn deserialize_i128<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>\n        {\n            let _ = visitor;\n            Err(Error::custom(\"i128 is not supported\"))\n        }\n    }\n\n    /// Hint that the `Deserialize` type is expecting a `u8` value.\n    fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a `u16` value.\n    fn deserialize_u16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a `u32` value.\n    fn deserialize_u32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a `u64` value.\n    fn deserialize_u64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    serde_if_integer128! {\n        /// Hint that the `Deserialize` type is expecting an `u128` value.\n        ///\n        /// This method is available only on Rust compiler versions >=1.26. The\n        /// default behavior unconditionally returns an error.\n        fn deserialize_u128<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>\n        {\n            let _ = visitor;\n            Err(Error::custom(\"u128 is not supported\"))\n        }\n    }\n\n    /// Hint that the `Deserialize` type is expecting a `f32` value.\n    fn deserialize_f32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a `f64` value.\n    fn deserialize_f64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a `char` value.\n    fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a string value and does\n    /// not benefit from taking ownership of buffered data owned by the\n    /// `Deserializer`.\n    ///\n    /// If the `Visitor` would benefit from taking ownership of `String` data,\n    /// indiciate this to the `Deserializer` by using `deserialize_string`\n    /// instead.\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a string value and would\n    /// benefit from taking ownership of buffered data owned by the\n    /// `Deserializer`.\n    ///\n    /// If the `Visitor` would not benefit from taking ownership of `String`\n    /// data, indicate that to the `Deserializer` by using `deserialize_str`\n    /// instead.\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a byte array and does not\n    /// benefit from taking ownership of buffered data owned by the\n    /// `Deserializer`.\n    ///\n    /// If the `Visitor` would benefit from taking ownership of `Vec<u8>` data,\n    /// indicate this to the `Deserializer` by using `deserialize_byte_buf`\n    /// instead.\n    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a byte array and would\n    /// benefit from taking ownership of buffered data owned by the\n    /// `Deserializer`.\n    ///\n    /// If the `Visitor` would not benefit from taking ownership of `Vec<u8>`\n    /// data, indicate that to the `Deserializer` by using `deserialize_bytes`\n    /// instead.\n    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting an optional value.\n    ///\n    /// This allows deserializers that encode an optional value as a nullable\n    /// value to convert the null value into `None` and a regular value into\n    /// `Some(value)`.\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a unit value.\n    fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a unit struct with a\n    /// particular name.\n    fn deserialize_unit_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a newtype struct with a\n    /// particular name.\n    fn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a sequence of values.\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a sequence of values and\n    /// knows how many values there are without looking at the serialized data.\n    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a tuple struct with a\n    /// particular name and number of fields.\n    fn deserialize_tuple_struct<V>(\n        self,\n        name: &'static str,\n        len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a map of key-value pairs.\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting a struct with a particular\n    /// name and fields.\n    fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting an enum value with a\n    /// particular name and possible variants.\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type is expecting the name of a struct\n    /// field or the discriminant of an enum variant.\n    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Hint that the `Deserialize` type needs to deserialize a value whose type\n    /// doesn't matter because it is ignored.\n    ///\n    /// Deserializers for non-self-describing formats may not support this mode.\n    fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Determine whether `Deserialize` implementations should expect to\n    /// deserialize their human-readable form.\n    ///\n    /// Some types have a human-readable form that may be somewhat expensive to\n    /// construct, as well as a binary form that is compact and efficient.\n    /// Generally text-based formats like JSON and YAML will prefer to use the\n    /// human-readable one and binary formats like Bincode will prefer the\n    /// compact one.\n    ///\n    /// ```edition2018\n    /// # use std::ops::Add;\n    /// # use std::str::FromStr;\n    /// #\n    /// # struct Timestamp;\n    /// #\n    /// # impl Timestamp {\n    /// #     const EPOCH: Timestamp = Timestamp;\n    /// # }\n    /// #\n    /// # impl FromStr for Timestamp {\n    /// #     type Err = String;\n    /// #     fn from_str(_: &str) -> Result<Self, Self::Err> {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// # struct Duration;\n    /// #\n    /// # impl Duration {\n    /// #     fn seconds(_: u64) -> Self { unimplemented!() }\n    /// # }\n    /// #\n    /// # impl Add<Duration> for Timestamp {\n    /// #     type Output = Timestamp;\n    /// #     fn add(self, _: Duration) -> Self::Output {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// use serde::de::{self, Deserialize, Deserializer};\n    ///\n    /// impl<'de> Deserialize<'de> for Timestamp {\n    ///     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    ///     where\n    ///         D: Deserializer<'de>,\n    ///     {\n    ///         if deserializer.is_human_readable() {\n    ///             // Deserialize from a human-readable string like \"2015-05-15T17:01:00Z\".\n    ///             let s = String::deserialize(deserializer)?;\n    ///             Timestamp::from_str(&s).map_err(de::Error::custom)\n    ///         } else {\n    ///             // Deserialize from a compact binary representation, seconds since\n    ///             // the Unix epoch.\n    ///             let n = u64::deserialize(deserializer)?;\n    ///             Ok(Timestamp::EPOCH + Duration::seconds(n))\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// The default implementation of this method returns `true`. Data formats\n    /// may override this to `false` to request a compact form for types that\n    /// support one. Note that modifying this method to change a format from\n    /// human-readable to compact or vice versa should be regarded as a breaking\n    /// change, as a value serialized in human-readable mode is not required to\n    /// deserialize from the same data in compact mode.\n    #[inline]\n    fn is_human_readable(&self) -> bool {\n        true\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// This trait represents a visitor that walks through a deserializer.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the requirement for lifetime of data\n/// that may be borrowed by `Self::Value`. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example\n///\n/// ```edition2018\n/// # use std::fmt;\n/// #\n/// # use serde::de::{self, Unexpected, Visitor};\n/// #\n/// /// A visitor that deserializes a long string - a string containing at least\n/// /// some minimum number of bytes.\n/// struct LongString {\n///     min: usize,\n/// }\n///\n/// impl<'de> Visitor<'de> for LongString {\n///     type Value = String;\n///\n///     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n///         write!(formatter, \"a string containing at least {} bytes\", self.min)\n///     }\n///\n///     fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n///     where\n///         E: de::Error,\n///     {\n///         if s.len() >= self.min {\n///             Ok(s.to_owned())\n///         } else {\n///             Err(de::Error::invalid_value(Unexpected::Str(s), &self))\n///         }\n///     }\n/// }\n/// ```\npub trait Visitor<'de>: Sized {\n    /// The value produced by this visitor.\n    type Value;\n\n    /// Format a message stating what data this Visitor expects to receive.\n    ///\n    /// This is used in error messages. The message should complete the sentence\n    /// \"This Visitor expects to receive ...\", for example the message could be\n    /// \"an integer between 0 and 64\". The message should not be capitalized and\n    /// should not end with a period.\n    ///\n    /// ```edition2018\n    /// # use std::fmt;\n    /// #\n    /// # struct S {\n    /// #     max: usize,\n    /// # }\n    /// #\n    /// # impl<'de> serde::de::Visitor<'de> for S {\n    /// #     type Value = ();\n    /// #\n    /// fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///     write!(formatter, \"an integer between 0 and {}\", self.max)\n    /// }\n    /// # }\n    /// ```\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result;\n\n    /// The input contains a boolean.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Bool(v), &self))\n    }\n\n    /// The input contains an `i8`.\n    ///\n    /// The default implementation forwards to [`visit_i64`].\n    ///\n    /// [`visit_i64`]: #method.visit_i64\n    fn visit_i8<E>(self, v: i8) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n\n    /// The input contains an `i16`.\n    ///\n    /// The default implementation forwards to [`visit_i64`].\n    ///\n    /// [`visit_i64`]: #method.visit_i64\n    fn visit_i16<E>(self, v: i16) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n\n    /// The input contains an `i32`.\n    ///\n    /// The default implementation forwards to [`visit_i64`].\n    ///\n    /// [`visit_i64`]: #method.visit_i64\n    fn visit_i32<E>(self, v: i32) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n\n    /// The input contains an `i64`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Signed(v), &self))\n    }\n\n    serde_if_integer128! {\n        /// The input contains a `i128`.\n        ///\n        /// This method is available only on Rust compiler versions >=1.26. The\n        /// default implementation fails with a type error.\n        fn visit_i128<E>(self, v: i128) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            let _ = v;\n            Err(Error::invalid_type(Unexpected::Other(\"i128\"), &self))\n        }\n    }\n\n    /// The input contains a `u8`.\n    ///\n    /// The default implementation forwards to [`visit_u64`].\n    ///\n    /// [`visit_u64`]: #method.visit_u64\n    fn visit_u8<E>(self, v: u8) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n\n    /// The input contains a `u16`.\n    ///\n    /// The default implementation forwards to [`visit_u64`].\n    ///\n    /// [`visit_u64`]: #method.visit_u64\n    fn visit_u16<E>(self, v: u16) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n\n    /// The input contains a `u32`.\n    ///\n    /// The default implementation forwards to [`visit_u64`].\n    ///\n    /// [`visit_u64`]: #method.visit_u64\n    fn visit_u32<E>(self, v: u32) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n\n    /// The input contains a `u64`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Unsigned(v), &self))\n    }\n\n    serde_if_integer128! {\n        /// The input contains a `u128`.\n        ///\n        /// This method is available only on Rust compiler versions >=1.26. The\n        /// default implementation fails with a type error.\n        fn visit_u128<E>(self, v: u128) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            let _ = v;\n            Err(Error::invalid_type(Unexpected::Other(\"u128\"), &self))\n        }\n    }\n\n    /// The input contains an `f32`.\n    ///\n    /// The default implementation forwards to [`visit_f64`].\n    ///\n    /// [`visit_f64`]: #method.visit_f64\n    fn visit_f32<E>(self, v: f32) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_f64(v as f64)\n    }\n\n    /// The input contains an `f64`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_f64<E>(self, v: f64) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Float(v), &self))\n    }\n\n    /// The input contains a `char`.\n    ///\n    /// The default implementation forwards to [`visit_str`] as a one-character\n    /// string.\n    ///\n    /// [`visit_str`]: #method.visit_str\n    #[inline]\n    fn visit_char<E>(self, v: char) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_str(utf8::encode(v).as_str())\n    }\n\n    /// The input contains a string. The lifetime of the string is ephemeral and\n    /// it may be destroyed after this method returns.\n    ///\n    /// This method allows the `Deserializer` to avoid a copy by retaining\n    /// ownership of any buffered data. `Deserialize` implementations that do\n    /// not benefit from taking ownership of `String` data should indicate that\n    /// to the deserializer by using `Deserializer::deserialize_str` rather than\n    /// `Deserializer::deserialize_string`.\n    ///\n    /// It is never correct to implement `visit_string` without implementing\n    /// `visit_str`. Implement neither, both, or just `visit_str`.\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Str(v), &self))\n    }\n\n    /// The input contains a string that lives at least as long as the\n    /// `Deserializer`.\n    ///\n    /// This enables zero-copy deserialization of strings in some formats. For\n    /// example JSON input containing the JSON string `\"borrowed\"` can be\n    /// deserialized with zero copying into a `&'a str` as long as the input\n    /// data outlives `'a`.\n    ///\n    /// The default implementation forwards to `visit_str`.\n    #[inline]\n    fn visit_borrowed_str<E>(self, v: &'de str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_str(v)\n    }\n\n    /// The input contains a string and ownership of the string is being given\n    /// to the `Visitor`.\n    ///\n    /// This method allows the `Visitor` to avoid a copy by taking ownership of\n    /// a string created by the `Deserializer`. `Deserialize` implementations\n    /// that benefit from taking ownership of `String` data should indicate that\n    /// to the deserializer by using `Deserializer::deserialize_string` rather\n    /// than `Deserializer::deserialize_str`, although not every deserializer\n    /// will honor such a request.\n    ///\n    /// It is never correct to implement `visit_string` without implementing\n    /// `visit_str`. Implement neither, both, or just `visit_str`.\n    ///\n    /// The default implementation forwards to `visit_str` and then drops the\n    /// `String`.\n    #[inline]\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_str(&v)\n    }\n\n    /// The input contains a byte array. The lifetime of the byte array is\n    /// ephemeral and it may be destroyed after this method returns.\n    ///\n    /// This method allows the `Deserializer` to avoid a copy by retaining\n    /// ownership of any buffered data. `Deserialize` implementations that do\n    /// not benefit from taking ownership of `Vec<u8>` data should indicate that\n    /// to the deserializer by using `Deserializer::deserialize_bytes` rather\n    /// than `Deserializer::deserialize_byte_buf`.\n    ///\n    /// It is never correct to implement `visit_byte_buf` without implementing\n    /// `visit_bytes`. Implement neither, both, or just `visit_bytes`.\n    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        let _ = v;\n        Err(Error::invalid_type(Unexpected::Bytes(v), &self))\n    }\n\n    /// The input contains a byte array that lives at least as long as the\n    /// `Deserializer`.\n    ///\n    /// This enables zero-copy deserialization of bytes in some formats. For\n    /// example Bincode data containing bytes can be deserialized with zero\n    /// copying into a `&'a [u8]` as long as the input data outlives `'a`.\n    ///\n    /// The default implementation forwards to `visit_bytes`.\n    #[inline]\n    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_bytes(v)\n    }\n\n    /// The input contains a byte array and ownership of the byte array is being\n    /// given to the `Visitor`.\n    ///\n    /// This method allows the `Visitor` to avoid a copy by taking ownership of\n    /// a byte buffer created by the `Deserializer`. `Deserialize`\n    /// implementations that benefit from taking ownership of `Vec<u8>` data\n    /// should indicate that to the deserializer by using\n    /// `Deserializer::deserialize_byte_buf` rather than\n    /// `Deserializer::deserialize_bytes`, although not every deserializer will\n    /// honor such a request.\n    ///\n    /// It is never correct to implement `visit_byte_buf` without implementing\n    /// `visit_bytes`. Implement neither, both, or just `visit_bytes`.\n    ///\n    /// The default implementation forwards to `visit_bytes` and then drops the\n    /// `Vec<u8>`.\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.visit_bytes(&v)\n    }\n\n    /// The input contains an optional that is absent.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_none<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Option, &self))\n    }\n\n    /// The input contains an optional that is present.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let _ = deserializer;\n        Err(Error::invalid_type(Unexpected::Option, &self))\n    }\n\n    /// The input contains a unit `()`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_unit<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Unit, &self))\n    }\n\n    /// The input contains a newtype struct.\n    ///\n    /// The content of the newtype struct may be read from the given\n    /// `Deserializer`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let _ = deserializer;\n        Err(Error::invalid_type(Unexpected::NewtypeStruct, &self))\n    }\n\n    /// The input contains a sequence of elements.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_seq<A>(self, seq: A) -> Result<Self::Value, A::Error>\n    where\n        A: SeqAccess<'de>,\n    {\n        let _ = seq;\n        Err(Error::invalid_type(Unexpected::Seq, &self))\n    }\n\n    /// The input contains a key-value map.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>\n    where\n        A: MapAccess<'de>,\n    {\n        let _ = map;\n        Err(Error::invalid_type(Unexpected::Map, &self))\n    }\n\n    /// The input contains an enum.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n    where\n        A: EnumAccess<'de>,\n    {\n        let _ = data;\n        Err(Error::invalid_type(Unexpected::Enum, &self))\n    }\n\n    // Used when deserializing a flattened Option field. Not public API.\n    #[doc(hidden)]\n    fn __private_visit_untagged_option<D>(self, _: D) -> Result<Self::Value, ()>\n    where\n        D: Deserializer<'de>,\n    {\n        Err(())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Provides a `Visitor` access to each element of a sequence in the input.\n///\n/// This is a trait that a `Deserializer` passes to a `Visitor` implementation,\n/// which deserializes each item in a sequence.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by deserialized sequence elements. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SeqAccess` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SeqAccess<'de> {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization.\n    type Error: Error;\n\n    /// This returns `Ok(Some(value))` for the next value in the sequence, or\n    /// `Ok(None)` if there are no more remaining items.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `SeqAccess::next_element` instead.\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n    where\n        T: DeserializeSeed<'de>;\n\n    /// This returns `Ok(Some(value))` for the next value in the sequence, or\n    /// `Ok(None)` if there are no more remaining items.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `SeqAccess` implementations should not override the default behavior.\n    #[inline]\n    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>\n    where\n        T: Deserialize<'de>,\n    {\n        self.next_element_seed(PhantomData)\n    }\n\n    /// Returns the number of elements remaining in the sequence, if known.\n    #[inline]\n    fn size_hint(&self) -> Option<usize> {\n        None\n    }\n}\n\nimpl<'de, 'a, A> SeqAccess<'de> for &'a mut A\nwhere\n    A: SeqAccess<'de>,\n{\n    type Error = A::Error;\n\n    #[inline]\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        (**self).next_element_seed(seed)\n    }\n\n    #[inline]\n    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>\n    where\n        T: Deserialize<'de>,\n    {\n        (**self).next_element()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> Option<usize> {\n        (**self).size_hint()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Provides a `Visitor` access to each entry of a map in the input.\n///\n/// This is a trait that a `Deserializer` passes to a `Visitor` implementation.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by deserialized map entries. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `MapAccess` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait MapAccess<'de> {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization.\n    type Error: Error;\n\n    /// This returns `Ok(Some(key))` for the next key in the map, or `Ok(None)`\n    /// if there are no more remaining entries.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `MapAccess::next_key` or `MapAccess::next_entry` instead.\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n    where\n        K: DeserializeSeed<'de>;\n\n    /// This returns a `Ok(value)` for the next value in the map.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `MapAccess::next_value` instead.\n    ///\n    /// # Panics\n    ///\n    /// Calling `next_value_seed` before `next_key_seed` is incorrect and is\n    /// allowed to panic or return bogus results.\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n    where\n        V: DeserializeSeed<'de>;\n\n    /// This returns `Ok(Some((key, value)))` for the next (key-value) pair in\n    /// the map, or `Ok(None)` if there are no more remaining items.\n    ///\n    /// `MapAccess` implementations should override the default behavior if a\n    /// more efficient implementation is possible.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `MapAccess::next_entry` instead.\n    #[inline]\n    fn next_entry_seed<K, V>(\n        &mut self,\n        kseed: K,\n        vseed: V,\n    ) -> Result<Option<(K::Value, V::Value)>, Self::Error>\n    where\n        K: DeserializeSeed<'de>,\n        V: DeserializeSeed<'de>,\n    {\n        match try!(self.next_key_seed(kseed)) {\n            Some(key) => {\n                let value = try!(self.next_value_seed(vseed));\n                Ok(Some((key, value)))\n            }\n            None => Ok(None),\n        }\n    }\n\n    /// This returns `Ok(Some(key))` for the next key in the map, or `Ok(None)`\n    /// if there are no more remaining entries.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `MapAccess` implementations should not override the default behavior.\n    #[inline]\n    fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n    where\n        K: Deserialize<'de>,\n    {\n        self.next_key_seed(PhantomData)\n    }\n\n    /// This returns a `Ok(value)` for the next value in the map.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `MapAccess` implementations should not override the default behavior.\n    ///\n    /// # Panics\n    ///\n    /// Calling `next_value` before `next_key` is incorrect and is allowed to\n    /// panic or return bogus results.\n    #[inline]\n    fn next_value<V>(&mut self) -> Result<V, Self::Error>\n    where\n        V: Deserialize<'de>,\n    {\n        self.next_value_seed(PhantomData)\n    }\n\n    /// This returns `Ok(Some((key, value)))` for the next (key-value) pair in\n    /// the map, or `Ok(None)` if there are no more remaining items.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `MapAccess` implementations should not override the default behavior.\n    #[inline]\n    fn next_entry<K, V>(&mut self) -> Result<Option<(K, V)>, Self::Error>\n    where\n        K: Deserialize<'de>,\n        V: Deserialize<'de>,\n    {\n        self.next_entry_seed(PhantomData, PhantomData)\n    }\n\n    /// Returns the number of entries remaining in the map, if known.\n    #[inline]\n    fn size_hint(&self) -> Option<usize> {\n        None\n    }\n}\n\nimpl<'de, 'a, A> MapAccess<'de> for &'a mut A\nwhere\n    A: MapAccess<'de>,\n{\n    type Error = A::Error;\n\n    #[inline]\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n    where\n        K: DeserializeSeed<'de>,\n    {\n        (**self).next_key_seed(seed)\n    }\n\n    #[inline]\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        (**self).next_value_seed(seed)\n    }\n\n    #[inline]\n    fn next_entry_seed<K, V>(\n        &mut self,\n        kseed: K,\n        vseed: V,\n    ) -> Result<Option<(K::Value, V::Value)>, Self::Error>\n    where\n        K: DeserializeSeed<'de>,\n        V: DeserializeSeed<'de>,\n    {\n        (**self).next_entry_seed(kseed, vseed)\n    }\n\n    #[inline]\n    fn next_entry<K, V>(&mut self) -> Result<Option<(K, V)>, Self::Error>\n    where\n        K: Deserialize<'de>,\n        V: Deserialize<'de>,\n    {\n        (**self).next_entry()\n    }\n\n    #[inline]\n    fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n    where\n        K: Deserialize<'de>,\n    {\n        (**self).next_key()\n    }\n\n    #[inline]\n    fn next_value<V>(&mut self) -> Result<V, Self::Error>\n    where\n        V: Deserialize<'de>,\n    {\n        (**self).next_value()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> Option<usize> {\n        (**self).size_hint()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Provides a `Visitor` access to the data of an enum in the input.\n///\n/// `EnumAccess` is created by the `Deserializer` and passed to the\n/// `Visitor` in order to identify which variant of an enum to deserialize.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by the deserialized enum variant. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `EnumAccess` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait EnumAccess<'de>: Sized {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization.\n    type Error: Error;\n    /// The `Visitor` that will be used to deserialize the content of the enum\n    /// variant.\n    type Variant: VariantAccess<'de, Error = Self::Error>;\n\n    /// `variant` is called to identify which variant to deserialize.\n    ///\n    /// `Deserialize` implementations should typically use `EnumAccess::variant`\n    /// instead.\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: DeserializeSeed<'de>;\n\n    /// `variant` is called to identify which variant to deserialize.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `EnumAccess` implementations should not override the default behavior.\n    #[inline]\n    fn variant<V>(self) -> Result<(V, Self::Variant), Self::Error>\n    where\n        V: Deserialize<'de>,\n    {\n        self.variant_seed(PhantomData)\n    }\n}\n\n/// `VariantAccess` is a visitor that is created by the `Deserializer` and\n/// passed to the `Deserialize` to deserialize the content of a particular enum\n/// variant.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by the deserialized enum variant. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `VariantAccess` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait VariantAccess<'de>: Sized {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization. Must match the error type of our `EnumAccess`.\n    type Error: Error;\n\n    /// Called when deserializing a variant with no values.\n    ///\n    /// If the data contains a different type of variant, the following\n    /// `invalid_type` error should be constructed:\n    ///\n    /// ```edition2018\n    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n    /// #\n    /// # struct X;\n    /// #\n    /// # impl<'de> VariantAccess<'de> for X {\n    /// #     type Error = value::Error;\n    /// #\n    /// fn unit_variant(self) -> Result<(), Self::Error> {\n    ///     // What the data actually contained; suppose it is a tuple variant.\n    ///     let unexp = Unexpected::TupleVariant;\n    ///     Err(de::Error::invalid_type(unexp, &\"unit variant\"))\n    /// }\n    /// #\n    /// #     fn newtype_variant_seed<T>(self, _: T) -> Result<T::Value, Self::Error>\n    /// #     where\n    /// #         T: DeserializeSeed<'de>,\n    /// #     { unimplemented!() }\n    /// #\n    /// #     fn tuple_variant<V>(self, _: usize, _: V) -> Result<V::Value, Self::Error>\n    /// #     where\n    /// #         V: Visitor<'de>,\n    /// #     { unimplemented!() }\n    /// #\n    /// #     fn struct_variant<V>(self, _: &[&str], _: V) -> Result<V::Value, Self::Error>\n    /// #     where\n    /// #         V: Visitor<'de>,\n    /// #     { unimplemented!() }\n    /// # }\n    /// ```\n    fn unit_variant(self) -> Result<(), Self::Error>;\n\n    /// Called when deserializing a variant with a single value.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `VariantAccess::newtype_variant` instead.\n    ///\n    /// If the data contains a different type of variant, the following\n    /// `invalid_type` error should be constructed:\n    ///\n    /// ```edition2018\n    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n    /// #\n    /// # struct X;\n    /// #\n    /// # impl<'de> VariantAccess<'de> for X {\n    /// #     type Error = value::Error;\n    /// #\n    /// #     fn unit_variant(self) -> Result<(), Self::Error> {\n    /// #         unimplemented!()\n    /// #     }\n    /// #\n    /// fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>\n    /// where\n    ///     T: DeserializeSeed<'de>,\n    /// {\n    ///     // What the data actually contained; suppose it is a unit variant.\n    ///     let unexp = Unexpected::UnitVariant;\n    ///     Err(de::Error::invalid_type(unexp, &\"newtype variant\"))\n    /// }\n    /// #\n    /// #     fn tuple_variant<V>(self, _: usize, _: V) -> Result<V::Value, Self::Error>\n    /// #     where\n    /// #         V: Visitor<'de>,\n    /// #     { unimplemented!() }\n    /// #\n    /// #     fn struct_variant<V>(self, _: &[&str], _: V) -> Result<V::Value, Self::Error>\n    /// #     where\n    /// #         V: Visitor<'de>,\n    /// #     { unimplemented!() }\n    /// # }\n    /// ```\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: DeserializeSeed<'de>;\n\n    /// Called when deserializing a variant with a single value.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `VariantAccess` implementations should not override the default\n    /// behavior.\n    #[inline]\n    fn newtype_variant<T>(self) -> Result<T, Self::Error>\n    where\n        T: Deserialize<'de>,\n    {\n        self.newtype_variant_seed(PhantomData)\n    }\n\n    /// Called when deserializing a tuple-like variant.\n    ///\n    /// The `len` is the number of fields expected in the tuple variant.\n    ///\n    /// If the data contains a different type of variant, the following\n    /// `invalid_type` error should be constructed:\n    ///\n    /// ```edition2018\n    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n    /// #\n    /// # struct X;\n    /// #\n    /// # impl<'de> VariantAccess<'de> for X {\n    /// #     type Error = value::Error;\n    /// #\n    /// #     fn unit_variant(self) -> Result<(), Self::Error> {\n    /// #         unimplemented!()\n    /// #     }\n    /// #\n    /// #     fn newtype_variant_seed<T>(self, _: T) -> Result<T::Value, Self::Error>\n    /// #     where\n    /// #         T: DeserializeSeed<'de>,\n    /// #     { unimplemented!() }\n    /// #\n    /// fn tuple_variant<V>(\n    ///     self,\n    ///     _len: usize,\n    ///     _visitor: V,\n    /// ) -> Result<V::Value, Self::Error>\n    /// where\n    ///     V: Visitor<'de>,\n    /// {\n    ///     // What the data actually contained; suppose it is a unit variant.\n    ///     let unexp = Unexpected::UnitVariant;\n    ///     Err(de::Error::invalid_type(unexp, &\"tuple variant\"))\n    /// }\n    /// #\n    /// #     fn struct_variant<V>(self, _: &[&str], _: V) -> Result<V::Value, Self::Error>\n    /// #     where\n    /// #         V: Visitor<'de>,\n    /// #     { unimplemented!() }\n    /// # }\n    /// ```\n    fn tuple_variant<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n\n    /// Called when deserializing a struct-like variant.\n    ///\n    /// The `fields` are the names of the fields of the struct variant.\n    ///\n    /// If the data contains a different type of variant, the following\n    /// `invalid_type` error should be constructed:\n    ///\n    /// ```edition2018\n    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n    /// #\n    /// # struct X;\n    /// #\n    /// # impl<'de> VariantAccess<'de> for X {\n    /// #     type Error = value::Error;\n    /// #\n    /// #     fn unit_variant(self) -> Result<(), Self::Error> {\n    /// #         unimplemented!()\n    /// #     }\n    /// #\n    /// #     fn newtype_variant_seed<T>(self, _: T) -> Result<T::Value, Self::Error>\n    /// #     where\n    /// #         T: DeserializeSeed<'de>,\n    /// #     { unimplemented!() }\n    /// #\n    /// #     fn tuple_variant<V>(self, _: usize, _: V) -> Result<V::Value, Self::Error>\n    /// #     where\n    /// #         V: Visitor<'de>,\n    /// #     { unimplemented!() }\n    /// #\n    /// fn struct_variant<V>(\n    ///     self,\n    ///     _fields: &'static [&'static str],\n    ///     _visitor: V,\n    /// ) -> Result<V::Value, Self::Error>\n    /// where\n    ///     V: Visitor<'de>,\n    /// {\n    ///     // What the data actually contained; suppose it is a unit variant.\n    ///     let unexp = Unexpected::UnitVariant;\n    ///     Err(de::Error::invalid_type(unexp, &\"struct variant\"))\n    /// }\n    /// # }\n    /// ```\n    fn struct_variant<V>(\n        self,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Converts an existing value into a `Deserializer` from which other values can\n/// be deserialized.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed from the resulting `Deserializer`. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example\n///\n/// ```edition2018\n/// use std::str::FromStr;\n/// use serde::Deserialize;\n/// use serde::de::{value, IntoDeserializer};\n///\n/// #[derive(Deserialize)]\n/// enum Setting {\n///     On,\n///     Off,\n/// }\n///\n/// impl FromStr for Setting {\n///     type Err = value::Error;\n///\n///     fn from_str(s: &str) -> Result<Self, Self::Err> {\n///         Self::deserialize(s.into_deserializer())\n///     }\n/// }\n/// ```\npub trait IntoDeserializer<'de, E: Error = value::Error> {\n    /// The type of the deserializer being converted into.\n    type Deserializer: Deserializer<'de, Error = E>;\n\n    /// Convert this value into a deserializer.\n    fn into_deserializer(self) -> Self::Deserializer;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Used in error messages.\n///\n/// - expected `a`\n/// - expected `a` or `b`\n/// - expected one of `a`, `b`, `c`\n///\n/// The slice of names must not be empty.\nstruct OneOf {\n    names: &'static [&'static str],\n}\n\nimpl Display for OneOf {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        match self.names.len() {\n            0 => panic!(), // special case elsewhere\n            1 => write!(formatter, \"`{}`\", self.names[0]),\n            2 => write!(formatter, \"`{}` or `{}`\", self.names[0], self.names[1]),\n            _ => {\n                try!(write!(formatter, \"one of \"));\n                for (i, alt) in self.names.iter().enumerate() {\n                    if i > 0 {\n                        try!(write!(formatter, \", \"));\n                    }\n                    try!(write!(formatter, \"`{}`\", alt));\n                }\n                Ok(())\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","utf8.rs"],"content":"use lib::*;\n\nconst TAG_CONT: u8 = 0b1000_0000;\nconst TAG_TWO_B: u8 = 0b1100_0000;\nconst TAG_THREE_B: u8 = 0b1110_0000;\nconst TAG_FOUR_B: u8 = 0b1111_0000;\nconst MAX_ONE_B: u32 = 0x80;\nconst MAX_TWO_B: u32 = 0x800;\nconst MAX_THREE_B: u32 = 0x10000;\n\n#[inline]\npub fn encode(c: char) -> Encode {\n    let code = c as u32;\n    let mut buf = [0; 4];\n    let pos = if code < MAX_ONE_B {\n        buf[3] = code as u8;\n        3\n    } else if code < MAX_TWO_B {\n        buf[2] = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n        buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n        2\n    } else if code < MAX_THREE_B {\n        buf[1] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n        buf[2] = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n        buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n        1\n    } else {\n        buf[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n        buf[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n        buf[2] = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n        buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n        0\n    };\n    Encode { buf: buf, pos: pos }\n}\n\npub struct Encode {\n    buf: [u8; 4],\n    pos: usize,\n}\n\nimpl Encode {\n    pub fn as_str(&self) -> &str {\n        str::from_utf8(&self.buf[self.pos..]).unwrap()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","value.rs"],"content":"//! Building blocks for deserializing basic values using the `IntoDeserializer`\n//! trait.\n//!\n//! ```edition2018\n//! use std::str::FromStr;\n//! use serde::Deserialize;\n//! use serde::de::{value, IntoDeserializer};\n//!\n//! #[derive(Deserialize)]\n//! enum Setting {\n//!     On,\n//!     Off,\n//! }\n//!\n//! impl FromStr for Setting {\n//!     type Err = value::Error;\n//!\n//!     fn from_str(s: &str) -> Result<Self, Self::Err> {\n//!         Self::deserialize(s.into_deserializer())\n//!     }\n//! }\n//! ```\n\nuse lib::*;\n\nuse self::private::{First, Second};\nuse de::{self, Expected, IntoDeserializer, SeqAccess};\nuse private::de::size_hint;\nuse ser;\n\n////////////////////////////////////////////////////////////////////////////////\n\n// For structs that contain a PhantomData. We do not want the trait\n// bound `E: Clone` inferred by derive(Clone).\nmacro_rules! impl_copy_clone {\n    ($ty:ident $(<$lifetime:tt>)*) => {\n        impl<$($lifetime,)* E> Copy for $ty<$($lifetime,)* E> {}\n\n        impl<$($lifetime,)* E> Clone for $ty<$($lifetime,)* E> {\n            fn clone(&self) -> Self {\n                *self\n            }\n        }\n    };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A minimal representation of all possible errors that can occur using the\n/// `IntoDeserializer` trait.\n#[derive(Clone, Debug, PartialEq)]\npub struct Error {\n    err: ErrorImpl,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\ntype ErrorImpl = Box<str>;\n#[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\ntype ErrorImpl = ();\n\nimpl de::Error for Error {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cold]\n    fn custom<T>(msg: T) -> Self\n    where\n        T: Display,\n    {\n        Error {\n            err: msg.to_string().into_boxed_str(),\n        }\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    #[cold]\n    fn custom<T>(msg: T) -> Self\n    where\n        T: Display,\n    {\n        let _ = msg;\n        Error { err: () }\n    }\n}\n\nimpl ser::Error for Error {\n    #[cold]\n    fn custom<T>(msg: T) -> Self\n    where\n        T: Display,\n    {\n        de::Error::custom(msg)\n    }\n}\n\nimpl Display for Error {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        formatter.write_str(&self.err)\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        formatter.write_str(\"Serde deserialization error\")\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl error::Error for Error {\n    fn description(&self) -> &str {\n        &self.err\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<'de, E> IntoDeserializer<'de, E> for ()\nwhere\n    E: de::Error,\n{\n    type Deserializer = UnitDeserializer<E>;\n\n    fn into_deserializer(self) -> UnitDeserializer<E> {\n        UnitDeserializer {\n            marker: PhantomData,\n        }\n    }\n}\n\n/// A deserializer holding a `()`.\n#[derive(Debug)]\npub struct UnitDeserializer<E> {\n    marker: PhantomData<E>,\n}\n\nimpl_copy_clone!(UnitDeserializer);\n\nimpl<'de, E> de::Deserializer<'de> for UnitDeserializer<E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf unit unit_struct newtype_struct seq tuple tuple_struct\n        map struct enum identifier ignored_any\n    }\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_unit()\n    }\n\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_none()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer that cannot be instantiated.\n#[cfg(feature = \"unstable\")]\npub struct NeverDeserializer<E> {\n    never: !,\n    marker: PhantomData<E>,\n}\n\n#[cfg(feature = \"unstable\")]\nimpl<'de, E> IntoDeserializer<'de, E> for !\nwhere\n    E: de::Error,\n{\n    type Deserializer = NeverDeserializer<E>;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        self\n    }\n}\n\n#[cfg(feature = \"unstable\")]\nimpl<'de, E> de::Deserializer<'de> for NeverDeserializer<E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any<V>(self, _visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        self.never\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! primitive_deserializer {\n    ($ty:ty, $doc:tt, $name:ident, $method:ident $($cast:tt)*) => {\n        #[doc = \"A deserializer holding\"]\n        #[doc = $doc]\n        #[derive(Debug)]\n        pub struct $name<E> {\n            value: $ty,\n            marker: PhantomData<E>\n        }\n\n        impl_copy_clone!($name);\n\n        impl<'de, E> IntoDeserializer<'de, E> for $ty\n        where\n            E: de::Error,\n        {\n            type Deserializer = $name<E>;\n\n            fn into_deserializer(self) -> $name<E> {\n                $name {\n                    value: self,\n                    marker: PhantomData,\n                }\n            }\n        }\n\n        impl<'de, E> de::Deserializer<'de> for $name<E>\n        where\n            E: de::Error,\n        {\n            type Error = E;\n\n            forward_to_deserialize_any! {\n                bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str\n                string bytes byte_buf option unit unit_struct newtype_struct seq\n                tuple tuple_struct map struct enum identifier ignored_any\n            }\n\n            fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n            where\n                V: de::Visitor<'de>,\n            {\n                visitor.$method(self.value $($cast)*)\n            }\n        }\n    }\n}\n\nprimitive_deserializer!(bool, \"a `bool`.\", BoolDeserializer, visit_bool);\nprimitive_deserializer!(i8, \"an `i8`.\", I8Deserializer, visit_i8);\nprimitive_deserializer!(i16, \"an `i16`.\", I16Deserializer, visit_i16);\nprimitive_deserializer!(i32, \"an `i32`.\", I32Deserializer, visit_i32);\nprimitive_deserializer!(i64, \"an `i64`.\", I64Deserializer, visit_i64);\nprimitive_deserializer!(isize, \"an `isize`.\", IsizeDeserializer, visit_i64 as i64);\nprimitive_deserializer!(u8, \"a `u8`.\", U8Deserializer, visit_u8);\nprimitive_deserializer!(u16, \"a `u16`.\", U16Deserializer, visit_u16);\nprimitive_deserializer!(u64, \"a `u64`.\", U64Deserializer, visit_u64);\nprimitive_deserializer!(usize, \"a `usize`.\", UsizeDeserializer, visit_u64 as u64);\nprimitive_deserializer!(f32, \"an `f32`.\", F32Deserializer, visit_f32);\nprimitive_deserializer!(f64, \"an `f64`.\", F64Deserializer, visit_f64);\nprimitive_deserializer!(char, \"a `char`.\", CharDeserializer, visit_char);\n\nserde_if_integer128! {\n    primitive_deserializer!(i128, \"an `i128`.\", I128Deserializer, visit_i128);\n    primitive_deserializer!(u128, \"a `u128`.\", U128Deserializer, visit_u128);\n}\n\n/// A deserializer holding a `u32`.\n#[derive(Debug)]\npub struct U32Deserializer<E> {\n    value: u32,\n    marker: PhantomData<E>,\n}\n\nimpl_copy_clone!(U32Deserializer);\n\nimpl<'de, E> IntoDeserializer<'de, E> for u32\nwhere\n    E: de::Error,\n{\n    type Deserializer = U32Deserializer<E>;\n\n    fn into_deserializer(self) -> U32Deserializer<E> {\n        U32Deserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<'de, E> de::Deserializer<'de> for U32Deserializer<E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_u32(self.value)\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        name: &str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n}\n\nimpl<'de, E> de::EnumAccess<'de> for U32Deserializer<E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly<E>;\n\n    fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `&str`.\n#[derive(Debug)]\npub struct StrDeserializer<'a, E> {\n    value: &'a str,\n    marker: PhantomData<E>,\n}\n\nimpl_copy_clone!(StrDeserializer<'de>);\n\nimpl<'de, 'a, E> IntoDeserializer<'de, E> for &'a str\nwhere\n    E: de::Error,\n{\n    type Deserializer = StrDeserializer<'a, E>;\n\n    fn into_deserializer(self) -> StrDeserializer<'a, E> {\n        StrDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<'de, 'a, E> de::Deserializer<'de> for StrDeserializer<'a, E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_str(self.value)\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        name: &str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\nimpl<'de, 'a, E> de::EnumAccess<'de> for StrDeserializer<'a, E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly<E>;\n\n    fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `&str` with a lifetime tied to another\n/// deserializer.\n#[derive(Debug)]\npub struct BorrowedStrDeserializer<'de, E> {\n    value: &'de str,\n    marker: PhantomData<E>,\n}\n\nimpl_copy_clone!(BorrowedStrDeserializer<'de>);\n\nimpl<'de, E> BorrowedStrDeserializer<'de, E> {\n    /// Create a new borrowed deserializer from the given string.\n    pub fn new(value: &'de str) -> BorrowedStrDeserializer<'de, E> {\n        BorrowedStrDeserializer {\n            value: value,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<'de, E> de::Deserializer<'de> for BorrowedStrDeserializer<'de, E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_borrowed_str(self.value)\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        name: &str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\nimpl<'de, E> de::EnumAccess<'de> for BorrowedStrDeserializer<'de, E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly<E>;\n\n    fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `String`.\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[derive(Debug)]\npub struct StringDeserializer<E> {\n    value: String,\n    marker: PhantomData<E>,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<E> Clone for StringDeserializer<E> {\n    fn clone(&self) -> Self {\n        StringDeserializer {\n            value: self.value.clone(),\n            marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de, E> IntoDeserializer<'de, E> for String\nwhere\n    E: de::Error,\n{\n    type Deserializer = StringDeserializer<E>;\n\n    fn into_deserializer(self) -> StringDeserializer<E> {\n        StringDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de, E> de::Deserializer<'de> for StringDeserializer<E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_string(self.value)\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        name: &str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de, 'a, E> de::EnumAccess<'de> for StringDeserializer<E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly<E>;\n\n    fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `Cow<str>`.\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[derive(Debug)]\npub struct CowStrDeserializer<'a, E> {\n    value: Cow<'a, str>,\n    marker: PhantomData<E>,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, E> Clone for CowStrDeserializer<'a, E> {\n    fn clone(&self) -> Self {\n        CowStrDeserializer {\n            value: self.value.clone(),\n            marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de, 'a, E> IntoDeserializer<'de, E> for Cow<'a, str>\nwhere\n    E: de::Error,\n{\n    type Deserializer = CowStrDeserializer<'a, E>;\n\n    fn into_deserializer(self) -> CowStrDeserializer<'a, E> {\n        CowStrDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de, 'a, E> de::Deserializer<'de> for CowStrDeserializer<'a, E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        match self.value {\n            Cow::Borrowed(string) => visitor.visit_str(string),\n            Cow::Owned(string) => visitor.visit_string(string),\n        }\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        name: &str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de, 'a, E> de::EnumAccess<'de> for CowStrDeserializer<'a, E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly<E>;\n\n    fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `&[u8]` with a lifetime tied to another\n/// deserializer.\n#[derive(Debug)]\npub struct BorrowedBytesDeserializer<'de, E> {\n    value: &'de [u8],\n    marker: PhantomData<E>,\n}\n\nimpl_copy_clone!(BorrowedBytesDeserializer<'de>);\n\nimpl<'de, E> BorrowedBytesDeserializer<'de, E> {\n    /// Create a new borrowed deserializer from the given byte slice.\n    pub fn new(value: &'de [u8]) -> BorrowedBytesDeserializer<'de, E> {\n        BorrowedBytesDeserializer {\n            value: value,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<'de, E> de::Deserializer<'de> for BorrowedBytesDeserializer<'de, E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_borrowed_bytes(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any enum\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer that iterates over a sequence.\n#[derive(Clone, Debug)]\npub struct SeqDeserializer<I, E> {\n    iter: iter::Fuse<I>,\n    count: usize,\n    marker: PhantomData<E>,\n}\n\nimpl<I, E> SeqDeserializer<I, E>\nwhere\n    I: Iterator,\n{\n    /// Construct a new `SeqDeserializer<I, E>`.\n    pub fn new(iter: I) -> Self {\n        SeqDeserializer {\n            iter: iter.fuse(),\n            count: 0,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<I, E> SeqDeserializer<I, E>\nwhere\n    I: Iterator,\n    E: de::Error,\n{\n    /// Check for remaining elements after passing a `SeqDeserializer` to\n    /// `Visitor::visit_seq`.\n    pub fn end(self) -> Result<(), E> {\n        let remaining = self.iter.count();\n        if remaining == 0 {\n            Ok(())\n        } else {\n            // First argument is the number of elements in the data, second\n            // argument is the number of elements expected by the Deserialize.\n            Err(de::Error::invalid_length(\n                self.count + remaining,\n                &ExpectedInSeq(self.count),\n            ))\n        }\n    }\n}\n\nimpl<'de, I, T, E> de::Deserializer<'de> for SeqDeserializer<I, E>\nwhere\n    I: Iterator<Item = T>,\n    T: IntoDeserializer<'de, E>,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let v = try!(visitor.visit_seq(&mut self));\n        try!(self.end());\n        Ok(v)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\nimpl<'de, I, T, E> de::SeqAccess<'de> for SeqDeserializer<I, E>\nwhere\n    I: Iterator<Item = T>,\n    T: IntoDeserializer<'de, E>,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn next_element_seed<V>(&mut self, seed: V) -> Result<Option<V::Value>, Self::Error>\n    where\n        V: de::DeserializeSeed<'de>,\n    {\n        match self.iter.next() {\n            Some(value) => {\n                self.count += 1;\n                seed.deserialize(value.into_deserializer()).map(Some)\n            }\n            None => Ok(None),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        size_hint::from_bounds(&self.iter)\n    }\n}\n\nstruct ExpectedInSeq(usize);\n\nimpl Expected for ExpectedInSeq {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        if self.0 == 1 {\n            write!(formatter, \"1 element in sequence\")\n        } else {\n            write!(formatter, \"{} elements in sequence\", self.0)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de, T, E> IntoDeserializer<'de, E> for Vec<T>\nwhere\n    T: IntoDeserializer<'de, E>,\n    E: de::Error,\n{\n    type Deserializer = SeqDeserializer<<Self as IntoIterator>::IntoIter, E>;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        SeqDeserializer::new(self.into_iter())\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de, T, E> IntoDeserializer<'de, E> for BTreeSet<T>\nwhere\n    T: IntoDeserializer<'de, E> + Eq + Ord,\n    E: de::Error,\n{\n    type Deserializer = SeqDeserializer<<Self as IntoIterator>::IntoIter, E>;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        SeqDeserializer::new(self.into_iter())\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl<'de, T, S, E> IntoDeserializer<'de, E> for HashSet<T, S>\nwhere\n    T: IntoDeserializer<'de, E> + Eq + Hash,\n    S: BuildHasher,\n    E: de::Error,\n{\n    type Deserializer = SeqDeserializer<<Self as IntoIterator>::IntoIter, E>;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        SeqDeserializer::new(self.into_iter())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `SeqAccess`.\n#[derive(Clone, Debug)]\npub struct SeqAccessDeserializer<A> {\n    seq: A,\n}\n\nimpl<A> SeqAccessDeserializer<A> {\n    /// Construct a new `SeqAccessDeserializer<A>`.\n    pub fn new(seq: A) -> Self {\n        SeqAccessDeserializer { seq: seq }\n    }\n}\n\nimpl<'de, A> de::Deserializer<'de> for SeqAccessDeserializer<A>\nwhere\n    A: de::SeqAccess<'de>,\n{\n    type Error = A::Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_seq(self.seq)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer that iterates over a map.\npub struct MapDeserializer<'de, I, E>\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n{\n    iter: iter::Fuse<I>,\n    value: Option<Second<I::Item>>,\n    count: usize,\n    lifetime: PhantomData<&'de ()>,\n    error: PhantomData<E>,\n}\n\nimpl<'de, I, E> MapDeserializer<'de, I, E>\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n{\n    /// Construct a new `MapDeserializer<I, E>`.\n    pub fn new(iter: I) -> Self {\n        MapDeserializer {\n            iter: iter.fuse(),\n            value: None,\n            count: 0,\n            lifetime: PhantomData,\n            error: PhantomData,\n        }\n    }\n}\n\nimpl<'de, I, E> MapDeserializer<'de, I, E>\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n    E: de::Error,\n{\n    /// Check for remaining elements after passing a `MapDeserializer` to\n    /// `Visitor::visit_map`.\n    pub fn end(self) -> Result<(), E> {\n        let remaining = self.iter.count();\n        if remaining == 0 {\n            Ok(())\n        } else {\n            // First argument is the number of elements in the data, second\n            // argument is the number of elements expected by the Deserialize.\n            Err(de::Error::invalid_length(\n                self.count + remaining,\n                &ExpectedInMap(self.count),\n            ))\n        }\n    }\n}\n\nimpl<'de, I, E> MapDeserializer<'de, I, E>\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n{\n    fn next_pair(&mut self) -> Option<(First<I::Item>, Second<I::Item>)> {\n        match self.iter.next() {\n            Some(kv) => {\n                self.count += 1;\n                Some(private::Pair::split(kv))\n            }\n            None => None,\n        }\n    }\n}\n\nimpl<'de, I, E> de::Deserializer<'de> for MapDeserializer<'de, I, E>\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n    First<I::Item>: IntoDeserializer<'de, E>,\n    Second<I::Item>: IntoDeserializer<'de, E>,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let value = try!(visitor.visit_map(&mut self));\n        try!(self.end());\n        Ok(value)\n    }\n\n    fn deserialize_seq<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let value = try!(visitor.visit_seq(&mut self));\n        try!(self.end());\n        Ok(value)\n    }\n\n    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let _ = len;\n        self.deserialize_seq(visitor)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct tuple_struct map\n        struct enum identifier ignored_any\n    }\n}\n\nimpl<'de, I, E> de::MapAccess<'de> for MapDeserializer<'de, I, E>\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n    First<I::Item>: IntoDeserializer<'de, E>,\n    Second<I::Item>: IntoDeserializer<'de, E>,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        match self.next_pair() {\n            Some((key, value)) => {\n                self.value = Some(value);\n                seed.deserialize(key.into_deserializer()).map(Some)\n            }\n            None => Ok(None),\n        }\n    }\n\n    fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        let value = self.value.take();\n        // Panic because this indicates a bug in the program rather than an\n        // expected failure.\n        let value = value.expect(\"MapAccess::visit_value called before visit_key\");\n        seed.deserialize(value.into_deserializer())\n    }\n\n    fn next_entry_seed<TK, TV>(\n        &mut self,\n        kseed: TK,\n        vseed: TV,\n    ) -> Result<Option<(TK::Value, TV::Value)>, Self::Error>\n    where\n        TK: de::DeserializeSeed<'de>,\n        TV: de::DeserializeSeed<'de>,\n    {\n        match self.next_pair() {\n            Some((key, value)) => {\n                let key = try!(kseed.deserialize(key.into_deserializer()));\n                let value = try!(vseed.deserialize(value.into_deserializer()));\n                Ok(Some((key, value)))\n            }\n            None => Ok(None),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        size_hint::from_bounds(&self.iter)\n    }\n}\n\nimpl<'de, I, E> de::SeqAccess<'de> for MapDeserializer<'de, I, E>\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n    First<I::Item>: IntoDeserializer<'de, E>,\n    Second<I::Item>: IntoDeserializer<'de, E>,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        match self.next_pair() {\n            Some((k, v)) => {\n                let de = PairDeserializer(k, v, PhantomData);\n                seed.deserialize(de).map(Some)\n            }\n            None => Ok(None),\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        size_hint::from_bounds(&self.iter)\n    }\n}\n\n// Cannot #[derive(Clone)] because of the bound `Second<I::Item>: Clone`.\nimpl<'de, I, E> Clone for MapDeserializer<'de, I, E>\nwhere\n    I: Iterator + Clone,\n    I::Item: private::Pair,\n    Second<I::Item>: Clone,\n{\n    fn clone(&self) -> Self {\n        MapDeserializer {\n            iter: self.iter.clone(),\n            value: self.value.clone(),\n            count: self.count,\n            lifetime: self.lifetime,\n            error: self.error,\n        }\n    }\n}\n\n// Cannot #[derive(Debug)] because of the bound `Second<I::Item>: Debug`.\nimpl<'de, I, E> Debug for MapDeserializer<'de, I, E>\nwhere\n    I: Iterator + Debug,\n    I::Item: private::Pair,\n    Second<I::Item>: Debug,\n{\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter\n            .debug_struct(\"MapDeserializer\")\n            .field(\"iter\", &self.iter)\n            .field(\"value\", &self.value)\n            .field(\"count\", &self.count)\n            .field(\"lifetime\", &self.lifetime)\n            .field(\"error\", &self.error)\n            .finish()\n    }\n}\n\n// Used in the `impl SeqAccess for MapDeserializer` to visit the map as a\n// sequence of pairs.\nstruct PairDeserializer<A, B, E>(A, B, PhantomData<E>);\n\nimpl<'de, A, B, E> de::Deserializer<'de> for PairDeserializer<A, B, E>\nwhere\n    A: IntoDeserializer<'de, E>,\n    B: IntoDeserializer<'de, E>,\n    E: de::Error,\n{\n    type Error = E;\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct tuple_struct map\n        struct enum identifier ignored_any\n    }\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        let mut pair_visitor = PairVisitor(Some(self.0), Some(self.1), PhantomData);\n        let pair = try!(visitor.visit_seq(&mut pair_visitor));\n        if pair_visitor.1.is_none() {\n            Ok(pair)\n        } else {\n            let remaining = pair_visitor.size_hint().unwrap();\n            // First argument is the number of elements in the data, second\n            // argument is the number of elements expected by the Deserialize.\n            Err(de::Error::invalid_length(2, &ExpectedInSeq(2 - remaining)))\n        }\n    }\n\n    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        if len == 2 {\n            self.deserialize_seq(visitor)\n        } else {\n            // First argument is the number of elements in the data, second\n            // argument is the number of elements expected by the Deserialize.\n            Err(de::Error::invalid_length(2, &ExpectedInSeq(len)))\n        }\n    }\n}\n\nstruct PairVisitor<A, B, E>(Option<A>, Option<B>, PhantomData<E>);\n\nimpl<'de, A, B, E> de::SeqAccess<'de> for PairVisitor<A, B, E>\nwhere\n    A: IntoDeserializer<'de, E>,\n    B: IntoDeserializer<'de, E>,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        if let Some(k) = self.0.take() {\n            seed.deserialize(k.into_deserializer()).map(Some)\n        } else if let Some(v) = self.1.take() {\n            seed.deserialize(v.into_deserializer()).map(Some)\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        if self.0.is_some() {\n            Some(2)\n        } else if self.1.is_some() {\n            Some(1)\n        } else {\n            Some(0)\n        }\n    }\n}\n\nstruct ExpectedInMap(usize);\n\nimpl Expected for ExpectedInMap {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        if self.0 == 1 {\n            write!(formatter, \"1 element in map\")\n        } else {\n            write!(formatter, \"{} elements in map\", self.0)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de, K, V, E> IntoDeserializer<'de, E> for BTreeMap<K, V>\nwhere\n    K: IntoDeserializer<'de, E> + Eq + Ord,\n    V: IntoDeserializer<'de, E>,\n    E: de::Error,\n{\n    type Deserializer = MapDeserializer<'de, <Self as IntoIterator>::IntoIter, E>;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        MapDeserializer::new(self.into_iter())\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl<'de, K, V, S, E> IntoDeserializer<'de, E> for HashMap<K, V, S>\nwhere\n    K: IntoDeserializer<'de, E> + Eq + Hash,\n    V: IntoDeserializer<'de, E>,\n    S: BuildHasher,\n    E: de::Error,\n{\n    type Deserializer = MapDeserializer<'de, <Self as IntoIterator>::IntoIter, E>;\n\n    fn into_deserializer(self) -> Self::Deserializer {\n        MapDeserializer::new(self.into_iter())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `MapAccess`.\n#[derive(Clone, Debug)]\npub struct MapAccessDeserializer<A> {\n    map: A,\n}\n\nimpl<A> MapAccessDeserializer<A> {\n    /// Construct a new `MapAccessDeserializer<A>`.\n    pub fn new(map: A) -> Self {\n        MapAccessDeserializer { map: map }\n    }\n}\n\nimpl<'de, A> de::Deserializer<'de> for MapAccessDeserializer<A>\nwhere\n    A: de::MapAccess<'de>,\n{\n    type Error = A::Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_map(self.map)\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\nimpl<'de, A> de::EnumAccess<'de> for MapAccessDeserializer<A>\nwhere\n    A: de::MapAccess<'de>,\n{\n    type Error = A::Error;\n    type Variant = private::MapAsEnum<A>;\n\n    fn variant_seed<T>(mut self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n    where\n        T: de::DeserializeSeed<'de>,\n    {\n        match self.map.next_key_seed(seed)? {\n            Some(key) => Ok((key, private::map_as_enum(self.map))),\n            None => Err(de::Error::invalid_type(de::Unexpected::Map, &\"enum\")),\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmod private {\n    use lib::*;\n\n    use de::{self, DeserializeSeed, Deserializer, MapAccess, Unexpected, VariantAccess, Visitor};\n\n    #[derive(Clone, Debug)]\n    pub struct UnitOnly<E> {\n        marker: PhantomData<E>,\n    }\n\n    pub fn unit_only<T, E>(t: T) -> (T, UnitOnly<E>) {\n        (\n            t,\n            UnitOnly {\n                marker: PhantomData,\n            },\n        )\n    }\n\n    impl<'de, E> de::VariantAccess<'de> for UnitOnly<E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn unit_variant(self) -> Result<(), Self::Error> {\n            Ok(())\n        }\n\n        fn newtype_variant_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>\n        where\n            T: de::DeserializeSeed<'de>,\n        {\n            Err(de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"newtype variant\",\n            ))\n        }\n\n        fn tuple_variant<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: de::Visitor<'de>,\n        {\n            Err(de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"tuple variant\",\n            ))\n        }\n\n        fn struct_variant<V>(\n            self,\n            _fields: &'static [&'static str],\n            _visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: de::Visitor<'de>,\n        {\n            Err(de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"struct variant\",\n            ))\n        }\n    }\n\n    #[derive(Clone, Debug)]\n    pub struct MapAsEnum<A> {\n        map: A,\n    }\n\n    pub fn map_as_enum<A>(map: A) -> MapAsEnum<A> {\n        MapAsEnum { map: map }\n    }\n\n    impl<'de, A> VariantAccess<'de> for MapAsEnum<A>\n    where\n        A: MapAccess<'de>,\n    {\n        type Error = A::Error;\n\n        fn unit_variant(mut self) -> Result<(), Self::Error> {\n            self.map.next_value()\n        }\n\n        fn newtype_variant_seed<T>(mut self, seed: T) -> Result<T::Value, Self::Error>\n        where\n            T: DeserializeSeed<'de>,\n        {\n            self.map.next_value_seed(seed)\n        }\n\n        fn tuple_variant<V>(mut self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.map.next_value_seed(SeedTupleVariant {\n                len: len,\n                visitor: visitor,\n            })\n        }\n\n        fn struct_variant<V>(\n            mut self,\n            _fields: &'static [&'static str],\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.map\n                .next_value_seed(SeedStructVariant { visitor: visitor })\n        }\n    }\n\n    struct SeedTupleVariant<V> {\n        len: usize,\n        visitor: V,\n    }\n\n    impl<'de, V> DeserializeSeed<'de> for SeedTupleVariant<V>\n    where\n        V: Visitor<'de>,\n    {\n        type Value = V::Value;\n\n        fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            deserializer.deserialize_tuple(self.len, self.visitor)\n        }\n    }\n\n    struct SeedStructVariant<V> {\n        visitor: V,\n    }\n\n    impl<'de, V> DeserializeSeed<'de> for SeedStructVariant<V>\n    where\n        V: Visitor<'de>,\n    {\n        type Value = V::Value;\n\n        fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            deserializer.deserialize_map(self.visitor)\n        }\n    }\n\n    /// Avoid having to restate the generic types on `MapDeserializer`. The\n    /// `Iterator::Item` contains enough information to figure out K and V.\n    pub trait Pair {\n        type First;\n        type Second;\n        fn split(self) -> (Self::First, Self::Second);\n    }\n\n    impl<A, B> Pair for (A, B) {\n        type First = A;\n        type Second = B;\n        fn split(self) -> (A, B) {\n            self\n        }\n    }\n\n    pub type First<T> = <T as Pair>::First;\n    pub type Second<T> = <T as Pair>::Second;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","export.rs"],"content":"pub use lib::clone::Clone;\npub use lib::convert::{From, Into};\npub use lib::default::Default;\npub use lib::fmt::{self, Formatter};\npub use lib::marker::PhantomData;\npub use lib::option::Option::{self, None, Some};\npub use lib::result::Result::{self, Err, Ok};\n\npub use self::string::from_utf8_lossy;\n\n#[cfg(any(feature = \"alloc\", feature = \"std\"))]\npub use lib::{ToString, Vec};\n\n#[cfg(core_try_from)]\npub use lib::convert::TryFrom;\n\nmod string {\n    use lib::*;\n\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    pub fn from_utf8_lossy(bytes: &[u8]) -> Cow<str> {\n        String::from_utf8_lossy(bytes)\n    }\n\n    // The generated code calls this like:\n    //\n    //     let value = &_serde::export::from_utf8_lossy(bytes);\n    //     Err(_serde::de::Error::unknown_variant(value, VARIANTS))\n    //\n    // so it is okay for the return type to be different from the std case as long\n    // as the above works.\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    pub fn from_utf8_lossy(bytes: &[u8]) -> &str {\n        // Three unicode replacement characters if it fails. They look like a\n        // white-on-black question mark. The user will recognize it as invalid\n        // UTF-8.\n        str::from_utf8(bytes).unwrap_or(\"\\u{fffd}\\u{fffd}\\u{fffd}\")\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","integer128.rs"],"content":"/// Conditional compilation depending on whether Serde is built with support for\n/// 128-bit integers.\n///\n/// Data formats that wish to support Rust compiler versions older than 1.26\n/// (or targets that lack 128-bit integers) may place the i128 / u128 methods\n/// of their Serializer and Deserializer behind this macro.\n///\n/// Data formats that require a minimum Rust compiler version of at least 1.26,\n/// or do not target platforms that lack 128-bit integers, do not need to\n/// bother with this macro and may assume support for 128-bit integers.\n///\n/// ```edition2018\n/// # use serde::private::ser::Error;\n/// #\n/// # struct MySerializer;\n/// #\n/// use serde::{serde_if_integer128, Serializer};\n///\n/// impl Serializer for MySerializer {\n///     type Ok = ();\n///     type Error = Error;\n///\n///     fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error> {\n///         /* ... */\n/// #         unimplemented!()\n///     }\n///\n///     /* ... */\n///\n///     serde_if_integer128! {\n///         fn serialize_i128(self, v: i128) -> Result<Self::Ok, Self::Error> {\n///             /* ... */\n/// #             unimplemented!()\n///         }\n///\n///         fn serialize_u128(self, v: u128) -> Result<Self::Ok, Self::Error> {\n///             /* ... */\n/// #             unimplemented!()\n///         }\n///     }\n/// #\n/// #     serde::__serialize_unimplemented! {\n/// #         bool i8 i16 i32 u8 u16 u32 u64 f32 f64 char str bytes none some\n/// #         unit unit_struct unit_variant newtype_struct newtype_variant seq\n/// #         tuple tuple_struct tuple_variant map struct struct_variant\n/// #     }\n/// }\n/// ```\n///\n/// When Serde is built with support for 128-bit integers, this macro expands\n/// transparently into just the input tokens.\n///\n/// ```edition2018\n/// macro_rules! serde_if_integer128 {\n///     ($($tt:tt)*) => {\n///         $($tt)*\n///     };\n/// }\n/// ```\n///\n/// When built without support for 128-bit integers, this macro expands to\n/// nothing.\n///\n/// ```edition2018\n/// macro_rules! serde_if_integer128 {\n///     ($($tt:tt)*) => {};\n/// }\n/// ```\n#[cfg(integer128)]\n#[macro_export]\nmacro_rules! serde_if_integer128 {\n    ($($tt:tt)*) => {\n        $($tt)*\n    };\n}\n\n#[cfg(not(integer128))]\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! serde_if_integer128 {\n    ($($tt:tt)*) => {};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","lib.rs"],"content":"//! # Serde\n//!\n//! Serde is a framework for ***ser***ializing and ***de***serializing Rust data\n//! structures efficiently and generically.\n//!\n//! The Serde ecosystem consists of data structures that know how to serialize\n//! and deserialize themselves along with data formats that know how to\n//! serialize and deserialize other things. Serde provides the layer by which\n//! these two groups interact with each other, allowing any supported data\n//! structure to be serialized and deserialized using any supported data format.\n//!\n//! See the Serde website [https://serde.rs/] for additional documentation and\n//! usage examples.\n//!\n//! [https://serde.rs/]: https://serde.rs/\n//!\n//! ## Design\n//!\n//! Where many other languages rely on runtime reflection for serializing data,\n//! Serde is instead built on Rust's powerful trait system. A data structure\n//! that knows how to serialize and deserialize itself is one that implements\n//! Serde's `Serialize` and `Deserialize` traits (or uses Serde's derive\n//! attribute to automatically generate implementations at compile time). This\n//! avoids any overhead of reflection or runtime type information. In fact in\n//! many situations the interaction between data structure and data format can\n//! be completely optimized away by the Rust compiler, leaving Serde\n//! serialization to perform the same speed as a handwritten serializer for the\n//! specific selection of data structure and data format.\n//!\n//! ## Data formats\n//!\n//! The following is a partial list of data formats that have been implemented\n//! for Serde by the community.\n//!\n//! - [JSON], the ubiquitous JavaScript Object Notation used by many HTTP APIs.\n//! - [Bincode], a compact binary format\n//!   used for IPC within the Servo rendering engine.\n//! - [CBOR], a Concise Binary Object Representation designed for small message\n//!   size without the need for version negotiation.\n//! - [YAML], a popular human-friendly configuration language that ain't markup\n//!   language.\n//! - [MessagePack], an efficient binary format that resembles a compact JSON.\n//! - [TOML], a minimal configuration format used by [Cargo].\n//! - [Pickle], a format common in the Python world.\n//! - [RON], a Rusty Object Notation.\n//! - [BSON], the data storage and network transfer format used by MongoDB.\n//! - [Avro], a binary format used within Apache Hadoop, with support for schema\n//!   definition.\n//! - [JSON5], A superset of JSON including some productions from ES5.\n//! - [Postcard], a no\\_std and embedded-systems friendly compact binary format.\n//! - [URL], the x-www-form-urlencoded format.\n//! - [Envy], a way to deserialize environment variables into Rust structs.\n//!   *(deserialization only)*\n//! - [Envy Store], a way to deserialize [AWS Parameter Store] parameters into\n//!   Rust structs. *(deserialization only)*\n//!\n//! [JSON]: https://github.com/serde-rs/json\n//! [Bincode]: https://github.com/TyOverby/bincode\n//! [CBOR]: https://github.com/pyfisch/cbor\n//! [YAML]: https://github.com/dtolnay/serde-yaml\n//! [MessagePack]: https://github.com/3Hren/msgpack-rust\n//! [TOML]: https://github.com/alexcrichton/toml-rs\n//! [Pickle]: https://github.com/birkenfeld/serde-pickle\n//! [RON]: https://github.com/ron-rs/ron\n//! [BSON]: https://github.com/zonyitoo/bson-rs\n//! [Avro]: https://github.com/flavray/avro-rs\n//! [JSON5]: https://github.com/callum-oakley/json5-rs\n//! [Postcard]: https://github.com/jamesmunns/postcard\n//! [URL]: https://github.com/nox/serde_urlencoded\n//! [Envy]: https://github.com/softprops/envy\n//! [Envy Store]: https://github.com/softprops/envy-store\n//! [Cargo]: http://doc.crates.io/manifest.html\n//! [AWS Parameter Store]: https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-paramstore.html\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Serde types in rustdoc of other crates get linked to here.\n#![doc(html_root_url = \"https://docs.rs/serde/1.0.100\")]\n// Support using Serde without the standard library!\n#![cfg_attr(not(feature = \"std\"), no_std)]\n// Unstable functionality only if the user asks for it. For tracking and\n// discussion of these features please refer to this issue:\n//\n//    https://github.com/serde-rs/serde/issues/812\n#![cfg_attr(feature = \"unstable\", feature(specialization, never_type))]\n#![allow(unknown_lints, bare_trait_objects, deprecated)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(renamed_and_removed_lints))]\n#![cfg_attr(feature = \"cargo-clippy\", deny(clippy, clippy_pedantic))]\n// Ignored clippy and clippy_pedantic lints\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        // not available in our oldest supported compiler\n        checked_conversions,\n        empty_enum,\n        redundant_field_names,\n        redundant_static_lifetimes,\n        // integer and float ser/de requires these sorts of casts\n        cast_possible_truncation,\n        cast_possible_wrap,\n        cast_sign_loss,\n        // things are often more readable this way\n        cast_lossless,\n        module_name_repetitions,\n        single_match_else,\n        type_complexity,\n        use_self,\n        zero_prefixed_literal,\n        // not practical\n        needless_pass_by_value,\n        similar_names,\n        // preference\n        doc_markdown,\n    )\n)]\n// Rustc lints.\n#![deny(missing_docs, unused_imports)]\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"alloc\")]\nextern crate alloc;\n\n/// A facade around all the types we need from the `std`, `core`, and `alloc`\n/// crates. This avoids elaborate import wrangling having to happen in every\n/// module.\nmod lib {\n    mod core {\n        #[cfg(not(feature = \"std\"))]\n        pub use core::*;\n        #[cfg(feature = \"std\")]\n        pub use std::*;\n    }\n\n    pub use self::core::{cmp, iter, mem, num, slice, str};\n    pub use self::core::{f32, f64};\n    pub use self::core::{i16, i32, i64, i8, isize};\n    pub use self::core::{u16, u32, u64, u8, usize};\n\n    pub use self::core::cell::{Cell, RefCell};\n    pub use self::core::clone::{self, Clone};\n    pub use self::core::convert::{self, From, Into};\n    pub use self::core::default::{self, Default};\n    pub use self::core::fmt::{self, Debug, Display};\n    pub use self::core::marker::{self, PhantomData};\n    pub use self::core::ops::Range;\n    pub use self::core::option::{self, Option};\n    pub use self::core::result::{self, Result};\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::borrow::{Cow, ToOwned};\n    #[cfg(feature = \"std\")]\n    pub use std::borrow::{Cow, ToOwned};\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::string::{String, ToString};\n    #[cfg(feature = \"std\")]\n    pub use std::string::{String, ToString};\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::vec::Vec;\n    #[cfg(feature = \"std\")]\n    pub use std::vec::Vec;\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::boxed::Box;\n    #[cfg(feature = \"std\")]\n    pub use std::boxed::Box;\n\n    #[cfg(all(feature = \"rc\", feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::rc::{Rc, Weak as RcWeak};\n    #[cfg(all(feature = \"rc\", feature = \"std\"))]\n    pub use std::rc::{Rc, Weak as RcWeak};\n\n    #[cfg(all(feature = \"rc\", feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::sync::{Arc, Weak as ArcWeak};\n    #[cfg(all(feature = \"rc\", feature = \"std\"))]\n    pub use std::sync::{Arc, Weak as ArcWeak};\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::collections::{BTreeMap, BTreeSet, BinaryHeap, LinkedList, VecDeque};\n    #[cfg(feature = \"std\")]\n    pub use std::collections::{BTreeMap, BTreeSet, BinaryHeap, LinkedList, VecDeque};\n\n    #[cfg(feature = \"std\")]\n    pub use std::{error, net};\n\n    #[cfg(feature = \"std\")]\n    pub use std::collections::{HashMap, HashSet};\n    #[cfg(feature = \"std\")]\n    pub use std::ffi::{CStr, CString, OsStr, OsString};\n    #[cfg(feature = \"std\")]\n    pub use std::hash::{BuildHasher, Hash};\n    #[cfg(feature = \"std\")]\n    pub use std::io::Write;\n    #[cfg(feature = \"std\")]\n    pub use std::num::Wrapping;\n    #[cfg(feature = \"std\")]\n    pub use std::path::{Path, PathBuf};\n    #[cfg(feature = \"std\")]\n    pub use std::sync::{Mutex, RwLock};\n    #[cfg(feature = \"std\")]\n    pub use std::time::{SystemTime, UNIX_EPOCH};\n\n    #[cfg(all(feature = \"std\", collections_bound))]\n    pub use std::collections::Bound;\n\n    #[cfg(core_reverse)]\n    pub use self::core::cmp::Reverse;\n\n    #[cfg(ops_bound)]\n    pub use self::core::ops::Bound;\n\n    #[cfg(range_inclusive)]\n    pub use self::core::ops::RangeInclusive;\n\n    #[cfg(all(feature = \"std\", std_atomic))]\n    pub use std::sync::atomic::{\n        AtomicBool, AtomicI16, AtomicI32, AtomicI8, AtomicIsize, AtomicU16, AtomicU32, AtomicU8,\n        AtomicUsize, Ordering,\n    };\n    #[cfg(all(feature = \"std\", std_atomic64))]\n    pub use std::sync::atomic::{AtomicI64, AtomicU64};\n\n    #[cfg(any(core_duration, feature = \"std\"))]\n    pub use self::core::time::Duration;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[macro_use]\nmod macros;\n\n#[macro_use]\nmod integer128;\n\npub mod de;\npub mod ser;\n\n#[doc(inline)]\npub use de::{Deserialize, Deserializer};\n#[doc(inline)]\npub use ser::{Serialize, Serializer};\n\n// Generated code uses these to support no_std. Not public API.\n#[doc(hidden)]\npub mod export;\n\n// Helpers used by generated code and doc tests. Not public API.\n#[doc(hidden)]\npub mod private;\n\n#[cfg(not(feature = \"std\"))]\nmod std_error;\n\n// Re-export #[derive(Serialize, Deserialize)].\n//\n// The reason re-exporting is not enabled by default is that disabling it would\n// be annoying for crates that provide handwritten impls or data formats. They\n// would need to disable default features and then explicitly re-enable std.\n#[cfg(feature = \"serde_derive\")]\n#[allow(unused_imports)]\n#[macro_use]\nextern crate serde_derive;\n#[cfg(feature = \"serde_derive\")]\n#[doc(hidden)]\npub use serde_derive::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","macros.rs"],"content":"// Super explicit first paragraph because this shows up at the top level and\n// trips up people who are just looking for basic Serialize / Deserialize\n// documentation.\n//\n/// Helper macro when implementing the `Deserializer` part of a new data format\n/// for Serde.\n///\n/// Some [`Deserializer`] implementations for self-describing formats do not\n/// care what hint the [`Visitor`] gives them, they just want to blindly call\n/// the [`Visitor`] method corresponding to the data they can tell is in the\n/// input. This requires repetitive implementations of all the [`Deserializer`]\n/// trait methods.\n///\n/// ```edition2018\n/// # use serde::forward_to_deserialize_any;\n/// # use serde::de::{value, Deserializer, Visitor};\n/// #\n/// # struct MyDeserializer;\n/// #\n/// # impl<'de> Deserializer<'de> for MyDeserializer {\n/// #     type Error = value::Error;\n/// #\n/// #     fn deserialize_any<V>(self, _: V) -> Result<V::Value, Self::Error>\n/// #     where\n/// #         V: Visitor<'de>,\n/// #     {\n/// #         unimplemented!()\n/// #     }\n/// #\n/// #[inline]\n/// fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n/// where\n///     V: Visitor<'de>,\n/// {\n///     self.deserialize_any(visitor)\n/// }\n/// #\n/// #     forward_to_deserialize_any! {\n/// #         i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n/// #         bytes byte_buf option unit unit_struct newtype_struct seq tuple\n/// #         tuple_struct map struct enum identifier ignored_any\n/// #     }\n/// # }\n/// ```\n///\n/// The `forward_to_deserialize_any!` macro implements these simple forwarding\n/// methods so that they forward directly to [`Deserializer::deserialize_any`].\n/// You can choose which methods to forward.\n///\n/// ```edition2018\n/// # use serde::forward_to_deserialize_any;\n/// # use serde::de::{value, Deserializer, Visitor};\n/// #\n/// # struct MyDeserializer;\n/// #\n/// impl<'de> Deserializer<'de> for MyDeserializer {\n/// #   type Error = value::Error;\n/// #\n///     fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n///     where\n///         V: Visitor<'de>,\n///     {\n///         /* ... */\n/// #       let _ = visitor;\n/// #       unimplemented!()\n///     }\n///\n///     forward_to_deserialize_any! {\n///         bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n///         bytes byte_buf option unit unit_struct newtype_struct seq tuple\n///         tuple_struct map struct enum identifier ignored_any\n///     }\n/// }\n/// ```\n///\n/// The macro assumes the convention that your `Deserializer` lifetime parameter\n/// is called `'de` and that the `Visitor` type parameters on each method are\n/// called `V`. A different type parameter and a different lifetime can be\n/// specified explicitly if necessary.\n///\n/// ```edition2018\n/// # use std::marker::PhantomData;\n/// #\n/// # use serde::forward_to_deserialize_any;\n/// # use serde::de::{value, Deserializer, Visitor};\n/// #\n/// # struct MyDeserializer<V>(PhantomData<V>);\n/// #\n/// # impl<'q, V> Deserializer<'q> for MyDeserializer<V> {\n/// #     type Error = value::Error;\n/// #\n/// #     fn deserialize_any<W>(self, visitor: W) -> Result<W::Value, Self::Error>\n/// #     where\n/// #         W: Visitor<'q>,\n/// #     {\n/// #         unimplemented!()\n/// #     }\n/// #\n/// forward_to_deserialize_any! {\n///     <W: Visitor<'q>>\n///     bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n///     bytes byte_buf option unit unit_struct newtype_struct seq tuple\n///     tuple_struct map struct enum identifier ignored_any\n/// }\n/// # }\n/// ```\n///\n/// [`Deserializer`]: trait.Deserializer.html\n/// [`Visitor`]: de/trait.Visitor.html\n/// [`Deserializer::deserialize_any`]: trait.Deserializer.html#tymethod.deserialize_any\n#[macro_export(local_inner_macros)]\nmacro_rules! forward_to_deserialize_any {\n    (<$visitor:ident: Visitor<$lifetime:tt>> $($func:ident)*) => {\n        $(forward_to_deserialize_any_helper!{$func<$lifetime, $visitor>})*\n    };\n    // This case must be after the previous one.\n    ($($func:ident)*) => {\n        $(forward_to_deserialize_any_helper!{$func<'de, V>})*\n    };\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! forward_to_deserialize_any_method {\n    ($func:ident<$l:tt, $v:ident>($($arg:ident : $ty:ty),*)) => {\n        #[inline]\n        fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::export::Result<$v::Value, Self::Error>\n        where\n            $v: $crate::de::Visitor<$l>,\n        {\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }\n    };\n}\n\n#[doc(hidden)]\n#[macro_export(local_inner_macros)]\nmacro_rules! forward_to_deserialize_any_helper {\n    (bool<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_bool<$l, $v>()}\n    };\n    (i8<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_i8<$l, $v>()}\n    };\n    (i16<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_i16<$l, $v>()}\n    };\n    (i32<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_i32<$l, $v>()}\n    };\n    (i64<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_i64<$l, $v>()}\n    };\n    (i128<$l:tt, $v:ident>) => {\n        serde_if_integer128! {\n            forward_to_deserialize_any_method!{deserialize_i128<$l, $v>()}\n        }\n    };\n    (u8<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_u8<$l, $v>()}\n    };\n    (u16<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_u16<$l, $v>()}\n    };\n    (u32<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_u32<$l, $v>()}\n    };\n    (u64<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_u64<$l, $v>()}\n    };\n    (u128<$l:tt, $v:ident>) => {\n        serde_if_integer128! {\n            forward_to_deserialize_any_method!{deserialize_u128<$l, $v>()}\n        }\n    };\n    (f32<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_f32<$l, $v>()}\n    };\n    (f64<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_f64<$l, $v>()}\n    };\n    (char<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_char<$l, $v>()}\n    };\n    (str<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_str<$l, $v>()}\n    };\n    (string<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_string<$l, $v>()}\n    };\n    (bytes<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_bytes<$l, $v>()}\n    };\n    (byte_buf<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_byte_buf<$l, $v>()}\n    };\n    (option<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_option<$l, $v>()}\n    };\n    (unit<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_unit<$l, $v>()}\n    };\n    (unit_struct<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_unit_struct<$l, $v>(name: &'static str)}\n    };\n    (newtype_struct<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_newtype_struct<$l, $v>(name: &'static str)}\n    };\n    (seq<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_seq<$l, $v>()}\n    };\n    (tuple<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_tuple<$l, $v>(len: usize)}\n    };\n    (tuple_struct<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_tuple_struct<$l, $v>(name: &'static str, len: usize)}\n    };\n    (map<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_map<$l, $v>()}\n    };\n    (struct<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_struct<$l, $v>(name: &'static str, fields: &'static [&'static str])}\n    };\n    (enum<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_enum<$l, $v>(name: &'static str, variants: &'static [&'static str])}\n    };\n    (identifier<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_identifier<$l, $v>()}\n    };\n    (ignored_any<$l:tt, $v:ident>) => {\n        forward_to_deserialize_any_method!{deserialize_ignored_any<$l, $v>()}\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","private","de.rs"],"content":"use lib::*;\n\nuse de::{Deserialize, DeserializeSeed, Deserializer, Error, IntoDeserializer, Visitor};\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse de::{MapAccess, Unexpected};\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub use self::content::{\n    Content, ContentDeserializer, ContentRefDeserializer, EnumDeserializer,\n    InternallyTaggedUnitVisitor, TagContentOtherField, TagContentOtherFieldVisitor,\n    TagOrContentField, TagOrContentFieldVisitor, TaggedContentVisitor, UntaggedUnitVisitor,\n};\n\n/// If the missing field is of type `Option<T>` then treat is as `None`,\n/// otherwise it is an error.\npub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>\nwhere\n    V: Deserialize<'de>,\n    E: Error,\n{\n    struct MissingFieldDeserializer<E>(&'static str, PhantomData<E>);\n\n    impl<'de, E> Deserializer<'de> for MissingFieldDeserializer<E>\n    where\n        E: Error,\n    {\n        type Error = E;\n\n        fn deserialize_any<V>(self, _visitor: V) -> Result<V::Value, E>\n        where\n            V: Visitor<'de>,\n        {\n            Err(Error::missing_field(self.0))\n        }\n\n        fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, E>\n        where\n            V: Visitor<'de>,\n        {\n            visitor.visit_none()\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    let deserializer = MissingFieldDeserializer(field, PhantomData);\n    Deserialize::deserialize(deserializer)\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub fn borrow_cow_str<'de: 'a, 'a, D>(deserializer: D) -> Result<Cow<'a, str>, D::Error>\nwhere\n    D: Deserializer<'de>,\n{\n    struct CowStrVisitor;\n\n    impl<'a> Visitor<'a> for CowStrVisitor {\n        type Value = Cow<'a, str>;\n\n        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n            formatter.write_str(\"a string\")\n        }\n\n        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v.to_owned()))\n        }\n\n        fn visit_borrowed_str<E>(self, v: &'a str) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(Cow::Borrowed(v))\n        }\n\n        fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v))\n        }\n\n        fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            match str::from_utf8(v) {\n                Ok(s) => Ok(Cow::Owned(s.to_owned())),\n                Err(_) => Err(Error::invalid_value(Unexpected::Bytes(v), &self)),\n            }\n        }\n\n        fn visit_borrowed_bytes<E>(self, v: &'a [u8]) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            match str::from_utf8(v) {\n                Ok(s) => Ok(Cow::Borrowed(s)),\n                Err(_) => Err(Error::invalid_value(Unexpected::Bytes(v), &self)),\n            }\n        }\n\n        fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            match String::from_utf8(v) {\n                Ok(s) => Ok(Cow::Owned(s)),\n                Err(e) => Err(Error::invalid_value(\n                    Unexpected::Bytes(&e.into_bytes()),\n                    &self,\n                )),\n            }\n        }\n    }\n\n    deserializer.deserialize_str(CowStrVisitor)\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub fn borrow_cow_bytes<'de: 'a, 'a, D>(deserializer: D) -> Result<Cow<'a, [u8]>, D::Error>\nwhere\n    D: Deserializer<'de>,\n{\n    struct CowBytesVisitor;\n\n    impl<'a> Visitor<'a> for CowBytesVisitor {\n        type Value = Cow<'a, [u8]>;\n\n        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n            formatter.write_str(\"a byte array\")\n        }\n\n        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v.as_bytes().to_vec()))\n        }\n\n        fn visit_borrowed_str<E>(self, v: &'a str) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(Cow::Borrowed(v.as_bytes()))\n        }\n\n        fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v.into_bytes()))\n        }\n\n        fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v.to_vec()))\n        }\n\n        fn visit_borrowed_bytes<E>(self, v: &'a [u8]) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(Cow::Borrowed(v))\n        }\n\n        fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v))\n        }\n    }\n\n    deserializer.deserialize_bytes(CowBytesVisitor)\n}\n\npub mod size_hint {\n    use lib::*;\n\n    pub fn from_bounds<I>(iter: &I) -> Option<usize>\n    where\n        I: Iterator,\n    {\n        helper(iter.size_hint())\n    }\n\n    #[inline]\n    pub fn cautious(hint: Option<usize>) -> usize {\n        cmp::min(hint.unwrap_or(0), 4096)\n    }\n\n    fn helper(bounds: (usize, Option<usize>)) -> Option<usize> {\n        match bounds {\n            (lower, Some(upper)) if lower == upper => Some(upper),\n            _ => None,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmod content {\n    // This module is private and nothing here should be used outside of\n    // generated code.\n    //\n    // We will iterate on the implementation for a few releases and only have to\n    // worry about backward compatibility for the `untagged` and `tag` attributes\n    // rather than for this entire mechanism.\n    //\n    // This issue is tracking making some of this stuff public:\n    // https://github.com/serde-rs/serde/issues/741\n\n    use lib::*;\n\n    use super::size_hint;\n    use de::{\n        self, Deserialize, DeserializeSeed, Deserializer, EnumAccess, Expected, IgnoredAny,\n        MapAccess, SeqAccess, Unexpected, Visitor,\n    };\n\n    /// Used from generated code to buffer the contents of the Deserializer when\n    /// deserializing untagged enums and internally tagged enums.\n    ///\n    /// Not public API. Use serde-value instead.\n    #[derive(Debug)]\n    pub enum Content<'de> {\n        Bool(bool),\n\n        U8(u8),\n        U16(u16),\n        U32(u32),\n        U64(u64),\n\n        I8(i8),\n        I16(i16),\n        I32(i32),\n        I64(i64),\n\n        F32(f32),\n        F64(f64),\n\n        Char(char),\n        String(String),\n        Str(&'de str),\n        ByteBuf(Vec<u8>),\n        Bytes(&'de [u8]),\n\n        None,\n        Some(Box<Content<'de>>),\n\n        Unit,\n        Newtype(Box<Content<'de>>),\n        Seq(Vec<Content<'de>>),\n        Map(Vec<(Content<'de>, Content<'de>)>),\n    }\n\n    impl<'de> Content<'de> {\n        pub fn as_str(&self) -> Option<&str> {\n            match *self {\n                Content::Str(x) => Some(x),\n                Content::String(ref x) => Some(x),\n                Content::Bytes(x) => str::from_utf8(x).ok(),\n                Content::ByteBuf(ref x) => str::from_utf8(x).ok(),\n                _ => None,\n            }\n        }\n\n        #[cold]\n        fn unexpected(&self) -> Unexpected {\n            match *self {\n                Content::Bool(b) => Unexpected::Bool(b),\n                Content::U8(n) => Unexpected::Unsigned(n as u64),\n                Content::U16(n) => Unexpected::Unsigned(n as u64),\n                Content::U32(n) => Unexpected::Unsigned(n as u64),\n                Content::U64(n) => Unexpected::Unsigned(n),\n                Content::I8(n) => Unexpected::Signed(n as i64),\n                Content::I16(n) => Unexpected::Signed(n as i64),\n                Content::I32(n) => Unexpected::Signed(n as i64),\n                Content::I64(n) => Unexpected::Signed(n),\n                Content::F32(f) => Unexpected::Float(f as f64),\n                Content::F64(f) => Unexpected::Float(f),\n                Content::Char(c) => Unexpected::Char(c),\n                Content::String(ref s) => Unexpected::Str(s),\n                Content::Str(s) => Unexpected::Str(s),\n                Content::ByteBuf(ref b) => Unexpected::Bytes(b),\n                Content::Bytes(b) => Unexpected::Bytes(b),\n                Content::None | Content::Some(_) => Unexpected::Option,\n                Content::Unit => Unexpected::Unit,\n                Content::Newtype(_) => Unexpected::NewtypeStruct,\n                Content::Seq(_) => Unexpected::Seq,\n                Content::Map(_) => Unexpected::Map,\n            }\n        }\n    }\n\n    impl<'de> Deserialize<'de> for Content<'de> {\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            // Untagged and internally tagged enums are only supported in\n            // self-describing formats.\n            let visitor = ContentVisitor { value: PhantomData };\n            deserializer.deserialize_any(visitor)\n        }\n    }\n\n    struct ContentVisitor<'de> {\n        value: PhantomData<Content<'de>>,\n    }\n\n    impl<'de> ContentVisitor<'de> {\n        fn new() -> Self {\n            ContentVisitor { value: PhantomData }\n        }\n    }\n\n    impl<'de> Visitor<'de> for ContentVisitor<'de> {\n        type Value = Content<'de>;\n\n        fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n            fmt.write_str(\"any value\")\n        }\n\n        fn visit_bool<F>(self, value: bool) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::Bool(value))\n        }\n\n        fn visit_i8<F>(self, value: i8) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::I8(value))\n        }\n\n        fn visit_i16<F>(self, value: i16) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::I16(value))\n        }\n\n        fn visit_i32<F>(self, value: i32) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::I32(value))\n        }\n\n        fn visit_i64<F>(self, value: i64) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::I64(value))\n        }\n\n        fn visit_u8<F>(self, value: u8) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::U8(value))\n        }\n\n        fn visit_u16<F>(self, value: u16) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::U16(value))\n        }\n\n        fn visit_u32<F>(self, value: u32) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::U32(value))\n        }\n\n        fn visit_u64<F>(self, value: u64) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::U64(value))\n        }\n\n        fn visit_f32<F>(self, value: f32) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::F32(value))\n        }\n\n        fn visit_f64<F>(self, value: f64) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::F64(value))\n        }\n\n        fn visit_char<F>(self, value: char) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::Char(value))\n        }\n\n        fn visit_str<F>(self, value: &str) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::String(value.into()))\n        }\n\n        fn visit_borrowed_str<F>(self, value: &'de str) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::Str(value))\n        }\n\n        fn visit_string<F>(self, value: String) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::String(value))\n        }\n\n        fn visit_bytes<F>(self, value: &[u8]) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::ByteBuf(value.into()))\n        }\n\n        fn visit_borrowed_bytes<F>(self, value: &'de [u8]) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::Bytes(value))\n        }\n\n        fn visit_byte_buf<F>(self, value: Vec<u8>) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::ByteBuf(value))\n        }\n\n        fn visit_unit<F>(self) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::Unit)\n        }\n\n        fn visit_none<F>(self) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            Ok(Content::None)\n        }\n\n        fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            Deserialize::deserialize(deserializer).map(|v| Content::Some(Box::new(v)))\n        }\n\n        fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            Deserialize::deserialize(deserializer).map(|v| Content::Newtype(Box::new(v)))\n        }\n\n        fn visit_seq<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n        where\n            V: SeqAccess<'de>,\n        {\n            let mut vec = Vec::with_capacity(size_hint::cautious(visitor.size_hint()));\n            while let Some(e) = try!(visitor.next_element()) {\n                vec.push(e);\n            }\n            Ok(Content::Seq(vec))\n        }\n\n        fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n        where\n            V: MapAccess<'de>,\n        {\n            let mut vec = Vec::with_capacity(size_hint::cautious(visitor.size_hint()));\n            while let Some(kv) = try!(visitor.next_entry()) {\n                vec.push(kv);\n            }\n            Ok(Content::Map(vec))\n        }\n\n        fn visit_enum<V>(self, _visitor: V) -> Result<Self::Value, V::Error>\n        where\n            V: EnumAccess<'de>,\n        {\n            Err(de::Error::custom(\n                \"untagged and internally tagged enums do not support enum input\",\n            ))\n        }\n    }\n\n    /// This is the type of the map keys in an internally tagged enum.\n    ///\n    /// Not public API.\n    pub enum TagOrContent<'de> {\n        Tag,\n        Content(Content<'de>),\n    }\n\n    struct TagOrContentVisitor<'de> {\n        name: &'static str,\n        value: PhantomData<TagOrContent<'de>>,\n    }\n\n    impl<'de> TagOrContentVisitor<'de> {\n        fn new(name: &'static str) -> Self {\n            TagOrContentVisitor {\n                name: name,\n                value: PhantomData,\n            }\n        }\n    }\n\n    impl<'de> DeserializeSeed<'de> for TagOrContentVisitor<'de> {\n        type Value = TagOrContent<'de>;\n\n        fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            // Internally tagged enums are only supported in self-describing\n            // formats.\n            deserializer.deserialize_any(self)\n        }\n    }\n\n    impl<'de> Visitor<'de> for TagOrContentVisitor<'de> {\n        type Value = TagOrContent<'de>;\n\n        fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n            write!(fmt, \"a type tag `{}` or any other value\", self.name)\n        }\n\n        fn visit_bool<F>(self, value: bool) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_bool(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_i8<F>(self, value: i8) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_i8(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_i16<F>(self, value: i16) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_i16(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_i32<F>(self, value: i32) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_i32(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_i64<F>(self, value: i64) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_i64(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_u8<F>(self, value: u8) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_u8(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_u16<F>(self, value: u16) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_u16(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_u32<F>(self, value: u32) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_u32(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_u64<F>(self, value: u64) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_u64(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_f32<F>(self, value: f32) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_f32(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_f64<F>(self, value: f64) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_f64(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_char<F>(self, value: char) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_char(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_str<F>(self, value: &str) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            if value == self.name {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_str(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_borrowed_str<F>(self, value: &'de str) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            if value == self.name {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_borrowed_str(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_string<F>(self, value: String) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            if value == self.name {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_string(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_bytes<F>(self, value: &[u8]) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            if value == self.name.as_bytes() {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_bytes(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_borrowed_bytes<F>(self, value: &'de [u8]) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            if value == self.name.as_bytes() {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_borrowed_bytes(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_byte_buf<F>(self, value: Vec<u8>) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            if value == self.name.as_bytes() {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_byte_buf(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_unit<F>(self) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_unit()\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_none<F>(self) -> Result<Self::Value, F>\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_none()\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            ContentVisitor::new()\n                .visit_some(deserializer)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            ContentVisitor::new()\n                .visit_newtype_struct(deserializer)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_seq<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n        where\n            V: SeqAccess<'de>,\n        {\n            ContentVisitor::new()\n                .visit_seq(visitor)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_map<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n        where\n            V: MapAccess<'de>,\n        {\n            ContentVisitor::new()\n                .visit_map(visitor)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_enum<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n        where\n            V: EnumAccess<'de>,\n        {\n            ContentVisitor::new()\n                .visit_enum(visitor)\n                .map(TagOrContent::Content)\n        }\n    }\n\n    /// Used by generated code to deserialize an internally tagged enum.\n    ///\n    /// Not public API.\n    pub struct TaggedContent<'de, T> {\n        pub tag: T,\n        pub content: Content<'de>,\n    }\n\n    /// Not public API.\n    pub struct TaggedContentVisitor<'de, T> {\n        tag_name: &'static str,\n        value: PhantomData<TaggedContent<'de, T>>,\n    }\n\n    impl<'de, T> TaggedContentVisitor<'de, T> {\n        /// Visitor for the content of an internally tagged enum with the given\n        /// tag name.\n        pub fn new(name: &'static str) -> Self {\n            TaggedContentVisitor {\n                tag_name: name,\n                value: PhantomData,\n            }\n        }\n    }\n\n    impl<'de, T> DeserializeSeed<'de> for TaggedContentVisitor<'de, T>\n    where\n        T: Deserialize<'de>,\n    {\n        type Value = TaggedContent<'de, T>;\n\n        fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            // Internally tagged enums are only supported in self-describing\n            // formats.\n            deserializer.deserialize_any(self)\n        }\n    }\n\n    impl<'de, T> Visitor<'de> for TaggedContentVisitor<'de, T>\n    where\n        T: Deserialize<'de>,\n    {\n        type Value = TaggedContent<'de, T>;\n\n        fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n            fmt.write_str(\"internally tagged enum\")\n        }\n\n        fn visit_seq<S>(self, mut seq: S) -> Result<Self::Value, S::Error>\n        where\n            S: SeqAccess<'de>,\n        {\n            let tag = match try!(seq.next_element()) {\n                Some(tag) => tag,\n                None => {\n                    return Err(de::Error::missing_field(self.tag_name));\n                }\n            };\n            let rest = de::value::SeqAccessDeserializer::new(seq);\n            Ok(TaggedContent {\n                tag: tag,\n                content: try!(Content::deserialize(rest)),\n            })\n        }\n\n        fn visit_map<M>(self, mut map: M) -> Result<Self::Value, M::Error>\n        where\n            M: MapAccess<'de>,\n        {\n            let mut tag = None;\n            let mut vec = Vec::with_capacity(size_hint::cautious(map.size_hint()));\n            while let Some(k) = try!(map.next_key_seed(TagOrContentVisitor::new(self.tag_name))) {\n                match k {\n                    TagOrContent::Tag => {\n                        if tag.is_some() {\n                            return Err(de::Error::duplicate_field(self.tag_name));\n                        }\n                        tag = Some(try!(map.next_value()));\n                    }\n                    TagOrContent::Content(k) => {\n                        let v = try!(map.next_value());\n                        vec.push((k, v));\n                    }\n                }\n            }\n            match tag {\n                None => Err(de::Error::missing_field(self.tag_name)),\n                Some(tag) => Ok(TaggedContent {\n                    tag: tag,\n                    content: Content::Map(vec),\n                }),\n            }\n        }\n    }\n\n    /// Used by generated code to deserialize an adjacently tagged enum.\n    ///\n    /// Not public API.\n    pub enum TagOrContentField {\n        Tag,\n        Content,\n    }\n\n    /// Not public API.\n    pub struct TagOrContentFieldVisitor {\n        pub tag: &'static str,\n        pub content: &'static str,\n    }\n\n    impl<'de> DeserializeSeed<'de> for TagOrContentFieldVisitor {\n        type Value = TagOrContentField;\n\n        fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            deserializer.deserialize_str(self)\n        }\n    }\n\n    impl<'de> Visitor<'de> for TagOrContentFieldVisitor {\n        type Value = TagOrContentField;\n\n        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n            write!(formatter, \"{:?} or {:?}\", self.tag, self.content)\n        }\n\n        fn visit_str<E>(self, field: &str) -> Result<Self::Value, E>\n        where\n            E: de::Error,\n        {\n            if field == self.tag {\n                Ok(TagOrContentField::Tag)\n            } else if field == self.content {\n                Ok(TagOrContentField::Content)\n            } else {\n                Err(de::Error::invalid_value(Unexpected::Str(field), &self))\n            }\n        }\n    }\n\n    /// Used by generated code to deserialize an adjacently tagged enum when\n    /// ignoring unrelated fields is allowed.\n    ///\n    /// Not public API.\n    pub enum TagContentOtherField {\n        Tag,\n        Content,\n        Other,\n    }\n\n    /// Not public API.\n    pub struct TagContentOtherFieldVisitor {\n        pub tag: &'static str,\n        pub content: &'static str,\n    }\n\n    impl<'de> DeserializeSeed<'de> for TagContentOtherFieldVisitor {\n        type Value = TagContentOtherField;\n\n        fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            deserializer.deserialize_str(self)\n        }\n    }\n\n    impl<'de> Visitor<'de> for TagContentOtherFieldVisitor {\n        type Value = TagContentOtherField;\n\n        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n            write!(\n                formatter,\n                \"{:?}, {:?}, or other ignored fields\",\n                self.tag, self.content\n            )\n        }\n\n        fn visit_str<E>(self, field: &str) -> Result<Self::Value, E>\n        where\n            E: de::Error,\n        {\n            if field == self.tag {\n                Ok(TagContentOtherField::Tag)\n            } else if field == self.content {\n                Ok(TagContentOtherField::Content)\n            } else {\n                Ok(TagContentOtherField::Other)\n            }\n        }\n    }\n\n    /// Not public API\n    pub struct ContentDeserializer<'de, E> {\n        content: Content<'de>,\n        err: PhantomData<E>,\n    }\n\n    impl<'de, E> ContentDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        #[cold]\n        fn invalid_type(self, exp: &Expected) -> E {\n            de::Error::invalid_type(self.content.unexpected(), exp)\n        }\n\n        fn deserialize_integer<V>(self, visitor: V) -> Result<V::Value, E>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::U8(v) => visitor.visit_u8(v),\n                Content::U16(v) => visitor.visit_u16(v),\n                Content::U32(v) => visitor.visit_u32(v),\n                Content::U64(v) => visitor.visit_u64(v),\n                Content::I8(v) => visitor.visit_i8(v),\n                Content::I16(v) => visitor.visit_i16(v),\n                Content::I32(v) => visitor.visit_i32(v),\n                Content::I64(v) => visitor.visit_i64(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n    }\n\n    fn visit_content_seq<'de, V, E>(content: Vec<Content<'de>>, visitor: V) -> Result<V::Value, E>\n    where\n        V: Visitor<'de>,\n        E: de::Error,\n    {\n        let seq = content.into_iter().map(ContentDeserializer::new);\n        let mut seq_visitor = de::value::SeqDeserializer::new(seq);\n        let value = try!(visitor.visit_seq(&mut seq_visitor));\n        try!(seq_visitor.end());\n        Ok(value)\n    }\n\n    fn visit_content_map<'de, V, E>(\n        content: Vec<(Content<'de>, Content<'de>)>,\n        visitor: V,\n    ) -> Result<V::Value, E>\n    where\n        V: Visitor<'de>,\n        E: de::Error,\n    {\n        let map = content\n            .into_iter()\n            .map(|(k, v)| (ContentDeserializer::new(k), ContentDeserializer::new(v)));\n        let mut map_visitor = de::value::MapDeserializer::new(map);\n        let value = try!(visitor.visit_map(&mut map_visitor));\n        try!(map_visitor.end());\n        Ok(value)\n    }\n\n    /// Used when deserializing an internally tagged enum because the content\n    /// will be used exactly once.\n    impl<'de, E> Deserializer<'de> for ContentDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::Bool(v) => visitor.visit_bool(v),\n                Content::U8(v) => visitor.visit_u8(v),\n                Content::U16(v) => visitor.visit_u16(v),\n                Content::U32(v) => visitor.visit_u32(v),\n                Content::U64(v) => visitor.visit_u64(v),\n                Content::I8(v) => visitor.visit_i8(v),\n                Content::I16(v) => visitor.visit_i16(v),\n                Content::I32(v) => visitor.visit_i32(v),\n                Content::I64(v) => visitor.visit_i64(v),\n                Content::F32(v) => visitor.visit_f32(v),\n                Content::F64(v) => visitor.visit_f64(v),\n                Content::Char(v) => visitor.visit_char(v),\n                Content::String(v) => visitor.visit_string(v),\n                Content::Str(v) => visitor.visit_borrowed_str(v),\n                Content::ByteBuf(v) => visitor.visit_byte_buf(v),\n                Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n                Content::Unit => visitor.visit_unit(),\n                Content::None => visitor.visit_none(),\n                Content::Some(v) => visitor.visit_some(ContentDeserializer::new(*v)),\n                Content::Newtype(v) => visitor.visit_newtype_struct(ContentDeserializer::new(*v)),\n                Content::Seq(v) => visit_content_seq(v, visitor),\n                Content::Map(v) => visit_content_map(v, visitor),\n            }\n        }\n\n        fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::Bool(v) => visitor.visit_bool(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_i8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_f32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::F32(v) => visitor.visit_f32(v),\n                Content::F64(v) => visitor.visit_f64(v),\n                Content::U64(v) => visitor.visit_u64(v),\n                Content::I64(v) => visitor.visit_i64(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_f64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::F64(v) => visitor.visit_f64(v),\n                Content::U64(v) => visitor.visit_u64(v),\n                Content::I64(v) => visitor.visit_i64(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::Char(v) => visitor.visit_char(v),\n                Content::String(v) => visitor.visit_string(v),\n                Content::Str(v) => visitor.visit_borrowed_str(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_string(visitor)\n        }\n\n        fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::String(v) => visitor.visit_string(v),\n                Content::Str(v) => visitor.visit_borrowed_str(v),\n                Content::ByteBuf(v) => visitor.visit_byte_buf(v),\n                Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_byte_buf(visitor)\n        }\n\n        fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::String(v) => visitor.visit_string(v),\n                Content::Str(v) => visitor.visit_borrowed_str(v),\n                Content::ByteBuf(v) => visitor.visit_byte_buf(v),\n                Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n                Content::Seq(v) => visit_content_seq(v, visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::None => visitor.visit_none(),\n                Content::Some(v) => visitor.visit_some(ContentDeserializer::new(*v)),\n                Content::Unit => visitor.visit_unit(),\n                _ => visitor.visit_some(self),\n            }\n        }\n\n        fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::Unit => visitor.visit_unit(),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_unit_struct<V>(\n            self,\n            _name: &'static str,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                // As a special case, allow deserializing untagged newtype\n                // variant containing unit struct.\n                //\n                //     #[derive(Deserialize)]\n                //     struct Info;\n                //\n                //     #[derive(Deserialize)]\n                //     #[serde(tag = \"topic\")]\n                //     enum Message {\n                //         Info(Info),\n                //     }\n                //\n                // We want {\"topic\":\"Info\"} to deserialize even though\n                // ordinarily unit structs do not deserialize from empty map.\n                Content::Map(ref v) if v.is_empty() => visitor.visit_unit(),\n                _ => self.deserialize_any(visitor),\n            }\n        }\n\n        fn deserialize_newtype_struct<V>(\n            self,\n            _name: &str,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::Newtype(v) => visitor.visit_newtype_struct(ContentDeserializer::new(*v)),\n                _ => visitor.visit_newtype_struct(self),\n            }\n        }\n\n        fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::Seq(v) => visit_content_seq(v, visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_seq(visitor)\n        }\n\n        fn deserialize_tuple_struct<V>(\n            self,\n            _name: &'static str,\n            _len: usize,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_seq(visitor)\n        }\n\n        fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::Map(v) => visit_content_map(v, visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_struct<V>(\n            self,\n            _name: &'static str,\n            _fields: &'static [&'static str],\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::Seq(v) => visit_content_seq(v, visitor),\n                Content::Map(v) => visit_content_map(v, visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_enum<V>(\n            self,\n            _name: &str,\n            _variants: &'static [&'static str],\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            let (variant, value) = match self.content {\n                Content::Map(value) => {\n                    let mut iter = value.into_iter();\n                    let (variant, value) = match iter.next() {\n                        Some(v) => v,\n                        None => {\n                            return Err(de::Error::invalid_value(\n                                de::Unexpected::Map,\n                                &\"map with a single key\",\n                            ));\n                        }\n                    };\n                    // enums are encoded in json as maps with a single key:value pair\n                    if iter.next().is_some() {\n                        return Err(de::Error::invalid_value(\n                            de::Unexpected::Map,\n                            &\"map with a single key\",\n                        ));\n                    }\n                    (variant, Some(value))\n                }\n                s @ Content::String(_) | s @ Content::Str(_) => (s, None),\n                other => {\n                    return Err(de::Error::invalid_type(\n                        other.unexpected(),\n                        &\"string or map\",\n                    ));\n                }\n            };\n\n            visitor.visit_enum(EnumDeserializer::new(variant, value))\n        }\n\n        fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match self.content {\n                Content::String(v) => visitor.visit_string(v),\n                Content::Str(v) => visitor.visit_borrowed_str(v),\n                Content::ByteBuf(v) => visitor.visit_byte_buf(v),\n                Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n                Content::U8(v) => visitor.visit_u8(v),\n                Content::U64(v) => visitor.visit_u64(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            drop(self);\n            visitor.visit_unit()\n        }\n    }\n\n    impl<'de, E> ContentDeserializer<'de, E> {\n        /// private API, don't use\n        pub fn new(content: Content<'de>) -> Self {\n            ContentDeserializer {\n                content: content,\n                err: PhantomData,\n            }\n        }\n    }\n\n    pub struct EnumDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        variant: Content<'de>,\n        value: Option<Content<'de>>,\n        err: PhantomData<E>,\n    }\n\n    impl<'de, E> EnumDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        pub fn new(variant: Content<'de>, value: Option<Content<'de>>) -> EnumDeserializer<'de, E> {\n            EnumDeserializer {\n                variant: variant,\n                value: value,\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl<'de, E> de::EnumAccess<'de> for EnumDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n        type Variant = VariantDeserializer<'de, Self::Error>;\n\n        fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), E>\n        where\n            V: de::DeserializeSeed<'de>,\n        {\n            let visitor = VariantDeserializer {\n                value: self.value,\n                err: PhantomData,\n            };\n            seed.deserialize(ContentDeserializer::new(self.variant))\n                .map(|v| (v, visitor))\n        }\n    }\n\n    pub struct VariantDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        value: Option<Content<'de>>,\n        err: PhantomData<E>,\n    }\n\n    impl<'de, E> de::VariantAccess<'de> for VariantDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn unit_variant(self) -> Result<(), E> {\n            match self.value {\n                Some(value) => de::Deserialize::deserialize(ContentDeserializer::new(value)),\n                None => Ok(()),\n            }\n        }\n\n        fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, E>\n        where\n            T: de::DeserializeSeed<'de>,\n        {\n            match self.value {\n                Some(value) => seed.deserialize(ContentDeserializer::new(value)),\n                None => Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    &\"newtype variant\",\n                )),\n            }\n        }\n\n        fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: de::Visitor<'de>,\n        {\n            match self.value {\n                Some(Content::Seq(v)) => {\n                    de::Deserializer::deserialize_any(SeqDeserializer::new(v), visitor)\n                }\n                Some(other) => Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    &\"tuple variant\",\n                )),\n                None => Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    &\"tuple variant\",\n                )),\n            }\n        }\n\n        fn struct_variant<V>(\n            self,\n            _fields: &'static [&'static str],\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: de::Visitor<'de>,\n        {\n            match self.value {\n                Some(Content::Map(v)) => {\n                    de::Deserializer::deserialize_any(MapDeserializer::new(v), visitor)\n                }\n                Some(Content::Seq(v)) => {\n                    de::Deserializer::deserialize_any(SeqDeserializer::new(v), visitor)\n                }\n                Some(other) => Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    &\"struct variant\",\n                )),\n                _ => Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    &\"struct variant\",\n                )),\n            }\n        }\n    }\n\n    struct SeqDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        iter: <Vec<Content<'de>> as IntoIterator>::IntoIter,\n        err: PhantomData<E>,\n    }\n\n    impl<'de, E> SeqDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        fn new(vec: Vec<Content<'de>>) -> Self {\n            SeqDeserializer {\n                iter: vec.into_iter(),\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl<'de, E> de::Deserializer<'de> for SeqDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        #[inline]\n        fn deserialize_any<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: de::Visitor<'de>,\n        {\n            let len = self.iter.len();\n            if len == 0 {\n                visitor.visit_unit()\n            } else {\n                let ret = try!(visitor.visit_seq(&mut self));\n                let remaining = self.iter.len();\n                if remaining == 0 {\n                    Ok(ret)\n                } else {\n                    Err(de::Error::invalid_length(len, &\"fewer elements in array\"))\n                }\n            }\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf option unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    impl<'de, E> de::SeqAccess<'de> for SeqDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n        where\n            T: de::DeserializeSeed<'de>,\n        {\n            match self.iter.next() {\n                Some(value) => seed.deserialize(ContentDeserializer::new(value)).map(Some),\n                None => Ok(None),\n            }\n        }\n\n        fn size_hint(&self) -> Option<usize> {\n            size_hint::from_bounds(&self.iter)\n        }\n    }\n\n    struct MapDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        iter: <Vec<(Content<'de>, Content<'de>)> as IntoIterator>::IntoIter,\n        value: Option<Content<'de>>,\n        err: PhantomData<E>,\n    }\n\n    impl<'de, E> MapDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        fn new(map: Vec<(Content<'de>, Content<'de>)>) -> Self {\n            MapDeserializer {\n                iter: map.into_iter(),\n                value: None,\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl<'de, E> de::MapAccess<'de> for MapDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n        where\n            T: de::DeserializeSeed<'de>,\n        {\n            match self.iter.next() {\n                Some((key, value)) => {\n                    self.value = Some(value);\n                    seed.deserialize(ContentDeserializer::new(key)).map(Some)\n                }\n                None => Ok(None),\n            }\n        }\n\n        fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n        where\n            T: de::DeserializeSeed<'de>,\n        {\n            match self.value.take() {\n                Some(value) => seed.deserialize(ContentDeserializer::new(value)),\n                None => Err(de::Error::custom(\"value is missing\")),\n            }\n        }\n\n        fn size_hint(&self) -> Option<usize> {\n            size_hint::from_bounds(&self.iter)\n        }\n    }\n\n    impl<'de, E> de::Deserializer<'de> for MapDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        #[inline]\n        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: de::Visitor<'de>,\n        {\n            visitor.visit_map(self)\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf option unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    /// Not public API.\n    pub struct ContentRefDeserializer<'a, 'de: 'a, E> {\n        content: &'a Content<'de>,\n        err: PhantomData<E>,\n    }\n\n    impl<'a, 'de, E> ContentRefDeserializer<'a, 'de, E>\n    where\n        E: de::Error,\n    {\n        #[cold]\n        fn invalid_type(self, exp: &Expected) -> E {\n            de::Error::invalid_type(self.content.unexpected(), exp)\n        }\n\n        fn deserialize_integer<V>(self, visitor: V) -> Result<V::Value, E>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::U8(v) => visitor.visit_u8(v),\n                Content::U16(v) => visitor.visit_u16(v),\n                Content::U32(v) => visitor.visit_u32(v),\n                Content::U64(v) => visitor.visit_u64(v),\n                Content::I8(v) => visitor.visit_i8(v),\n                Content::I16(v) => visitor.visit_i16(v),\n                Content::I32(v) => visitor.visit_i32(v),\n                Content::I64(v) => visitor.visit_i64(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n    }\n\n    fn visit_content_seq_ref<'a, 'de, V, E>(\n        content: &'a [Content<'de>],\n        visitor: V,\n    ) -> Result<V::Value, E>\n    where\n        V: Visitor<'de>,\n        E: de::Error,\n    {\n        let seq = content.iter().map(ContentRefDeserializer::new);\n        let mut seq_visitor = de::value::SeqDeserializer::new(seq);\n        let value = try!(visitor.visit_seq(&mut seq_visitor));\n        try!(seq_visitor.end());\n        Ok(value)\n    }\n\n    fn visit_content_map_ref<'a, 'de, V, E>(\n        content: &'a [(Content<'de>, Content<'de>)],\n        visitor: V,\n    ) -> Result<V::Value, E>\n    where\n        V: Visitor<'de>,\n        E: de::Error,\n    {\n        let map = content.iter().map(|&(ref k, ref v)| {\n            (\n                ContentRefDeserializer::new(k),\n                ContentRefDeserializer::new(v),\n            )\n        });\n        let mut map_visitor = de::value::MapDeserializer::new(map);\n        let value = try!(visitor.visit_map(&mut map_visitor));\n        try!(map_visitor.end());\n        Ok(value)\n    }\n\n    /// Used when deserializing an untagged enum because the content may need\n    /// to be used more than once.\n    impl<'de, 'a, E> Deserializer<'de> for ContentRefDeserializer<'a, 'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, E>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::Bool(v) => visitor.visit_bool(v),\n                Content::U8(v) => visitor.visit_u8(v),\n                Content::U16(v) => visitor.visit_u16(v),\n                Content::U32(v) => visitor.visit_u32(v),\n                Content::U64(v) => visitor.visit_u64(v),\n                Content::I8(v) => visitor.visit_i8(v),\n                Content::I16(v) => visitor.visit_i16(v),\n                Content::I32(v) => visitor.visit_i32(v),\n                Content::I64(v) => visitor.visit_i64(v),\n                Content::F32(v) => visitor.visit_f32(v),\n                Content::F64(v) => visitor.visit_f64(v),\n                Content::Char(v) => visitor.visit_char(v),\n                Content::String(ref v) => visitor.visit_str(v),\n                Content::Str(v) => visitor.visit_borrowed_str(v),\n                Content::ByteBuf(ref v) => visitor.visit_bytes(v),\n                Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n                Content::Unit => visitor.visit_unit(),\n                Content::None => visitor.visit_none(),\n                Content::Some(ref v) => visitor.visit_some(ContentRefDeserializer::new(v)),\n                Content::Newtype(ref v) => {\n                    visitor.visit_newtype_struct(ContentRefDeserializer::new(v))\n                }\n                Content::Seq(ref v) => visit_content_seq_ref(v, visitor),\n                Content::Map(ref v) => visit_content_map_ref(v, visitor),\n            }\n        }\n\n        fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::Bool(v) => visitor.visit_bool(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_i8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_f32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::F32(v) => visitor.visit_f32(v),\n                Content::F64(v) => visitor.visit_f64(v),\n                Content::U64(v) => visitor.visit_u64(v),\n                Content::I64(v) => visitor.visit_i64(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_f64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::F64(v) => visitor.visit_f64(v),\n                Content::U64(v) => visitor.visit_u64(v),\n                Content::I64(v) => visitor.visit_i64(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::Char(v) => visitor.visit_char(v),\n                Content::String(ref v) => visitor.visit_str(v),\n                Content::Str(v) => visitor.visit_borrowed_str(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::String(ref v) => visitor.visit_str(v),\n                Content::Str(v) => visitor.visit_borrowed_str(v),\n                Content::ByteBuf(ref v) => visitor.visit_bytes(v),\n                Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_str(visitor)\n        }\n\n        fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::String(ref v) => visitor.visit_str(v),\n                Content::Str(v) => visitor.visit_borrowed_str(v),\n                Content::ByteBuf(ref v) => visitor.visit_bytes(v),\n                Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n                Content::Seq(ref v) => visit_content_seq_ref(v, visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_bytes(visitor)\n        }\n\n        fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, E>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::None => visitor.visit_none(),\n                Content::Some(ref v) => visitor.visit_some(ContentRefDeserializer::new(v)),\n                Content::Unit => visitor.visit_unit(),\n                _ => visitor.visit_some(self),\n            }\n        }\n\n        fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::Unit => visitor.visit_unit(),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_unit_struct<V>(\n            self,\n            _name: &'static str,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_unit(visitor)\n        }\n\n        fn deserialize_newtype_struct<V>(self, _name: &str, visitor: V) -> Result<V::Value, E>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::Newtype(ref v) => {\n                    visitor.visit_newtype_struct(ContentRefDeserializer::new(v))\n                }\n                _ => visitor.visit_newtype_struct(self),\n            }\n        }\n\n        fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::Seq(ref v) => visit_content_seq_ref(v, visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_seq(visitor)\n        }\n\n        fn deserialize_tuple_struct<V>(\n            self,\n            _name: &'static str,\n            _len: usize,\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            self.deserialize_seq(visitor)\n        }\n\n        fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::Map(ref v) => visit_content_map_ref(v, visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_struct<V>(\n            self,\n            _name: &'static str,\n            _fields: &'static [&'static str],\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::Seq(ref v) => visit_content_seq_ref(v, visitor),\n                Content::Map(ref v) => visit_content_map_ref(v, visitor),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_enum<V>(\n            self,\n            _name: &str,\n            _variants: &'static [&'static str],\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            let (variant, value) = match *self.content {\n                Content::Map(ref value) => {\n                    let mut iter = value.iter();\n                    let &(ref variant, ref value) = match iter.next() {\n                        Some(v) => v,\n                        None => {\n                            return Err(de::Error::invalid_value(\n                                de::Unexpected::Map,\n                                &\"map with a single key\",\n                            ));\n                        }\n                    };\n                    // enums are encoded in json as maps with a single key:value pair\n                    if iter.next().is_some() {\n                        return Err(de::Error::invalid_value(\n                            de::Unexpected::Map,\n                            &\"map with a single key\",\n                        ));\n                    }\n                    (variant, Some(value))\n                }\n                ref s @ Content::String(_) | ref s @ Content::Str(_) => (s, None),\n                ref other => {\n                    return Err(de::Error::invalid_type(\n                        other.unexpected(),\n                        &\"string or map\",\n                    ));\n                }\n            };\n\n            visitor.visit_enum(EnumRefDeserializer {\n                variant: variant,\n                value: value,\n                err: PhantomData,\n            })\n        }\n\n        fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            match *self.content {\n                Content::String(ref v) => visitor.visit_str(v),\n                Content::Str(v) => visitor.visit_borrowed_str(v),\n                Content::ByteBuf(ref v) => visitor.visit_bytes(v),\n                Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n                Content::U8(v) => visitor.visit_u8(v),\n                Content::U64(v) => visitor.visit_u64(v),\n                _ => Err(self.invalid_type(&visitor)),\n            }\n        }\n\n        fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: Visitor<'de>,\n        {\n            visitor.visit_unit()\n        }\n    }\n\n    impl<'a, 'de, E> ContentRefDeserializer<'a, 'de, E> {\n        /// private API, don't use\n        pub fn new(content: &'a Content<'de>) -> Self {\n            ContentRefDeserializer {\n                content: content,\n                err: PhantomData,\n            }\n        }\n    }\n\n    struct EnumRefDeserializer<'a, 'de: 'a, E>\n    where\n        E: de::Error,\n    {\n        variant: &'a Content<'de>,\n        value: Option<&'a Content<'de>>,\n        err: PhantomData<E>,\n    }\n\n    impl<'de, 'a, E> de::EnumAccess<'de> for EnumRefDeserializer<'a, 'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n        type Variant = VariantRefDeserializer<'a, 'de, Self::Error>;\n\n        fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n        where\n            V: de::DeserializeSeed<'de>,\n        {\n            let visitor = VariantRefDeserializer {\n                value: self.value,\n                err: PhantomData,\n            };\n            seed.deserialize(ContentRefDeserializer::new(self.variant))\n                .map(|v| (v, visitor))\n        }\n    }\n\n    struct VariantRefDeserializer<'a, 'de: 'a, E>\n    where\n        E: de::Error,\n    {\n        value: Option<&'a Content<'de>>,\n        err: PhantomData<E>,\n    }\n\n    impl<'de, 'a, E> de::VariantAccess<'de> for VariantRefDeserializer<'a, 'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn unit_variant(self) -> Result<(), E> {\n            match self.value {\n                Some(value) => de::Deserialize::deserialize(ContentRefDeserializer::new(value)),\n                None => Ok(()),\n            }\n        }\n\n        fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, E>\n        where\n            T: de::DeserializeSeed<'de>,\n        {\n            match self.value {\n                Some(value) => seed.deserialize(ContentRefDeserializer::new(value)),\n                None => Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    &\"newtype variant\",\n                )),\n            }\n        }\n\n        fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: de::Visitor<'de>,\n        {\n            match self.value {\n                Some(&Content::Seq(ref v)) => {\n                    de::Deserializer::deserialize_any(SeqRefDeserializer::new(v), visitor)\n                }\n                Some(other) => Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    &\"tuple variant\",\n                )),\n                None => Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    &\"tuple variant\",\n                )),\n            }\n        }\n\n        fn struct_variant<V>(\n            self,\n            _fields: &'static [&'static str],\n            visitor: V,\n        ) -> Result<V::Value, Self::Error>\n        where\n            V: de::Visitor<'de>,\n        {\n            match self.value {\n                Some(&Content::Map(ref v)) => {\n                    de::Deserializer::deserialize_any(MapRefDeserializer::new(v), visitor)\n                }\n                Some(&Content::Seq(ref v)) => {\n                    de::Deserializer::deserialize_any(SeqRefDeserializer::new(v), visitor)\n                }\n                Some(other) => Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    &\"struct variant\",\n                )),\n                _ => Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    &\"struct variant\",\n                )),\n            }\n        }\n    }\n\n    struct SeqRefDeserializer<'a, 'de: 'a, E>\n    where\n        E: de::Error,\n    {\n        iter: <&'a [Content<'de>] as IntoIterator>::IntoIter,\n        err: PhantomData<E>,\n    }\n\n    impl<'a, 'de, E> SeqRefDeserializer<'a, 'de, E>\n    where\n        E: de::Error,\n    {\n        fn new(slice: &'a [Content<'de>]) -> Self {\n            SeqRefDeserializer {\n                iter: slice.iter(),\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl<'de, 'a, E> de::Deserializer<'de> for SeqRefDeserializer<'a, 'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        #[inline]\n        fn deserialize_any<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: de::Visitor<'de>,\n        {\n            let len = self.iter.len();\n            if len == 0 {\n                visitor.visit_unit()\n            } else {\n                let ret = try!(visitor.visit_seq(&mut self));\n                let remaining = self.iter.len();\n                if remaining == 0 {\n                    Ok(ret)\n                } else {\n                    Err(de::Error::invalid_length(len, &\"fewer elements in array\"))\n                }\n            }\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf option unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    impl<'de, 'a, E> de::SeqAccess<'de> for SeqRefDeserializer<'a, 'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n        where\n            T: de::DeserializeSeed<'de>,\n        {\n            match self.iter.next() {\n                Some(value) => seed\n                    .deserialize(ContentRefDeserializer::new(value))\n                    .map(Some),\n                None => Ok(None),\n            }\n        }\n\n        fn size_hint(&self) -> Option<usize> {\n            size_hint::from_bounds(&self.iter)\n        }\n    }\n\n    struct MapRefDeserializer<'a, 'de: 'a, E>\n    where\n        E: de::Error,\n    {\n        iter: <&'a [(Content<'de>, Content<'de>)] as IntoIterator>::IntoIter,\n        value: Option<&'a Content<'de>>,\n        err: PhantomData<E>,\n    }\n\n    impl<'a, 'de, E> MapRefDeserializer<'a, 'de, E>\n    where\n        E: de::Error,\n    {\n        fn new(map: &'a [(Content<'de>, Content<'de>)]) -> Self {\n            MapRefDeserializer {\n                iter: map.iter(),\n                value: None,\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl<'de, 'a, E> de::MapAccess<'de> for MapRefDeserializer<'a, 'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n        where\n            T: de::DeserializeSeed<'de>,\n        {\n            match self.iter.next() {\n                Some(&(ref key, ref value)) => {\n                    self.value = Some(value);\n                    seed.deserialize(ContentRefDeserializer::new(key)).map(Some)\n                }\n                None => Ok(None),\n            }\n        }\n\n        fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n        where\n            T: de::DeserializeSeed<'de>,\n        {\n            match self.value.take() {\n                Some(value) => seed.deserialize(ContentRefDeserializer::new(value)),\n                None => Err(de::Error::custom(\"value is missing\")),\n            }\n        }\n\n        fn size_hint(&self) -> Option<usize> {\n            size_hint::from_bounds(&self.iter)\n        }\n    }\n\n    impl<'de, 'a, E> de::Deserializer<'de> for MapRefDeserializer<'a, 'de, E>\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        #[inline]\n        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n        where\n            V: de::Visitor<'de>,\n        {\n            visitor.visit_map(self)\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf option unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    impl<'de, E> de::IntoDeserializer<'de, E> for ContentDeserializer<'de, E>\n    where\n        E: de::Error,\n    {\n        type Deserializer = Self;\n\n        fn into_deserializer(self) -> Self {\n            self\n        }\n    }\n\n    impl<'de, 'a, E> de::IntoDeserializer<'de, E> for ContentRefDeserializer<'a, 'de, E>\n    where\n        E: de::Error,\n    {\n        type Deserializer = Self;\n\n        fn into_deserializer(self) -> Self {\n            self\n        }\n    }\n\n    /// Visitor for deserializing an internally tagged unit variant.\n    ///\n    /// Not public API.\n    pub struct InternallyTaggedUnitVisitor<'a> {\n        type_name: &'a str,\n        variant_name: &'a str,\n    }\n\n    impl<'a> InternallyTaggedUnitVisitor<'a> {\n        /// Not public API.\n        pub fn new(type_name: &'a str, variant_name: &'a str) -> Self {\n            InternallyTaggedUnitVisitor {\n                type_name: type_name,\n                variant_name: variant_name,\n            }\n        }\n    }\n\n    impl<'de, 'a> Visitor<'de> for InternallyTaggedUnitVisitor<'a> {\n        type Value = ();\n\n        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n            write!(\n                formatter,\n                \"unit variant {}::{}\",\n                self.type_name, self.variant_name\n            )\n        }\n\n        fn visit_seq<S>(self, _: S) -> Result<(), S::Error>\n        where\n            S: SeqAccess<'de>,\n        {\n            Ok(())\n        }\n\n        fn visit_map<M>(self, mut access: M) -> Result<(), M::Error>\n        where\n            M: MapAccess<'de>,\n        {\n            while let Some(_) = try!(access.next_entry::<IgnoredAny, IgnoredAny>()) {}\n            Ok(())\n        }\n    }\n\n    /// Visitor for deserializing an untagged unit variant.\n    ///\n    /// Not public API.\n    pub struct UntaggedUnitVisitor<'a> {\n        type_name: &'a str,\n        variant_name: &'a str,\n    }\n\n    impl<'a> UntaggedUnitVisitor<'a> {\n        /// Not public API.\n        pub fn new(type_name: &'a str, variant_name: &'a str) -> Self {\n            UntaggedUnitVisitor {\n                type_name: type_name,\n                variant_name: variant_name,\n            }\n        }\n    }\n\n    impl<'de, 'a> Visitor<'de> for UntaggedUnitVisitor<'a> {\n        type Value = ();\n\n        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n            write!(\n                formatter,\n                \"unit variant {}::{}\",\n                self.type_name, self.variant_name\n            )\n        }\n\n        fn visit_unit<E>(self) -> Result<(), E>\n        where\n            E: de::Error,\n        {\n            Ok(())\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Like `IntoDeserializer` but also implemented for `&[u8]`. This is used for\n// the newtype fallthrough case of `field_identifier`.\n//\n//    #[derive(Deserialize)]\n//    #[serde(field_identifier)]\n//    enum F {\n//        A,\n//        B,\n//        Other(String), // deserialized using IdentifierDeserializer\n//    }\npub trait IdentifierDeserializer<'de, E: Error> {\n    type Deserializer: Deserializer<'de, Error = E>;\n\n    fn from(self) -> Self::Deserializer;\n}\n\nimpl<'de, E> IdentifierDeserializer<'de, E> for u32\nwhere\n    E: Error,\n{\n    type Deserializer = <u32 as IntoDeserializer<'de, E>>::Deserializer;\n\n    fn from(self) -> Self::Deserializer {\n        self.into_deserializer()\n    }\n}\n\npub struct StrDeserializer<'a, E> {\n    value: &'a str,\n    marker: PhantomData<E>,\n}\n\nimpl<'a, E> IdentifierDeserializer<'a, E> for &'a str\nwhere\n    E: Error,\n{\n    type Deserializer = StrDeserializer<'a, E>;\n\n    fn from(self) -> Self::Deserializer {\n        StrDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<'de, 'a, E> Deserializer<'de> for StrDeserializer<'a, E>\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_str(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\npub struct BytesDeserializer<'a, E> {\n    value: &'a [u8],\n    marker: PhantomData<E>,\n}\n\nimpl<'a, E> IdentifierDeserializer<'a, E> for &'a [u8]\nwhere\n    E: Error,\n{\n    type Deserializer = BytesDeserializer<'a, E>;\n\n    fn from(self) -> Self::Deserializer {\n        BytesDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<'de, 'a, E> Deserializer<'de> for BytesDeserializer<'a, E>\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_bytes(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\n/// A DeserializeSeed helper for implementing deserialize_in_place Visitors.\n///\n/// Wraps a mutable reference and calls deserialize_in_place on it.\npub struct InPlaceSeed<'a, T: 'a>(pub &'a mut T);\n\nimpl<'a, 'de, T> DeserializeSeed<'de> for InPlaceSeed<'a, T>\nwhere\n    T: Deserialize<'de>,\n{\n    type Value = ();\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        T::deserialize_in_place(deserializer, self.0)\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapDeserializer<'a, 'de: 'a, E>(\n    pub &'a mut Vec<Option<(Content<'de>, Content<'de>)>>,\n    pub PhantomData<E>,\n);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, 'de, E> FlatMapDeserializer<'a, 'de, E>\nwhere\n    E: Error,\n{\n    fn deserialize_other<V>() -> Result<V, E> {\n        Err(Error::custom(\"can only flatten structs and maps\"))\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! forward_to_deserialize_other {\n    ($($func:ident ( $($arg:ty),* ))*) => {\n        $(\n            fn $func<V>(self, $(_: $arg,)* _visitor: V) -> Result<V::Value, Self::Error>\n            where\n                V: Visitor<'de>,\n            {\n                Self::deserialize_other()\n            }\n        )*\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, 'de, E> Deserializer<'de> for FlatMapDeserializer<'a, 'de, E>\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_map(FlatInternallyTaggedAccess {\n            iter: self.0.iter_mut(),\n            pending: None,\n            _marker: PhantomData,\n        })\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        for item in self.0.iter_mut() {\n            // items in the vector are nulled out when used.  So we can only use\n            // an item if it's still filled in and if the field is one we care\n            // about.\n            let use_item = match *item {\n                None => false,\n                Some((ref c, _)) => c.as_str().map_or(false, |x| variants.contains(&x)),\n            };\n\n            if use_item {\n                let (key, value) = item.take().unwrap();\n                return visitor.visit_enum(EnumDeserializer::new(key, Some(value)));\n            }\n        }\n\n        Err(Error::custom(format_args!(\n            \"no variant of enum {} found in flattened data\",\n            name\n        )))\n    }\n\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_map(FlatMapAccess::new(self.0.iter()))\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        _: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_map(FlatStructAccess::new(self.0.iter_mut(), fields))\n    }\n\n    fn deserialize_newtype_struct<V>(self, _name: &str, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_newtype_struct(self)\n    }\n\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match visitor.__private_visit_untagged_option(self) {\n            Ok(value) => Ok(value),\n            Err(()) => Self::deserialize_other(),\n        }\n    }\n\n    forward_to_deserialize_other! {\n        deserialize_bool()\n        deserialize_i8()\n        deserialize_i16()\n        deserialize_i32()\n        deserialize_i64()\n        deserialize_u8()\n        deserialize_u16()\n        deserialize_u32()\n        deserialize_u64()\n        deserialize_f32()\n        deserialize_f64()\n        deserialize_char()\n        deserialize_str()\n        deserialize_string()\n        deserialize_bytes()\n        deserialize_byte_buf()\n        deserialize_unit()\n        deserialize_unit_struct(&'static str)\n        deserialize_seq()\n        deserialize_tuple(usize)\n        deserialize_tuple_struct(&'static str, usize)\n        deserialize_identifier()\n        deserialize_ignored_any()\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapAccess<'a, 'de: 'a, E> {\n    iter: slice::Iter<'a, Option<(Content<'de>, Content<'de>)>>,\n    pending_content: Option<&'a Content<'de>>,\n    _marker: PhantomData<E>,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, 'de, E> FlatMapAccess<'a, 'de, E> {\n    fn new(\n        iter: slice::Iter<'a, Option<(Content<'de>, Content<'de>)>>,\n    ) -> FlatMapAccess<'a, 'de, E> {\n        FlatMapAccess {\n            iter: iter,\n            pending_content: None,\n            _marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, 'de, E> MapAccess<'de> for FlatMapAccess<'a, 'de, E>\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        while let Some(item) = self.iter.next() {\n            // Items in the vector are nulled out when used by a struct.\n            if let Some((ref key, ref content)) = *item {\n                self.pending_content = Some(content);\n                return seed.deserialize(ContentRefDeserializer::new(key)).map(Some);\n            }\n        }\n        Ok(None)\n    }\n\n    fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.pending_content.take() {\n            Some(value) => seed.deserialize(ContentRefDeserializer::new(value)),\n            None => Err(Error::custom(\"value is missing\")),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatStructAccess<'a, 'de: 'a, E> {\n    iter: slice::IterMut<'a, Option<(Content<'de>, Content<'de>)>>,\n    pending_content: Option<Content<'de>>,\n    fields: &'static [&'static str],\n    _marker: PhantomData<E>,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, 'de, E> FlatStructAccess<'a, 'de, E> {\n    fn new(\n        iter: slice::IterMut<'a, Option<(Content<'de>, Content<'de>)>>,\n        fields: &'static [&'static str],\n    ) -> FlatStructAccess<'a, 'de, E> {\n        FlatStructAccess {\n            iter: iter,\n            pending_content: None,\n            fields: fields,\n            _marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, 'de, E> MapAccess<'de> for FlatStructAccess<'a, 'de, E>\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        while let Some(item) = self.iter.next() {\n            // items in the vector are nulled out when used.  So we can only use\n            // an item if it's still filled in and if the field is one we care\n            // about.  In case we do not know which fields we want, we take them all.\n            let use_item = match *item {\n                None => false,\n                Some((ref c, _)) => c.as_str().map_or(false, |key| self.fields.contains(&key)),\n            };\n\n            if use_item {\n                let (key, content) = item.take().unwrap();\n                self.pending_content = Some(content);\n                return seed.deserialize(ContentDeserializer::new(key)).map(Some);\n            }\n        }\n        Ok(None)\n    }\n\n    fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.pending_content.take() {\n            Some(value) => seed.deserialize(ContentDeserializer::new(value)),\n            None => Err(Error::custom(\"value is missing\")),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatInternallyTaggedAccess<'a, 'de: 'a, E> {\n    iter: slice::IterMut<'a, Option<(Content<'de>, Content<'de>)>>,\n    pending: Option<&'a Content<'de>>,\n    _marker: PhantomData<E>,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, 'de, E> MapAccess<'de> for FlatInternallyTaggedAccess<'a, 'de, E>\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        while let Some(item) = self.iter.next() {\n            if let Some((ref key, ref content)) = *item {\n                // Do not take(), instead borrow this entry. The internally tagged\n                // enum does its own buffering so we can't tell whether this entry\n                // is going to be consumed. Borrowing here leaves the entry\n                // available for later flattened fields.\n                self.pending = Some(content);\n                return seed.deserialize(ContentRefDeserializer::new(key)).map(Some);\n            }\n        }\n        Ok(None)\n    }\n\n    fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.pending.take() {\n            Some(value) => seed.deserialize(ContentRefDeserializer::new(value)),\n            None => panic!(\"value is missing\"),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","private","macros.rs"],"content":"#[doc(hidden)]\n#[macro_export]\nmacro_rules! __private_serialize {\n    () => {\n        trait Serialize {\n            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n            where\n                S: $crate::Serializer;\n        }\n    };\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! __private_deserialize {\n    () => {\n        trait Deserialize<'de>: Sized {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: $crate::Deserializer<'de>;\n        }\n    };\n}\n\n/// Used only by Serde doc tests. Not public API.\n#[doc(hidden)]\n#[macro_export(local_inner_macros)]\nmacro_rules! __serialize_unimplemented {\n    ($($func:ident)*) => {\n        $(\n            __serialize_unimplemented_helper!($func);\n        )*\n    };\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! __serialize_unimplemented_method {\n    ($func:ident $(<$t:ident>)* ($($arg:ty),*) -> $ret:ident) => {\n        fn $func $(<$t: ?Sized + $crate::Serialize>)* (self $(, _: $arg)*) -> $crate::export::Result<Self::$ret, Self::Error> {\n            unimplemented!()\n        }\n    };\n}\n\n#[doc(hidden)]\n#[macro_export(local_inner_macros)]\nmacro_rules! __serialize_unimplemented_helper {\n    (bool) => {\n        __serialize_unimplemented_method!(serialize_bool(bool) -> Ok);\n    };\n    (i8) => {\n        __serialize_unimplemented_method!(serialize_i8(i8) -> Ok);\n    };\n    (i16) => {\n        __serialize_unimplemented_method!(serialize_i16(i16) -> Ok);\n    };\n    (i32) => {\n        __serialize_unimplemented_method!(serialize_i32(i32) -> Ok);\n    };\n    (i64) => {\n        __serialize_unimplemented_method!(serialize_i64(i64) -> Ok);\n    };\n    (u8) => {\n        __serialize_unimplemented_method!(serialize_u8(u8) -> Ok);\n    };\n    (u16) => {\n        __serialize_unimplemented_method!(serialize_u16(u16) -> Ok);\n    };\n    (u32) => {\n        __serialize_unimplemented_method!(serialize_u32(u32) -> Ok);\n    };\n    (u64) => {\n        __serialize_unimplemented_method!(serialize_u64(u64) -> Ok);\n    };\n    (f32) => {\n        __serialize_unimplemented_method!(serialize_f32(f32) -> Ok);\n    };\n    (f64) => {\n        __serialize_unimplemented_method!(serialize_f64(f64) -> Ok);\n    };\n    (char) => {\n        __serialize_unimplemented_method!(serialize_char(char) -> Ok);\n    };\n    (str) => {\n        __serialize_unimplemented_method!(serialize_str(&str) -> Ok);\n    };\n    (bytes) => {\n        __serialize_unimplemented_method!(serialize_bytes(&[u8]) -> Ok);\n    };\n    (none) => {\n        __serialize_unimplemented_method!(serialize_none() -> Ok);\n    };\n    (some) => {\n        __serialize_unimplemented_method!(serialize_some<T>(&T) -> Ok);\n    };\n    (unit) => {\n        __serialize_unimplemented_method!(serialize_unit() -> Ok);\n    };\n    (unit_struct) => {\n        __serialize_unimplemented_method!(serialize_unit_struct(&str) -> Ok);\n    };\n    (unit_variant) => {\n        __serialize_unimplemented_method!(serialize_unit_variant(&str, u32, &str) -> Ok);\n    };\n    (newtype_struct) => {\n        __serialize_unimplemented_method!(serialize_newtype_struct<T>(&str, &T) -> Ok);\n    };\n    (newtype_variant) => {\n        __serialize_unimplemented_method!(serialize_newtype_variant<T>(&str, u32, &str, &T) -> Ok);\n    };\n    (seq) => {\n        type SerializeSeq = $crate::ser::Impossible<Self::Ok, Self::Error>;\n        __serialize_unimplemented_method!(serialize_seq(Option<usize>) -> SerializeSeq);\n    };\n    (tuple) => {\n        type SerializeTuple = $crate::ser::Impossible<Self::Ok, Self::Error>;\n        __serialize_unimplemented_method!(serialize_tuple(usize) -> SerializeTuple);\n    };\n    (tuple_struct) => {\n        type SerializeTupleStruct = $crate::ser::Impossible<Self::Ok, Self::Error>;\n        __serialize_unimplemented_method!(serialize_tuple_struct(&str, usize) -> SerializeTupleStruct);\n    };\n    (tuple_variant) => {\n        type SerializeTupleVariant = $crate::ser::Impossible<Self::Ok, Self::Error>;\n        __serialize_unimplemented_method!(serialize_tuple_variant(&str, u32, &str, usize) -> SerializeTupleVariant);\n    };\n    (map) => {\n        type SerializeMap = $crate::ser::Impossible<Self::Ok, Self::Error>;\n        __serialize_unimplemented_method!(serialize_map(Option<usize>) -> SerializeMap);\n    };\n    (struct) => {\n        type SerializeStruct = $crate::ser::Impossible<Self::Ok, Self::Error>;\n        __serialize_unimplemented_method!(serialize_struct(&str, usize) -> SerializeStruct);\n    };\n    (struct_variant) => {\n        type SerializeStructVariant = $crate::ser::Impossible<Self::Ok, Self::Error>;\n        __serialize_unimplemented_method!(serialize_struct_variant(&str, u32, &str, usize) -> SerializeStructVariant);\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","private","mod.rs"],"content":"mod macros;\n\npub mod de;\npub mod ser;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","private","ser.rs"],"content":"use lib::*;\n\nuse ser::{self, Impossible, Serialize, SerializeMap, SerializeStruct, Serializer};\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse self::content::{\n    Content, ContentSerializer, SerializeStructVariantAsMapValue, SerializeTupleVariantAsMapValue,\n};\n\n/// Used to check that serde(getter) attributes return the expected type.\n/// Not public API.\npub fn constrain<T: ?Sized>(t: &T) -> &T {\n    t\n}\n\n/// Not public API.\npub fn serialize_tagged_newtype<S, T>(\n    serializer: S,\n    type_ident: &'static str,\n    variant_ident: &'static str,\n    tag: &'static str,\n    variant_name: &'static str,\n    value: &T,\n) -> Result<S::Ok, S::Error>\nwhere\n    S: Serializer,\n    T: Serialize,\n{\n    value.serialize(TaggedSerializer {\n        type_ident: type_ident,\n        variant_ident: variant_ident,\n        tag: tag,\n        variant_name: variant_name,\n        delegate: serializer,\n    })\n}\n\nstruct TaggedSerializer<S> {\n    type_ident: &'static str,\n    variant_ident: &'static str,\n    tag: &'static str,\n    variant_name: &'static str,\n    delegate: S,\n}\n\nenum Unsupported {\n    Boolean,\n    Integer,\n    Float,\n    Char,\n    String,\n    ByteArray,\n    Optional,\n    Unit,\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    UnitStruct,\n    Sequence,\n    Tuple,\n    TupleStruct,\n    Enum,\n}\n\nimpl Display for Unsupported {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            Unsupported::Boolean => formatter.write_str(\"a boolean\"),\n            Unsupported::Integer => formatter.write_str(\"an integer\"),\n            Unsupported::Float => formatter.write_str(\"a float\"),\n            Unsupported::Char => formatter.write_str(\"a char\"),\n            Unsupported::String => formatter.write_str(\"a string\"),\n            Unsupported::ByteArray => formatter.write_str(\"a byte array\"),\n            Unsupported::Optional => formatter.write_str(\"an optional\"),\n            Unsupported::Unit => formatter.write_str(\"unit\"),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Unsupported::UnitStruct => formatter.write_str(\"unit struct\"),\n            Unsupported::Sequence => formatter.write_str(\"a sequence\"),\n            Unsupported::Tuple => formatter.write_str(\"a tuple\"),\n            Unsupported::TupleStruct => formatter.write_str(\"a tuple struct\"),\n            Unsupported::Enum => formatter.write_str(\"an enum\"),\n        }\n    }\n}\n\nimpl<S> TaggedSerializer<S>\nwhere\n    S: Serializer,\n{\n    fn bad_type(self, what: Unsupported) -> S::Error {\n        ser::Error::custom(format_args!(\n            \"cannot serialize tagged newtype variant {}::{} containing {}\",\n            self.type_ident, self.variant_ident, what\n        ))\n    }\n}\n\nimpl<S> Serializer for TaggedSerializer<S>\nwhere\n    S: Serializer,\n{\n    type Ok = S::Ok;\n    type Error = S::Error;\n\n    type SerializeSeq = Impossible<S::Ok, S::Error>;\n    type SerializeTuple = Impossible<S::Ok, S::Error>;\n    type SerializeTupleStruct = Impossible<S::Ok, S::Error>;\n    type SerializeMap = S::SerializeMap;\n    type SerializeStruct = S::SerializeStruct;\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    type SerializeTupleVariant = Impossible<S::Ok, S::Error>;\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    type SerializeTupleVariant = SerializeTupleVariantAsMapValue<S::SerializeMap>;\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    type SerializeStructVariant = Impossible<S::Ok, S::Error>;\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    type SerializeStructVariant = SerializeStructVariantAsMapValue<S::SerializeMap>;\n\n    fn serialize_bool(self, _: bool) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Boolean))\n    }\n\n    fn serialize_i8(self, _: i8) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i16(self, _: i16) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i32(self, _: i32) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i64(self, _: i64) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u8(self, _: u8) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u16(self, _: u16) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u32(self, _: u32) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u64(self, _: u64) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_f32(self, _: f32) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Float))\n    }\n\n    fn serialize_f64(self, _: f64) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Float))\n    }\n\n    fn serialize_char(self, _: char) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Char))\n    }\n\n    fn serialize_str(self, _: &str) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::String))\n    }\n\n    fn serialize_bytes(self, _: &[u8]) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::ByteArray))\n    }\n\n    fn serialize_none(self) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Optional))\n    }\n\n    fn serialize_some<T: ?Sized>(self, _: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: Serialize,\n    {\n        Err(self.bad_type(Unsupported::Optional))\n    }\n\n    fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Unit))\n    }\n\n    fn serialize_unit_struct(self, _: &'static str) -> Result<Self::Ok, Self::Error> {\n        let mut map = try!(self.delegate.serialize_map(Some(1)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        map.end()\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        inner_variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error> {\n        let mut map = try!(self.delegate.serialize_map(Some(2)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        try!(map.serialize_entry(inner_variant, &()));\n        map.end()\n    }\n\n    fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        _: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        _: &'static str,\n        _: u32,\n        inner_variant: &'static str,\n        inner_value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: Serialize,\n    {\n        let mut map = try!(self.delegate.serialize_map(Some(2)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        try!(map.serialize_entry(inner_variant, inner_value));\n        map.end()\n    }\n\n    fn serialize_seq(self, _: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {\n        Err(self.bad_type(Unsupported::Sequence))\n    }\n\n    fn serialize_tuple(self, _: usize) -> Result<Self::SerializeTuple, Self::Error> {\n        Err(self.bad_type(Unsupported::Tuple))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error> {\n        Err(self.bad_type(Unsupported::TupleStruct))\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn serialize_tuple_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        _: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        // Lack of push-based serialization means we need to buffer the content\n        // of the tuple variant, so it requires std.\n        Err(self.bad_type(Unsupported::Enum))\n    }\n\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn serialize_tuple_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        inner_variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        let mut map = try!(self.delegate.serialize_map(Some(2)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        try!(map.serialize_key(inner_variant));\n        Ok(SerializeTupleVariantAsMapValue::new(\n            map,\n            inner_variant,\n            len,\n        ))\n    }\n\n    fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {\n        let mut map = try!(self.delegate.serialize_map(len.map(|len| len + 1)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        Ok(map)\n    }\n\n    fn serialize_struct(\n        self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error> {\n        let mut state = try!(self.delegate.serialize_struct(name, len + 1));\n        try!(state.serialize_field(self.tag, self.variant_name));\n        Ok(state)\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn serialize_struct_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        _: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        // Lack of push-based serialization means we need to buffer the content\n        // of the struct variant, so it requires std.\n        Err(self.bad_type(Unsupported::Enum))\n    }\n\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn serialize_struct_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        inner_variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        let mut map = try!(self.delegate.serialize_map(Some(2)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        try!(map.serialize_key(inner_variant));\n        Ok(SerializeStructVariantAsMapValue::new(\n            map,\n            inner_variant,\n            len,\n        ))\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn collect_str<T: ?Sized>(self, _: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: Display,\n    {\n        Err(self.bad_type(Unsupported::String))\n    }\n}\n\n/// Used only by Serde doc tests. Not public API.\n#[doc(hidden)]\n#[derive(Debug)]\npub struct Error;\n\nimpl ser::Error for Error {\n    fn custom<T>(_: T) -> Self\n    where\n        T: Display,\n    {\n        unimplemented!()\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl error::Error for Error {\n    fn description(&self) -> &str {\n        unimplemented!()\n    }\n}\n\nimpl Display for Error {\n    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n        unimplemented!()\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmod content {\n    use lib::*;\n\n    use ser::{self, Serialize, Serializer};\n\n    pub struct SerializeTupleVariantAsMapValue<M> {\n        map: M,\n        name: &'static str,\n        fields: Vec<Content>,\n    }\n\n    impl<M> SerializeTupleVariantAsMapValue<M> {\n        pub fn new(map: M, name: &'static str, len: usize) -> Self {\n            SerializeTupleVariantAsMapValue {\n                map: map,\n                name: name,\n                fields: Vec::with_capacity(len),\n            }\n        }\n    }\n\n    impl<M> ser::SerializeTupleVariant for SerializeTupleVariantAsMapValue<M>\n    where\n        M: ser::SerializeMap,\n    {\n        type Ok = M::Ok;\n        type Error = M::Error;\n\n        fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), M::Error>\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::<M::Error>::new()));\n            self.fields.push(value);\n            Ok(())\n        }\n\n        fn end(mut self) -> Result<M::Ok, M::Error> {\n            try!(self\n                .map\n                .serialize_value(&Content::TupleStruct(self.name, self.fields)));\n            self.map.end()\n        }\n    }\n\n    pub struct SerializeStructVariantAsMapValue<M> {\n        map: M,\n        name: &'static str,\n        fields: Vec<(&'static str, Content)>,\n    }\n\n    impl<M> SerializeStructVariantAsMapValue<M> {\n        pub fn new(map: M, name: &'static str, len: usize) -> Self {\n            SerializeStructVariantAsMapValue {\n                map: map,\n                name: name,\n                fields: Vec::with_capacity(len),\n            }\n        }\n    }\n\n    impl<M> ser::SerializeStructVariant for SerializeStructVariantAsMapValue<M>\n    where\n        M: ser::SerializeMap,\n    {\n        type Ok = M::Ok;\n        type Error = M::Error;\n\n        fn serialize_field<T: ?Sized>(\n            &mut self,\n            key: &'static str,\n            value: &T,\n        ) -> Result<(), M::Error>\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::<M::Error>::new()));\n            self.fields.push((key, value));\n            Ok(())\n        }\n\n        fn end(mut self) -> Result<M::Ok, M::Error> {\n            try!(self\n                .map\n                .serialize_value(&Content::Struct(self.name, self.fields)));\n            self.map.end()\n        }\n    }\n\n    #[derive(Debug)]\n    pub enum Content {\n        Bool(bool),\n\n        U8(u8),\n        U16(u16),\n        U32(u32),\n        U64(u64),\n\n        I8(i8),\n        I16(i16),\n        I32(i32),\n        I64(i64),\n\n        F32(f32),\n        F64(f64),\n\n        Char(char),\n        String(String),\n        Bytes(Vec<u8>),\n\n        None,\n        Some(Box<Content>),\n\n        Unit,\n        UnitStruct(&'static str),\n        UnitVariant(&'static str, u32, &'static str),\n        NewtypeStruct(&'static str, Box<Content>),\n        NewtypeVariant(&'static str, u32, &'static str, Box<Content>),\n\n        Seq(Vec<Content>),\n        Tuple(Vec<Content>),\n        TupleStruct(&'static str, Vec<Content>),\n        TupleVariant(&'static str, u32, &'static str, Vec<Content>),\n        Map(Vec<(Content, Content)>),\n        Struct(&'static str, Vec<(&'static str, Content)>),\n        StructVariant(\n            &'static str,\n            u32,\n            &'static str,\n            Vec<(&'static str, Content)>,\n        ),\n    }\n\n    impl Serialize for Content {\n        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n        where\n            S: Serializer,\n        {\n            match *self {\n                Content::Bool(b) => serializer.serialize_bool(b),\n                Content::U8(u) => serializer.serialize_u8(u),\n                Content::U16(u) => serializer.serialize_u16(u),\n                Content::U32(u) => serializer.serialize_u32(u),\n                Content::U64(u) => serializer.serialize_u64(u),\n                Content::I8(i) => serializer.serialize_i8(i),\n                Content::I16(i) => serializer.serialize_i16(i),\n                Content::I32(i) => serializer.serialize_i32(i),\n                Content::I64(i) => serializer.serialize_i64(i),\n                Content::F32(f) => serializer.serialize_f32(f),\n                Content::F64(f) => serializer.serialize_f64(f),\n                Content::Char(c) => serializer.serialize_char(c),\n                Content::String(ref s) => serializer.serialize_str(s),\n                Content::Bytes(ref b) => serializer.serialize_bytes(b),\n                Content::None => serializer.serialize_none(),\n                Content::Some(ref c) => serializer.serialize_some(&**c),\n                Content::Unit => serializer.serialize_unit(),\n                Content::UnitStruct(n) => serializer.serialize_unit_struct(n),\n                Content::UnitVariant(n, i, v) => serializer.serialize_unit_variant(n, i, v),\n                Content::NewtypeStruct(n, ref c) => serializer.serialize_newtype_struct(n, &**c),\n                Content::NewtypeVariant(n, i, v, ref c) => {\n                    serializer.serialize_newtype_variant(n, i, v, &**c)\n                }\n                Content::Seq(ref elements) => elements.serialize(serializer),\n                Content::Tuple(ref elements) => {\n                    use ser::SerializeTuple;\n                    let mut tuple = try!(serializer.serialize_tuple(elements.len()));\n                    for e in elements {\n                        try!(tuple.serialize_element(e));\n                    }\n                    tuple.end()\n                }\n                Content::TupleStruct(n, ref fields) => {\n                    use ser::SerializeTupleStruct;\n                    let mut ts = try!(serializer.serialize_tuple_struct(n, fields.len()));\n                    for f in fields {\n                        try!(ts.serialize_field(f));\n                    }\n                    ts.end()\n                }\n                Content::TupleVariant(n, i, v, ref fields) => {\n                    use ser::SerializeTupleVariant;\n                    let mut tv = try!(serializer.serialize_tuple_variant(n, i, v, fields.len()));\n                    for f in fields {\n                        try!(tv.serialize_field(f));\n                    }\n                    tv.end()\n                }\n                Content::Map(ref entries) => {\n                    use ser::SerializeMap;\n                    let mut map = try!(serializer.serialize_map(Some(entries.len())));\n                    for &(ref k, ref v) in entries {\n                        try!(map.serialize_entry(k, v));\n                    }\n                    map.end()\n                }\n                Content::Struct(n, ref fields) => {\n                    use ser::SerializeStruct;\n                    let mut s = try!(serializer.serialize_struct(n, fields.len()));\n                    for &(k, ref v) in fields {\n                        try!(s.serialize_field(k, v));\n                    }\n                    s.end()\n                }\n                Content::StructVariant(n, i, v, ref fields) => {\n                    use ser::SerializeStructVariant;\n                    let mut sv = try!(serializer.serialize_struct_variant(n, i, v, fields.len()));\n                    for &(k, ref v) in fields {\n                        try!(sv.serialize_field(k, v));\n                    }\n                    sv.end()\n                }\n            }\n        }\n    }\n\n    pub struct ContentSerializer<E> {\n        error: PhantomData<E>,\n    }\n\n    impl<E> ContentSerializer<E> {\n        pub fn new() -> Self {\n            ContentSerializer { error: PhantomData }\n        }\n    }\n\n    impl<E> Serializer for ContentSerializer<E>\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        type SerializeSeq = SerializeSeq<E>;\n        type SerializeTuple = SerializeTuple<E>;\n        type SerializeTupleStruct = SerializeTupleStruct<E>;\n        type SerializeTupleVariant = SerializeTupleVariant<E>;\n        type SerializeMap = SerializeMap<E>;\n        type SerializeStruct = SerializeStruct<E>;\n        type SerializeStructVariant = SerializeStructVariant<E>;\n\n        fn serialize_bool(self, v: bool) -> Result<Content, E> {\n            Ok(Content::Bool(v))\n        }\n\n        fn serialize_i8(self, v: i8) -> Result<Content, E> {\n            Ok(Content::I8(v))\n        }\n\n        fn serialize_i16(self, v: i16) -> Result<Content, E> {\n            Ok(Content::I16(v))\n        }\n\n        fn serialize_i32(self, v: i32) -> Result<Content, E> {\n            Ok(Content::I32(v))\n        }\n\n        fn serialize_i64(self, v: i64) -> Result<Content, E> {\n            Ok(Content::I64(v))\n        }\n\n        fn serialize_u8(self, v: u8) -> Result<Content, E> {\n            Ok(Content::U8(v))\n        }\n\n        fn serialize_u16(self, v: u16) -> Result<Content, E> {\n            Ok(Content::U16(v))\n        }\n\n        fn serialize_u32(self, v: u32) -> Result<Content, E> {\n            Ok(Content::U32(v))\n        }\n\n        fn serialize_u64(self, v: u64) -> Result<Content, E> {\n            Ok(Content::U64(v))\n        }\n\n        fn serialize_f32(self, v: f32) -> Result<Content, E> {\n            Ok(Content::F32(v))\n        }\n\n        fn serialize_f64(self, v: f64) -> Result<Content, E> {\n            Ok(Content::F64(v))\n        }\n\n        fn serialize_char(self, v: char) -> Result<Content, E> {\n            Ok(Content::Char(v))\n        }\n\n        fn serialize_str(self, value: &str) -> Result<Content, E> {\n            Ok(Content::String(value.to_owned()))\n        }\n\n        fn serialize_bytes(self, value: &[u8]) -> Result<Content, E> {\n            Ok(Content::Bytes(value.to_owned()))\n        }\n\n        fn serialize_none(self) -> Result<Content, E> {\n            Ok(Content::None)\n        }\n\n        fn serialize_some<T: ?Sized>(self, value: &T) -> Result<Content, E>\n        where\n            T: Serialize,\n        {\n            Ok(Content::Some(Box::new(try!(value.serialize(self)))))\n        }\n\n        fn serialize_unit(self) -> Result<Content, E> {\n            Ok(Content::Unit)\n        }\n\n        fn serialize_unit_struct(self, name: &'static str) -> Result<Content, E> {\n            Ok(Content::UnitStruct(name))\n        }\n\n        fn serialize_unit_variant(\n            self,\n            name: &'static str,\n            variant_index: u32,\n            variant: &'static str,\n        ) -> Result<Content, E> {\n            Ok(Content::UnitVariant(name, variant_index, variant))\n        }\n\n        fn serialize_newtype_struct<T: ?Sized>(\n            self,\n            name: &'static str,\n            value: &T,\n        ) -> Result<Content, E>\n        where\n            T: Serialize,\n        {\n            Ok(Content::NewtypeStruct(\n                name,\n                Box::new(try!(value.serialize(self))),\n            ))\n        }\n\n        fn serialize_newtype_variant<T: ?Sized>(\n            self,\n            name: &'static str,\n            variant_index: u32,\n            variant: &'static str,\n            value: &T,\n        ) -> Result<Content, E>\n        where\n            T: Serialize,\n        {\n            Ok(Content::NewtypeVariant(\n                name,\n                variant_index,\n                variant,\n                Box::new(try!(value.serialize(self))),\n            ))\n        }\n\n        fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, E> {\n            Ok(SerializeSeq {\n                elements: Vec::with_capacity(len.unwrap_or(0)),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, E> {\n            Ok(SerializeTuple {\n                elements: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_tuple_struct(\n            self,\n            name: &'static str,\n            len: usize,\n        ) -> Result<Self::SerializeTupleStruct, E> {\n            Ok(SerializeTupleStruct {\n                name: name,\n                fields: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_tuple_variant(\n            self,\n            name: &'static str,\n            variant_index: u32,\n            variant: &'static str,\n            len: usize,\n        ) -> Result<Self::SerializeTupleVariant, E> {\n            Ok(SerializeTupleVariant {\n                name: name,\n                variant_index: variant_index,\n                variant: variant,\n                fields: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, E> {\n            Ok(SerializeMap {\n                entries: Vec::with_capacity(len.unwrap_or(0)),\n                key: None,\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_struct(\n            self,\n            name: &'static str,\n            len: usize,\n        ) -> Result<Self::SerializeStruct, E> {\n            Ok(SerializeStruct {\n                name: name,\n                fields: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_struct_variant(\n            self,\n            name: &'static str,\n            variant_index: u32,\n            variant: &'static str,\n            len: usize,\n        ) -> Result<Self::SerializeStructVariant, E> {\n            Ok(SerializeStructVariant {\n                name: name,\n                variant_index: variant_index,\n                variant: variant,\n                fields: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n    }\n\n    pub struct SerializeSeq<E> {\n        elements: Vec<Content>,\n        error: PhantomData<E>,\n    }\n\n    impl<E> ser::SerializeSeq for SerializeSeq<E>\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), E>\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::<E>::new()));\n            self.elements.push(value);\n            Ok(())\n        }\n\n        fn end(self) -> Result<Content, E> {\n            Ok(Content::Seq(self.elements))\n        }\n    }\n\n    pub struct SerializeTuple<E> {\n        elements: Vec<Content>,\n        error: PhantomData<E>,\n    }\n\n    impl<E> ser::SerializeTuple for SerializeTuple<E>\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), E>\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::<E>::new()));\n            self.elements.push(value);\n            Ok(())\n        }\n\n        fn end(self) -> Result<Content, E> {\n            Ok(Content::Tuple(self.elements))\n        }\n    }\n\n    pub struct SerializeTupleStruct<E> {\n        name: &'static str,\n        fields: Vec<Content>,\n        error: PhantomData<E>,\n    }\n\n    impl<E> ser::SerializeTupleStruct for SerializeTupleStruct<E>\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), E>\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::<E>::new()));\n            self.fields.push(value);\n            Ok(())\n        }\n\n        fn end(self) -> Result<Content, E> {\n            Ok(Content::TupleStruct(self.name, self.fields))\n        }\n    }\n\n    pub struct SerializeTupleVariant<E> {\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        fields: Vec<Content>,\n        error: PhantomData<E>,\n    }\n\n    impl<E> ser::SerializeTupleVariant for SerializeTupleVariant<E>\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), E>\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::<E>::new()));\n            self.fields.push(value);\n            Ok(())\n        }\n\n        fn end(self) -> Result<Content, E> {\n            Ok(Content::TupleVariant(\n                self.name,\n                self.variant_index,\n                self.variant,\n                self.fields,\n            ))\n        }\n    }\n\n    pub struct SerializeMap<E> {\n        entries: Vec<(Content, Content)>,\n        key: Option<Content>,\n        error: PhantomData<E>,\n    }\n\n    impl<E> ser::SerializeMap for SerializeMap<E>\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), E>\n        where\n            T: Serialize,\n        {\n            let key = try!(key.serialize(ContentSerializer::<E>::new()));\n            self.key = Some(key);\n            Ok(())\n        }\n\n        fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), E>\n        where\n            T: Serialize,\n        {\n            let key = self\n                .key\n                .take()\n                .expect(\"serialize_value called before serialize_key\");\n            let value = try!(value.serialize(ContentSerializer::<E>::new()));\n            self.entries.push((key, value));\n            Ok(())\n        }\n\n        fn end(self) -> Result<Content, E> {\n            Ok(Content::Map(self.entries))\n        }\n\n        fn serialize_entry<K: ?Sized, V: ?Sized>(&mut self, key: &K, value: &V) -> Result<(), E>\n        where\n            K: Serialize,\n            V: Serialize,\n        {\n            let key = try!(key.serialize(ContentSerializer::<E>::new()));\n            let value = try!(value.serialize(ContentSerializer::<E>::new()));\n            self.entries.push((key, value));\n            Ok(())\n        }\n    }\n\n    pub struct SerializeStruct<E> {\n        name: &'static str,\n        fields: Vec<(&'static str, Content)>,\n        error: PhantomData<E>,\n    }\n\n    impl<E> ser::SerializeStruct for SerializeStruct<E>\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_field<T: ?Sized>(&mut self, key: &'static str, value: &T) -> Result<(), E>\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::<E>::new()));\n            self.fields.push((key, value));\n            Ok(())\n        }\n\n        fn end(self) -> Result<Content, E> {\n            Ok(Content::Struct(self.name, self.fields))\n        }\n    }\n\n    pub struct SerializeStructVariant<E> {\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        fields: Vec<(&'static str, Content)>,\n        error: PhantomData<E>,\n    }\n\n    impl<E> ser::SerializeStructVariant for SerializeStructVariant<E>\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_field<T: ?Sized>(&mut self, key: &'static str, value: &T) -> Result<(), E>\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::<E>::new()));\n            self.fields.push((key, value));\n            Ok(())\n        }\n\n        fn end(self) -> Result<Content, E> {\n            Ok(Content::StructVariant(\n                self.name,\n                self.variant_index,\n                self.variant,\n                self.fields,\n            ))\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapSerializer<'a, M: 'a>(pub &'a mut M);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, M> FlatMapSerializer<'a, M>\nwhere\n    M: SerializeMap + 'a,\n{\n    fn bad_type(self, what: Unsupported) -> M::Error {\n        ser::Error::custom(format_args!(\n            \"can only flatten structs and maps (got {})\",\n            what\n        ))\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, M> Serializer for FlatMapSerializer<'a, M>\nwhere\n    M: SerializeMap + 'a,\n{\n    type Ok = ();\n    type Error = M::Error;\n\n    type SerializeSeq = Impossible<Self::Ok, M::Error>;\n    type SerializeTuple = Impossible<Self::Ok, M::Error>;\n    type SerializeTupleStruct = Impossible<Self::Ok, M::Error>;\n    type SerializeMap = FlatMapSerializeMap<'a, M>;\n    type SerializeStruct = FlatMapSerializeStruct<'a, M>;\n    type SerializeTupleVariant = Impossible<Self::Ok, M::Error>;\n    type SerializeStructVariant = FlatMapSerializeStructVariantAsMapValue<'a, M>;\n\n    fn serialize_bool(self, _: bool) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Boolean))\n    }\n\n    fn serialize_i8(self, _: i8) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i16(self, _: i16) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i32(self, _: i32) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i64(self, _: i64) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u8(self, _: u8) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u16(self, _: u16) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u32(self, _: u32) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u64(self, _: u64) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_f32(self, _: f32) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Float))\n    }\n\n    fn serialize_f64(self, _: f64) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Float))\n    }\n\n    fn serialize_char(self, _: char) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Char))\n    }\n\n    fn serialize_str(self, _: &str) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::String))\n    }\n\n    fn serialize_bytes(self, _: &[u8]) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::ByteArray))\n    }\n\n    fn serialize_none(self) -> Result<Self::Ok, Self::Error> {\n        Ok(())\n    }\n\n    fn serialize_some<T: ?Sized>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Unit))\n    }\n\n    fn serialize_unit_struct(self, _: &'static str) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::UnitStruct))\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        _: &'static str,\n    ) -> Result<Self::Ok, Self::Error> {\n        Err(self.bad_type(Unsupported::Enum))\n    }\n\n    fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        _: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        _: &'static str,\n        _: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: Serialize,\n    {\n        try!(self.0.serialize_key(variant));\n        self.0.serialize_value(value)\n    }\n\n    fn serialize_seq(self, _: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {\n        Err(self.bad_type(Unsupported::Sequence))\n    }\n\n    fn serialize_tuple(self, _: usize) -> Result<Self::SerializeTuple, Self::Error> {\n        Err(self.bad_type(Unsupported::Tuple))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error> {\n        Err(self.bad_type(Unsupported::TupleStruct))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        _: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        Err(self.bad_type(Unsupported::Enum))\n    }\n\n    fn serialize_map(self, _: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {\n        Ok(FlatMapSerializeMap(self.0))\n    }\n\n    fn serialize_struct(\n        self,\n        _: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error> {\n        Ok(FlatMapSerializeStruct(self.0))\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _: &'static str,\n        _: u32,\n        inner_variant: &'static str,\n        _: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        try!(self.0.serialize_key(inner_variant));\n        Ok(FlatMapSerializeStructVariantAsMapValue::new(\n            self.0,\n            inner_variant,\n        ))\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapSerializeMap<'a, M: 'a>(&'a mut M);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, M> ser::SerializeMap for FlatMapSerializeMap<'a, M>\nwhere\n    M: SerializeMap + 'a,\n{\n    type Ok = ();\n    type Error = M::Error;\n\n    fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        self.0.serialize_key(key)\n    }\n\n    fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        self.0.serialize_value(value)\n    }\n\n    fn end(self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapSerializeStruct<'a, M: 'a>(&'a mut M);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, M> ser::SerializeStruct for FlatMapSerializeStruct<'a, M>\nwhere\n    M: SerializeMap + 'a,\n{\n    type Ok = ();\n    type Error = M::Error;\n\n    fn serialize_field<T: ?Sized>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        self.0.serialize_entry(key, value)\n    }\n\n    fn end(self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapSerializeStructVariantAsMapValue<'a, M: 'a> {\n    map: &'a mut M,\n    name: &'static str,\n    fields: Vec<(&'static str, Content)>,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, M> FlatMapSerializeStructVariantAsMapValue<'a, M>\nwhere\n    M: SerializeMap + 'a,\n{\n    fn new(map: &'a mut M, name: &'static str) -> FlatMapSerializeStructVariantAsMapValue<'a, M> {\n        FlatMapSerializeStructVariantAsMapValue {\n            map: map,\n            name: name,\n            fields: Vec::new(),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, M> ser::SerializeStructVariant for FlatMapSerializeStructVariantAsMapValue<'a, M>\nwhere\n    M: SerializeMap + 'a,\n{\n    type Ok = ();\n    type Error = M::Error;\n\n    fn serialize_field<T: ?Sized>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        let value = try!(value.serialize(ContentSerializer::<M::Error>::new()));\n        self.fields.push((key, value));\n        Ok(())\n    }\n\n    fn end(self) -> Result<(), Self::Error> {\n        try!(self\n            .map\n            .serialize_value(&Content::Struct(self.name, self.fields)));\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","ser","impls.rs"],"content":"use lib::*;\n\nuse ser::{Error, Serialize, SerializeTuple, Serializer};\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! primitive_impl {\n    ($ty:ident, $method:ident $($cast:tt)*) => {\n        impl Serialize for $ty {\n            #[inline]\n            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n            where\n                S: Serializer,\n            {\n                serializer.$method(*self $($cast)*)\n            }\n        }\n    }\n}\n\nprimitive_impl!(bool, serialize_bool);\nprimitive_impl!(isize, serialize_i64 as i64);\nprimitive_impl!(i8, serialize_i8);\nprimitive_impl!(i16, serialize_i16);\nprimitive_impl!(i32, serialize_i32);\nprimitive_impl!(i64, serialize_i64);\nprimitive_impl!(usize, serialize_u64 as u64);\nprimitive_impl!(u8, serialize_u8);\nprimitive_impl!(u16, serialize_u16);\nprimitive_impl!(u32, serialize_u32);\nprimitive_impl!(u64, serialize_u64);\nprimitive_impl!(f32, serialize_f32);\nprimitive_impl!(f64, serialize_f64);\nprimitive_impl!(char, serialize_char);\n\nserde_if_integer128! {\n    primitive_impl!(i128, serialize_i128);\n    primitive_impl!(u128, serialize_u128);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Serialize for str {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.serialize_str(self)\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl Serialize for String {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.serialize_str(self)\n    }\n}\n\nimpl<'a> Serialize for fmt::Arguments<'a> {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.collect_str(self)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl Serialize for CStr {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.serialize_bytes(self.to_bytes())\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for CString {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.serialize_bytes(self.to_bytes())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match *self {\n            Some(ref value) => serializer.serialize_some(value),\n            None => serializer.serialize_none(),\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<T: ?Sized> Serialize for PhantomData<T> {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.serialize_unit_struct(\"PhantomData\")\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Does not require T: Serialize.\nimpl<T> Serialize for [T; 0] {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        try!(serializer.serialize_tuple(0)).end()\n    }\n}\n\nmacro_rules! array_impls {\n    ($($len:tt)+) => {\n        $(\n            impl<T> Serialize for [T; $len]\n            where\n                T: Serialize,\n            {\n                #[inline]\n                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n                where\n                    S: Serializer,\n                {\n                    let mut seq = try!(serializer.serialize_tuple($len));\n                    for e in self {\n                        try!(seq.serialize_element(e));\n                    }\n                    seq.end()\n                }\n            }\n        )+\n    }\n}\n\narray_impls! {\n    01 02 03 04 05 06 07 08 09 10\n    11 12 13 14 15 16 17 18 19 20\n    21 22 23 24 25 26 27 28 29 30\n    31 32\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Serialize for [T]\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.collect_seq(self)\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! seq_impl {\n    ($ty:ident < T $(: $tbound1:ident $(+ $tbound2:ident)*)* $(, $typaram:ident : $bound:ident)* >) => {\n        impl<T $(, $typaram)*> Serialize for $ty<T $(, $typaram)*>\n        where\n            T: Serialize $(+ $tbound1 $(+ $tbound2)*)*,\n            $($typaram: $bound,)*\n        {\n            #[inline]\n            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n            where\n                S: Serializer,\n            {\n                serializer.collect_seq(self)\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(BinaryHeap<T: Ord>);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(BTreeSet<T: Ord>);\n\n#[cfg(feature = \"std\")]\nseq_impl!(HashSet<T: Eq + Hash, H: BuildHasher>);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(LinkedList<T>);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(Vec<T>);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(VecDeque<T>);\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<Idx> Serialize for Range<Idx>\nwhere\n    Idx: Serialize,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use super::SerializeStruct;\n        let mut state = try!(serializer.serialize_struct(\"Range\", 2));\n        try!(state.serialize_field(\"start\", &self.start));\n        try!(state.serialize_field(\"end\", &self.end));\n        state.end()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(range_inclusive)]\nimpl<Idx> Serialize for RangeInclusive<Idx>\nwhere\n    Idx: Serialize,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use super::SerializeStruct;\n        let mut state = try!(serializer.serialize_struct(\"RangeInclusive\", 2));\n        try!(state.serialize_field(\"start\", &self.start()));\n        try!(state.serialize_field(\"end\", &self.end()));\n        state.end()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(ops_bound, collections_bound))]\nimpl<T> Serialize for Bound<T>\nwhere\n    T: Serialize,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match *self {\n            Bound::Unbounded => serializer.serialize_unit_variant(\"Bound\", 0, \"Unbounded\"),\n            Bound::Included(ref value) => {\n                serializer.serialize_newtype_variant(\"Bound\", 1, \"Included\", value)\n            }\n            Bound::Excluded(ref value) => {\n                serializer.serialize_newtype_variant(\"Bound\", 2, \"Excluded\", value)\n            }\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Serialize for () {\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        serializer.serialize_unit()\n    }\n}\n\n#[cfg(feature = \"unstable\")]\nimpl Serialize for ! {\n    fn serialize<S>(&self, _serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        *self\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! tuple_impls {\n    ($($len:expr => ($($n:tt $name:ident)+))+) => {\n        $(\n            impl<$($name),+> Serialize for ($($name,)+)\n            where\n                $($name: Serialize,)+\n            {\n                #[inline]\n                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n                where\n                    S: Serializer,\n                {\n                    let mut tuple = try!(serializer.serialize_tuple($len));\n                    $(\n                        try!(tuple.serialize_element(&self.$n));\n                    )+\n                    tuple.end()\n                }\n            }\n        )+\n    }\n}\n\ntuple_impls! {\n    1 => (0 T0)\n    2 => (0 T0 1 T1)\n    3 => (0 T0 1 T1 2 T2)\n    4 => (0 T0 1 T1 2 T2 3 T3)\n    5 => (0 T0 1 T1 2 T2 3 T3 4 T4)\n    6 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5)\n    7 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6)\n    8 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7)\n    9 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8)\n    10 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9)\n    11 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10)\n    12 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11)\n    13 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12)\n    14 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13)\n    15 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14)\n    16 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! map_impl {\n    ($ty:ident < K $(: $kbound1:ident $(+ $kbound2:ident)*)*, V $(, $typaram:ident : $bound:ident)* >) => {\n        impl<K, V $(, $typaram)*> Serialize for $ty<K, V $(, $typaram)*>\n        where\n            K: Serialize $(+ $kbound1 $(+ $kbound2)*)*,\n            V: Serialize,\n            $($typaram: $bound,)*\n        {\n            #[inline]\n            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n            where\n                S: Serializer,\n            {\n                serializer.collect_map(self)\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmap_impl!(BTreeMap<K: Ord, V>);\n\n#[cfg(feature = \"std\")]\nmap_impl!(HashMap<K: Eq + Hash, V, H: BuildHasher>);\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! deref_impl {\n    (\n        $(#[doc = $doc:tt])*\n        <$($desc:tt)+\n    ) => {\n        $(#[doc = $doc])*\n        impl <$($desc)+ {\n            #[inline]\n            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n            where\n                S: Serializer,\n            {\n                (**self).serialize(serializer)\n            }\n        }\n    };\n}\n\nderef_impl!(<'a, T: ?Sized> Serialize for &'a T where T: Serialize);\nderef_impl!(<'a, T: ?Sized> Serialize for &'a mut T where T: Serialize);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nderef_impl!(<T: ?Sized> Serialize for Box<T> where T: Serialize);\n\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nderef_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Serializing a data structure containing `Rc` will serialize a copy of\n    /// the contents of the `Rc` each time the `Rc` is referenced within the\n    /// data structure. Serialization will not attempt to deduplicate these\n    /// repeated data.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    <T: ?Sized> Serialize for Rc<T> where T: Serialize\n}\n\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nderef_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Serializing a data structure containing `Arc` will serialize a copy of\n    /// the contents of the `Arc` each time the `Arc` is referenced within the\n    /// data structure. Serialization will not attempt to deduplicate these\n    /// repeated data.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    <T: ?Sized> Serialize for Arc<T> where T: Serialize\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nderef_impl!(<'a, T: ?Sized> Serialize for Cow<'a, T> where T: Serialize + ToOwned);\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nimpl<T: ?Sized> Serialize for RcWeak<T>\nwhere\n    T: Serialize,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        self.upgrade().serialize(serializer)\n    }\n}\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nimpl<T: ?Sized> Serialize for ArcWeak<T>\nwhere\n    T: Serialize,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        self.upgrade().serialize(serializer)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! nonzero_integers {\n    ( $( $T: ident, )+ ) => {\n        $(\n            #[cfg(num_nonzero)]\n            impl Serialize for num::$T {\n                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n                where\n                    S: Serializer,\n                {\n                    self.get().serialize(serializer)\n                }\n            }\n        )+\n    }\n}\n\nnonzero_integers! {\n    NonZeroU8,\n    NonZeroU16,\n    NonZeroU32,\n    NonZeroU64,\n    NonZeroUsize,\n}\n\n#[cfg(num_nonzero_signed)]\nnonzero_integers! {\n    NonZeroI8,\n    NonZeroI16,\n    NonZeroI32,\n    NonZeroI64,\n    NonZeroIsize,\n}\n\n// Currently 128-bit integers do not work on Emscripten targets so we need an\n// additional `#[cfg]`\nserde_if_integer128! {\n    nonzero_integers! {\n        NonZeroU128,\n    }\n\n    #[cfg(num_nonzero_signed)]\n    nonzero_integers! {\n        NonZeroI128,\n    }\n}\n\nimpl<T> Serialize for Cell<T>\nwhere\n    T: Serialize + Copy,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        self.get().serialize(serializer)\n    }\n}\n\nimpl<T> Serialize for RefCell<T>\nwhere\n    T: Serialize,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match self.try_borrow() {\n            Ok(value) => value.serialize(serializer),\n            Err(_) => Err(S::Error::custom(\"already mutably borrowed\")),\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl<T> Serialize for Mutex<T>\nwhere\n    T: Serialize,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match self.lock() {\n            Ok(locked) => locked.serialize(serializer),\n            Err(_) => Err(S::Error::custom(\"lock poison error while serializing\")),\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl<T> Serialize for RwLock<T>\nwhere\n    T: Serialize,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match self.read() {\n            Ok(locked) => locked.serialize(serializer),\n            Err(_) => Err(S::Error::custom(\"lock poison error while serializing\")),\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<T, E> Serialize for Result<T, E>\nwhere\n    T: Serialize,\n    E: Serialize,\n{\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match *self {\n            Result::Ok(ref value) => serializer.serialize_newtype_variant(\"Result\", 0, \"Ok\", value),\n            Result::Err(ref value) => {\n                serializer.serialize_newtype_variant(\"Result\", 1, \"Err\", value)\n            }\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(core_duration, feature = \"std\"))]\nimpl Serialize for Duration {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use super::SerializeStruct;\n        let mut state = try!(serializer.serialize_struct(\"Duration\", 2));\n        try!(state.serialize_field(\"secs\", &self.as_secs()));\n        try!(state.serialize_field(\"nanos\", &self.subsec_nanos()));\n        state.end()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl Serialize for SystemTime {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use super::SerializeStruct;\n        let duration_since_epoch = self\n            .duration_since(UNIX_EPOCH)\n            .expect(\"SystemTime must be later than UNIX_EPOCH\");\n        let mut state = try!(serializer.serialize_struct(\"SystemTime\", 2));\n        try!(state.serialize_field(\"secs_since_epoch\", &duration_since_epoch.as_secs()));\n        try!(state.serialize_field(\"nanos_since_epoch\", &duration_since_epoch.subsec_nanos()));\n        state.end()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Serialize a value that implements `Display` as a string, when that string is\n/// statically known to never have more than a constant `MAX_LEN` bytes.\n///\n/// Panics if the `Display` impl tries to write more than `MAX_LEN` bytes.\n#[cfg(feature = \"std\")]\nmacro_rules! serialize_display_bounded_length {\n    ($value:expr, $max:expr, $serializer:expr) => {{\n        #[allow(deprecated)]\n        let mut buffer: [u8; $max] = unsafe { mem::uninitialized() };\n        let remaining_len = {\n            let mut remaining = &mut buffer[..];\n            write!(remaining, \"{}\", $value).unwrap();\n            remaining.len()\n        };\n        let written_len = buffer.len() - remaining_len;\n        let written = &buffer[..written_len];\n\n        // write! only provides fmt::Formatter to Display implementations, which\n        // has methods write_str and write_char but no method to write arbitrary\n        // bytes. Therefore `written` must be valid UTF-8.\n        let written_str = unsafe { str::from_utf8_unchecked(written) };\n        $serializer.serialize_str(written_str)\n    }};\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::IpAddr {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            match *self {\n                net::IpAddr::V4(ref a) => a.serialize(serializer),\n                net::IpAddr::V6(ref a) => a.serialize(serializer),\n            }\n        } else {\n            match *self {\n                net::IpAddr::V4(ref a) => {\n                    serializer.serialize_newtype_variant(\"IpAddr\", 0, \"V4\", a)\n                }\n                net::IpAddr::V6(ref a) => {\n                    serializer.serialize_newtype_variant(\"IpAddr\", 1, \"V6\", a)\n                }\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::Ipv4Addr {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            const MAX_LEN: usize = 15;\n            debug_assert_eq!(MAX_LEN, \"101.102.103.104\".len());\n            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n        } else {\n            self.octets().serialize(serializer)\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::Ipv6Addr {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            const MAX_LEN: usize = 39;\n            debug_assert_eq!(MAX_LEN, \"1001:1002:1003:1004:1005:1006:1007:1008\".len());\n            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n        } else {\n            self.octets().serialize(serializer)\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::SocketAddr {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            match *self {\n                net::SocketAddr::V4(ref addr) => addr.serialize(serializer),\n                net::SocketAddr::V6(ref addr) => addr.serialize(serializer),\n            }\n        } else {\n            match *self {\n                net::SocketAddr::V4(ref addr) => {\n                    serializer.serialize_newtype_variant(\"SocketAddr\", 0, \"V4\", addr)\n                }\n                net::SocketAddr::V6(ref addr) => {\n                    serializer.serialize_newtype_variant(\"SocketAddr\", 1, \"V6\", addr)\n                }\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::SocketAddrV4 {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            const MAX_LEN: usize = 21;\n            debug_assert_eq!(MAX_LEN, \"101.102.103.104:65000\".len());\n            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n        } else {\n            (self.ip(), self.port()).serialize(serializer)\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::SocketAddrV6 {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            const MAX_LEN: usize = 47;\n            debug_assert_eq!(\n                MAX_LEN,\n                \"[1001:1002:1003:1004:1005:1006:1007:1008]:65000\".len()\n            );\n            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n        } else {\n            (self.ip(), self.port()).serialize(serializer)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl Serialize for Path {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match self.to_str() {\n            Some(s) => s.serialize(serializer),\n            None => Err(Error::custom(\"path contains invalid UTF-8 characters\")),\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for PathBuf {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        self.as_path().serialize(serializer)\n    }\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl Serialize for OsStr {\n    #[cfg(unix)]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use std::os::unix::ffi::OsStrExt;\n        serializer.serialize_newtype_variant(\"OsString\", 0, \"Unix\", self.as_bytes())\n    }\n\n    #[cfg(windows)]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        use std::os::windows::ffi::OsStrExt;\n        let val = self.encode_wide().collect::<Vec<_>>();\n        serializer.serialize_newtype_variant(\"OsString\", 1, \"Windows\", &val)\n    }\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl Serialize for OsString {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        self.as_os_str().serialize(serializer)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl<T> Serialize for Wrapping<T>\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        self.0.serialize(serializer)\n    }\n}\n\n#[cfg(core_reverse)]\nimpl<T> Serialize for Reverse<T>\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        self.0.serialize(serializer)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(all(feature = \"std\", std_atomic))]\nmacro_rules! atomic_impl {\n    ($($ty:ident)*) => {\n        $(\n            impl Serialize for $ty {\n                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n                where\n                    S: Serializer,\n                {\n                    self.load(Ordering::SeqCst).serialize(serializer)\n                }\n            }\n        )*\n    }\n}\n\n#[cfg(all(feature = \"std\", std_atomic))]\natomic_impl! {\n    AtomicBool\n    AtomicI8 AtomicI16 AtomicI32 AtomicIsize\n    AtomicU8 AtomicU16 AtomicU32 AtomicUsize\n}\n\n#[cfg(all(feature = \"std\", std_atomic64))]\natomic_impl! {\n    AtomicI64 AtomicU64\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","ser","impossible.rs"],"content":"//! This module contains `Impossible` serializer and its implementations.\n\nuse lib::*;\n\nuse ser::{\n    self, Serialize, SerializeMap, SerializeSeq, SerializeStruct, SerializeStructVariant,\n    SerializeTuple, SerializeTupleStruct, SerializeTupleVariant,\n};\n\n/// Helper type for implementing a `Serializer` that does not support\n/// serializing one of the compound types.\n///\n/// This type cannot be instantiated, but implements every one of the traits\n/// corresponding to the [`Serializer`] compound types: [`SerializeSeq`],\n/// [`SerializeTuple`], [`SerializeTupleStruct`], [`SerializeTupleVariant`],\n/// [`SerializeMap`], [`SerializeStruct`], and [`SerializeStructVariant`].\n///\n/// ```edition2018\n/// # use serde::ser::{Serializer, Impossible};\n/// # use serde::private::ser::Error;\n/// #\n/// # struct MySerializer;\n/// #\n/// impl Serializer for MySerializer {\n///     type Ok = ();\n///     type Error = Error;\n///\n///     type SerializeSeq = Impossible<(), Error>;\n///     /* other associated types */\n///\n///     /// This data format does not support serializing sequences.\n///     fn serialize_seq(self,\n///                      len: Option<usize>)\n///                      -> Result<Self::SerializeSeq, Error> {\n///         // Given Impossible cannot be instantiated, the only\n///         // thing we can do here is to return an error.\n/// #         stringify! {\n///         Err(...)\n/// #         };\n/// #         unimplemented!()\n///     }\n///\n///     /* other Serializer methods */\n/// #     serde::__serialize_unimplemented! {\n/// #         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str bytes none some\n/// #         unit unit_struct unit_variant newtype_struct newtype_variant\n/// #         tuple tuple_struct tuple_variant map struct struct_variant\n/// #     }\n/// }\n/// ```\n///\n/// [`Serializer`]: trait.Serializer.html\n/// [`SerializeSeq`]: trait.SerializeSeq.html\n/// [`SerializeTuple`]: trait.SerializeTuple.html\n/// [`SerializeTupleStruct`]: trait.SerializeTupleStruct.html\n/// [`SerializeTupleVariant`]: trait.SerializeTupleVariant.html\n/// [`SerializeMap`]: trait.SerializeMap.html\n/// [`SerializeStruct`]: trait.SerializeStruct.html\n/// [`SerializeStructVariant`]: trait.SerializeStructVariant.html\npub struct Impossible<Ok, Error> {\n    void: Void,\n    ok: PhantomData<Ok>,\n    error: PhantomData<Error>,\n}\n\nenum Void {}\n\nimpl<Ok, Error> SerializeSeq for Impossible<Ok, Error>\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -> Result<Ok, Error> {\n        match self.void {}\n    }\n}\n\nimpl<Ok, Error> SerializeTuple for Impossible<Ok, Error>\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -> Result<Ok, Error> {\n        match self.void {}\n    }\n}\n\nimpl<Ok, Error> SerializeTupleStruct for Impossible<Ok, Error>\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -> Result<Ok, Error> {\n        match self.void {}\n    }\n}\n\nimpl<Ok, Error> SerializeTupleVariant for Impossible<Ok, Error>\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -> Result<Ok, Error> {\n        match self.void {}\n    }\n}\n\nimpl<Ok, Error> SerializeMap for Impossible<Ok, Error>\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        let _ = key;\n        match self.void {}\n    }\n\n    fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -> Result<Ok, Error> {\n        match self.void {}\n    }\n}\n\nimpl<Ok, Error> SerializeStruct for Impossible<Ok, Error>\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, key: &'static str, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        let _ = key;\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -> Result<Ok, Error> {\n        match self.void {}\n    }\n}\n\nimpl<Ok, Error> SerializeStructVariant for Impossible<Ok, Error>\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, key: &'static str, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        let _ = key;\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -> Result<Ok, Error> {\n        match self.void {}\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","ser","mod.rs"],"content":"//! Generic data structure serialization framework.\n//!\n//! The two most important traits in this module are [`Serialize`] and\n//! [`Serializer`].\n//!\n//!  - **A type that implements `Serialize` is a data structure** that can be\n//!    serialized to any data format supported by Serde, and conversely\n//!  - **A type that implements `Serializer` is a data format** that can\n//!    serialize any data structure supported by Serde.\n//!\n//! # The Serialize trait\n//!\n//! Serde provides [`Serialize`] implementations for many Rust primitive and\n//! standard library types. The complete list is below. All of these can be\n//! serialized using Serde out of the box.\n//!\n//! Additionally, Serde provides a procedural macro called [`serde_derive`] to\n//! automatically generate [`Serialize`] implementations for structs and enums\n//! in your program. See the [derive section of the manual] for how to use this.\n//!\n//! In rare cases it may be necessary to implement [`Serialize`] manually for\n//! some type in your program. See the [Implementing `Serialize`] section of the\n//! manual for more about this.\n//!\n//! Third-party crates may provide [`Serialize`] implementations for types that\n//! they expose. For example the [`linked-hash-map`] crate provides a\n//! [`LinkedHashMap<K, V>`] type that is serializable by Serde because the crate\n//! provides an implementation of [`Serialize`] for it.\n//!\n//! # The Serializer trait\n//!\n//! [`Serializer`] implementations are provided by third-party crates, for\n//! example [`serde_json`], [`serde_yaml`] and [`bincode`].\n//!\n//! A partial list of well-maintained formats is given on the [Serde\n//! website][data formats].\n//!\n//! # Implementations of Serialize provided by Serde\n//!\n//!  - **Primitive types**:\n//!    - bool\n//!    - i8, i16, i32, i64, i128, isize\n//!    - u8, u16, u32, u64, u128, usize\n//!    - f32, f64\n//!    - char\n//!    - str\n//!    - &T and &mut T\n//!  - **Compound types**:\n//!    - \\[T\\]\n//!    - \\[T; 0\\] through \\[T; 32\\]\n//!    - tuples up to size 16\n//!  - **Common standard library types**:\n//!    - String\n//!    - Option\\<T\\>\n//!    - Result\\<T, E\\>\n//!    - PhantomData\\<T\\>\n//!  - **Wrapper types**:\n//!    - Box\\<T\\>\n//!    - Cow\\<'a, T\\>\n//!    - Cell\\<T\\>\n//!    - RefCell\\<T\\>\n//!    - Mutex\\<T\\>\n//!    - RwLock\\<T\\>\n//!    - Rc\\<T\\>&emsp;*(if* features = [\"rc\"] *is enabled)*\n//!    - Arc\\<T\\>&emsp;*(if* features = [\"rc\"] *is enabled)*\n//!  - **Collection types**:\n//!    - BTreeMap\\<K, V\\>\n//!    - BTreeSet\\<T\\>\n//!    - BinaryHeap\\<T\\>\n//!    - HashMap\\<K, V, H\\>\n//!    - HashSet\\<T, H\\>\n//!    - LinkedList\\<T\\>\n//!    - VecDeque\\<T\\>\n//!    - Vec\\<T\\>\n//!  - **FFI types**:\n//!    - CStr\n//!    - CString\n//!    - OsStr\n//!    - OsString\n//!  - **Miscellaneous standard library types**:\n//!    - Duration\n//!    - SystemTime\n//!    - Path\n//!    - PathBuf\n//!    - Range\\<T\\>\n//!    - RangeInclusive\\<T\\>\n//!    - Bound\\<T\\>\n//!    - num::NonZero*\n//!    - `!` *(unstable)*\n//!  - **Net types**:\n//!    - IpAddr\n//!    - Ipv4Addr\n//!    - Ipv6Addr\n//!    - SocketAddr\n//!    - SocketAddrV4\n//!    - SocketAddrV6\n//!\n//! [Implementing `Serialize`]: https://serde.rs/impl-serialize.html\n//! [`LinkedHashMap<K, V>`]: https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html\n//! [`Serialize`]: ../trait.Serialize.html\n//! [`Serializer`]: ../trait.Serializer.html\n//! [`bincode`]: https://github.com/TyOverby/bincode\n//! [`linked-hash-map`]: https://crates.io/crates/linked-hash-map\n//! [`serde_derive`]: https://crates.io/crates/serde_derive\n//! [`serde_json`]: https://github.com/serde-rs/json\n//! [`serde_yaml`]: https://github.com/dtolnay/serde-yaml\n//! [derive section of the manual]: https://serde.rs/derive.html\n//! [data formats]: https://serde.rs/#data-formats\n\nuse lib::*;\n\nmod impls;\nmod impossible;\n\npub use self::impossible::Impossible;\n\n#[cfg(feature = \"std\")]\n#[doc(no_inline)]\npub use std::error::Error as StdError;\n#[cfg(not(feature = \"std\"))]\n#[doc(no_inline)]\npub use std_error::Error as StdError;\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! declare_error_trait {\n    (Error: Sized $(+ $($supertrait:ident)::+)*) => {\n        /// Trait used by `Serialize` implementations to generically construct\n        /// errors belonging to the `Serializer` against which they are\n        /// currently running.\n        ///\n        /// # Example implementation\n        ///\n        /// The [example data format] presented on the website shows an error\n        /// type appropriate for a basic JSON data format.\n        ///\n        /// [example data format]: https://serde.rs/data-format.html\n        pub trait Error: Sized $(+ $($supertrait)::+)* {\n            /// Used when a [`Serialize`] implementation encounters any error\n            /// while serializing a type.\n            ///\n            /// The message should not be capitalized and should not end with a\n            /// period.\n            ///\n            /// For example, a filesystem [`Path`] may refuse to serialize\n            /// itself if it contains invalid UTF-8 data.\n            ///\n            /// ```edition2018\n            /// # struct Path;\n            /// #\n            /// # impl Path {\n            /// #     fn to_str(&self) -> Option<&str> {\n            /// #         unimplemented!()\n            /// #     }\n            /// # }\n            /// #\n            /// use serde::ser::{self, Serialize, Serializer};\n            ///\n            /// impl Serialize for Path {\n            ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n            ///     where\n            ///         S: Serializer,\n            ///     {\n            ///         match self.to_str() {\n            ///             Some(s) => serializer.serialize_str(s),\n            ///             None => Err(ser::Error::custom(\"path contains invalid UTF-8 characters\")),\n            ///         }\n            ///     }\n            /// }\n            /// ```\n            ///\n            /// [`Path`]: https://doc.rust-lang.org/std/path/struct.Path.html\n            /// [`Serialize`]: ../trait.Serialize.html\n            fn custom<T>(msg: T) -> Self\n            where\n                T: Display;\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\ndeclare_error_trait!(Error: Sized + StdError);\n\n#[cfg(not(feature = \"std\"))]\ndeclare_error_trait!(Error: Sized + Debug + Display);\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A **data structure** that can be serialized into any data format supported\n/// by Serde.\n///\n/// Serde provides `Serialize` implementations for many Rust primitive and\n/// standard library types. The complete list is [here][ser]. All of these can\n/// be serialized using Serde out of the box.\n///\n/// Additionally, Serde provides a procedural macro called [`serde_derive`] to\n/// automatically generate `Serialize` implementations for structs and enums in\n/// your program. See the [derive section of the manual] for how to use this.\n///\n/// In rare cases it may be necessary to implement `Serialize` manually for some\n/// type in your program. See the [Implementing `Serialize`] section of the\n/// manual for more about this.\n///\n/// Third-party crates may provide `Serialize` implementations for types that\n/// they expose. For example the [`linked-hash-map`] crate provides a\n/// [`LinkedHashMap<K, V>`] type that is serializable by Serde because the crate\n/// provides an implementation of `Serialize` for it.\n///\n/// [Implementing `Serialize`]: https://serde.rs/impl-serialize.html\n/// [`LinkedHashMap<K, V>`]: https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html\n/// [`linked-hash-map`]: https://crates.io/crates/linked-hash-map\n/// [`serde_derive`]: https://crates.io/crates/serde_derive\n/// [derive section of the manual]: https://serde.rs/derive.html\n/// [ser]: https://docs.serde.rs/serde/ser/index.html\npub trait Serialize {\n    /// Serialize this value into the given Serde serializer.\n    ///\n    /// See the [Implementing `Serialize`] section of the manual for more\n    /// information about how to implement this method.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeStruct, Serializer};\n    ///\n    /// struct Person {\n    ///     name: String,\n    ///     age: u8,\n    ///     phones: Vec<String>,\n    /// }\n    ///\n    /// // This is what #[derive(Serialize)] would generate.\n    /// impl Serialize for Person {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut s = serializer.serialize_struct(\"Person\", 3)?;\n    ///         s.serialize_field(\"name\", &self.name)?;\n    ///         s.serialize_field(\"age\", &self.age)?;\n    ///         s.serialize_field(\"phones\", &self.phones)?;\n    ///         s.end()\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [Implementing `Serialize`]: https://serde.rs/impl-serialize.html\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A **data format** that can serialize any data structure supported by Serde.\n///\n/// The role of this trait is to define the serialization half of the [Serde\n/// data model], which is a way to categorize every Rust data structure into one\n/// of 29 possible types. Each method of the `Serializer` trait corresponds to\n/// one of the types of the data model.\n///\n/// Implementations of `Serialize` map themselves into this data model by\n/// invoking exactly one of the `Serializer` methods.\n///\n/// The types that make up the Serde data model are:\n///\n///  - **14 primitive types**\n///    - bool\n///    - i8, i16, i32, i64, i128\n///    - u8, u16, u32, u64, u128\n///    - f32, f64\n///    - char\n///  - **string**\n///    - UTF-8 bytes with a length and no null terminator.\n///    - When serializing, all strings are handled equally. When deserializing,\n///      there are three flavors of strings: transient, owned, and borrowed.\n///  - **byte array** - \\[u8\\]\n///    - Similar to strings, during deserialization byte arrays can be\n///      transient, owned, or borrowed.\n///  - **option**\n///    - Either none or some value.\n///  - **unit**\n///    - The type of `()` in Rust. It represents an anonymous value containing\n///      no data.\n///  - **unit_struct**\n///    - For example `struct Unit` or `PhantomData<T>`. It represents a named\n///      value containing no data.\n///  - **unit_variant**\n///    - For example the `E::A` and `E::B` in `enum E { A, B }`.\n///  - **newtype_struct**\n///    - For example `struct Millimeters(u8)`.\n///  - **newtype_variant**\n///    - For example the `E::N` in `enum E { N(u8) }`.\n///  - **seq**\n///    - A variably sized heterogeneous sequence of values, for example\n///      `Vec<T>` or `HashSet<T>`. When serializing, the length may or may not\n///      be known before iterating through all the data. When deserializing,\n///      the length is determined by looking at the serialized data.\n///  - **tuple**\n///    - A statically sized heterogeneous sequence of values for which the\n///      length will be known at deserialization time without looking at the\n///      serialized data, for example `(u8,)` or `(String, u64, Vec<T>)` or\n///      `[u64; 10]`.\n///  - **tuple_struct**\n///    - A named tuple, for example `struct Rgb(u8, u8, u8)`.\n///  - **tuple_variant**\n///    - For example the `E::T` in `enum E { T(u8, u8) }`.\n///  - **map**\n///    - A heterogeneous key-value pairing, for example `BTreeMap<K, V>`.\n///  - **struct**\n///    - A heterogeneous key-value pairing in which the keys are strings and\n///      will be known at deserialization time without looking at the\n///      serialized data, for example `struct S { r: u8, g: u8, b: u8 }`.\n///  - **struct_variant**\n///    - For example the `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`.\n///\n/// Many Serde serializers produce text or binary data as output, for example\n/// JSON or Bincode. This is not a requirement of the `Serializer` trait, and\n/// there are serializers that do not produce text or binary output. One example\n/// is the `serde_json::value::Serializer` (distinct from the main `serde_json`\n/// serializer) that produces a `serde_json::Value` data structure in memory as\n/// output.\n///\n/// [Serde data model]: https://serde.rs/data-model.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website contains example code for\n/// a basic JSON `Serializer`.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait Serializer: Sized {\n    /// The output type produced by this `Serializer` during successful\n    /// serialization. Most serializers that produce text or binary output\n    /// should set `Ok = ()` and serialize into an [`io::Write`] or buffer\n    /// contained within the `Serializer` instance. Serializers that build\n    /// in-memory data structures may be simplified by using `Ok` to propagate\n    /// the data structure around.\n    ///\n    /// [`io::Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n    type Ok;\n\n    /// The error type when some error occurs during serialization.\n    type Error: Error;\n\n    /// Type returned from [`serialize_seq`] for serializing the content of the\n    /// sequence.\n    ///\n    /// [`serialize_seq`]: #tymethod.serialize_seq\n    type SerializeSeq: SerializeSeq<Ok = Self::Ok, Error = Self::Error>;\n\n    /// Type returned from [`serialize_tuple`] for serializing the content of\n    /// the tuple.\n    ///\n    /// [`serialize_tuple`]: #tymethod.serialize_tuple\n    type SerializeTuple: SerializeTuple<Ok = Self::Ok, Error = Self::Error>;\n\n    /// Type returned from [`serialize_tuple_struct`] for serializing the\n    /// content of the tuple struct.\n    ///\n    /// [`serialize_tuple_struct`]: #tymethod.serialize_tuple_struct\n    type SerializeTupleStruct: SerializeTupleStruct<Ok = Self::Ok, Error = Self::Error>;\n\n    /// Type returned from [`serialize_tuple_variant`] for serializing the\n    /// content of the tuple variant.\n    ///\n    /// [`serialize_tuple_variant`]: #tymethod.serialize_tuple_variant\n    type SerializeTupleVariant: SerializeTupleVariant<Ok = Self::Ok, Error = Self::Error>;\n\n    /// Type returned from [`serialize_map`] for serializing the content of the\n    /// map.\n    ///\n    /// [`serialize_map`]: #tymethod.serialize_map\n    type SerializeMap: SerializeMap<Ok = Self::Ok, Error = Self::Error>;\n\n    /// Type returned from [`serialize_struct`] for serializing the content of\n    /// the struct.\n    ///\n    /// [`serialize_struct`]: #tymethod.serialize_struct\n    type SerializeStruct: SerializeStruct<Ok = Self::Ok, Error = Self::Error>;\n\n    /// Type returned from [`serialize_struct_variant`] for serializing the\n    /// content of the struct variant.\n    ///\n    /// [`serialize_struct_variant`]: #tymethod.serialize_struct_variant\n    type SerializeStructVariant: SerializeStructVariant<Ok = Self::Ok, Error = Self::Error>;\n\n    /// Serialize a `bool` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for bool {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_bool(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize an `i8` value.\n    ///\n    /// If the format does not differentiate between `i8` and `i64`, a\n    /// reasonable implementation would be to cast the value to `i64` and\n    /// forward to `serialize_i64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for i8 {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_i8(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize an `i16` value.\n    ///\n    /// If the format does not differentiate between `i16` and `i64`, a\n    /// reasonable implementation would be to cast the value to `i64` and\n    /// forward to `serialize_i64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for i16 {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_i16(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize an `i32` value.\n    ///\n    /// If the format does not differentiate between `i32` and `i64`, a\n    /// reasonable implementation would be to cast the value to `i64` and\n    /// forward to `serialize_i64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for i32 {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_i32(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize an `i64` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for i64 {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_i64(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error>;\n\n    serde_if_integer128! {\n        /// Serialize an `i128` value.\n        ///\n        /// ```edition2018\n        /// # use serde::Serializer;\n        /// #\n        /// # serde::__private_serialize!();\n        /// #\n        /// impl Serialize for i128 {\n        ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n        ///     where\n        ///         S: Serializer,\n        ///     {\n        ///         serializer.serialize_i128(*self)\n        ///     }\n        /// }\n        /// ```\n        ///\n        /// This method is available only on Rust compiler versions >=1.26. The\n        /// default behavior unconditionally returns an error.\n        fn serialize_i128(self, v: i128) -> Result<Self::Ok, Self::Error> {\n            let _ = v;\n            Err(Error::custom(\"i128 is not supported\"))\n        }\n    }\n\n    /// Serialize a `u8` value.\n    ///\n    /// If the format does not differentiate between `u8` and `u64`, a\n    /// reasonable implementation would be to cast the value to `u64` and\n    /// forward to `serialize_u64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for u8 {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_u8(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize a `u16` value.\n    ///\n    /// If the format does not differentiate between `u16` and `u64`, a\n    /// reasonable implementation would be to cast the value to `u64` and\n    /// forward to `serialize_u64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for u16 {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_u16(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize a `u32` value.\n    ///\n    /// If the format does not differentiate between `u32` and `u64`, a\n    /// reasonable implementation would be to cast the value to `u64` and\n    /// forward to `serialize_u64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for u32 {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_u32(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize a `u64` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for u64 {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_u64(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error>;\n\n    serde_if_integer128! {\n        /// Serialize a `u128` value.\n        ///\n        /// ```edition2018\n        /// # use serde::Serializer;\n        /// #\n        /// # serde::__private_serialize!();\n        /// #\n        /// impl Serialize for u128 {\n        ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n        ///     where\n        ///         S: Serializer,\n        ///     {\n        ///         serializer.serialize_u128(*self)\n        ///     }\n        /// }\n        /// ```\n        ///\n        /// This method is available only on Rust compiler versions >=1.26. The\n        /// default behavior unconditionally returns an error.\n        fn serialize_u128(self, v: u128) -> Result<Self::Ok, Self::Error> {\n            let _ = v;\n            Err(Error::custom(\"u128 is not supported\"))\n        }\n    }\n\n    /// Serialize an `f32` value.\n    ///\n    /// If the format does not differentiate between `f32` and `f64`, a\n    /// reasonable implementation would be to cast the value to `f64` and\n    /// forward to `serialize_f64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for f32 {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_f32(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize an `f64` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for f64 {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_f64(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize a character.\n    ///\n    /// If the format does not support characters, it is reasonable to serialize\n    /// it as a single element `str` or a `u32`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for char {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_char(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize a `&str`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for str {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_str(self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_str(self, v: &str) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize a chunk of raw byte data.\n    ///\n    /// Enables serializers to serialize byte slices more compactly or more\n    /// efficiently than other types of slices. If no efficient implementation\n    /// is available, a reasonable implementation would be to forward to\n    /// `serialize_seq`. If forwarded, the implementation looks usually just\n    /// like this:\n    ///\n    /// ```edition2018\n    /// # use serde::ser::{Serializer, SerializeSeq};\n    /// # use serde::private::ser::Error;\n    /// #\n    /// # struct MySerializer;\n    /// #\n    /// # impl Serializer for MySerializer {\n    /// #     type Ok = ();\n    /// #     type Error = Error;\n    /// #\n    /// fn serialize_bytes(self, v: &[u8]) -> Result<Self::Ok, Self::Error> {\n    ///     let mut seq = self.serialize_seq(Some(v.len()))?;\n    ///     for b in v {\n    ///         seq.serialize_element(b)?;\n    ///     }\n    ///     seq.end()\n    /// }\n    /// #\n    /// #     serde::__serialize_unimplemented! {\n    /// #         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str none some\n    /// #         unit unit_struct unit_variant newtype_struct newtype_variant\n    /// #         seq tuple tuple_struct tuple_variant map struct struct_variant\n    /// #     }\n    /// # }\n    /// ```\n    fn serialize_bytes(self, v: &[u8]) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize a [`None`] value.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Serializer};\n    /// #\n    /// # enum Option<T> {\n    /// #     Some(T),\n    /// #     None,\n    /// # }\n    /// #\n    /// # use self::Option::{Some, None};\n    /// #\n    /// impl<T> Serialize for Option<T>\n    /// where\n    ///     T: Serialize,\n    /// {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             Some(ref value) => serializer.serialize_some(value),\n    ///             None => serializer.serialize_none(),\n    ///         }\n    ///     }\n    /// }\n    /// #\n    /// # fn main() {}\n    /// ```\n    ///\n    /// [`None`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n    fn serialize_none(self) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize a [`Some(T)`] value.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Serializer};\n    /// #\n    /// # enum Option<T> {\n    /// #     Some(T),\n    /// #     None,\n    /// # }\n    /// #\n    /// # use self::Option::{Some, None};\n    /// #\n    /// impl<T> Serialize for Option<T>\n    /// where\n    ///     T: Serialize,\n    /// {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             Some(ref value) => serializer.serialize_some(value),\n    ///             None => serializer.serialize_none(),\n    ///         }\n    ///     }\n    /// }\n    /// #\n    /// # fn main() {}\n    /// ```\n    ///\n    /// [`Some(T)`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some\n    fn serialize_some<T: ?Sized>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: Serialize;\n\n    /// Serialize a `()` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for () {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_unit()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_unit(self) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize a unit struct like `struct Unit` or `PhantomData<T>`.\n    ///\n    /// A reasonable implementation would be to forward to `serialize_unit`.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// struct Nothing;\n    ///\n    /// impl Serialize for Nothing {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_unit_struct(\"Nothing\")\n    ///     }\n    /// }\n    /// ```\n    fn serialize_unit_struct(self, name: &'static str) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize a unit variant like `E::A` in `enum E { A, B }`.\n    ///\n    /// The `name` is the name of the enum, the `variant_index` is the index of\n    /// this variant within the enum, and the `variant` is the name of the\n    /// variant.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// enum E {\n    ///     A,\n    ///     B,\n    /// }\n    ///\n    /// impl Serialize for E {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             E::A => serializer.serialize_unit_variant(\"E\", 0, \"A\"),\n    ///             E::B => serializer.serialize_unit_variant(\"E\", 1, \"B\"),\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn serialize_unit_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error>;\n\n    /// Serialize a newtype struct like `struct Millimeters(u8)`.\n    ///\n    /// Serializers are encouraged to treat newtype structs as insignificant\n    /// wrappers around the data they contain. A reasonable implementation would\n    /// be to forward to `value.serialize(self)`.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// struct Millimeters(u8);\n    ///\n    /// impl Serialize for Millimeters {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_newtype_struct(\"Millimeters\", &self.0)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_newtype_struct<T: ?Sized>(\n        self,\n        name: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: Serialize;\n\n    /// Serialize a newtype variant like `E::N` in `enum E { N(u8) }`.\n    ///\n    /// The `name` is the name of the enum, the `variant_index` is the index of\n    /// this variant within the enum, and the `variant` is the name of the\n    /// variant. The `value` is the data contained within this newtype variant.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// enum E {\n    ///     M(String),\n    ///     N(u8),\n    /// }\n    ///\n    /// impl Serialize for E {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             E::M(ref s) => serializer.serialize_newtype_variant(\"E\", 0, \"M\", s),\n    ///             E::N(n) => serializer.serialize_newtype_variant(\"E\", 1, \"N\", &n),\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: Serialize;\n\n    /// Begin to serialize a variably sized sequence. This call must be\n    /// followed by zero or more calls to `serialize_element`, then a call to\n    /// `end`.\n    ///\n    /// The argument is the number of elements in the sequence, which may or may\n    /// not be computable before the sequence is iterated. Some serializers only\n    /// support sequences whose length is known up front.\n    ///\n    /// ```edition2018\n    /// # use std::marker::PhantomData;\n    /// #\n    /// # struct Vec<T>(PhantomData<T>);\n    /// #\n    /// # impl<T> Vec<T> {\n    /// #     fn len(&self) -> usize {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// # impl<'a, T> IntoIterator for &'a Vec<T> {\n    /// #     type Item = &'a T;\n    /// #     type IntoIter = Box<Iterator<Item = &'a T>>;\n    /// #\n    /// #     fn into_iter(self) -> Self::IntoIter {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// use serde::ser::{Serialize, Serializer, SerializeSeq};\n    ///\n    /// impl<T> Serialize for Vec<T>\n    /// where\n    ///     T: Serialize,\n    /// {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut seq = serializer.serialize_seq(Some(self.len()))?;\n    ///         for element in self {\n    ///             seq.serialize_element(element)?;\n    ///         }\n    ///         seq.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error>;\n\n    /// Begin to serialize a statically sized sequence whose length will be\n    /// known at deserialization time without looking at the serialized data.\n    /// This call must be followed by zero or more calls to `serialize_element`,\n    /// then a call to `end`.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, Serializer, SerializeTuple};\n    ///\n    /// # mod fool {\n    /// #     trait Serialize {}\n    /// impl<A, B, C> Serialize for (A, B, C)\n    /// #     {}\n    /// # }\n    /// #\n    /// # struct Tuple3<A, B, C>(A, B, C);\n    /// #\n    /// # impl<A, B, C> Serialize for Tuple3<A, B, C>\n    /// where\n    ///     A: Serialize,\n    ///     B: Serialize,\n    ///     C: Serialize,\n    /// {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut tup = serializer.serialize_tuple(3)?;\n    ///         tup.serialize_element(&self.0)?;\n    ///         tup.serialize_element(&self.1)?;\n    ///         tup.serialize_element(&self.2)?;\n    ///         tup.end()\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeTuple, Serializer};\n    ///\n    /// const VRAM_SIZE: usize = 386;\n    /// struct Vram([u16; VRAM_SIZE]);\n    ///\n    /// impl Serialize for Vram {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut seq = serializer.serialize_tuple(VRAM_SIZE)?;\n    ///         for element in &self.0[..] {\n    ///             seq.serialize_element(element)?;\n    ///         }\n    ///         seq.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error>;\n\n    /// Begin to serialize a tuple struct like `struct Rgb(u8, u8, u8)`. This\n    /// call must be followed by zero or more calls to `serialize_field`, then a\n    /// call to `end`.\n    ///\n    /// The `name` is the name of the tuple struct and the `len` is the number\n    /// of data fields that will be serialized.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeTupleStruct, Serializer};\n    ///\n    /// struct Rgb(u8, u8, u8);\n    ///\n    /// impl Serialize for Rgb {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut ts = serializer.serialize_tuple_struct(\"Rgb\", 3)?;\n    ///         ts.serialize_field(&self.0)?;\n    ///         ts.serialize_field(&self.1)?;\n    ///         ts.serialize_field(&self.2)?;\n    ///         ts.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_tuple_struct(\n        self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error>;\n\n    /// Begin to serialize a tuple variant like `E::T` in `enum E { T(u8, u8)\n    /// }`. This call must be followed by zero or more calls to\n    /// `serialize_field`, then a call to `end`.\n    ///\n    /// The `name` is the name of the enum, the `variant_index` is the index of\n    /// this variant within the enum, the `variant` is the name of the variant,\n    /// and the `len` is the number of data fields that will be serialized.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeTupleVariant, Serializer};\n    ///\n    /// enum E {\n    ///     T(u8, u8),\n    ///     U(String, u32, u32),\n    /// }\n    ///\n    /// impl Serialize for E {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             E::T(ref a, ref b) => {\n    ///                 let mut tv = serializer.serialize_tuple_variant(\"E\", 0, \"T\", 2)?;\n    ///                 tv.serialize_field(a)?;\n    ///                 tv.serialize_field(b)?;\n    ///                 tv.end()\n    ///             }\n    ///             E::U(ref a, ref b, ref c) => {\n    ///                 let mut tv = serializer.serialize_tuple_variant(\"E\", 1, \"U\", 3)?;\n    ///                 tv.serialize_field(a)?;\n    ///                 tv.serialize_field(b)?;\n    ///                 tv.serialize_field(c)?;\n    ///                 tv.end()\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn serialize_tuple_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error>;\n\n    /// Begin to serialize a map. This call must be followed by zero or more\n    /// calls to `serialize_key` and `serialize_value`, then a call to `end`.\n    ///\n    /// The argument is the number of elements in the map, which may or may not\n    /// be computable before the map is iterated. Some serializers only support\n    /// maps whose length is known up front.\n    ///\n    /// ```edition2018\n    /// # use std::marker::PhantomData;\n    /// #\n    /// # struct HashMap<K, V>(PhantomData<K>, PhantomData<V>);\n    /// #\n    /// # impl<K, V> HashMap<K, V> {\n    /// #     fn len(&self) -> usize {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// # impl<'a, K, V> IntoIterator for &'a HashMap<K, V> {\n    /// #     type Item = (&'a K, &'a V);\n    /// #     type IntoIter = Box<Iterator<Item = (&'a K, &'a V)>>;\n    /// #\n    /// #     fn into_iter(self) -> Self::IntoIter {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// use serde::ser::{Serialize, Serializer, SerializeMap};\n    ///\n    /// impl<K, V> Serialize for HashMap<K, V>\n    /// where\n    ///     K: Serialize,\n    ///     V: Serialize,\n    /// {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut map = serializer.serialize_map(Some(self.len()))?;\n    ///         for (k, v) in self {\n    ///             map.serialize_entry(k, v)?;\n    ///         }\n    ///         map.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, Self::Error>;\n\n    /// Begin to serialize a struct like `struct Rgb { r: u8, g: u8, b: u8 }`.\n    /// This call must be followed by zero or more calls to `serialize_field`,\n    /// then a call to `end`.\n    ///\n    /// The `name` is the name of the struct and the `len` is the number of\n    /// data fields that will be serialized.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeStruct, Serializer};\n    ///\n    /// struct Rgb {\n    ///     r: u8,\n    ///     g: u8,\n    ///     b: u8,\n    /// }\n    ///\n    /// impl Serialize for Rgb {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut rgb = serializer.serialize_struct(\"Rgb\", 3)?;\n    ///         rgb.serialize_field(\"r\", &self.r)?;\n    ///         rgb.serialize_field(\"g\", &self.g)?;\n    ///         rgb.serialize_field(\"b\", &self.b)?;\n    ///         rgb.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_struct(\n        self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error>;\n\n    /// Begin to serialize a struct variant like `E::S` in `enum E { S { r: u8,\n    /// g: u8, b: u8 } }`. This call must be followed by zero or more calls to\n    /// `serialize_field`, then a call to `end`.\n    ///\n    /// The `name` is the name of the enum, the `variant_index` is the index of\n    /// this variant within the enum, the `variant` is the name of the variant,\n    /// and the `len` is the number of data fields that will be serialized.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeStructVariant, Serializer};\n    ///\n    /// enum E {\n    ///     S { r: u8, g: u8, b: u8 },\n    /// }\n    ///\n    /// impl Serialize for E {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             E::S {\n    ///                 ref r,\n    ///                 ref g,\n    ///                 ref b,\n    ///             } => {\n    ///                 let mut sv = serializer.serialize_struct_variant(\"E\", 0, \"S\", 3)?;\n    ///                 sv.serialize_field(\"r\", r)?;\n    ///                 sv.serialize_field(\"g\", g)?;\n    ///                 sv.serialize_field(\"b\", b)?;\n    ///                 sv.end()\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error>;\n\n    /// Collect an iterator as a sequence.\n    ///\n    /// The default implementation serializes each item yielded by the iterator\n    /// using [`serialize_seq`]. Implementors should not need to override this\n    /// method.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// struct SecretlyOneHigher {\n    ///     data: Vec<i32>,\n    /// }\n    ///\n    /// impl Serialize for SecretlyOneHigher {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.collect_seq(self.data.iter().map(|x| x + 1))\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`serialize_seq`]: #tymethod.serialize_seq\n    fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>\n    where\n        I: IntoIterator,\n        <I as IntoIterator>::Item: Serialize,\n    {\n        let iter = iter.into_iter();\n        let mut serializer = try!(self.serialize_seq(iter.len_hint()));\n        for item in iter {\n            try!(serializer.serialize_element(&item));\n        }\n        serializer.end()\n    }\n\n    /// Collect an iterator as a map.\n    ///\n    /// The default implementation serializes each pair yielded by the iterator\n    /// using [`serialize_map`]. Implementors should not need to override this\n    /// method.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    /// use std::collections::BTreeSet;\n    ///\n    /// struct MapToUnit {\n    ///     keys: BTreeSet<i32>,\n    /// }\n    ///\n    /// // Serializes as a map in which the values are all unit.\n    /// impl Serialize for MapToUnit {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.collect_map(self.keys.iter().map(|k| (k, ())))\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`serialize_map`]: #tymethod.serialize_map\n    fn collect_map<K, V, I>(self, iter: I) -> Result<Self::Ok, Self::Error>\n    where\n        K: Serialize,\n        V: Serialize,\n        I: IntoIterator<Item = (K, V)>,\n    {\n        let iter = iter.into_iter();\n        let mut serializer = try!(self.serialize_map(iter.len_hint()));\n        for (key, value) in iter {\n            try!(serializer.serialize_entry(&key, &value));\n        }\n        serializer.end()\n    }\n\n    /// Serialize a string produced by an implementation of `Display`.\n    ///\n    /// The default implementation builds a heap-allocated [`String`] and\n    /// delegates to [`serialize_str`]. Serializers are encouraged to provide a\n    /// more efficient implementation if possible.\n    ///\n    /// ```edition2018\n    /// # struct DateTime;\n    /// #\n    /// # impl DateTime {\n    /// #     fn naive_local(&self) -> () { () }\n    /// #     fn offset(&self) -> () { () }\n    /// # }\n    /// #\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// impl Serialize for DateTime {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.collect_str(&format_args!(\"{:?}{:?}\",\n    ///                                              self.naive_local(),\n    ///                                              self.offset()))\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`String`]: https://doc.rust-lang.org/std/string/struct.String.html\n    /// [`serialize_str`]: #tymethod.serialize_str\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn collect_str<T: ?Sized>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: Display,\n    {\n        use lib::fmt::Write;\n        let mut string = String::new();\n        write!(string, \"{}\", value).unwrap();\n        self.serialize_str(&string)\n    }\n\n    /// Serialize a string produced by an implementation of `Display`.\n    ///\n    /// Serializers that use `no_std` are required to provide an implementation\n    /// of this method. If no more sensible behavior is possible, the\n    /// implementation is expected to return an error.\n    ///\n    /// ```edition2018\n    /// # struct DateTime;\n    /// #\n    /// # impl DateTime {\n    /// #     fn naive_local(&self) -> () { () }\n    /// #     fn offset(&self) -> () { () }\n    /// # }\n    /// #\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// impl Serialize for DateTime {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.collect_str(&format_args!(\"{:?}{:?}\",\n    ///                                              self.naive_local(),\n    ///                                              self.offset()))\n    ///     }\n    /// }\n    /// ```\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn collect_str<T: ?Sized>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: Display;\n\n    /// Determine whether `Serialize` implementations should serialize in\n    /// human-readable form.\n    ///\n    /// Some types have a human-readable form that may be somewhat expensive to\n    /// construct, as well as a binary form that is compact and efficient.\n    /// Generally text-based formats like JSON and YAML will prefer to use the\n    /// human-readable one and binary formats like Bincode will prefer the\n    /// compact one.\n    ///\n    /// ```edition2018\n    /// # use std::fmt::{self, Display};\n    /// #\n    /// # struct Timestamp;\n    /// #\n    /// # impl Timestamp {\n    /// #     fn seconds_since_epoch(&self) -> u64 { unimplemented!() }\n    /// # }\n    /// #\n    /// # impl Display for Timestamp {\n    /// #     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// impl Serialize for Timestamp {\n    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         if serializer.is_human_readable() {\n    ///             // Serialize to a human-readable string \"2015-05-15T17:01:00Z\".\n    ///             self.to_string().serialize(serializer)\n    ///         } else {\n    ///             // Serialize to a compact binary representation.\n    ///             self.seconds_since_epoch().serialize(serializer)\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// The default implementation of this method returns `true`. Data formats\n    /// may override this to `false` to request a compact form for types that\n    /// support one. Note that modifying this method to change a format from\n    /// human-readable to compact or vice versa should be regarded as a breaking\n    /// change, as a value serialized in human-readable mode is not required to\n    /// deserialize from the same data in compact mode.\n    #[inline]\n    fn is_human_readable(&self) -> bool {\n        true\n    }\n}\n\n/// Returned from `Serializer::serialize_seq`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// # use std::marker::PhantomData;\n/// #\n/// # struct Vec<T>(PhantomData<T>);\n/// #\n/// # impl<T> Vec<T> {\n/// #     fn len(&self) -> usize {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// # impl<'a, T> IntoIterator for &'a Vec<T> {\n/// #     type Item = &'a T;\n/// #     type IntoIter = Box<Iterator<Item = &'a T>>;\n/// #     fn into_iter(self) -> Self::IntoIter {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// use serde::ser::{Serialize, Serializer, SerializeSeq};\n///\n/// impl<T> Serialize for Vec<T>\n/// where\n///     T: Serialize,\n/// {\n///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n///     where\n///         S: Serializer,\n///     {\n///         let mut seq = serializer.serialize_seq(Some(self.len()))?;\n///         for element in self {\n///             seq.serialize_element(element)?;\n///         }\n///         seq.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeSeq` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeSeq {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a sequence element.\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize;\n\n    /// Finish serializing a sequence.\n    fn end(self) -> Result<Self::Ok, Self::Error>;\n}\n\n/// Returned from `Serializer::serialize_tuple`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, Serializer, SerializeTuple};\n///\n/// # mod fool {\n/// #     trait Serialize {}\n/// impl<A, B, C> Serialize for (A, B, C)\n/// #     {}\n/// # }\n/// #\n/// # struct Tuple3<A, B, C>(A, B, C);\n/// #\n/// # impl<A, B, C> Serialize for Tuple3<A, B, C>\n/// where\n///     A: Serialize,\n///     B: Serialize,\n///     C: Serialize,\n/// {\n///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n///     where\n///         S: Serializer,\n///     {\n///         let mut tup = serializer.serialize_tuple(3)?;\n///         tup.serialize_element(&self.0)?;\n///         tup.serialize_element(&self.1)?;\n///         tup.serialize_element(&self.2)?;\n///         tup.end()\n///     }\n/// }\n/// ```\n///\n/// ```edition2018\n/// # use std::marker::PhantomData;\n/// #\n/// # struct Array<T>(PhantomData<T>);\n/// #\n/// # impl<T> Array<T> {\n/// #     fn len(&self) -> usize {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// # impl<'a, T> IntoIterator for &'a Array<T> {\n/// #     type Item = &'a T;\n/// #     type IntoIter = Box<Iterator<Item = &'a T>>;\n/// #     fn into_iter(self) -> Self::IntoIter {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// use serde::ser::{Serialize, Serializer, SerializeTuple};\n///\n/// # mod fool {\n/// #     trait Serialize {}\n/// impl<T> Serialize for [T; 16]\n/// #     {}\n/// # }\n/// #\n/// # impl<T> Serialize for Array<T>\n/// where\n///     T: Serialize,\n/// {\n///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n///     where\n///         S: Serializer,\n///     {\n///         let mut seq = serializer.serialize_tuple(16)?;\n///         for element in self {\n///             seq.serialize_element(element)?;\n///         }\n///         seq.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeTuple` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeTuple {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a tuple element.\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize;\n\n    /// Finish serializing a tuple.\n    fn end(self) -> Result<Self::Ok, Self::Error>;\n}\n\n/// Returned from `Serializer::serialize_tuple_struct`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, SerializeTupleStruct, Serializer};\n///\n/// struct Rgb(u8, u8, u8);\n///\n/// impl Serialize for Rgb {\n///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n///     where\n///         S: Serializer,\n///     {\n///         let mut ts = serializer.serialize_tuple_struct(\"Rgb\", 3)?;\n///         ts.serialize_field(&self.0)?;\n///         ts.serialize_field(&self.1)?;\n///         ts.serialize_field(&self.2)?;\n///         ts.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeTupleStruct` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeTupleStruct {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a tuple struct field.\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize;\n\n    /// Finish serializing a tuple struct.\n    fn end(self) -> Result<Self::Ok, Self::Error>;\n}\n\n/// Returned from `Serializer::serialize_tuple_variant`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, SerializeTupleVariant, Serializer};\n///\n/// enum E {\n///     T(u8, u8),\n///     U(String, u32, u32),\n/// }\n///\n/// impl Serialize for E {\n///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n///     where\n///         S: Serializer,\n///     {\n///         match *self {\n///             E::T(ref a, ref b) => {\n///                 let mut tv = serializer.serialize_tuple_variant(\"E\", 0, \"T\", 2)?;\n///                 tv.serialize_field(a)?;\n///                 tv.serialize_field(b)?;\n///                 tv.end()\n///             }\n///             E::U(ref a, ref b, ref c) => {\n///                 let mut tv = serializer.serialize_tuple_variant(\"E\", 1, \"U\", 3)?;\n///                 tv.serialize_field(a)?;\n///                 tv.serialize_field(b)?;\n///                 tv.serialize_field(c)?;\n///                 tv.end()\n///             }\n///         }\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeTupleVariant` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeTupleVariant {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a tuple variant field.\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize;\n\n    /// Finish serializing a tuple variant.\n    fn end(self) -> Result<Self::Ok, Self::Error>;\n}\n\n/// Returned from `Serializer::serialize_map`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// # use std::marker::PhantomData;\n/// #\n/// # struct HashMap<K, V>(PhantomData<K>, PhantomData<V>);\n/// #\n/// # impl<K, V> HashMap<K, V> {\n/// #     fn len(&self) -> usize {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// # impl<'a, K, V> IntoIterator for &'a HashMap<K, V> {\n/// #     type Item = (&'a K, &'a V);\n/// #     type IntoIter = Box<Iterator<Item = (&'a K, &'a V)>>;\n/// #\n/// #     fn into_iter(self) -> Self::IntoIter {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// use serde::ser::{Serialize, Serializer, SerializeMap};\n///\n/// impl<K, V> Serialize for HashMap<K, V>\n/// where\n///     K: Serialize,\n///     V: Serialize,\n/// {\n///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n///     where\n///         S: Serializer,\n///     {\n///         let mut map = serializer.serialize_map(Some(self.len()))?;\n///         for (k, v) in self {\n///             map.serialize_entry(k, v)?;\n///         }\n///         map.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeMap` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeMap {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a map key.\n    ///\n    /// If possible, `Serialize` implementations are encouraged to use\n    /// `serialize_entry` instead as it may be implemented more efficiently in\n    /// some formats compared to a pair of calls to `serialize_key` and\n    /// `serialize_value`.\n    fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize;\n\n    /// Serialize a map value.\n    ///\n    /// # Panics\n    ///\n    /// Calling `serialize_value` before `serialize_key` is incorrect and is\n    /// allowed to panic or produce bogus results.\n    fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize;\n\n    /// Serialize a map entry consisting of a key and a value.\n    ///\n    /// Some [`Serialize`] types are not able to hold a key and value in memory\n    /// at the same time so `SerializeMap` implementations are required to\n    /// support [`serialize_key`] and [`serialize_value`] individually. The\n    /// `serialize_entry` method allows serializers to optimize for the case\n    /// where key and value are both available. [`Serialize`] implementations\n    /// are encouraged to use `serialize_entry` if possible.\n    ///\n    /// The default implementation delegates to [`serialize_key`] and\n    /// [`serialize_value`]. This is appropriate for serializers that do not\n    /// care about performance or are not able to optimize `serialize_entry` any\n    /// better than this.\n    ///\n    /// [`Serialize`]: ../trait.Serialize.html\n    /// [`serialize_key`]: #tymethod.serialize_key\n    /// [`serialize_value`]: #tymethod.serialize_value\n    fn serialize_entry<K: ?Sized, V: ?Sized>(\n        &mut self,\n        key: &K,\n        value: &V,\n    ) -> Result<(), Self::Error>\n    where\n        K: Serialize,\n        V: Serialize,\n    {\n        try!(self.serialize_key(key));\n        self.serialize_value(value)\n    }\n\n    /// Finish serializing a map.\n    fn end(self) -> Result<Self::Ok, Self::Error>;\n}\n\n/// Returned from `Serializer::serialize_struct`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, SerializeStruct, Serializer};\n///\n/// struct Rgb {\n///     r: u8,\n///     g: u8,\n///     b: u8,\n/// }\n///\n/// impl Serialize for Rgb {\n///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n///     where\n///         S: Serializer,\n///     {\n///         let mut rgb = serializer.serialize_struct(\"Rgb\", 3)?;\n///         rgb.serialize_field(\"r\", &self.r)?;\n///         rgb.serialize_field(\"g\", &self.g)?;\n///         rgb.serialize_field(\"b\", &self.b)?;\n///         rgb.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeStruct` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeStruct {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a struct field.\n    fn serialize_field<T: ?Sized>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: Serialize;\n\n    /// Indicate that a struct field has been skipped.\n    #[inline]\n    fn skip_field(&mut self, key: &'static str) -> Result<(), Self::Error> {\n        let _ = key;\n        Ok(())\n    }\n\n    /// Finish serializing a struct.\n    fn end(self) -> Result<Self::Ok, Self::Error>;\n}\n\n/// Returned from `Serializer::serialize_struct_variant`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, SerializeStructVariant, Serializer};\n///\n/// enum E {\n///     S { r: u8, g: u8, b: u8 },\n/// }\n///\n/// impl Serialize for E {\n///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n///     where\n///         S: Serializer,\n///     {\n///         match *self {\n///             E::S {\n///                 ref r,\n///                 ref g,\n///                 ref b,\n///             } => {\n///                 let mut sv = serializer.serialize_struct_variant(\"E\", 0, \"S\", 3)?;\n///                 sv.serialize_field(\"r\", r)?;\n///                 sv.serialize_field(\"g\", g)?;\n///                 sv.serialize_field(\"b\", b)?;\n///                 sv.end()\n///             }\n///         }\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeStructVariant` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeStructVariant {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a struct variant field.\n    fn serialize_field<T: ?Sized>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: Serialize;\n\n    /// Indicate that a struct variant field has been skipped.\n    #[inline]\n    fn skip_field(&mut self, key: &'static str) -> Result<(), Self::Error> {\n        let _ = key;\n        Ok(())\n    }\n\n    /// Finish serializing a struct variant.\n    fn end(self) -> Result<Self::Ok, Self::Error>;\n}\n\ntrait LenHint: Iterator {\n    fn len_hint(&self) -> Option<usize>;\n}\n\nimpl<I> LenHint for I\nwhere\n    I: Iterator,\n{\n    #[cfg(not(feature = \"unstable\"))]\n    fn len_hint(&self) -> Option<usize> {\n        iterator_len_hint(self)\n    }\n\n    #[cfg(feature = \"unstable\")]\n    default fn len_hint(&self) -> Option<usize> {\n        iterator_len_hint(self)\n    }\n}\n\n#[cfg(feature = \"unstable\")]\nimpl<I> LenHint for I\nwhere\n    I: ExactSizeIterator,\n{\n    fn len_hint(&self) -> Option<usize> {\n        Some(self.len())\n    }\n}\n\nfn iterator_len_hint<I>(iter: &I) -> Option<usize>\nwhere\n    I: Iterator,\n{\n    match iter.size_hint() {\n        (lo, Some(hi)) if lo == hi => Some(lo),\n        _ => None,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","std_error.rs"],"content":"use lib::{Debug, Display};\n\n/// Either a re-export of std::error::Error or a new identical trait, depending\n/// on whether Serde's \"std\" feature is enabled.\n///\n/// Serde's error traits [`serde::ser::Error`] and [`serde::de::Error`] require\n/// [`std::error::Error`] as a supertrait, but only when Serde is built with\n/// \"std\" enabled. Data formats that don't care about no\\_std support should\n/// generally provide their error types with a `std::error::Error` impl\n/// directly:\n///\n/// ```edition2018\n/// #[derive(Debug)]\n/// struct MySerError {...}\n///\n/// impl serde::ser::Error for MySerError {...}\n///\n/// impl std::fmt::Display for MySerError {...}\n///\n/// // We don't support no_std!\n/// impl std::error::Error for MySerError {}\n/// ```\n///\n/// Data formats that *do* support no\\_std may either have a \"std\" feature of\n/// their own:\n///\n/// ```toml\n/// [features]\n/// std = [\"serde/std\"]\n/// ```\n///\n/// ```edition2018\n/// #[cfg(feature = \"std\")]\n/// impl std::error::Error for MySerError {}\n/// ```\n///\n/// ... or else provide the std Error impl unconditionally via Serde's\n/// re-export:\n///\n/// ```edition2018\n/// impl serde::ser::StdError for MySerError {}\n/// ```\npub trait Error: Debug + Display {\n    /// The underlying cause of this error, if any.\n    fn source(&self) -> Option<&(Error + 'static)> {\n        None\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","bound.rs"],"content":"use std::collections::HashSet;\n\nuse syn;\nuse syn::punctuated::{Pair, Punctuated};\nuse syn::visit::{self, Visit};\n\nuse internals::ast::{Container, Data};\nuse internals::attr;\n\nuse proc_macro2::Span;\n\n// Remove the default from every type parameter because in the generated impls\n// they look like associated types: \"error: associated type bindings are not\n// allowed here\".\npub fn without_defaults(generics: &syn::Generics) -> syn::Generics {\n    syn::Generics {\n        params: generics\n            .params\n            .iter()\n            .map(|param| match *param {\n                syn::GenericParam::Type(ref param) => syn::GenericParam::Type(syn::TypeParam {\n                    eq_token: None,\n                    default: None,\n                    ..param.clone()\n                }),\n                _ => param.clone(),\n            })\n            .collect(),\n        ..generics.clone()\n    }\n}\n\npub fn with_where_predicates(\n    generics: &syn::Generics,\n    predicates: &[syn::WherePredicate],\n) -> syn::Generics {\n    let mut generics = generics.clone();\n    generics\n        .make_where_clause()\n        .predicates\n        .extend(predicates.iter().cloned());\n    generics\n}\n\npub fn with_where_predicates_from_fields(\n    cont: &Container,\n    generics: &syn::Generics,\n    from_field: fn(&attr::Field) -> Option<&[syn::WherePredicate]>,\n) -> syn::Generics {\n    let predicates = cont\n        .data\n        .all_fields()\n        .flat_map(|field| from_field(&field.attrs))\n        .flat_map(|predicates| predicates.to_vec());\n\n    let mut generics = generics.clone();\n    generics.make_where_clause().predicates.extend(predicates);\n    generics\n}\n\npub fn with_where_predicates_from_variants(\n    cont: &Container,\n    generics: &syn::Generics,\n    from_variant: fn(&attr::Variant) -> Option<&[syn::WherePredicate]>,\n) -> syn::Generics {\n    let variants = match cont.data {\n        Data::Enum(ref variants) => variants,\n        Data::Struct(_, _) => {\n            return generics.clone();\n        }\n    };\n\n    let predicates = variants\n        .iter()\n        .flat_map(|variant| from_variant(&variant.attrs))\n        .flat_map(|predicates| predicates.to_vec());\n\n    let mut generics = generics.clone();\n    generics.make_where_clause().predicates.extend(predicates);\n    generics\n}\n\n// Puts the given bound on any generic type parameters that are used in fields\n// for which filter returns true.\n//\n// For example, the following struct needs the bound `A: Serialize, B:\n// Serialize`.\n//\n//     struct S<'b, A, B: 'b, C> {\n//         a: A,\n//         b: Option<&'b B>\n//         #[serde(skip_serializing)]\n//         c: C,\n//     }\npub fn with_bound(\n    cont: &Container,\n    generics: &syn::Generics,\n    filter: fn(&attr::Field, Option<&attr::Variant>) -> bool,\n    bound: &syn::Path,\n) -> syn::Generics {\n    struct FindTyParams<'ast> {\n        // Set of all generic type parameters on the current struct (A, B, C in\n        // the example). Initialized up front.\n        all_type_params: HashSet<syn::Ident>,\n\n        // Set of generic type parameters used in fields for which filter\n        // returns true (A and B in the example). Filled in as the visitor sees\n        // them.\n        relevant_type_params: HashSet<syn::Ident>,\n\n        // Fields whose type is an associated type of one of the generic type\n        // parameters.\n        associated_type_usage: Vec<&'ast syn::TypePath>,\n    }\n    impl<'ast> Visit<'ast> for FindTyParams<'ast> {\n        fn visit_field(&mut self, field: &'ast syn::Field) {\n            if let syn::Type::Path(ref ty) = field.ty {\n                if let Some(Pair::Punctuated(ref t, _)) = ty.path.segments.pairs().next() {\n                    if self.all_type_params.contains(&t.ident) {\n                        self.associated_type_usage.push(ty);\n                    }\n                }\n            }\n            self.visit_type(&field.ty);\n        }\n\n        fn visit_path(&mut self, path: &'ast syn::Path) {\n            if let Some(seg) = path.segments.last() {\n                if seg.ident == \"PhantomData\" {\n                    // Hardcoded exception, because PhantomData<T> implements\n                    // Serialize and Deserialize whether or not T implements it.\n                    return;\n                }\n            }\n            if path.leading_colon.is_none() && path.segments.len() == 1 {\n                let id = &path.segments[0].ident;\n                if self.all_type_params.contains(id) {\n                    self.relevant_type_params.insert(id.clone());\n                }\n            }\n            visit::visit_path(self, path);\n        }\n\n        // Type parameter should not be considered used by a macro path.\n        //\n        //     struct TypeMacro<T> {\n        //         mac: T!(),\n        //         marker: PhantomData<T>,\n        //     }\n        fn visit_macro(&mut self, _mac: &'ast syn::Macro) {}\n    }\n\n    let all_type_params = generics\n        .type_params()\n        .map(|param| param.ident.clone())\n        .collect();\n\n    let mut visitor = FindTyParams {\n        all_type_params: all_type_params,\n        relevant_type_params: HashSet::new(),\n        associated_type_usage: Vec::new(),\n    };\n    match cont.data {\n        Data::Enum(ref variants) => {\n            for variant in variants.iter() {\n                let relevant_fields = variant\n                    .fields\n                    .iter()\n                    .filter(|field| filter(&field.attrs, Some(&variant.attrs)));\n                for field in relevant_fields {\n                    visitor.visit_field(field.original);\n                }\n            }\n        }\n        Data::Struct(_, ref fields) => {\n            for field in fields.iter().filter(|field| filter(&field.attrs, None)) {\n                visitor.visit_field(field.original);\n            }\n        }\n    }\n\n    let relevant_type_params = visitor.relevant_type_params;\n    let associated_type_usage = visitor.associated_type_usage;\n    let new_predicates = generics\n        .type_params()\n        .map(|param| param.ident.clone())\n        .filter(|id| relevant_type_params.contains(id))\n        .map(|id| syn::TypePath {\n            qself: None,\n            path: id.into(),\n        })\n        .chain(associated_type_usage.into_iter().cloned())\n        .map(|bounded_ty| {\n            syn::WherePredicate::Type(syn::PredicateType {\n                lifetimes: None,\n                // the type parameter that is being bounded e.g. T\n                bounded_ty: syn::Type::Path(bounded_ty),\n                colon_token: <Token![:]>::default(),\n                // the bound e.g. Serialize\n                bounds: vec![syn::TypeParamBound::Trait(syn::TraitBound {\n                    paren_token: None,\n                    modifier: syn::TraitBoundModifier::None,\n                    lifetimes: None,\n                    path: bound.clone(),\n                })]\n                .into_iter()\n                .collect(),\n            })\n        });\n\n    let mut generics = generics.clone();\n    generics\n        .make_where_clause()\n        .predicates\n        .extend(new_predicates);\n    generics\n}\n\npub fn with_self_bound(\n    cont: &Container,\n    generics: &syn::Generics,\n    bound: &syn::Path,\n) -> syn::Generics {\n    let mut generics = generics.clone();\n    generics\n        .make_where_clause()\n        .predicates\n        .push(syn::WherePredicate::Type(syn::PredicateType {\n            lifetimes: None,\n            // the type that is being bounded e.g. MyStruct<'a, T>\n            bounded_ty: type_of_item(cont),\n            colon_token: <Token![:]>::default(),\n            // the bound e.g. Default\n            bounds: vec![syn::TypeParamBound::Trait(syn::TraitBound {\n                paren_token: None,\n                modifier: syn::TraitBoundModifier::None,\n                lifetimes: None,\n                path: bound.clone(),\n            })]\n            .into_iter()\n            .collect(),\n        }));\n    generics\n}\n\npub fn with_lifetime_bound(generics: &syn::Generics, lifetime: &str) -> syn::Generics {\n    let bound = syn::Lifetime::new(lifetime, Span::call_site());\n    let def = syn::LifetimeDef {\n        attrs: Vec::new(),\n        lifetime: bound.clone(),\n        colon_token: None,\n        bounds: Punctuated::new(),\n    };\n\n    let params = Some(syn::GenericParam::Lifetime(def))\n        .into_iter()\n        .chain(generics.params.iter().cloned().map(|mut param| {\n            match param {\n                syn::GenericParam::Lifetime(ref mut param) => {\n                    param.bounds.push(bound.clone());\n                }\n                syn::GenericParam::Type(ref mut param) => {\n                    param\n                        .bounds\n                        .push(syn::TypeParamBound::Lifetime(bound.clone()));\n                }\n                syn::GenericParam::Const(_) => {}\n            }\n            param\n        }))\n        .collect();\n\n    syn::Generics {\n        params: params,\n        ..generics.clone()\n    }\n}\n\nfn type_of_item(cont: &Container) -> syn::Type {\n    syn::Type::Path(syn::TypePath {\n        qself: None,\n        path: syn::Path {\n            leading_colon: None,\n            segments: vec![syn::PathSegment {\n                ident: cont.ident.clone(),\n                arguments: syn::PathArguments::AngleBracketed(\n                    syn::AngleBracketedGenericArguments {\n                        colon2_token: None,\n                        lt_token: <Token![<]>::default(),\n                        args: cont\n                            .generics\n                            .params\n                            .iter()\n                            .map(|param| match *param {\n                                syn::GenericParam::Type(ref param) => {\n                                    syn::GenericArgument::Type(syn::Type::Path(syn::TypePath {\n                                        qself: None,\n                                        path: param.ident.clone().into(),\n                                    }))\n                                }\n                                syn::GenericParam::Lifetime(ref param) => {\n                                    syn::GenericArgument::Lifetime(param.lifetime.clone())\n                                }\n                                syn::GenericParam::Const(_) => {\n                                    panic!(\"Serde does not support const generics yet\");\n                                }\n                            })\n                            .collect(),\n                        gt_token: <Token![>]>::default(),\n                    },\n                ),\n            }]\n            .into_iter()\n            .collect(),\n        },\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","de.rs"],"content":"use proc_macro2::{Literal, Span, TokenStream};\nuse quote::ToTokens;\nuse syn::punctuated::Punctuated;\nuse syn::spanned::Spanned;\nuse syn::{self, Ident, Index, Member};\n\nuse bound;\nuse dummy;\nuse fragment::{Expr, Fragment, Match, Stmts};\nuse internals::ast::{Container, Data, Field, Style, Variant};\nuse internals::{attr, Ctxt, Derive};\nuse pretend;\n\nuse std::collections::BTreeSet;\n\npub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<TokenStream, Vec<syn::Error>> {\n    let ctxt = Ctxt::new();\n    let cont = match Container::from_ast(&ctxt, input, Derive::Deserialize) {\n        Some(cont) => cont,\n        None => return Err(ctxt.check().unwrap_err()),\n    };\n    precondition(&ctxt, &cont);\n    ctxt.check()?;\n\n    let ident = &cont.ident;\n    let params = Parameters::new(&cont);\n    let (de_impl_generics, _, ty_generics, where_clause) = split_with_de_lifetime(&params);\n    let body = Stmts(deserialize_body(&cont, &params));\n    let delife = params.borrowed.de_lifetime();\n    let serde = cont.attrs.serde_path();\n\n    let impl_block = if let Some(remote) = cont.attrs.remote() {\n        let vis = &input.vis;\n        let used = pretend::pretend_used(&cont);\n        quote! {\n            impl #de_impl_generics #ident #ty_generics #where_clause {\n                #vis fn deserialize<__D>(__deserializer: __D) -> #serde::export::Result<#remote #ty_generics, __D::Error>\n                where\n                    __D: #serde::Deserializer<#delife>,\n                {\n                    #used\n                    #body\n                }\n            }\n        }\n    } else {\n        let fn_deserialize_in_place = deserialize_in_place_body(&cont, &params);\n\n        quote! {\n            #[automatically_derived]\n            impl #de_impl_generics #serde::Deserialize<#delife> for #ident #ty_generics #where_clause {\n                fn deserialize<__D>(__deserializer: __D) -> #serde::export::Result<Self, __D::Error>\n                where\n                    __D: #serde::Deserializer<#delife>,\n                {\n                    #body\n                }\n\n                #fn_deserialize_in_place\n            }\n        }\n    };\n\n    Ok(dummy::wrap_in_const(\n        cont.attrs.custom_serde_path(),\n        \"DESERIALIZE\",\n        ident,\n        impl_block,\n    ))\n}\n\nfn precondition(cx: &Ctxt, cont: &Container) {\n    precondition_sized(cx, cont);\n    precondition_no_de_lifetime(cx, cont);\n}\n\nfn precondition_sized(cx: &Ctxt, cont: &Container) {\n    if let Data::Struct(_, ref fields) = cont.data {\n        if let Some(last) = fields.last() {\n            if let syn::Type::Slice(_) = *last.ty {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"cannot deserialize a dynamically sized struct\",\n                );\n            }\n        }\n    }\n}\n\nfn precondition_no_de_lifetime(cx: &Ctxt, cont: &Container) {\n    if let BorrowedLifetimes::Borrowed(_) = borrowed_lifetimes(cont) {\n        for param in cont.generics.lifetimes() {\n            if param.lifetime.to_string() == \"'de\" {\n                cx.error_spanned_by(\n                    &param.lifetime,\n                    \"cannot deserialize when there is a lifetime parameter called 'de\",\n                );\n                return;\n            }\n        }\n    }\n}\n\nstruct Parameters {\n    /// Name of the type the `derive` is on.\n    local: syn::Ident,\n\n    /// Path to the type the impl is for. Either a single `Ident` for local\n    /// types or `some::remote::Ident` for remote types. Does not include\n    /// generic parameters.\n    this: syn::Path,\n\n    /// Generics including any explicit and inferred bounds for the impl.\n    generics: syn::Generics,\n\n    /// Lifetimes borrowed from the deserializer. These will become bounds on\n    /// the `'de` lifetime of the deserializer.\n    borrowed: BorrowedLifetimes,\n\n    /// At least one field has a serde(getter) attribute, implying that the\n    /// remote type has a private field.\n    has_getter: bool,\n}\n\nimpl Parameters {\n    fn new(cont: &Container) -> Self {\n        let local = cont.ident.clone();\n        let this = match cont.attrs.remote() {\n            Some(remote) => remote.clone(),\n            None => cont.ident.clone().into(),\n        };\n        let borrowed = borrowed_lifetimes(cont);\n        let generics = build_generics(cont, &borrowed);\n        let has_getter = cont.data.has_getter();\n\n        Parameters {\n            local: local,\n            this: this,\n            generics: generics,\n            borrowed: borrowed,\n            has_getter: has_getter,\n        }\n    }\n\n    /// Type name to use in error messages and `&'static str` arguments to\n    /// various Deserializer methods.\n    fn type_name(&self) -> String {\n        self.this.segments.last().unwrap().ident.to_string()\n    }\n}\n\n// All the generics in the input, plus a bound `T: Deserialize` for each generic\n// field type that will be deserialized by us, plus a bound `T: Default` for\n// each generic field type that will be set to a default value.\nfn build_generics(cont: &Container, borrowed: &BorrowedLifetimes) -> syn::Generics {\n    let generics = bound::without_defaults(cont.generics);\n\n    let generics = bound::with_where_predicates_from_fields(cont, &generics, attr::Field::de_bound);\n\n    let generics =\n        bound::with_where_predicates_from_variants(cont, &generics, attr::Variant::de_bound);\n\n    match cont.attrs.de_bound() {\n        Some(predicates) => bound::with_where_predicates(&generics, predicates),\n        None => {\n            let generics = match *cont.attrs.default() {\n                attr::Default::Default => {\n                    bound::with_self_bound(cont, &generics, &parse_quote!(_serde::export::Default))\n                }\n                attr::Default::None | attr::Default::Path(_) => generics,\n            };\n\n            let delife = borrowed.de_lifetime();\n            let generics = bound::with_bound(\n                cont,\n                &generics,\n                needs_deserialize_bound,\n                &parse_quote!(_serde::Deserialize<#delife>),\n            );\n\n            bound::with_bound(\n                cont,\n                &generics,\n                requires_default,\n                &parse_quote!(_serde::export::Default),\n            )\n        }\n    }\n}\n\n// Fields with a `skip_deserializing` or `deserialize_with` attribute, or which\n// belong to a variant with a `skip_deserializing` or `deserialize_with`\n// attribute, are not deserialized by us so we do not generate a bound. Fields\n// with a `bound` attribute specify their own bound so we do not generate one.\n// All other fields may need a `T: Deserialize` bound where T is the type of the\n// field.\nfn needs_deserialize_bound(field: &attr::Field, variant: Option<&attr::Variant>) -> bool {\n    !field.skip_deserializing()\n        && field.deserialize_with().is_none()\n        && field.de_bound().is_none()\n        && variant.map_or(true, |variant| {\n            !variant.skip_deserializing()\n                && variant.deserialize_with().is_none()\n                && variant.de_bound().is_none()\n        })\n}\n\n// Fields with a `default` attribute (not `default=...`), and fields with a\n// `skip_deserializing` attribute that do not also have `default=...`.\nfn requires_default(field: &attr::Field, _variant: Option<&attr::Variant>) -> bool {\n    if let attr::Default::Default = *field.default() {\n        true\n    } else {\n        false\n    }\n}\n\nenum BorrowedLifetimes {\n    Borrowed(BTreeSet<syn::Lifetime>),\n    Static,\n}\n\nimpl BorrowedLifetimes {\n    fn de_lifetime(&self) -> syn::Lifetime {\n        match *self {\n            BorrowedLifetimes::Borrowed(_) => syn::Lifetime::new(\"'de\", Span::call_site()),\n            BorrowedLifetimes::Static => syn::Lifetime::new(\"'static\", Span::call_site()),\n        }\n    }\n\n    fn de_lifetime_def(&self) -> Option<syn::LifetimeDef> {\n        match *self {\n            BorrowedLifetimes::Borrowed(ref bounds) => Some(syn::LifetimeDef {\n                attrs: Vec::new(),\n                lifetime: syn::Lifetime::new(\"'de\", Span::call_site()),\n                colon_token: None,\n                bounds: bounds.iter().cloned().collect(),\n            }),\n            BorrowedLifetimes::Static => None,\n        }\n    }\n}\n\n// The union of lifetimes borrowed by each field of the container.\n//\n// These turn into bounds on the `'de` lifetime of the Deserialize impl. If\n// lifetimes `'a` and `'b` are borrowed but `'c` is not, the impl is:\n//\n//     impl<'de: 'a + 'b, 'a, 'b, 'c> Deserialize<'de> for S<'a, 'b, 'c>\n//\n// If any borrowed lifetime is `'static`, then `'de: 'static` would be redundant\n// and we use plain `'static` instead of `'de`.\nfn borrowed_lifetimes(cont: &Container) -> BorrowedLifetimes {\n    let mut lifetimes = BTreeSet::new();\n    for field in cont.data.all_fields() {\n        if !field.attrs.skip_deserializing() {\n            lifetimes.extend(field.attrs.borrowed_lifetimes().iter().cloned());\n        }\n    }\n    if lifetimes.iter().any(|b| b.to_string() == \"'static\") {\n        BorrowedLifetimes::Static\n    } else {\n        BorrowedLifetimes::Borrowed(lifetimes)\n    }\n}\n\nfn deserialize_body(cont: &Container, params: &Parameters) -> Fragment {\n    if cont.attrs.transparent() {\n        deserialize_transparent(cont, params)\n    } else if let Some(type_from) = cont.attrs.type_from() {\n        deserialize_from(type_from)\n    } else if let Some(type_try_from) = cont.attrs.type_try_from() {\n        deserialize_try_from(type_try_from)\n    } else if let attr::Identifier::No = cont.attrs.identifier() {\n        match cont.data {\n            Data::Enum(ref variants) => deserialize_enum(params, variants, &cont.attrs),\n            Data::Struct(Style::Struct, ref fields) => {\n                deserialize_struct(None, params, fields, &cont.attrs, None, &Untagged::No)\n            }\n            Data::Struct(Style::Tuple, ref fields) | Data::Struct(Style::Newtype, ref fields) => {\n                deserialize_tuple(None, params, fields, &cont.attrs, None)\n            }\n            Data::Struct(Style::Unit, _) => deserialize_unit_struct(params, &cont.attrs),\n        }\n    } else {\n        match cont.data {\n            Data::Enum(ref variants) => {\n                deserialize_custom_identifier(params, variants, &cont.attrs)\n            }\n            Data::Struct(_, _) => unreachable!(\"checked in serde_derive_internals\"),\n        }\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_in_place_body(cont: &Container, params: &Parameters) -> Option<Stmts> {\n    // Only remote derives have getters, and we do not generate\n    // deserialize_in_place for remote derives.\n    assert!(!params.has_getter);\n\n    if cont.attrs.transparent()\n        || cont.attrs.type_from().is_some()\n        || cont.attrs.type_try_from().is_some()\n        || cont.attrs.identifier().is_some()\n        || cont\n            .data\n            .all_fields()\n            .all(|f| f.attrs.deserialize_with().is_some())\n    {\n        return None;\n    }\n\n    let code = match cont.data {\n        Data::Struct(Style::Struct, ref fields) => {\n            if let Some(code) = deserialize_struct_in_place(None, params, fields, &cont.attrs, None)\n            {\n                code\n            } else {\n                return None;\n            }\n        }\n        Data::Struct(Style::Tuple, ref fields) | Data::Struct(Style::Newtype, ref fields) => {\n            deserialize_tuple_in_place(None, params, fields, &cont.attrs, None)\n        }\n        Data::Enum(_) | Data::Struct(Style::Unit, _) => {\n            return None;\n        }\n    };\n\n    let delife = params.borrowed.de_lifetime();\n    let stmts = Stmts(code);\n\n    let fn_deserialize_in_place = quote_block! {\n        fn deserialize_in_place<__D>(__deserializer: __D, __place: &mut Self) -> _serde::export::Result<(), __D::Error>\n        where\n            __D: _serde::Deserializer<#delife>,\n        {\n            #stmts\n        }\n    };\n\n    Some(Stmts(fn_deserialize_in_place))\n}\n\n#[cfg(not(feature = \"deserialize_in_place\"))]\nfn deserialize_in_place_body(_cont: &Container, _params: &Parameters) -> Option<Stmts> {\n    None\n}\n\nfn deserialize_transparent(cont: &Container, params: &Parameters) -> Fragment {\n    let fields = match cont.data {\n        Data::Struct(_, ref fields) => fields,\n        Data::Enum(_) => unreachable!(),\n    };\n\n    let this = &params.this;\n    let transparent_field = fields.iter().find(|f| f.attrs.transparent()).unwrap();\n\n    let path = match transparent_field.attrs.deserialize_with() {\n        Some(path) => quote!(#path),\n        None => {\n            let span = transparent_field.original.span();\n            quote_spanned!(span=> _serde::Deserialize::deserialize)\n        }\n    };\n\n    let assign = fields.iter().map(|field| {\n        let member = &field.member;\n        if field as *const Field == transparent_field as *const Field {\n            quote!(#member: __transparent)\n        } else {\n            let value = match *field.attrs.default() {\n                attr::Default::Default => quote!(_serde::export::Default::default()),\n                attr::Default::Path(ref path) => quote!(#path()),\n                attr::Default::None => quote!(_serde::export::PhantomData),\n            };\n            quote!(#member: #value)\n        }\n    });\n\n    quote_block! {\n        _serde::export::Result::map(\n            #path(__deserializer),\n            |__transparent| #this { #(#assign),* })\n    }\n}\n\nfn deserialize_from(type_from: &syn::Type) -> Fragment {\n    quote_block! {\n        _serde::export::Result::map(\n            <#type_from as _serde::Deserialize>::deserialize(__deserializer),\n            _serde::export::From::from)\n    }\n}\n\nfn deserialize_try_from(type_try_from: &syn::Type) -> Fragment {\n    quote_block! {\n        _serde::export::Result::and_then(\n            <#type_try_from as _serde::Deserialize>::deserialize(__deserializer),\n            |v| _serde::export::TryFrom::try_from(v).map_err(_serde::de::Error::custom))\n    }\n}\n\nfn deserialize_unit_struct(params: &Parameters, cattrs: &attr::Container) -> Fragment {\n    let this = &params.this;\n    let type_name = cattrs.name().deserialize_name();\n\n    let expecting = format!(\"unit struct {}\", params.type_name());\n\n    quote_block! {\n        struct __Visitor;\n\n        impl<'de> _serde::de::Visitor<'de> for __Visitor {\n            type Value = #this;\n\n            fn expecting(&self, __formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #[inline]\n            fn visit_unit<__E>(self) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(#this)\n            }\n        }\n\n        _serde::Deserializer::deserialize_unit_struct(__deserializer, #type_name, __Visitor)\n    }\n}\n\nfn deserialize_tuple(\n    variant_ident: Option<&syn::Ident>,\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n    deserializer: Option<TokenStream>,\n) -> Fragment {\n    let this = &params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    assert!(!cattrs.has_flatten());\n\n    // If there are getters (implying private fields), construct the local type\n    // and use an `Into` conversion to get the remote type. If there are no\n    // getters then construct the target type directly.\n    let construct = if params.has_getter {\n        let local = &params.local;\n        quote!(#local)\n    } else {\n        quote!(#this)\n    };\n\n    let is_enum = variant_ident.is_some();\n    let type_path = match variant_ident {\n        Some(ref variant_ident) => quote!(#construct::#variant_ident),\n        None => construct,\n    };\n    let expecting = match variant_ident {\n        Some(variant_ident) => format!(\"tuple variant {}::{}\", params.type_name(), variant_ident),\n        None => format!(\"tuple struct {}\", params.type_name()),\n    };\n\n    let nfields = fields.len();\n\n    let visit_newtype_struct = if !is_enum && nfields == 1 {\n        Some(deserialize_newtype_struct(&type_path, params, &fields[0]))\n    } else {\n        None\n    };\n\n    let visit_seq = Stmts(deserialize_seq(\n        &type_path, params, fields, false, cattrs, &expecting,\n    ));\n\n    let visitor_expr = quote! {\n        __Visitor {\n            marker: _serde::export::PhantomData::<#this #ty_generics>,\n            lifetime: _serde::export::PhantomData,\n        }\n    };\n    let dispatch = if let Some(deserializer) = deserializer {\n        quote!(_serde::Deserializer::deserialize_tuple(#deserializer, #nfields, #visitor_expr))\n    } else if is_enum {\n        quote!(_serde::de::VariantAccess::tuple_variant(__variant, #nfields, #visitor_expr))\n    } else if nfields == 1 {\n        let type_name = cattrs.name().deserialize_name();\n        quote!(_serde::Deserializer::deserialize_newtype_struct(__deserializer, #type_name, #visitor_expr))\n    } else {\n        let type_name = cattrs.name().deserialize_name();\n        quote!(_serde::Deserializer::deserialize_tuple_struct(__deserializer, #type_name, #nfields, #visitor_expr))\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let visitor_var = if all_skipped {\n        quote!(_)\n    } else {\n        quote!(mut __seq)\n    };\n\n    quote_block! {\n        struct __Visitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData<#this #ty_generics>,\n            lifetime: _serde::export::PhantomData<&#delife ()>,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor<#delife> for __Visitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn expecting(&self, __formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #visit_newtype_struct\n\n            #[inline]\n            fn visit_seq<__A>(self, #visitor_var: __A) -> _serde::export::Result<Self::Value, __A::Error>\n            where\n                __A: _serde::de::SeqAccess<#delife>,\n            {\n                #visit_seq\n            }\n        }\n\n        #dispatch\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_tuple_in_place(\n    variant_ident: Option<syn::Ident>,\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n    deserializer: Option<TokenStream>,\n) -> Fragment {\n    let this = &params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    assert!(!cattrs.has_flatten());\n\n    let is_enum = variant_ident.is_some();\n    let expecting = match variant_ident {\n        Some(variant_ident) => format!(\"tuple variant {}::{}\", params.type_name(), variant_ident),\n        None => format!(\"tuple struct {}\", params.type_name()),\n    };\n\n    let nfields = fields.len();\n\n    let visit_newtype_struct = if !is_enum && nfields == 1 {\n        Some(deserialize_newtype_struct_in_place(params, &fields[0]))\n    } else {\n        None\n    };\n\n    let visit_seq = Stmts(deserialize_seq_in_place(params, fields, cattrs, &expecting));\n\n    let visitor_expr = quote! {\n        __Visitor {\n            place: __place,\n            lifetime: _serde::export::PhantomData,\n        }\n    };\n\n    let dispatch = if let Some(deserializer) = deserializer {\n        quote!(_serde::Deserializer::deserialize_tuple(#deserializer, #nfields, #visitor_expr))\n    } else if is_enum {\n        quote!(_serde::de::VariantAccess::tuple_variant(__variant, #nfields, #visitor_expr))\n    } else if nfields == 1 {\n        let type_name = cattrs.name().deserialize_name();\n        quote!(_serde::Deserializer::deserialize_newtype_struct(__deserializer, #type_name, #visitor_expr))\n    } else {\n        let type_name = cattrs.name().deserialize_name();\n        quote!(_serde::Deserializer::deserialize_tuple_struct(__deserializer, #type_name, #nfields, #visitor_expr))\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let visitor_var = if all_skipped {\n        quote!(_)\n    } else {\n        quote!(mut __seq)\n    };\n\n    let in_place_impl_generics = de_impl_generics.in_place();\n    let in_place_ty_generics = de_ty_generics.in_place();\n    let place_life = place_lifetime();\n\n    quote_block! {\n        struct __Visitor #in_place_impl_generics #where_clause {\n            place: &#place_life mut #this #ty_generics,\n            lifetime: _serde::export::PhantomData<&#delife ()>,\n        }\n\n        impl #in_place_impl_generics _serde::de::Visitor<#delife> for __Visitor #in_place_ty_generics #where_clause {\n            type Value = ();\n\n            fn expecting(&self, __formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #visit_newtype_struct\n\n            #[inline]\n            fn visit_seq<__A>(self, #visitor_var: __A) -> _serde::export::Result<Self::Value, __A::Error>\n            where\n                __A: _serde::de::SeqAccess<#delife>,\n            {\n                #visit_seq\n            }\n        }\n\n        #dispatch\n    }\n}\n\nfn deserialize_seq(\n    type_path: &TokenStream,\n    params: &Parameters,\n    fields: &[Field],\n    is_struct: bool,\n    cattrs: &attr::Container,\n    expecting: &str,\n) -> Fragment {\n    let vars = (0..fields.len()).map(field_i as fn(_) -> _);\n\n    let deserialized_count = fields\n        .iter()\n        .filter(|field| !field.attrs.skip_deserializing())\n        .count();\n    let expecting = if deserialized_count == 1 {\n        format!(\"{} with 1 element\", expecting)\n    } else {\n        format!(\"{} with {} elements\", expecting, deserialized_count)\n    };\n\n    let mut index_in_seq = 0_usize;\n    let let_values = vars.clone().zip(fields).map(|(var, field)| {\n        if field.attrs.skip_deserializing() {\n            let default = Expr(expr_is_missing(field, cattrs));\n            quote! {\n                let #var = #default;\n            }\n        } else {\n            let visit = match field.attrs.deserialize_with() {\n                None => {\n                    let field_ty = field.ty;\n                    let span = field.original.span();\n                    let func =\n                        quote_spanned!(span=> _serde::de::SeqAccess::next_element::<#field_ty>);\n                    quote!(try!(#func(&mut __seq)))\n                }\n                Some(path) => {\n                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n                    quote!({\n                        #wrapper\n                        _serde::export::Option::map(\n                            try!(_serde::de::SeqAccess::next_element::<#wrapper_ty>(&mut __seq)),\n                            |__wrap| __wrap.value)\n                    })\n                }\n            };\n            let value_if_none = match *field.attrs.default() {\n                attr::Default::Default => quote!(_serde::export::Default::default()),\n                attr::Default::Path(ref path) => quote!(#path()),\n                attr::Default::None => quote!(\n                    return _serde::export::Err(_serde::de::Error::invalid_length(#index_in_seq, &#expecting));\n                ),\n            };\n            let assign = quote! {\n                let #var = match #visit {\n                    _serde::export::Some(__value) => __value,\n                    _serde::export::None => {\n                        #value_if_none\n                    }\n                };\n            };\n            index_in_seq += 1;\n            assign\n        }\n    });\n\n    let mut result = if is_struct {\n        let names = fields.iter().map(|f| &f.member);\n        quote! {\n            #type_path { #( #names: #vars ),* }\n        }\n    } else {\n        quote! {\n            #type_path ( #(#vars),* )\n        }\n    };\n\n    if params.has_getter {\n        let this = &params.this;\n        result = quote! {\n            _serde::export::Into::<#this>::into(#result)\n        };\n    }\n\n    let let_default = match *cattrs.default() {\n        attr::Default::Default => Some(quote!(\n            let __default: Self::Value = _serde::export::Default::default();\n        )),\n        attr::Default::Path(ref path) => Some(quote!(\n            let __default: Self::Value = #path();\n        )),\n        attr::Default::None => {\n            // We don't need the default value, to prevent an unused variable warning\n            // we'll leave the line empty.\n            None\n        }\n    };\n\n    quote_block! {\n        #let_default\n        #(#let_values)*\n        _serde::export::Ok(#result)\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_seq_in_place(\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n    expecting: &str,\n) -> Fragment {\n    let deserialized_count = fields\n        .iter()\n        .filter(|field| !field.attrs.skip_deserializing())\n        .count();\n    let expecting = if deserialized_count == 1 {\n        format!(\"{} with 1 element\", expecting)\n    } else {\n        format!(\"{} with {} elements\", expecting, deserialized_count)\n    };\n\n    let mut index_in_seq = 0usize;\n    let write_values = fields.iter().map(|field| {\n        let member = &field.member;\n\n        if field.attrs.skip_deserializing() {\n            let default = Expr(expr_is_missing(field, cattrs));\n            quote! {\n                self.place.#member = #default;\n            }\n        } else {\n            let value_if_none = match *field.attrs.default() {\n                attr::Default::Default => quote!(\n                    self.place.#member = _serde::export::Default::default();\n                ),\n                attr::Default::Path(ref path) => quote!(\n                    self.place.#member = #path();\n                ),\n                attr::Default::None => quote!(\n                    return _serde::export::Err(_serde::de::Error::invalid_length(#index_in_seq, &#expecting));\n                ),\n            };\n            let write = match field.attrs.deserialize_with() {\n                None => {\n                    quote! {\n                        if let _serde::export::None = try!(_serde::de::SeqAccess::next_element_seed(&mut __seq,\n                            _serde::private::de::InPlaceSeed(&mut self.place.#member)))\n                        {\n                            #value_if_none\n                        }\n                    }\n                }\n                Some(path) => {\n                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n                    quote!({\n                        #wrapper\n                        match try!(_serde::de::SeqAccess::next_element::<#wrapper_ty>(&mut __seq)) {\n                            _serde::export::Some(__wrap) => {\n                                self.place.#member = __wrap.value;\n                            }\n                            _serde::export::None => {\n                                #value_if_none\n                            }\n                        }\n                    })\n                }\n            };\n            index_in_seq += 1;\n            write\n        }\n    });\n\n    let this = &params.this;\n    let (_, ty_generics, _) = params.generics.split_for_impl();\n    let let_default = match *cattrs.default() {\n        attr::Default::Default => Some(quote!(\n            let __default: #this #ty_generics  = _serde::export::Default::default();\n        )),\n        attr::Default::Path(ref path) => Some(quote!(\n            let __default: #this #ty_generics  = #path();\n        )),\n        attr::Default::None => {\n            // We don't need the default value, to prevent an unused variable warning\n            // we'll leave the line empty.\n            None\n        }\n    };\n\n    quote_block! {\n        #let_default\n        #(#write_values)*\n        _serde::export::Ok(())\n    }\n}\n\nfn deserialize_newtype_struct(\n    type_path: &TokenStream,\n    params: &Parameters,\n    field: &Field,\n) -> TokenStream {\n    let delife = params.borrowed.de_lifetime();\n    let field_ty = field.ty;\n\n    let value = match field.attrs.deserialize_with() {\n        None => {\n            let span = field.original.span();\n            let func = quote_spanned!(span=> <#field_ty as _serde::Deserialize>::deserialize);\n            quote! {\n                try!(#func(__e))\n            }\n        }\n        Some(path) => {\n            quote! {\n                try!(#path(__e))\n            }\n        }\n    };\n\n    let mut result = quote!(#type_path(__field0));\n    if params.has_getter {\n        let this = &params.this;\n        result = quote! {\n            _serde::export::Into::<#this>::into(#result)\n        };\n    }\n\n    quote! {\n        #[inline]\n        fn visit_newtype_struct<__E>(self, __e: __E) -> _serde::export::Result<Self::Value, __E::Error>\n        where\n            __E: _serde::Deserializer<#delife>,\n        {\n            let __field0: #field_ty = #value;\n            _serde::export::Ok(#result)\n        }\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_newtype_struct_in_place(params: &Parameters, field: &Field) -> TokenStream {\n    // We do not generate deserialize_in_place if every field has a\n    // deserialize_with.\n    assert!(field.attrs.deserialize_with().is_none());\n\n    let delife = params.borrowed.de_lifetime();\n\n    quote! {\n        #[inline]\n        fn visit_newtype_struct<__E>(self, __e: __E) -> _serde::export::Result<Self::Value, __E::Error>\n        where\n            __E: _serde::Deserializer<#delife>,\n        {\n            _serde::Deserialize::deserialize_in_place(__e, &mut self.place.0)\n        }\n    }\n}\n\nenum Untagged {\n    Yes,\n    No,\n}\n\nfn deserialize_struct(\n    variant_ident: Option<&syn::Ident>,\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n    deserializer: Option<TokenStream>,\n    untagged: &Untagged,\n) -> Fragment {\n    let is_enum = variant_ident.is_some();\n\n    let this = &params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    // If there are getters (implying private fields), construct the local type\n    // and use an `Into` conversion to get the remote type. If there are no\n    // getters then construct the target type directly.\n    let construct = if params.has_getter {\n        let local = &params.local;\n        quote!(#local)\n    } else {\n        quote!(#this)\n    };\n\n    let type_path = match variant_ident {\n        Some(ref variant_ident) => quote!(#construct::#variant_ident),\n        None => construct,\n    };\n    let expecting = match variant_ident {\n        Some(variant_ident) => format!(\"struct variant {}::{}\", params.type_name(), variant_ident),\n        None => format!(\"struct {}\", params.type_name()),\n    };\n\n    let visit_seq = Stmts(deserialize_seq(\n        &type_path, params, fields, true, cattrs, &expecting,\n    ));\n\n    let (field_visitor, fields_stmt, visit_map) = if cattrs.has_flatten() {\n        deserialize_struct_as_map_visitor(&type_path, params, fields, cattrs)\n    } else {\n        deserialize_struct_as_struct_visitor(&type_path, params, fields, cattrs)\n    };\n    let field_visitor = Stmts(field_visitor);\n    let fields_stmt = fields_stmt.map(Stmts);\n    let visit_map = Stmts(visit_map);\n\n    let visitor_expr = quote! {\n        __Visitor {\n            marker: _serde::export::PhantomData::<#this #ty_generics>,\n            lifetime: _serde::export::PhantomData,\n        }\n    };\n    let dispatch = if let Some(deserializer) = deserializer {\n        quote! {\n            _serde::Deserializer::deserialize_any(#deserializer, #visitor_expr)\n        }\n    } else if is_enum && cattrs.has_flatten() {\n        quote! {\n            _serde::de::VariantAccess::newtype_variant_seed(__variant, #visitor_expr)\n        }\n    } else if is_enum {\n        quote! {\n            _serde::de::VariantAccess::struct_variant(__variant, FIELDS, #visitor_expr)\n        }\n    } else if cattrs.has_flatten() {\n        quote! {\n            _serde::Deserializer::deserialize_map(__deserializer, #visitor_expr)\n        }\n    } else {\n        let type_name = cattrs.name().deserialize_name();\n        quote! {\n            _serde::Deserializer::deserialize_struct(__deserializer, #type_name, FIELDS, #visitor_expr)\n        }\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let visitor_var = if all_skipped {\n        quote!(_)\n    } else {\n        quote!(mut __seq)\n    };\n\n    // untagged struct variants do not get a visit_seq method. The same applies to\n    // structs that only have a map representation.\n    let visit_seq = match *untagged {\n        Untagged::No if !cattrs.has_flatten() => Some(quote! {\n            #[inline]\n            fn visit_seq<__A>(self, #visitor_var: __A) -> _serde::export::Result<Self::Value, __A::Error>\n            where\n                __A: _serde::de::SeqAccess<#delife>,\n            {\n                #visit_seq\n            }\n        }),\n        _ => None,\n    };\n\n    let visitor_seed = if is_enum && cattrs.has_flatten() {\n        Some(quote! {\n            impl #de_impl_generics _serde::de::DeserializeSeed<#delife> for __Visitor #de_ty_generics #where_clause {\n                type Value = #this #ty_generics;\n\n                fn deserialize<__D>(self, __deserializer: __D) -> _serde::export::Result<Self::Value, __D::Error>\n                where\n                    __D: _serde::Deserializer<'de>,\n                {\n                    _serde::Deserializer::deserialize_map(__deserializer, self)\n                }\n            }\n        })\n    } else {\n        None\n    };\n\n    quote_block! {\n        #field_visitor\n\n        struct __Visitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData<#this #ty_generics>,\n            lifetime: _serde::export::PhantomData<&#delife ()>,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor<#delife> for __Visitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn expecting(&self, __formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #visit_seq\n\n            #[inline]\n            fn visit_map<__A>(self, mut __map: __A) -> _serde::export::Result<Self::Value, __A::Error>\n            where\n                __A: _serde::de::MapAccess<#delife>,\n            {\n                #visit_map\n            }\n        }\n\n        #visitor_seed\n\n        #fields_stmt\n\n        #dispatch\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_struct_in_place(\n    variant_ident: Option<syn::Ident>,\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n    deserializer: Option<TokenStream>,\n) -> Option<Fragment> {\n    let is_enum = variant_ident.is_some();\n\n    // for now we do not support in_place deserialization for structs that\n    // are represented as map.\n    if cattrs.has_flatten() {\n        return None;\n    }\n\n    let this = &params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    let expecting = match variant_ident {\n        Some(variant_ident) => format!(\"struct variant {}::{}\", params.type_name(), variant_ident),\n        None => format!(\"struct {}\", params.type_name()),\n    };\n\n    let visit_seq = Stmts(deserialize_seq_in_place(params, fields, cattrs, &expecting));\n\n    let (field_visitor, fields_stmt, visit_map) =\n        deserialize_struct_as_struct_in_place_visitor(params, fields, cattrs);\n\n    let field_visitor = Stmts(field_visitor);\n    let fields_stmt = Stmts(fields_stmt);\n    let visit_map = Stmts(visit_map);\n\n    let visitor_expr = quote! {\n        __Visitor {\n            place: __place,\n            lifetime: _serde::export::PhantomData,\n        }\n    };\n    let dispatch = if let Some(deserializer) = deserializer {\n        quote! {\n            _serde::Deserializer::deserialize_any(#deserializer, #visitor_expr)\n        }\n    } else if is_enum {\n        quote! {\n            _serde::de::VariantAccess::struct_variant(__variant, FIELDS, #visitor_expr)\n        }\n    } else {\n        let type_name = cattrs.name().deserialize_name();\n        quote! {\n            _serde::Deserializer::deserialize_struct(__deserializer, #type_name, FIELDS, #visitor_expr)\n        }\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let visitor_var = if all_skipped {\n        quote!(_)\n    } else {\n        quote!(mut __seq)\n    };\n\n    let visit_seq = quote! {\n        #[inline]\n        fn visit_seq<__A>(self, #visitor_var: __A) -> _serde::export::Result<Self::Value, __A::Error>\n        where\n            __A: _serde::de::SeqAccess<#delife>,\n        {\n            #visit_seq\n        }\n    };\n\n    let in_place_impl_generics = de_impl_generics.in_place();\n    let in_place_ty_generics = de_ty_generics.in_place();\n    let place_life = place_lifetime();\n\n    Some(quote_block! {\n        #field_visitor\n\n        struct __Visitor #in_place_impl_generics #where_clause {\n            place: &#place_life mut #this #ty_generics,\n            lifetime: _serde::export::PhantomData<&#delife ()>,\n        }\n\n        impl #in_place_impl_generics _serde::de::Visitor<#delife> for __Visitor #in_place_ty_generics #where_clause {\n            type Value = ();\n\n            fn expecting(&self, __formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #visit_seq\n\n            #[inline]\n            fn visit_map<__A>(self, mut __map: __A) -> _serde::export::Result<Self::Value, __A::Error>\n            where\n                __A: _serde::de::MapAccess<#delife>,\n            {\n                #visit_map\n            }\n        }\n\n        #fields_stmt\n\n        #dispatch\n    })\n}\n\nfn deserialize_enum(\n    params: &Parameters,\n    variants: &[Variant],\n    cattrs: &attr::Container,\n) -> Fragment {\n    match *cattrs.tag() {\n        attr::TagType::External => deserialize_externally_tagged_enum(params, variants, cattrs),\n        attr::TagType::Internal { ref tag } => {\n            deserialize_internally_tagged_enum(params, variants, cattrs, tag)\n        }\n        attr::TagType::Adjacent {\n            ref tag,\n            ref content,\n        } => deserialize_adjacently_tagged_enum(params, variants, cattrs, tag, content),\n        attr::TagType::None => deserialize_untagged_enum(params, variants, cattrs),\n    }\n}\n\nfn prepare_enum_variant_enum(\n    variants: &[Variant],\n    cattrs: &attr::Container,\n) -> (TokenStream, Stmts) {\n    let variant_names_idents: Vec<_> = variants\n        .iter()\n        .enumerate()\n        .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n        .map(|(i, variant)| {\n            (\n                variant.attrs.name().deserialize_name(),\n                field_i(i),\n                variant.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let other_idx = variants\n        .iter()\n        .position(|ref variant| variant.attrs.other());\n\n    let variants_stmt = {\n        let variant_names = variant_names_idents.iter().map(|&(ref name, _, _)| name);\n        quote! {\n            const VARIANTS: &'static [&'static str] = &[ #(#variant_names),* ];\n        }\n    };\n\n    let variant_visitor = Stmts(deserialize_generated_identifier(\n        &variant_names_idents,\n        cattrs,\n        true,\n        other_idx,\n    ));\n\n    (variants_stmt, variant_visitor)\n}\n\nfn deserialize_externally_tagged_enum(\n    params: &Parameters,\n    variants: &[Variant],\n    cattrs: &attr::Container,\n) -> Fragment {\n    let this = &params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    let type_name = cattrs.name().deserialize_name();\n    let expecting = format!(\"enum {}\", params.type_name());\n\n    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n\n    // Match arms to extract a variant from a string\n    let variant_arms = variants\n        .iter()\n        .enumerate()\n        .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n        .map(|(i, variant)| {\n            let variant_name = field_i(i);\n\n            let block = Match(deserialize_externally_tagged_variant(\n                params, variant, cattrs,\n            ));\n\n            quote! {\n                (__Field::#variant_name, __variant) => #block\n            }\n        });\n\n    let all_skipped = variants\n        .iter()\n        .all(|variant| variant.attrs.skip_deserializing());\n    let match_variant = if all_skipped {\n        // This is an empty enum like `enum Impossible {}` or an enum in which\n        // all variants have `#[serde(skip_deserializing)]`.\n        quote! {\n            // FIXME: Once we drop support for Rust 1.15:\n            // let _serde::export::Err(__err) = _serde::de::EnumAccess::variant::<__Field>(__data);\n            // _serde::export::Err(__err)\n            _serde::export::Result::map(\n                _serde::de::EnumAccess::variant::<__Field>(__data),\n                |(__impossible, _)| match __impossible {})\n        }\n    } else {\n        quote! {\n            match try!(_serde::de::EnumAccess::variant(__data)) {\n                #(#variant_arms)*\n            }\n        }\n    };\n\n    quote_block! {\n        #variant_visitor\n\n        struct __Visitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData<#this #ty_generics>,\n            lifetime: _serde::export::PhantomData<&#delife ()>,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor<#delife> for __Visitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn expecting(&self, __formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            fn visit_enum<__A>(self, __data: __A) -> _serde::export::Result<Self::Value, __A::Error>\n            where\n                __A: _serde::de::EnumAccess<#delife>,\n            {\n                #match_variant\n            }\n        }\n\n        #variants_stmt\n\n        _serde::Deserializer::deserialize_enum(\n            __deserializer,\n            #type_name,\n            VARIANTS,\n            __Visitor {\n                marker: _serde::export::PhantomData::<#this #ty_generics>,\n                lifetime: _serde::export::PhantomData,\n            },\n        )\n    }\n}\n\nfn deserialize_internally_tagged_enum(\n    params: &Parameters,\n    variants: &[Variant],\n    cattrs: &attr::Container,\n    tag: &str,\n) -> Fragment {\n    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n\n    // Match arms to extract a variant from a string\n    let variant_arms = variants\n        .iter()\n        .enumerate()\n        .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n        .map(|(i, variant)| {\n            let variant_name = field_i(i);\n\n            let block = Match(deserialize_internally_tagged_variant(\n                params,\n                variant,\n                cattrs,\n                quote! {\n                    _serde::private::de::ContentDeserializer::<__D::Error>::new(__tagged.content)\n                },\n            ));\n\n            quote! {\n                __Field::#variant_name => #block\n            }\n        });\n\n    quote_block! {\n        #variant_visitor\n\n        #variants_stmt\n\n        let __tagged = try!(_serde::Deserializer::deserialize_any(\n            __deserializer,\n            _serde::private::de::TaggedContentVisitor::<__Field>::new(#tag)));\n\n        match __tagged.tag {\n            #(#variant_arms)*\n        }\n    }\n}\n\nfn deserialize_adjacently_tagged_enum(\n    params: &Parameters,\n    variants: &[Variant],\n    cattrs: &attr::Container,\n    tag: &str,\n    content: &str,\n) -> Fragment {\n    let this = &params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n\n    let variant_arms: &Vec<_> = &variants\n        .iter()\n        .enumerate()\n        .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n        .map(|(i, variant)| {\n            let variant_index = field_i(i);\n\n            let block = Match(deserialize_untagged_variant(\n                params,\n                variant,\n                cattrs,\n                quote!(__deserializer),\n            ));\n\n            quote! {\n                __Field::#variant_index => #block\n            }\n        })\n        .collect();\n\n    let expecting = format!(\"adjacently tagged enum {}\", params.type_name());\n    let type_name = cattrs.name().deserialize_name();\n    let deny_unknown_fields = cattrs.deny_unknown_fields();\n\n    // If unknown fields are allowed, we pick the visitor that can step over\n    // those. Otherwise we pick the visitor that fails on unknown keys.\n    let field_visitor_ty = if deny_unknown_fields {\n        quote! { _serde::private::de::TagOrContentFieldVisitor }\n    } else {\n        quote! { _serde::private::de::TagContentOtherFieldVisitor }\n    };\n\n    let tag_or_content = quote! {\n        #field_visitor_ty {\n            tag: #tag,\n            content: #content,\n        }\n    };\n\n    fn is_unit(variant: &Variant) -> bool {\n        match variant.style {\n            Style::Unit => true,\n            Style::Struct | Style::Tuple | Style::Newtype => false,\n        }\n    }\n\n    let mut missing_content = quote! {\n        _serde::export::Err(<__A::Error as _serde::de::Error>::missing_field(#content))\n    };\n    if variants.iter().any(is_unit) {\n        let fallthrough = if variants.iter().all(is_unit) {\n            None\n        } else {\n            Some(quote! {\n                _ => #missing_content\n            })\n        };\n        let arms = variants\n            .iter()\n            .enumerate()\n            .filter(|&(_, variant)| !variant.attrs.skip_deserializing() && is_unit(variant))\n            .map(|(i, variant)| {\n                let variant_index = field_i(i);\n                let variant_ident = &variant.ident;\n                quote! {\n                    __Field::#variant_index => _serde::export::Ok(#this::#variant_ident),\n                }\n            });\n        missing_content = quote! {\n            match __field {\n                #(#arms)*\n                #fallthrough\n            }\n        };\n    }\n\n    // Advance the map by one key, returning early in case of error.\n    let next_key = quote! {\n        try!(_serde::de::MapAccess::next_key_seed(&mut __map, #tag_or_content))\n    };\n\n    // When allowing unknown fields, we want to transparently step through keys\n    // we don't care about until we find `tag`, `content`, or run out of keys.\n    let next_relevant_key = if deny_unknown_fields {\n        next_key\n    } else {\n        quote!({\n            let mut __rk : _serde::export::Option<_serde::private::de::TagOrContentField> = _serde::export::None;\n            while let _serde::export::Some(__k) = #next_key {\n                match __k {\n                    _serde::private::de::TagContentOtherField::Other => {\n                        try!(_serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map));\n                        continue;\n                    },\n                    _serde::private::de::TagContentOtherField::Tag => {\n                        __rk = _serde::export::Some(_serde::private::de::TagOrContentField::Tag);\n                        break;\n                    }\n                    _serde::private::de::TagContentOtherField::Content => {\n                        __rk = _serde::export::Some(_serde::private::de::TagOrContentField::Content);\n                        break;\n                    }\n                }\n            }\n\n            __rk\n        })\n    };\n\n    // Step through remaining keys, looking for duplicates of previously-seen\n    // keys. When unknown fields are denied, any key that isn't a duplicate will\n    // at this point immediately produce an error.\n    let visit_remaining_keys = quote! {\n        match #next_relevant_key {\n            _serde::export::Some(_serde::private::de::TagOrContentField::Tag) => {\n                _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#tag))\n            }\n            _serde::export::Some(_serde::private::de::TagOrContentField::Content) => {\n                _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#content))\n            }\n            _serde::export::None => _serde::export::Ok(__ret),\n        }\n    };\n\n    let finish_content_then_tag = if variant_arms.is_empty() {\n        quote! {\n            match try!(_serde::de::MapAccess::next_value::<__Field>(&mut __map)) {}\n        }\n    } else {\n        quote! {\n            let __ret = try!(match try!(_serde::de::MapAccess::next_value(&mut __map)) {\n                // Deserialize the buffered content now that we know the variant.\n                #(#variant_arms)*\n            });\n            // Visit remaining keys, looking for duplicates.\n            #visit_remaining_keys\n        }\n    };\n\n    quote_block! {\n        #variant_visitor\n\n        #variants_stmt\n\n        struct __Seed #de_impl_generics #where_clause {\n            field: __Field,\n            marker: _serde::export::PhantomData<#this #ty_generics>,\n            lifetime: _serde::export::PhantomData<&#delife ()>,\n        }\n\n        impl #de_impl_generics _serde::de::DeserializeSeed<#delife> for __Seed #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn deserialize<__D>(self, __deserializer: __D) -> _serde::export::Result<Self::Value, __D::Error>\n            where\n                __D: _serde::Deserializer<#delife>,\n            {\n                match self.field {\n                    #(#variant_arms)*\n                }\n            }\n        }\n\n        struct __Visitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData<#this #ty_generics>,\n            lifetime: _serde::export::PhantomData<&#delife ()>,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor<#delife> for __Visitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn expecting(&self, __formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            fn visit_map<__A>(self, mut __map: __A) -> _serde::export::Result<Self::Value, __A::Error>\n            where\n                __A: _serde::de::MapAccess<#delife>,\n            {\n                // Visit the first relevant key.\n                match #next_relevant_key {\n                    // First key is the tag.\n                    _serde::export::Some(_serde::private::de::TagOrContentField::Tag) => {\n                        // Parse the tag.\n                        let __field = try!(_serde::de::MapAccess::next_value(&mut __map));\n                        // Visit the second key.\n                        match #next_relevant_key {\n                            // Second key is a duplicate of the tag.\n                            _serde::export::Some(_serde::private::de::TagOrContentField::Tag) => {\n                                _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#tag))\n                            }\n                            // Second key is the content.\n                            _serde::export::Some(_serde::private::de::TagOrContentField::Content) => {\n                                let __ret = try!(_serde::de::MapAccess::next_value_seed(&mut __map,\n                                    __Seed {\n                                        field: __field,\n                                        marker: _serde::export::PhantomData,\n                                        lifetime: _serde::export::PhantomData,\n                                    }));\n                                // Visit remaining keys, looking for duplicates.\n                                #visit_remaining_keys\n                            }\n                            // There is no second key; might be okay if the we have a unit variant.\n                            _serde::export::None => #missing_content\n                        }\n                    }\n                    // First key is the content.\n                    _serde::export::Some(_serde::private::de::TagOrContentField::Content) => {\n                        // Buffer up the content.\n                        let __content = try!(_serde::de::MapAccess::next_value::<_serde::private::de::Content>(&mut __map));\n                        // Visit the second key.\n                        match #next_relevant_key {\n                            // Second key is the tag.\n                            _serde::export::Some(_serde::private::de::TagOrContentField::Tag) => {\n                                let __deserializer = _serde::private::de::ContentDeserializer::<__A::Error>::new(__content);\n                                #finish_content_then_tag\n                            }\n                            // Second key is a duplicate of the content.\n                            _serde::export::Some(_serde::private::de::TagOrContentField::Content) => {\n                                _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#content))\n                            }\n                            // There is no second key.\n                            _serde::export::None => {\n                                _serde::export::Err(<__A::Error as _serde::de::Error>::missing_field(#tag))\n                            }\n                        }\n                    }\n                    // There is no first key.\n                    _serde::export::None => {\n                        _serde::export::Err(<__A::Error as _serde::de::Error>::missing_field(#tag))\n                    }\n                }\n            }\n\n            fn visit_seq<__A>(self, mut __seq: __A) -> _serde::export::Result<Self::Value, __A::Error>\n            where\n                __A: _serde::de::SeqAccess<#delife>,\n            {\n                // Visit the first element - the tag.\n                match try!(_serde::de::SeqAccess::next_element(&mut __seq)) {\n                    _serde::export::Some(__field) => {\n                        // Visit the second element - the content.\n                        match try!(_serde::de::SeqAccess::next_element_seed(\n                            &mut __seq,\n                            __Seed {\n                                field: __field,\n                                marker: _serde::export::PhantomData,\n                                lifetime: _serde::export::PhantomData,\n                            },\n                        )) {\n                            _serde::export::Some(__ret) => _serde::export::Ok(__ret),\n                            // There is no second element.\n                            _serde::export::None => {\n                                _serde::export::Err(_serde::de::Error::invalid_length(1, &self))\n                            }\n                        }\n                    }\n                    // There is no first element.\n                    _serde::export::None => {\n                        _serde::export::Err(_serde::de::Error::invalid_length(0, &self))\n                    }\n                }\n            }\n        }\n\n        const FIELDS: &'static [&'static str] = &[#tag, #content];\n        _serde::Deserializer::deserialize_struct(\n            __deserializer,\n            #type_name,\n            FIELDS,\n            __Visitor {\n                marker: _serde::export::PhantomData::<#this #ty_generics>,\n                lifetime: _serde::export::PhantomData,\n            },\n        )\n    }\n}\n\nfn deserialize_untagged_enum(\n    params: &Parameters,\n    variants: &[Variant],\n    cattrs: &attr::Container,\n) -> Fragment {\n    let attempts = variants\n        .iter()\n        .filter(|variant| !variant.attrs.skip_deserializing())\n        .map(|variant| {\n            Expr(deserialize_untagged_variant(\n                params,\n                variant,\n                cattrs,\n                quote!(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content)),\n            ))\n        });\n\n    // TODO this message could be better by saving the errors from the failed\n    // attempts. The heuristic used by TOML was to count the number of fields\n    // processed before an error, and use the error that happened after the\n    // largest number of fields. I'm not sure I like that. Maybe it would be\n    // better to save all the errors and combine them into one message that\n    // explains why none of the variants matched.\n    let fallthrough_msg = format!(\n        \"data did not match any variant of untagged enum {}\",\n        params.type_name()\n    );\n\n    quote_block! {\n        let __content = try!(<_serde::private::de::Content as _serde::Deserialize>::deserialize(__deserializer));\n\n        #(\n            if let _serde::export::Ok(__ok) = #attempts {\n                return _serde::export::Ok(__ok);\n            }\n        )*\n\n        _serde::export::Err(_serde::de::Error::custom(#fallthrough_msg))\n    }\n}\n\nfn deserialize_externally_tagged_variant(\n    params: &Parameters,\n    variant: &Variant,\n    cattrs: &attr::Container,\n) -> Fragment {\n    if let Some(path) = variant.attrs.deserialize_with() {\n        let (wrapper, wrapper_ty, unwrap_fn) = wrap_deserialize_variant_with(params, variant, path);\n        return quote_block! {\n            #wrapper\n            _serde::export::Result::map(\n                _serde::de::VariantAccess::newtype_variant::<#wrapper_ty>(__variant), #unwrap_fn)\n        };\n    }\n\n    let variant_ident = &variant.ident;\n\n    match variant.style {\n        Style::Unit => {\n            let this = &params.this;\n            quote_block! {\n                try!(_serde::de::VariantAccess::unit_variant(__variant));\n                _serde::export::Ok(#this::#variant_ident)\n            }\n        }\n        Style::Newtype => {\n            deserialize_externally_tagged_newtype_variant(variant_ident, params, &variant.fields[0])\n        }\n        Style::Tuple => {\n            deserialize_tuple(Some(variant_ident), params, &variant.fields, cattrs, None)\n        }\n        Style::Struct => deserialize_struct(\n            Some(variant_ident),\n            params,\n            &variant.fields,\n            cattrs,\n            None,\n            &Untagged::No,\n        ),\n    }\n}\n\nfn deserialize_internally_tagged_variant(\n    params: &Parameters,\n    variant: &Variant,\n    cattrs: &attr::Container,\n    deserializer: TokenStream,\n) -> Fragment {\n    if variant.attrs.deserialize_with().is_some() {\n        return deserialize_untagged_variant(params, variant, cattrs, deserializer);\n    }\n\n    let variant_ident = &variant.ident;\n\n    match variant.style {\n        Style::Unit => {\n            let this = &params.this;\n            let type_name = params.type_name();\n            let variant_name = variant.ident.to_string();\n            quote_block! {\n                try!(_serde::Deserializer::deserialize_any(#deserializer, _serde::private::de::InternallyTaggedUnitVisitor::new(#type_name, #variant_name)));\n                _serde::export::Ok(#this::#variant_ident)\n            }\n        }\n        Style::Newtype => deserialize_untagged_newtype_variant(\n            variant_ident,\n            params,\n            &variant.fields[0],\n            &deserializer,\n        ),\n        Style::Struct => deserialize_struct(\n            Some(variant_ident),\n            params,\n            &variant.fields,\n            cattrs,\n            Some(deserializer),\n            &Untagged::No,\n        ),\n        Style::Tuple => unreachable!(\"checked in serde_derive_internals\"),\n    }\n}\n\nfn deserialize_untagged_variant(\n    params: &Parameters,\n    variant: &Variant,\n    cattrs: &attr::Container,\n    deserializer: TokenStream,\n) -> Fragment {\n    if let Some(path) = variant.attrs.deserialize_with() {\n        let (wrapper, wrapper_ty, unwrap_fn) = wrap_deserialize_variant_with(params, variant, path);\n        return quote_block! {\n            #wrapper\n            _serde::export::Result::map(\n                <#wrapper_ty as _serde::Deserialize>::deserialize(#deserializer), #unwrap_fn)\n        };\n    }\n\n    let variant_ident = &variant.ident;\n\n    match variant.style {\n        Style::Unit => {\n            let this = &params.this;\n            let type_name = params.type_name();\n            let variant_name = variant.ident.to_string();\n            quote_expr! {\n                match _serde::Deserializer::deserialize_any(\n                    #deserializer,\n                    _serde::private::de::UntaggedUnitVisitor::new(#type_name, #variant_name)\n                ) {\n                    _serde::export::Ok(()) => _serde::export::Ok(#this::#variant_ident),\n                    _serde::export::Err(__err) => _serde::export::Err(__err),\n                }\n            }\n        }\n        Style::Newtype => deserialize_untagged_newtype_variant(\n            variant_ident,\n            params,\n            &variant.fields[0],\n            &deserializer,\n        ),\n        Style::Tuple => deserialize_tuple(\n            Some(variant_ident),\n            params,\n            &variant.fields,\n            cattrs,\n            Some(deserializer),\n        ),\n        Style::Struct => deserialize_struct(\n            Some(variant_ident),\n            params,\n            &variant.fields,\n            cattrs,\n            Some(deserializer),\n            &Untagged::Yes,\n        ),\n    }\n}\n\nfn deserialize_externally_tagged_newtype_variant(\n    variant_ident: &syn::Ident,\n    params: &Parameters,\n    field: &Field,\n) -> Fragment {\n    let this = &params.this;\n    match field.attrs.deserialize_with() {\n        None => {\n            let field_ty = field.ty;\n            let span = field.original.span();\n            let func =\n                quote_spanned!(span=> _serde::de::VariantAccess::newtype_variant::<#field_ty>);\n            quote_expr! {\n                _serde::export::Result::map(#func(__variant), #this::#variant_ident)\n            }\n        }\n        Some(path) => {\n            let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n            quote_block! {\n                #wrapper\n                _serde::export::Result::map(\n                    _serde::de::VariantAccess::newtype_variant::<#wrapper_ty>(__variant),\n                    |__wrapper| #this::#variant_ident(__wrapper.value))\n            }\n        }\n    }\n}\n\nfn deserialize_untagged_newtype_variant(\n    variant_ident: &syn::Ident,\n    params: &Parameters,\n    field: &Field,\n    deserializer: &TokenStream,\n) -> Fragment {\n    let this = &params.this;\n    let field_ty = field.ty;\n    match field.attrs.deserialize_with() {\n        None => {\n            let span = field.original.span();\n            let func = quote_spanned!(span=> <#field_ty as _serde::Deserialize>::deserialize);\n            quote_expr! {\n                _serde::export::Result::map(#func(#deserializer), #this::#variant_ident)\n            }\n        }\n        Some(path) => {\n            quote_block! {\n                let __value: _serde::export::Result<#field_ty, _> = #path(#deserializer);\n                _serde::export::Result::map(__value, #this::#variant_ident)\n            }\n        }\n    }\n}\n\nfn deserialize_generated_identifier(\n    fields: &[(String, Ident, Vec<String>)],\n    cattrs: &attr::Container,\n    is_variant: bool,\n    other_idx: Option<usize>,\n) -> Fragment {\n    let this = quote!(__Field);\n    let field_idents: &Vec<_> = &fields.iter().map(|&(_, ref ident, _)| ident).collect();\n\n    let (ignore_variant, fallthrough) = if !is_variant && cattrs.has_flatten() {\n        let ignore_variant = quote!(__other(_serde::private::de::Content<'de>),);\n        let fallthrough = quote!(_serde::export::Ok(__Field::__other(__value)));\n        (Some(ignore_variant), Some(fallthrough))\n    } else if let Some(other_idx) = other_idx {\n        let ignore_variant = fields[other_idx].1.clone();\n        let fallthrough = quote!(_serde::export::Ok(__Field::#ignore_variant));\n        (None, Some(fallthrough))\n    } else if is_variant || cattrs.deny_unknown_fields() {\n        (None, None)\n    } else {\n        let ignore_variant = quote!(__ignore,);\n        let fallthrough = quote!(_serde::export::Ok(__Field::__ignore));\n        (Some(ignore_variant), Some(fallthrough))\n    };\n\n    let visitor_impl = Stmts(deserialize_identifier(\n        &this,\n        fields,\n        is_variant,\n        fallthrough,\n        !is_variant && cattrs.has_flatten(),\n    ));\n\n    let lifetime = if !is_variant && cattrs.has_flatten() {\n        Some(quote!(<'de>))\n    } else {\n        None\n    };\n\n    quote_block! {\n        #[allow(non_camel_case_types)]\n        enum __Field #lifetime {\n            #(#field_idents,)*\n            #ignore_variant\n        }\n\n        struct __FieldVisitor;\n\n        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {\n            type Value = __Field #lifetime;\n\n            #visitor_impl\n        }\n\n        impl<'de> _serde::Deserialize<'de> for __Field #lifetime {\n            #[inline]\n            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>\n            where\n                __D: _serde::Deserializer<'de>,\n            {\n                _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)\n            }\n        }\n    }\n}\n\nfn deserialize_custom_identifier(\n    params: &Parameters,\n    variants: &[Variant],\n    cattrs: &attr::Container,\n) -> Fragment {\n    let is_variant = match cattrs.identifier() {\n        attr::Identifier::Variant => true,\n        attr::Identifier::Field => false,\n        attr::Identifier::No => unreachable!(),\n    };\n\n    let this = &params.this;\n    let this = quote!(#this);\n\n    let (ordinary, fallthrough) = if let Some(last) = variants.last() {\n        let last_ident = &last.ident;\n        if last.attrs.other() {\n            let ordinary = &variants[..variants.len() - 1];\n            let fallthrough = quote!(_serde::export::Ok(#this::#last_ident));\n            (ordinary, Some(fallthrough))\n        } else if let Style::Newtype = last.style {\n            let ordinary = &variants[..variants.len() - 1];\n            let deserializer = quote!(_serde::private::de::IdentifierDeserializer::from(__value));\n            let fallthrough = quote! {\n                _serde::export::Result::map(\n                    _serde::Deserialize::deserialize(#deserializer),\n                    #this::#last_ident)\n            };\n            (ordinary, Some(fallthrough))\n        } else {\n            (variants, None)\n        }\n    } else {\n        (variants, None)\n    };\n\n    let names_idents: Vec<_> = ordinary\n        .iter()\n        .map(|variant| {\n            (\n                variant.attrs.name().deserialize_name(),\n                variant.ident.clone(),\n                variant.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let names = names_idents.iter().map(|&(ref name, _, _)| name);\n\n    let names_const = if fallthrough.is_some() {\n        None\n    } else if is_variant {\n        let variants = quote! {\n            const VARIANTS: &'static [&'static str] = &[ #(#names),* ];\n        };\n        Some(variants)\n    } else {\n        let fields = quote! {\n            const FIELDS: &'static [&'static str] = &[ #(#names),* ];\n        };\n        Some(fields)\n    };\n\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n    let visitor_impl = Stmts(deserialize_identifier(\n        &this,\n        &names_idents,\n        is_variant,\n        fallthrough,\n        false,\n    ));\n\n    quote_block! {\n        #names_const\n\n        struct __FieldVisitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData<#this #ty_generics>,\n            lifetime: _serde::export::PhantomData<&#delife ()>,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor<#delife> for __FieldVisitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            #visitor_impl\n        }\n\n        let __visitor = __FieldVisitor {\n            marker: _serde::export::PhantomData::<#this #ty_generics>,\n            lifetime: _serde::export::PhantomData,\n        };\n        _serde::Deserializer::deserialize_identifier(__deserializer, __visitor)\n    }\n}\n\nfn deserialize_identifier(\n    this: &TokenStream,\n    fields: &[(String, Ident, Vec<String>)],\n    is_variant: bool,\n    fallthrough: Option<TokenStream>,\n    collect_other_fields: bool,\n) -> Fragment {\n    let mut flat_fields = Vec::new();\n    for &(_, ref ident, ref aliases) in fields {\n        flat_fields.extend(aliases.iter().map(|alias| (alias, ident)))\n    }\n\n    let field_strs = flat_fields.iter().map(|&(ref name, _)| name);\n    let field_borrowed_strs = flat_fields.iter().map(|&(ref name, _)| name);\n    let field_bytes = flat_fields\n        .iter()\n        .map(|&(ref name, _)| Literal::byte_string(name.as_bytes()));\n    let field_borrowed_bytes = flat_fields\n        .iter()\n        .map(|&(ref name, _)| Literal::byte_string(name.as_bytes()));\n\n    let constructors: &Vec<_> = &flat_fields\n        .iter()\n        .map(|&(_, ref ident)| quote!(#this::#ident))\n        .collect();\n    let main_constructors: &Vec<_> = &fields\n        .iter()\n        .map(|&(_, ref ident, _)| quote!(#this::#ident))\n        .collect();\n\n    let expecting = if is_variant {\n        \"variant identifier\"\n    } else {\n        \"field identifier\"\n    };\n\n    let index_expecting = if is_variant { \"variant\" } else { \"field\" };\n\n    let bytes_to_str = if fallthrough.is_some() || collect_other_fields {\n        None\n    } else {\n        Some(quote! {\n            let __value = &_serde::export::from_utf8_lossy(__value);\n        })\n    };\n\n    let (\n        value_as_str_content,\n        value_as_borrowed_str_content,\n        value_as_bytes_content,\n        value_as_borrowed_bytes_content,\n    ) = if collect_other_fields {\n        (\n            Some(quote! {\n                let __value = _serde::private::de::Content::String(_serde::export::ToString::to_string(__value));\n            }),\n            Some(quote! {\n                let __value = _serde::private::de::Content::Str(__value);\n            }),\n            Some(quote! {\n                let __value = _serde::private::de::Content::ByteBuf(__value.to_vec());\n            }),\n            Some(quote! {\n                let __value = _serde::private::de::Content::Bytes(__value);\n            }),\n        )\n    } else {\n        (None, None, None, None)\n    };\n\n    let fallthrough_arm = if let Some(fallthrough) = fallthrough {\n        fallthrough\n    } else if is_variant {\n        quote! {\n            _serde::export::Err(_serde::de::Error::unknown_variant(__value, VARIANTS))\n        }\n    } else {\n        quote! {\n            _serde::export::Err(_serde::de::Error::unknown_field(__value, FIELDS))\n        }\n    };\n\n    let variant_indices = 0_u64..;\n    let fallthrough_msg = format!(\"{} index 0 <= i < {}\", index_expecting, fields.len());\n    let visit_other = if collect_other_fields {\n        quote! {\n            fn visit_bool<__E>(self, __value: bool) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::Bool(__value)))\n            }\n\n            fn visit_i8<__E>(self, __value: i8) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I8(__value)))\n            }\n\n            fn visit_i16<__E>(self, __value: i16) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I16(__value)))\n            }\n\n            fn visit_i32<__E>(self, __value: i32) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I32(__value)))\n            }\n\n            fn visit_i64<__E>(self, __value: i64) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I64(__value)))\n            }\n\n            fn visit_u8<__E>(self, __value: u8) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U8(__value)))\n            }\n\n            fn visit_u16<__E>(self, __value: u16) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U16(__value)))\n            }\n\n            fn visit_u32<__E>(self, __value: u32) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U32(__value)))\n            }\n\n            fn visit_u64<__E>(self, __value: u64) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U64(__value)))\n            }\n\n            fn visit_f32<__E>(self, __value: f32) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::F32(__value)))\n            }\n\n            fn visit_f64<__E>(self, __value: f64) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::F64(__value)))\n            }\n\n            fn visit_char<__E>(self, __value: char) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::Char(__value)))\n            }\n\n            fn visit_unit<__E>(self) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::Unit))\n            }\n\n            fn visit_borrowed_str<__E>(self, __value: &'de str) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                match __value {\n                    #(\n                        #field_borrowed_strs => _serde::export::Ok(#constructors),\n                    )*\n                    _ => {\n                        #value_as_borrowed_str_content\n                        #fallthrough_arm\n                    }\n                }\n            }\n\n            fn visit_borrowed_bytes<__E>(self, __value: &'de [u8]) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                match __value {\n                    #(\n                        #field_borrowed_bytes => _serde::export::Ok(#constructors),\n                    )*\n                    _ => {\n                        #bytes_to_str\n                        #value_as_borrowed_bytes_content\n                        #fallthrough_arm\n                    }\n                }\n            }\n        }\n    } else {\n        quote! {\n            fn visit_u64<__E>(self, __value: u64) -> _serde::export::Result<Self::Value, __E>\n            where\n                __E: _serde::de::Error,\n            {\n                match __value {\n                    #(\n                        #variant_indices => _serde::export::Ok(#main_constructors),\n                    )*\n                    _ => _serde::export::Err(_serde::de::Error::invalid_value(\n                        _serde::de::Unexpected::Unsigned(__value),\n                        &#fallthrough_msg,\n                    ))\n                }\n            }\n        }\n    };\n\n    quote_block! {\n        fn expecting(&self, __formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n            _serde::export::Formatter::write_str(__formatter, #expecting)\n        }\n\n        #visit_other\n\n        fn visit_str<__E>(self, __value: &str) -> _serde::export::Result<Self::Value, __E>\n        where\n            __E: _serde::de::Error,\n        {\n            match __value {\n                #(\n                    #field_strs => _serde::export::Ok(#constructors),\n                )*\n                _ => {\n                    #value_as_str_content\n                    #fallthrough_arm\n                }\n            }\n        }\n\n        fn visit_bytes<__E>(self, __value: &[u8]) -> _serde::export::Result<Self::Value, __E>\n        where\n            __E: _serde::de::Error,\n        {\n            match __value {\n                #(\n                    #field_bytes => _serde::export::Ok(#constructors),\n                )*\n                _ => {\n                    #bytes_to_str\n                    #value_as_bytes_content\n                    #fallthrough_arm\n                }\n            }\n        }\n    }\n}\n\nfn deserialize_struct_as_struct_visitor(\n    struct_path: &TokenStream,\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n) -> (Fragment, Option<Fragment>, Fragment) {\n    assert!(!cattrs.has_flatten());\n\n    let field_names_idents: Vec<_> = fields\n        .iter()\n        .enumerate()\n        .filter(|&(_, field)| !field.attrs.skip_deserializing())\n        .map(|(i, field)| {\n            (\n                field.attrs.name().deserialize_name(),\n                field_i(i),\n                field.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let fields_stmt = {\n        let field_names = field_names_idents.iter().map(|&(ref name, _, _)| name);\n        quote_block! {\n            const FIELDS: &'static [&'static str] = &[ #(#field_names),* ];\n        }\n    };\n\n    let field_visitor = deserialize_generated_identifier(&field_names_idents, cattrs, false, None);\n\n    let visit_map = deserialize_map(struct_path, params, fields, cattrs);\n\n    (field_visitor, Some(fields_stmt), visit_map)\n}\n\nfn deserialize_struct_as_map_visitor(\n    struct_path: &TokenStream,\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n) -> (Fragment, Option<Fragment>, Fragment) {\n    let field_names_idents: Vec<_> = fields\n        .iter()\n        .enumerate()\n        .filter(|&(_, field)| !field.attrs.skip_deserializing() && !field.attrs.flatten())\n        .map(|(i, field)| {\n            (\n                field.attrs.name().deserialize_name(),\n                field_i(i),\n                field.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let field_visitor = deserialize_generated_identifier(&field_names_idents, cattrs, false, None);\n\n    let visit_map = deserialize_map(struct_path, params, fields, cattrs);\n\n    (field_visitor, None, visit_map)\n}\n\nfn deserialize_map(\n    struct_path: &TokenStream,\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n) -> Fragment {\n    // Create the field names for the fields.\n    let fields_names: Vec<_> = fields\n        .iter()\n        .enumerate()\n        .map(|(i, field)| (field, field_i(i)))\n        .collect();\n\n    // Declare each field that will be deserialized.\n    let let_values = fields_names\n        .iter()\n        .filter(|&&(field, _)| !field.attrs.skip_deserializing() && !field.attrs.flatten())\n        .map(|&(field, ref name)| {\n            let field_ty = field.ty;\n            quote! {\n                let mut #name: _serde::export::Option<#field_ty> = _serde::export::None;\n            }\n        });\n\n    // Collect contents for flatten fields into a buffer\n    let let_collect = if cattrs.has_flatten() {\n        Some(quote! {\n            let mut __collect = _serde::export::Vec::<_serde::export::Option<(\n                _serde::private::de::Content,\n                _serde::private::de::Content\n            )>>::new();\n        })\n    } else {\n        None\n    };\n\n    // Match arms to extract a value for a field.\n    let value_arms = fields_names\n        .iter()\n        .filter(|&&(field, _)| !field.attrs.skip_deserializing() && !field.attrs.flatten())\n        .map(|&(field, ref name)| {\n            let deser_name = field.attrs.name().deserialize_name();\n\n            let visit = match field.attrs.deserialize_with() {\n                None => {\n                    let field_ty = field.ty;\n                    let span = field.original.span();\n                    let func =\n                        quote_spanned!(span=> _serde::de::MapAccess::next_value::<#field_ty>);\n                    quote! {\n                        try!(#func(&mut __map))\n                    }\n                }\n                Some(path) => {\n                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n                    quote!({\n                        #wrapper\n                        match _serde::de::MapAccess::next_value::<#wrapper_ty>(&mut __map) {\n                            _serde::export::Ok(__wrapper) => __wrapper.value,\n                            _serde::export::Err(__err) => {\n                                return _serde::export::Err(__err);\n                            }\n                        }\n                    })\n                }\n            };\n            quote! {\n                __Field::#name => {\n                    if _serde::export::Option::is_some(&#name) {\n                        return _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#deser_name));\n                    }\n                    #name = _serde::export::Some(#visit);\n                }\n            }\n        });\n\n    // Visit ignored values to consume them\n    let ignored_arm = if cattrs.has_flatten() {\n        Some(quote! {\n            __Field::__other(__name) => {\n                __collect.push(_serde::export::Some((\n                    __name,\n                    try!(_serde::de::MapAccess::next_value(&mut __map)))));\n            }\n        })\n    } else if cattrs.deny_unknown_fields() {\n        None\n    } else {\n        Some(quote! {\n            _ => { let _ = try!(_serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)); }\n        })\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let match_keys = if cattrs.deny_unknown_fields() && all_skipped {\n        quote! {\n            // FIXME: Once we drop support for Rust 1.15:\n            // let _serde::export::None::<__Field> = try!(_serde::de::MapAccess::next_key(&mut __map));\n            _serde::export::Option::map(\n                try!(_serde::de::MapAccess::next_key::<__Field>(&mut __map)),\n                |__impossible| match __impossible {});\n        }\n    } else {\n        quote! {\n            while let _serde::export::Some(__key) = try!(_serde::de::MapAccess::next_key::<__Field>(&mut __map)) {\n                match __key {\n                    #(#value_arms)*\n                    #ignored_arm\n                }\n            }\n        }\n    };\n\n    let extract_values = fields_names\n        .iter()\n        .filter(|&&(field, _)| !field.attrs.skip_deserializing() && !field.attrs.flatten())\n        .map(|&(field, ref name)| {\n            let missing_expr = Match(expr_is_missing(field, cattrs));\n\n            quote! {\n                let #name = match #name {\n                    _serde::export::Some(#name) => #name,\n                    _serde::export::None => #missing_expr\n                };\n            }\n        });\n\n    let extract_collected = fields_names\n        .iter()\n        .filter(|&&(field, _)| field.attrs.flatten() && !field.attrs.skip_deserializing())\n        .map(|&(field, ref name)| {\n            let field_ty = field.ty;\n            let func = match field.attrs.deserialize_with() {\n                None => {\n                    let span = field.original.span();\n                    quote_spanned!(span=> _serde::de::Deserialize::deserialize)\n                }\n                Some(path) => quote!(#path),\n            };\n            quote! {\n                let #name: #field_ty = try!(#func(\n                    _serde::private::de::FlatMapDeserializer(\n                        &mut __collect,\n                        _serde::export::PhantomData)));\n            }\n        });\n\n    let collected_deny_unknown_fields = if cattrs.has_flatten() && cattrs.deny_unknown_fields() {\n        Some(quote! {\n            if let _serde::export::Some(_serde::export::Some((__key, _))) =\n                __collect.into_iter().filter(_serde::export::Option::is_some).next()\n            {\n                if let _serde::export::Some(__key) = __key.as_str() {\n                    return _serde::export::Err(\n                        _serde::de::Error::custom(format_args!(\"unknown field `{}`\", &__key)));\n                } else {\n                    return _serde::export::Err(\n                        _serde::de::Error::custom(format_args!(\"unexpected map key\")));\n                }\n            }\n        })\n    } else {\n        None\n    };\n\n    let result = fields_names.iter().map(|&(field, ref name)| {\n        let member = &field.member;\n        if field.attrs.skip_deserializing() {\n            let value = Expr(expr_is_missing(field, cattrs));\n            quote!(#member: #value)\n        } else {\n            quote!(#member: #name)\n        }\n    });\n\n    let let_default = match *cattrs.default() {\n        attr::Default::Default => Some(quote!(\n            let __default: Self::Value = _serde::export::Default::default();\n        )),\n        attr::Default::Path(ref path) => Some(quote!(\n            let __default: Self::Value = #path();\n        )),\n        attr::Default::None => {\n            // We don't need the default value, to prevent an unused variable warning\n            // we'll leave the line empty.\n            None\n        }\n    };\n\n    let mut result = quote!(#struct_path { #(#result),* });\n    if params.has_getter {\n        let this = &params.this;\n        result = quote! {\n            _serde::export::Into::<#this>::into(#result)\n        };\n    }\n\n    quote_block! {\n        #(#let_values)*\n\n        #let_collect\n\n        #match_keys\n\n        #let_default\n\n        #(#extract_values)*\n\n        #(#extract_collected)*\n\n        #collected_deny_unknown_fields\n\n        _serde::export::Ok(#result)\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_struct_as_struct_in_place_visitor(\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n) -> (Fragment, Fragment, Fragment) {\n    assert!(!cattrs.has_flatten());\n\n    let field_names_idents: Vec<_> = fields\n        .iter()\n        .enumerate()\n        .filter(|&(_, field)| !field.attrs.skip_deserializing())\n        .map(|(i, field)| {\n            (\n                field.attrs.name().deserialize_name(),\n                field_i(i),\n                field.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let fields_stmt = {\n        let field_names = field_names_idents.iter().map(|&(ref name, _, _)| name);\n        quote_block! {\n            const FIELDS: &'static [&'static str] = &[ #(#field_names),* ];\n        }\n    };\n\n    let field_visitor = deserialize_generated_identifier(&field_names_idents, cattrs, false, None);\n\n    let visit_map = deserialize_map_in_place(params, fields, cattrs);\n\n    (field_visitor, fields_stmt, visit_map)\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_map_in_place(\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n) -> Fragment {\n    assert!(!cattrs.has_flatten());\n\n    // Create the field names for the fields.\n    let fields_names: Vec<_> = fields\n        .iter()\n        .enumerate()\n        .map(|(i, field)| (field, field_i(i)))\n        .collect();\n\n    // For deserialize_in_place, declare booleans for each field that will be\n    // deserialized.\n    let let_flags = fields_names\n        .iter()\n        .filter(|&&(field, _)| !field.attrs.skip_deserializing())\n        .map(|&(_, ref name)| {\n            quote! {\n                let mut #name: bool = false;\n            }\n        });\n\n    // Match arms to extract a value for a field.\n    let value_arms_from = fields_names\n        .iter()\n        .filter(|&&(field, _)| !field.attrs.skip_deserializing())\n        .map(|&(field, ref name)| {\n            let deser_name = field.attrs.name().deserialize_name();\n            let member = &field.member;\n\n            let visit = match field.attrs.deserialize_with() {\n                None => {\n                    quote! {\n                        try!(_serde::de::MapAccess::next_value_seed(&mut __map, _serde::private::de::InPlaceSeed(&mut self.place.#member)))\n                    }\n                }\n                Some(path) => {\n                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n                    quote!({\n                        #wrapper\n                        self.place.#member = match _serde::de::MapAccess::next_value::<#wrapper_ty>(&mut __map) {\n                            _serde::export::Ok(__wrapper) => __wrapper.value,\n                            _serde::export::Err(__err) => {\n                                return _serde::export::Err(__err);\n                            }\n                        };\n                    })\n                }\n            };\n            quote! {\n                __Field::#name => {\n                    if #name {\n                        return _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#deser_name));\n                    }\n                    #visit;\n                    #name = true;\n                }\n            }\n        });\n\n    // Visit ignored values to consume them\n    let ignored_arm = if cattrs.deny_unknown_fields() {\n        None\n    } else {\n        Some(quote! {\n            _ => { let _ = try!(_serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)); }\n        })\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n\n    let match_keys = if cattrs.deny_unknown_fields() && all_skipped {\n        quote! {\n            // FIXME: Once we drop support for Rust 1.15:\n            // let _serde::export::None::<__Field> = try!(_serde::de::MapAccess::next_key(&mut __map));\n            _serde::export::Option::map(\n                try!(_serde::de::MapAccess::next_key::<__Field>(&mut __map)),\n                |__impossible| match __impossible {});\n        }\n    } else {\n        quote! {\n            while let _serde::export::Some(__key) = try!(_serde::de::MapAccess::next_key::<__Field>(&mut __map)) {\n                match __key {\n                    #(#value_arms_from)*\n                    #ignored_arm\n                }\n            }\n        }\n    };\n\n    let check_flags = fields_names\n        .iter()\n        .filter(|&&(field, _)| !field.attrs.skip_deserializing())\n        .map(|&(field, ref name)| {\n            let missing_expr = expr_is_missing(field, cattrs);\n            // If missing_expr unconditionally returns an error, don't try\n            // to assign its value to self.place.\n            if field.attrs.default().is_none()\n                && cattrs.default().is_none()\n                && field.attrs.deserialize_with().is_some()\n            {\n                let missing_expr = Stmts(missing_expr);\n                quote! {\n                    if !#name {\n                        #missing_expr;\n                    }\n                }\n            } else {\n                let member = &field.member;\n                let missing_expr = Expr(missing_expr);\n                quote! {\n                    if !#name {\n                        self.place.#member = #missing_expr;\n                    };\n                }\n            }\n        });\n\n    let this = &params.this;\n    let (_, _, ty_generics, _) = split_with_de_lifetime(params);\n\n    let let_default = match *cattrs.default() {\n        attr::Default::Default => Some(quote!(\n            let __default: #this #ty_generics = _serde::export::Default::default();\n        )),\n        attr::Default::Path(ref path) => Some(quote!(\n            let __default: #this #ty_generics = #path();\n        )),\n        attr::Default::None => {\n            // We don't need the default value, to prevent an unused variable warning\n            // we'll leave the line empty.\n            None\n        }\n    };\n\n    quote_block! {\n        #(#let_flags)*\n\n        #match_keys\n\n        #let_default\n\n        #(#check_flags)*\n\n        _serde::export::Ok(())\n    }\n}\n\nfn field_i(i: usize) -> Ident {\n    Ident::new(&format!(\"__field{}\", i), Span::call_site())\n}\n\n/// This function wraps the expression in `#[serde(deserialize_with = \"...\")]`\n/// in a trait to prevent it from accessing the internal `Deserialize` state.\nfn wrap_deserialize_with(\n    params: &Parameters,\n    value_ty: &TokenStream,\n    deserialize_with: &syn::ExprPath,\n) -> (TokenStream, TokenStream) {\n    let this = &params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    let wrapper = quote! {\n        struct __DeserializeWith #de_impl_generics #where_clause {\n            value: #value_ty,\n            phantom: _serde::export::PhantomData<#this #ty_generics>,\n            lifetime: _serde::export::PhantomData<&#delife ()>,\n        }\n\n        impl #de_impl_generics _serde::Deserialize<#delife> for __DeserializeWith #de_ty_generics #where_clause {\n            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>\n            where\n                __D: _serde::Deserializer<#delife>,\n            {\n                _serde::export::Ok(__DeserializeWith {\n                    value: try!(#deserialize_with(__deserializer)),\n                    phantom: _serde::export::PhantomData,\n                    lifetime: _serde::export::PhantomData,\n                })\n            }\n        }\n    };\n\n    let wrapper_ty = quote!(__DeserializeWith #de_ty_generics);\n\n    (wrapper, wrapper_ty)\n}\n\nfn wrap_deserialize_field_with(\n    params: &Parameters,\n    field_ty: &syn::Type,\n    deserialize_with: &syn::ExprPath,\n) -> (TokenStream, TokenStream) {\n    wrap_deserialize_with(params, &quote!(#field_ty), deserialize_with)\n}\n\nfn wrap_deserialize_variant_with(\n    params: &Parameters,\n    variant: &Variant,\n    deserialize_with: &syn::ExprPath,\n) -> (TokenStream, TokenStream, TokenStream) {\n    let this = &params.this;\n    let variant_ident = &variant.ident;\n\n    let field_tys = variant.fields.iter().map(|field| field.ty);\n    let (wrapper, wrapper_ty) =\n        wrap_deserialize_with(params, &quote!((#(#field_tys),*)), deserialize_with);\n\n    let field_access = (0..variant.fields.len()).map(|n| {\n        Member::Unnamed(Index {\n            index: n as u32,\n            span: Span::call_site(),\n        })\n    });\n    let unwrap_fn = match variant.style {\n        Style::Struct if variant.fields.len() == 1 => {\n            let member = &variant.fields[0].member;\n            quote! {\n                |__wrap| #this::#variant_ident { #member: __wrap.value }\n            }\n        }\n        Style::Struct => {\n            let members = variant.fields.iter().map(|field| &field.member);\n            quote! {\n                |__wrap| #this::#variant_ident { #(#members: __wrap.value.#field_access),* }\n            }\n        }\n        Style::Tuple => quote! {\n            |__wrap| #this::#variant_ident(#(__wrap.value.#field_access),*)\n        },\n        Style::Newtype => quote! {\n            |__wrap| #this::#variant_ident(__wrap.value)\n        },\n        Style::Unit => quote! {\n            |__wrap| #this::#variant_ident\n        },\n    };\n\n    (wrapper, wrapper_ty, unwrap_fn)\n}\n\nfn expr_is_missing(field: &Field, cattrs: &attr::Container) -> Fragment {\n    match *field.attrs.default() {\n        attr::Default::Default => {\n            let span = field.original.span();\n            let func = quote_spanned!(span=> _serde::export::Default::default);\n            return quote_expr!(#func());\n        }\n        attr::Default::Path(ref path) => {\n            return quote_expr!(#path());\n        }\n        attr::Default::None => { /* below */ }\n    }\n\n    match *cattrs.default() {\n        attr::Default::Default | attr::Default::Path(_) => {\n            let member = &field.member;\n            return quote_expr!(__default.#member);\n        }\n        attr::Default::None => { /* below */ }\n    }\n\n    let name = field.attrs.name().deserialize_name();\n    match field.attrs.deserialize_with() {\n        None => {\n            let span = field.original.span();\n            let func = quote_spanned!(span=> _serde::private::de::missing_field);\n            quote_expr! {\n                try!(#func(#name))\n            }\n        }\n        Some(_) => {\n            quote_expr! {\n                return _serde::export::Err(<__A::Error as _serde::de::Error>::missing_field(#name))\n            }\n        }\n    }\n}\n\nstruct DeImplGenerics<'a>(&'a Parameters);\n#[cfg(feature = \"deserialize_in_place\")]\nstruct InPlaceImplGenerics<'a>(&'a Parameters);\n\nimpl<'a> ToTokens for DeImplGenerics<'a> {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        let mut generics = self.0.generics.clone();\n        if let Some(de_lifetime) = self.0.borrowed.de_lifetime_def() {\n            generics.params = Some(syn::GenericParam::Lifetime(de_lifetime))\n                .into_iter()\n                .chain(generics.params)\n                .collect();\n        }\n        let (impl_generics, _, _) = generics.split_for_impl();\n        impl_generics.to_tokens(tokens);\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nimpl<'a> ToTokens for InPlaceImplGenerics<'a> {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        let place_lifetime = place_lifetime();\n        let mut generics = self.0.generics.clone();\n\n        // Add lifetime for `&'place mut Self, and `'a: 'place`\n        for param in &mut generics.params {\n            match *param {\n                syn::GenericParam::Lifetime(ref mut param) => {\n                    param.bounds.push(place_lifetime.lifetime.clone());\n                }\n                syn::GenericParam::Type(ref mut param) => {\n                    param.bounds.push(syn::TypeParamBound::Lifetime(\n                        place_lifetime.lifetime.clone(),\n                    ));\n                }\n                syn::GenericParam::Const(_) => {}\n            }\n        }\n        generics.params = Some(syn::GenericParam::Lifetime(place_lifetime))\n            .into_iter()\n            .chain(generics.params)\n            .collect();\n        if let Some(de_lifetime) = self.0.borrowed.de_lifetime_def() {\n            generics.params = Some(syn::GenericParam::Lifetime(de_lifetime))\n                .into_iter()\n                .chain(generics.params)\n                .collect();\n        }\n        let (impl_generics, _, _) = generics.split_for_impl();\n        impl_generics.to_tokens(tokens);\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nimpl<'a> DeImplGenerics<'a> {\n    fn in_place(self) -> InPlaceImplGenerics<'a> {\n        InPlaceImplGenerics(self.0)\n    }\n}\n\nstruct DeTypeGenerics<'a>(&'a Parameters);\n#[cfg(feature = \"deserialize_in_place\")]\nstruct InPlaceTypeGenerics<'a>(&'a Parameters);\n\nimpl<'a> ToTokens for DeTypeGenerics<'a> {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        let mut generics = self.0.generics.clone();\n        if self.0.borrowed.de_lifetime_def().is_some() {\n            let def = syn::LifetimeDef {\n                attrs: Vec::new(),\n                lifetime: syn::Lifetime::new(\"'de\", Span::call_site()),\n                colon_token: None,\n                bounds: Punctuated::new(),\n            };\n            generics.params = Some(syn::GenericParam::Lifetime(def))\n                .into_iter()\n                .chain(generics.params)\n                .collect();\n        }\n        let (_, ty_generics, _) = generics.split_for_impl();\n        ty_generics.to_tokens(tokens);\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nimpl<'a> ToTokens for InPlaceTypeGenerics<'a> {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        let mut generics = self.0.generics.clone();\n        generics.params = Some(syn::GenericParam::Lifetime(place_lifetime()))\n            .into_iter()\n            .chain(generics.params)\n            .collect();\n\n        if self.0.borrowed.de_lifetime_def().is_some() {\n            let def = syn::LifetimeDef {\n                attrs: Vec::new(),\n                lifetime: syn::Lifetime::new(\"'de\", Span::call_site()),\n                colon_token: None,\n                bounds: Punctuated::new(),\n            };\n            generics.params = Some(syn::GenericParam::Lifetime(def))\n                .into_iter()\n                .chain(generics.params)\n                .collect();\n        }\n        let (_, ty_generics, _) = generics.split_for_impl();\n        ty_generics.to_tokens(tokens);\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nimpl<'a> DeTypeGenerics<'a> {\n    fn in_place(self) -> InPlaceTypeGenerics<'a> {\n        InPlaceTypeGenerics(self.0)\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn place_lifetime() -> syn::LifetimeDef {\n    syn::LifetimeDef {\n        attrs: Vec::new(),\n        lifetime: syn::Lifetime::new(\"'place\", Span::call_site()),\n        colon_token: None,\n        bounds: Punctuated::new(),\n    }\n}\n\nfn split_with_de_lifetime(\n    params: &Parameters,\n) -> (\n    DeImplGenerics,\n    DeTypeGenerics,\n    syn::TypeGenerics,\n    Option<&syn::WhereClause>,\n) {\n    let de_impl_generics = DeImplGenerics(params);\n    let de_ty_generics = DeTypeGenerics(params);\n    let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n    (de_impl_generics, de_ty_generics, ty_generics, where_clause)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","dummy.rs"],"content":"use proc_macro2::{Ident, Span, TokenStream};\n\nuse syn;\nuse try;\n\npub fn wrap_in_const(\n    serde_path: Option<&syn::Path>,\n    trait_: &str,\n    ty: &Ident,\n    code: TokenStream,\n) -> TokenStream {\n    let try_replacement = try::replacement();\n\n    let dummy_const = Ident::new(\n        &format!(\"_IMPL_{}_FOR_{}\", trait_, unraw(ty)),\n        Span::call_site(),\n    );\n\n    let use_serde = match serde_path {\n        Some(path) => quote! {\n            use #path as _serde;\n        },\n        None => quote! {\n            #[allow(unknown_lints)]\n            #[cfg_attr(feature = \"cargo-clippy\", allow(useless_attribute))]\n            #[allow(rust_2018_idioms)]\n            extern crate serde as _serde;\n        },\n    };\n\n    quote! {\n        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n        const #dummy_const: () = {\n            #use_serde\n            #try_replacement\n            #code\n        };\n    }\n}\n\n#[allow(deprecated)]\nfn unraw(ident: &Ident) -> String {\n    // str::trim_start_matches was added in 1.30, trim_left_matches deprecated\n    // in 1.33. We currently support rustc back to 1.15 so we need to continue\n    // to use the deprecated one.\n    ident.to_string().trim_left_matches(\"r#\").to_owned()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","fragment.rs"],"content":"use proc_macro2::TokenStream;\nuse quote::ToTokens;\nuse syn::token;\n\npub enum Fragment {\n    /// Tokens that can be used as an expression.\n    Expr(TokenStream),\n    /// Tokens that can be used inside a block. The surrounding curly braces are\n    /// not part of these tokens.\n    Block(TokenStream),\n}\n\nmacro_rules! quote_expr {\n    ($($tt:tt)*) => {\n        $crate::fragment::Fragment::Expr(quote!($($tt)*))\n    }\n}\n\nmacro_rules! quote_block {\n    ($($tt:tt)*) => {\n        $crate::fragment::Fragment::Block(quote!($($tt)*))\n    }\n}\n\n/// Interpolate a fragment in place of an expression. This involves surrounding\n/// Block fragments in curly braces.\npub struct Expr(pub Fragment);\nimpl ToTokens for Expr {\n    fn to_tokens(&self, out: &mut TokenStream) {\n        match self.0 {\n            Fragment::Expr(ref expr) => expr.to_tokens(out),\n            Fragment::Block(ref block) => {\n                token::Brace::default().surround(out, |out| block.to_tokens(out));\n            }\n        }\n    }\n}\n\n/// Interpolate a fragment as the statements of a block.\npub struct Stmts(pub Fragment);\nimpl ToTokens for Stmts {\n    fn to_tokens(&self, out: &mut TokenStream) {\n        match self.0 {\n            Fragment::Expr(ref expr) => expr.to_tokens(out),\n            Fragment::Block(ref block) => block.to_tokens(out),\n        }\n    }\n}\n\n/// Interpolate a fragment as the value part of a `match` expression. This\n/// involves putting a comma after expressions and curly braces around blocks.\npub struct Match(pub Fragment);\nimpl ToTokens for Match {\n    fn to_tokens(&self, out: &mut TokenStream) {\n        match self.0 {\n            Fragment::Expr(ref expr) => {\n                expr.to_tokens(out);\n                <Token![,]>::default().to_tokens(out);\n            }\n            Fragment::Block(ref block) => {\n                token::Brace::default().surround(out, |out| block.to_tokens(out));\n            }\n        }\n    }\n}\n\nimpl AsRef<TokenStream> for Fragment {\n    fn as_ref(&self) -> &TokenStream {\n        match *self {\n            Fragment::Expr(ref expr) => expr,\n            Fragment::Block(ref block) => block,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","ast.rs"],"content":"//! A Serde ast, parsed from the Syn ast and ready to generate Rust code.\n\nuse internals::attr;\nuse internals::check;\nuse internals::{Ctxt, Derive};\nuse syn;\nuse syn::punctuated::Punctuated;\n\n/// A source data structure annotated with `#[derive(Serialize)]` and/or `#[derive(Deserialize)]`,\n/// parsed into an internal representation.\npub struct Container<'a> {\n    /// The struct or enum name (without generics).\n    pub ident: syn::Ident,\n    /// Attributes on the structure, parsed for Serde.\n    pub attrs: attr::Container,\n    /// The contents of the struct or enum.\n    pub data: Data<'a>,\n    /// Any generics on the struct or enum.\n    pub generics: &'a syn::Generics,\n    /// Original input.\n    pub original: &'a syn::DeriveInput,\n}\n\n/// The fields of a struct or enum.\n///\n/// Analagous to `syn::Data`.\npub enum Data<'a> {\n    Enum(Vec<Variant<'a>>),\n    Struct(Style, Vec<Field<'a>>),\n}\n\n/// A variant of an enum.\npub struct Variant<'a> {\n    pub ident: syn::Ident,\n    pub attrs: attr::Variant,\n    pub style: Style,\n    pub fields: Vec<Field<'a>>,\n    pub original: &'a syn::Variant,\n}\n\n/// A field of a struct.\npub struct Field<'a> {\n    pub member: syn::Member,\n    pub attrs: attr::Field,\n    pub ty: &'a syn::Type,\n    pub original: &'a syn::Field,\n}\n\n#[derive(Copy, Clone)]\npub enum Style {\n    /// Named fields.\n    Struct,\n    /// Many unnamed fields.\n    Tuple,\n    /// One unnamed field.\n    Newtype,\n    /// No fields.\n    Unit,\n}\n\nimpl<'a> Container<'a> {\n    /// Convert the raw Syn ast into a parsed container object, collecting errors in `cx`.\n    pub fn from_ast(\n        cx: &Ctxt,\n        item: &'a syn::DeriveInput,\n        derive: Derive,\n    ) -> Option<Container<'a>> {\n        let mut attrs = attr::Container::from_ast(cx, item);\n\n        let mut data = match item.data {\n            syn::Data::Enum(ref data) => {\n                Data::Enum(enum_from_ast(cx, &data.variants, attrs.default()))\n            }\n            syn::Data::Struct(ref data) => {\n                let (style, fields) = struct_from_ast(cx, &data.fields, None, attrs.default());\n                Data::Struct(style, fields)\n            }\n            syn::Data::Union(_) => {\n                cx.error_spanned_by(item, \"Serde does not support derive for unions\");\n                return None;\n            }\n        };\n\n        let mut has_flatten = false;\n        match data {\n            Data::Enum(ref mut variants) => {\n                for variant in variants {\n                    variant.attrs.rename_by_rules(attrs.rename_all_rules());\n                    for field in &mut variant.fields {\n                        if field.attrs.flatten() {\n                            has_flatten = true;\n                        }\n                        field\n                            .attrs\n                            .rename_by_rules(variant.attrs.rename_all_rules());\n                    }\n                }\n            }\n            Data::Struct(_, ref mut fields) => {\n                for field in fields {\n                    if field.attrs.flatten() {\n                        has_flatten = true;\n                    }\n                    field.attrs.rename_by_rules(attrs.rename_all_rules());\n                }\n            }\n        }\n\n        if has_flatten {\n            attrs.mark_has_flatten();\n        }\n\n        let mut item = Container {\n            ident: item.ident.clone(),\n            attrs: attrs,\n            data: data,\n            generics: &item.generics,\n            original: item,\n        };\n        check::check(cx, &mut item, derive);\n        Some(item)\n    }\n}\n\nimpl<'a> Data<'a> {\n    pub fn all_fields(&'a self) -> Box<Iterator<Item = &'a Field<'a>> + 'a> {\n        match *self {\n            Data::Enum(ref variants) => {\n                Box::new(variants.iter().flat_map(|variant| variant.fields.iter()))\n            }\n            Data::Struct(_, ref fields) => Box::new(fields.iter()),\n        }\n    }\n\n    pub fn has_getter(&self) -> bool {\n        self.all_fields().any(|f| f.attrs.getter().is_some())\n    }\n}\n\nfn enum_from_ast<'a>(\n    cx: &Ctxt,\n    variants: &'a Punctuated<syn::Variant, Token![,]>,\n    container_default: &attr::Default,\n) -> Vec<Variant<'a>> {\n    variants\n        .iter()\n        .map(|variant| {\n            let attrs = attr::Variant::from_ast(cx, variant);\n            let (style, fields) =\n                struct_from_ast(cx, &variant.fields, Some(&attrs), container_default);\n            Variant {\n                ident: variant.ident.clone(),\n                attrs: attrs,\n                style: style,\n                fields: fields,\n                original: variant,\n            }\n        })\n        .collect()\n}\n\nfn struct_from_ast<'a>(\n    cx: &Ctxt,\n    fields: &'a syn::Fields,\n    attrs: Option<&attr::Variant>,\n    container_default: &attr::Default,\n) -> (Style, Vec<Field<'a>>) {\n    match *fields {\n        syn::Fields::Named(ref fields) => (\n            Style::Struct,\n            fields_from_ast(cx, &fields.named, attrs, container_default),\n        ),\n        syn::Fields::Unnamed(ref fields) if fields.unnamed.len() == 1 => (\n            Style::Newtype,\n            fields_from_ast(cx, &fields.unnamed, attrs, container_default),\n        ),\n        syn::Fields::Unnamed(ref fields) => (\n            Style::Tuple,\n            fields_from_ast(cx, &fields.unnamed, attrs, container_default),\n        ),\n        syn::Fields::Unit => (Style::Unit, Vec::new()),\n    }\n}\n\nfn fields_from_ast<'a>(\n    cx: &Ctxt,\n    fields: &'a Punctuated<syn::Field, Token![,]>,\n    attrs: Option<&attr::Variant>,\n    container_default: &attr::Default,\n) -> Vec<Field<'a>> {\n    fields\n        .iter()\n        .enumerate()\n        .map(|(i, field)| Field {\n            member: match field.ident {\n                Some(ref ident) => syn::Member::Named(ident.clone()),\n                None => syn::Member::Unnamed(i.into()),\n            },\n            attrs: attr::Field::from_ast(cx, i, field, attrs, container_default),\n            ty: &field.ty,\n            original: field,\n        })\n        .collect()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","attr.rs"],"content":"use internals::symbol::*;\nuse internals::Ctxt;\nuse proc_macro2::{Group, Span, TokenStream, TokenTree};\nuse quote::ToTokens;\nuse std::borrow::Cow;\nuse std::collections::BTreeSet;\nuse std::str::FromStr;\nuse syn;\nuse syn::parse::{self, Parse, ParseStream};\nuse syn::punctuated::Punctuated;\nuse syn::Ident;\nuse syn::Meta::{List, NameValue, Path};\nuse syn::NestedMeta::{Lit, Meta};\n\n// This module handles parsing of `#[serde(...)]` attributes. The entrypoints\n// are `attr::Container::from_ast`, `attr::Variant::from_ast`, and\n// `attr::Field::from_ast`. Each returns an instance of the corresponding\n// struct. Note that none of them return a Result. Unrecognized, malformed, or\n// duplicated attributes result in a span_err but otherwise are ignored. The\n// user will see errors simultaneously for all bad attributes in the crate\n// rather than just the first.\n\npub use internals::case::RenameRule;\n\nstruct Attr<'c, T> {\n    cx: &'c Ctxt,\n    name: Symbol,\n    tokens: TokenStream,\n    value: Option<T>,\n}\n\nimpl<'c, T> Attr<'c, T> {\n    fn none(cx: &'c Ctxt, name: Symbol) -> Self {\n        Attr {\n            cx: cx,\n            name: name,\n            tokens: TokenStream::new(),\n            value: None,\n        }\n    }\n\n    fn set<A: ToTokens>(&mut self, obj: A, value: T) {\n        let tokens = obj.into_token_stream();\n\n        if self.value.is_some() {\n            self.cx\n                .error_spanned_by(tokens, format!(\"duplicate serde attribute `{}`\", self.name));\n        } else {\n            self.tokens = tokens;\n            self.value = Some(value);\n        }\n    }\n\n    fn set_opt<A: ToTokens>(&mut self, obj: A, value: Option<T>) {\n        if let Some(value) = value {\n            self.set(obj, value);\n        }\n    }\n\n    fn set_if_none(&mut self, value: T) {\n        if self.value.is_none() {\n            self.value = Some(value);\n        }\n    }\n\n    fn get(self) -> Option<T> {\n        self.value\n    }\n\n    fn get_with_tokens(self) -> Option<(TokenStream, T)> {\n        match self.value {\n            Some(v) => Some((self.tokens, v)),\n            None => None,\n        }\n    }\n}\n\nstruct BoolAttr<'c>(Attr<'c, ()>);\n\nimpl<'c> BoolAttr<'c> {\n    fn none(cx: &'c Ctxt, name: Symbol) -> Self {\n        BoolAttr(Attr::none(cx, name))\n    }\n\n    fn set_true<A: ToTokens>(&mut self, obj: A) {\n        self.0.set(obj, ());\n    }\n\n    fn get(&self) -> bool {\n        self.0.value.is_some()\n    }\n}\n\nstruct VecAttr<'c, T> {\n    cx: &'c Ctxt,\n    name: Symbol,\n    first_dup_tokens: TokenStream,\n    values: Vec<T>,\n}\n\nimpl<'c, T> VecAttr<'c, T> {\n    fn none(cx: &'c Ctxt, name: Symbol) -> Self {\n        VecAttr {\n            cx: cx,\n            name: name,\n            first_dup_tokens: TokenStream::new(),\n            values: Vec::new(),\n        }\n    }\n\n    fn insert<A: ToTokens>(&mut self, obj: A, value: T) {\n        if self.values.len() == 1 {\n            self.first_dup_tokens = obj.into_token_stream();\n        }\n        self.values.push(value);\n    }\n\n    fn at_most_one(mut self) -> Result<Option<T>, ()> {\n        if self.values.len() > 1 {\n            let dup_token = self.first_dup_tokens;\n            self.cx.error_spanned_by(\n                dup_token,\n                format!(\"duplicate serde attribute `{}`\", self.name),\n            );\n            Err(())\n        } else {\n            Ok(self.values.pop())\n        }\n    }\n\n    fn get(self) -> Vec<T> {\n        self.values\n    }\n}\n\npub struct Name {\n    serialize: String,\n    serialize_renamed: bool,\n    deserialize: String,\n    deserialize_renamed: bool,\n    deserialize_aliases: Vec<String>,\n}\n\n#[allow(deprecated)]\nfn unraw(ident: &Ident) -> String {\n    // str::trim_start_matches was added in 1.30, trim_left_matches deprecated\n    // in 1.33. We currently support rustc back to 1.15 so we need to continue\n    // to use the deprecated one.\n    ident.to_string().trim_left_matches(\"r#\").to_owned()\n}\n\nimpl Name {\n    fn from_attrs(\n        source_name: String,\n        ser_name: Attr<String>,\n        de_name: Attr<String>,\n        de_aliases: Option<VecAttr<String>>,\n    ) -> Name {\n        let deserialize_aliases = match de_aliases {\n            Some(de_aliases) => {\n                let mut alias_list = BTreeSet::new();\n                for alias_name in de_aliases.get() {\n                    alias_list.insert(alias_name);\n                }\n                alias_list.into_iter().collect()\n            }\n            None => Vec::new(),\n        };\n\n        let ser_name = ser_name.get();\n        let ser_renamed = ser_name.is_some();\n        let de_name = de_name.get();\n        let de_renamed = de_name.is_some();\n        Name {\n            serialize: ser_name.unwrap_or_else(|| source_name.clone()),\n            serialize_renamed: ser_renamed,\n            deserialize: de_name.unwrap_or(source_name),\n            deserialize_renamed: de_renamed,\n            deserialize_aliases: deserialize_aliases,\n        }\n    }\n\n    /// Return the container name for the container when serializing.\n    pub fn serialize_name(&self) -> String {\n        self.serialize.clone()\n    }\n\n    /// Return the container name for the container when deserializing.\n    pub fn deserialize_name(&self) -> String {\n        self.deserialize.clone()\n    }\n\n    fn deserialize_aliases(&self) -> Vec<String> {\n        let mut aliases = self.deserialize_aliases.clone();\n        let main_name = self.deserialize_name();\n        if !aliases.contains(&main_name) {\n            aliases.push(main_name);\n        }\n        aliases\n    }\n}\n\npub struct RenameAllRules {\n    serialize: RenameRule,\n    deserialize: RenameRule,\n}\n\n/// Represents struct or enum attribute information.\npub struct Container {\n    name: Name,\n    transparent: bool,\n    deny_unknown_fields: bool,\n    default: Default,\n    rename_all_rules: RenameAllRules,\n    ser_bound: Option<Vec<syn::WherePredicate>>,\n    de_bound: Option<Vec<syn::WherePredicate>>,\n    tag: TagType,\n    type_from: Option<syn::Type>,\n    type_try_from: Option<syn::Type>,\n    type_into: Option<syn::Type>,\n    remote: Option<syn::Path>,\n    identifier: Identifier,\n    has_flatten: bool,\n    serde_path: Option<syn::Path>,\n}\n\n/// Styles of representing an enum.\npub enum TagType {\n    /// The default.\n    ///\n    /// ```json\n    /// {\"variant1\": {\"key1\": \"value1\", \"key2\": \"value2\"}}\n    /// ```\n    External,\n\n    /// `#[serde(tag = \"type\")]`\n    ///\n    /// ```json\n    /// {\"type\": \"variant1\", \"key1\": \"value1\", \"key2\": \"value2\"}\n    /// ```\n    Internal { tag: String },\n\n    /// `#[serde(tag = \"t\", content = \"c\")]`\n    ///\n    /// ```json\n    /// {\"t\": \"variant1\", \"c\": {\"key1\": \"value1\", \"key2\": \"value2\"}}\n    /// ```\n    Adjacent { tag: String, content: String },\n\n    /// `#[serde(untagged)]`\n    ///\n    /// ```json\n    /// {\"key1\": \"value1\", \"key2\": \"value2\"}\n    /// ```\n    None,\n}\n\n/// Whether this enum represents the fields of a struct or the variants of an\n/// enum.\n#[derive(Copy, Clone)]\npub enum Identifier {\n    /// It does not.\n    No,\n\n    /// This enum represents the fields of a struct. All of the variants must be\n    /// unit variants, except possibly one which is annotated with\n    /// `#[serde(other)]` and is a newtype variant.\n    Field,\n\n    /// This enum represents the variants of an enum. All of the variants must\n    /// be unit variants.\n    Variant,\n}\n\nimpl Identifier {\n    #[cfg(feature = \"deserialize_in_place\")]\n    pub fn is_some(self) -> bool {\n        match self {\n            Identifier::No => false,\n            Identifier::Field | Identifier::Variant => true,\n        }\n    }\n}\n\nimpl Container {\n    /// Extract out the `#[serde(...)]` attributes from an item.\n    pub fn from_ast(cx: &Ctxt, item: &syn::DeriveInput) -> Self {\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut transparent = BoolAttr::none(cx, TRANSPARENT);\n        let mut deny_unknown_fields = BoolAttr::none(cx, DENY_UNKNOWN_FIELDS);\n        let mut default = Attr::none(cx, DEFAULT);\n        let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);\n        let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut untagged = BoolAttr::none(cx, UNTAGGED);\n        let mut internal_tag = Attr::none(cx, TAG);\n        let mut content = Attr::none(cx, CONTENT);\n        let mut type_from = Attr::none(cx, FROM);\n        let mut type_try_from = Attr::none(cx, TRY_FROM);\n        let mut type_into = Attr::none(cx, INTO);\n        let mut remote = Attr::none(cx, REMOTE);\n        let mut field_identifier = BoolAttr::none(cx, FIELD_IDENTIFIER);\n        let mut variant_identifier = BoolAttr::none(cx, VARIANT_IDENTIFIER);\n        let mut serde_path = Attr::none(cx, CRATE);\n\n        for meta_items in item.attrs.iter().filter_map(get_serde_meta_items) {\n            for meta_item in meta_items {\n                match meta_item {\n                    // Parse `#[serde(rename = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME => {\n                        if let Ok(s) = get_lit_str(cx, RENAME, &m.lit) {\n                            ser_name.set(&m.path, s.value());\n                            de_name.set(&m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME => {\n                        if let Ok((ser, de)) = get_renames(cx, &m.nested) {\n                            ser_name.set_opt(&m.path, ser.map(syn::LitStr::value));\n                            de_name.set_opt(&m.path, de.map(syn::LitStr::value));\n                        }\n                    }\n\n                    // Parse `#[serde(rename_all = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME_ALL => {\n                        if let Ok(s) = get_lit_str(cx, RENAME_ALL, &m.lit) {\n                            match RenameRule::from_str(&s.value()) {\n                                Ok(rename_rule) => {\n                                    rename_all_ser_rule.set(&m.path, rename_rule);\n                                    rename_all_de_rule.set(&m.path, rename_rule);\n                                }\n                                Err(()) => cx.error_spanned_by(\n                                    s,\n                                    format!(\n                                        \"unknown rename rule for #[serde(rename_all \\\n                                         = {:?})]\",\n                                        s.value(),\n                                    ),\n                                ),\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME_ALL => {\n                        if let Ok((ser, de)) = get_renames(cx, &m.nested) {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_ser_rule.set(&m.path, rename_rule)\n                                    }\n                                    Err(()) => cx.error_spanned_by(\n                                        ser,\n                                        format!(\n                                            \"unknown rename rule for #[serde(rename_all \\\n                                             = {:?})]\",\n                                            ser.value(),\n                                        ),\n                                    ),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => rename_all_de_rule.set(&m.path, rename_rule),\n                                    Err(()) => cx.error_spanned_by(\n                                        de,\n                                        format!(\n                                            \"unknown rename rule for #[serde(rename_all \\\n                                             = {:?})]\",\n                                            de.value(),\n                                        ),\n                                    ),\n                                }\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(transparent)]`\n                    Meta(Path(ref word)) if word == TRANSPARENT => {\n                        transparent.set_true(word);\n                    }\n\n                    // Parse `#[serde(deny_unknown_fields)]`\n                    Meta(Path(ref word)) if word == DENY_UNKNOWN_FIELDS => {\n                        deny_unknown_fields.set_true(word);\n                    }\n\n                    // Parse `#[serde(default)]`\n                    Meta(Path(ref word)) if word == DEFAULT => match item.data {\n                        syn::Data::Struct(syn::DataStruct { ref fields, .. }) => match *fields {\n                            syn::Fields::Named(_) => {\n                                default.set(word, Default::Default);\n                            }\n                            syn::Fields::Unnamed(_) | syn::Fields::Unit => cx.error_spanned_by(\n                                fields,\n                                \"#[serde(default)] can only be used on structs \\\n                                 with named fields\",\n                            ),\n                        },\n                        syn::Data::Enum(syn::DataEnum { ref enum_token, .. }) => cx\n                            .error_spanned_by(\n                                enum_token,\n                                \"#[serde(default)] can only be used on structs \\\n                                 with named fields\",\n                            ),\n                        syn::Data::Union(syn::DataUnion {\n                            ref union_token, ..\n                        }) => cx.error_spanned_by(\n                            union_token,\n                            \"#[serde(default)] can only be used on structs \\\n                             with named fields\",\n                        ),\n                    },\n\n                    // Parse `#[serde(default = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == DEFAULT => {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, DEFAULT, &m.lit) {\n                            match item.data {\n                                syn::Data::Struct(syn::DataStruct { ref fields, .. }) => {\n                                    match *fields {\n                                        syn::Fields::Named(_) => {\n                                            default.set(&m.path, Default::Path(path));\n                                        }\n                                        syn::Fields::Unnamed(_) | syn::Fields::Unit => cx\n                                            .error_spanned_by(\n                                                fields,\n                                                \"#[serde(default = \\\"...\\\")] can only be used \\\n                                                 on structs with named fields\",\n                                            ),\n                                    }\n                                }\n                                syn::Data::Enum(syn::DataEnum { ref enum_token, .. }) => cx\n                                    .error_spanned_by(\n                                        enum_token,\n                                        \"#[serde(default = \\\"...\\\")] can only be used \\\n                                         on structs with named fields\",\n                                    ),\n                                syn::Data::Union(syn::DataUnion {\n                                    ref union_token, ..\n                                }) => cx.error_spanned_by(\n                                    union_token,\n                                    \"#[serde(default = \\\"...\\\")] can only be used \\\n                                     on structs with named fields\",\n                                ),\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(bound = \"T: SomeBound\")]`\n                    Meta(NameValue(ref m)) if m.path == BOUND => {\n                        if let Ok(where_predicates) = parse_lit_into_where(cx, BOUND, BOUND, &m.lit)\n                        {\n                            ser_bound.set(&m.path, where_predicates.clone());\n                            de_bound.set(&m.path, where_predicates);\n                        }\n                    }\n\n                    // Parse `#[serde(bound(serialize = \"...\", deserialize = \"...\"))]`\n                    Meta(List(ref m)) if m.path == BOUND => {\n                        if let Ok((ser, de)) = get_where_predicates(cx, &m.nested) {\n                            ser_bound.set_opt(&m.path, ser);\n                            de_bound.set_opt(&m.path, de);\n                        }\n                    }\n\n                    // Parse `#[serde(untagged)]`\n                    Meta(Path(ref word)) if word == UNTAGGED => match item.data {\n                        syn::Data::Enum(_) => {\n                            untagged.set_true(word);\n                        }\n                        syn::Data::Struct(syn::DataStruct {\n                            ref struct_token, ..\n                        }) => {\n                            cx.error_spanned_by(\n                                struct_token,\n                                \"#[serde(untagged)] can only be used on enums\",\n                            );\n                        }\n                        syn::Data::Union(syn::DataUnion {\n                            ref union_token, ..\n                        }) => {\n                            cx.error_spanned_by(\n                                union_token,\n                                \"#[serde(untagged)] can only be used on enums\",\n                            );\n                        }\n                    },\n\n                    // Parse `#[serde(tag = \"type\")]`\n                    Meta(NameValue(ref m)) if m.path == TAG => {\n                        if let Ok(s) = get_lit_str(cx, TAG, &m.lit) {\n                            match item.data {\n                                syn::Data::Enum(_) => {\n                                    internal_tag.set(&m.path, s.value());\n                                }\n                                syn::Data::Struct(syn::DataStruct { ref fields, .. }) => {\n                                    match *fields {\n                                        syn::Fields::Named(_) => {\n                                            internal_tag.set(&m.path, s.value());\n                                        }\n                                        syn::Fields::Unnamed(_) | syn::Fields::Unit => {\n                                            cx.error_spanned_by(\n                                                fields,\n                                                \"#[serde(tag = \\\"...\\\")] can only be used on enums \\\n                                                and structs with named fields\",\n                                            );\n                                        }\n                                    }\n                                }\n                                syn::Data::Union(syn::DataUnion {\n                                    ref union_token, ..\n                                }) => {\n                                    cx.error_spanned_by(\n                                        union_token,\n                                        \"#[serde(tag = \\\"...\\\")] can only be used on enums \\\n                                         and structs with named fields\",\n                                    );\n                                }\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(content = \"c\")]`\n                    Meta(NameValue(ref m)) if m.path == CONTENT => {\n                        if let Ok(s) = get_lit_str(cx, CONTENT, &m.lit) {\n                            match item.data {\n                                syn::Data::Enum(_) => {\n                                    content.set(&m.path, s.value());\n                                }\n                                syn::Data::Struct(syn::DataStruct {\n                                    ref struct_token, ..\n                                }) => {\n                                    cx.error_spanned_by(\n                                        struct_token,\n                                        \"#[serde(content = \\\"...\\\")] can only be used on enums\",\n                                    );\n                                }\n                                syn::Data::Union(syn::DataUnion {\n                                    ref union_token, ..\n                                }) => {\n                                    cx.error_spanned_by(\n                                        union_token,\n                                        \"#[serde(content = \\\"...\\\")] can only be used on enums\",\n                                    );\n                                }\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(from = \"Type\")]\n                    Meta(NameValue(ref m)) if m.path == FROM => {\n                        if let Ok(from_ty) = parse_lit_into_ty(cx, FROM, &m.lit) {\n                            type_from.set_opt(&m.path, Some(from_ty));\n                        }\n                    }\n\n                    // Parse `#[serde(try_from = \"Type\")]\n                    Meta(NameValue(ref m)) if m.path == TRY_FROM => {\n                        if let Ok(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, &m.lit) {\n                            type_try_from.set_opt(&m.path, Some(try_from_ty));\n                        }\n                    }\n\n                    // Parse `#[serde(into = \"Type\")]\n                    Meta(NameValue(ref m)) if m.path == INTO => {\n                        if let Ok(into_ty) = parse_lit_into_ty(cx, INTO, &m.lit) {\n                            type_into.set_opt(&m.path, Some(into_ty));\n                        }\n                    }\n\n                    // Parse `#[serde(remote = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == REMOTE => {\n                        if let Ok(path) = parse_lit_into_path(cx, REMOTE, &m.lit) {\n                            if is_primitive_path(&path, \"Self\") {\n                                remote.set(&m.path, item.ident.clone().into());\n                            } else {\n                                remote.set(&m.path, path);\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(field_identifier)]`\n                    Meta(Path(ref word)) if word == FIELD_IDENTIFIER => {\n                        field_identifier.set_true(word);\n                    }\n\n                    // Parse `#[serde(variant_identifier)]`\n                    Meta(Path(ref word)) if word == VARIANT_IDENTIFIER => {\n                        variant_identifier.set_true(word);\n                    }\n\n                    // Parse `#[serde(crate = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == CRATE => {\n                        if let Ok(path) = parse_lit_into_path(cx, CRATE, &m.lit) {\n                            serde_path.set(&m.path, path)\n                        }\n                    }\n\n                    Meta(ref meta_item) => {\n                        let path = meta_item\n                            .path()\n                            .into_token_stream()\n                            .to_string()\n                            .replace(' ', \"\");\n                        cx.error_spanned_by(\n                            meta_item.path(),\n                            format!(\"unknown serde container attribute `{}`\", path),\n                        );\n                    }\n\n                    Lit(ref lit) => {\n                        cx.error_spanned_by(lit, \"unexpected literal in serde container attribute\");\n                    }\n                }\n            }\n        }\n\n        Container {\n            name: Name::from_attrs(unraw(&item.ident), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            has_flatten: false,\n            serde_path: serde_path.get(),\n        }\n    }\n\n    pub fn name(&self) -> &Name {\n        &self.name\n    }\n\n    pub fn rename_all_rules(&self) -> &RenameAllRules {\n        &self.rename_all_rules\n    }\n\n    pub fn transparent(&self) -> bool {\n        self.transparent\n    }\n\n    pub fn deny_unknown_fields(&self) -> bool {\n        self.deny_unknown_fields\n    }\n\n    pub fn default(&self) -> &Default {\n        &self.default\n    }\n\n    pub fn ser_bound(&self) -> Option<&[syn::WherePredicate]> {\n        self.ser_bound.as_ref().map(|vec| &vec[..])\n    }\n\n    pub fn de_bound(&self) -> Option<&[syn::WherePredicate]> {\n        self.de_bound.as_ref().map(|vec| &vec[..])\n    }\n\n    pub fn tag(&self) -> &TagType {\n        &self.tag\n    }\n\n    pub fn type_from(&self) -> Option<&syn::Type> {\n        self.type_from.as_ref()\n    }\n\n    pub fn type_try_from(&self) -> Option<&syn::Type> {\n        self.type_try_from.as_ref()\n    }\n\n    pub fn type_into(&self) -> Option<&syn::Type> {\n        self.type_into.as_ref()\n    }\n\n    pub fn remote(&self) -> Option<&syn::Path> {\n        self.remote.as_ref()\n    }\n\n    pub fn identifier(&self) -> Identifier {\n        self.identifier\n    }\n\n    pub fn has_flatten(&self) -> bool {\n        self.has_flatten\n    }\n\n    pub fn mark_has_flatten(&mut self) {\n        self.has_flatten = true;\n    }\n\n    pub fn custom_serde_path(&self) -> Option<&syn::Path> {\n        self.serde_path.as_ref()\n    }\n\n    pub fn serde_path(&self) -> Cow<syn::Path> {\n        self.custom_serde_path()\n            .map_or_else(|| Cow::Owned(parse_quote!(_serde)), Cow::Borrowed)\n    }\n}\n\nfn decide_tag(\n    cx: &Ctxt,\n    item: &syn::DeriveInput,\n    untagged: BoolAttr,\n    internal_tag: Attr<String>,\n    content: Attr<String>,\n) -> TagType {\n    match (\n        untagged.0.get_with_tokens(),\n        internal_tag.get_with_tokens(),\n        content.get_with_tokens(),\n    ) {\n        (None, None, None) => TagType::External,\n        (Some(_), None, None) => TagType::None,\n        (None, Some((_, tag)), None) => {\n            // Check that there are no tuple variants.\n            if let syn::Data::Enum(ref data) = item.data {\n                for variant in &data.variants {\n                    match variant.fields {\n                        syn::Fields::Named(_) | syn::Fields::Unit => {}\n                        syn::Fields::Unnamed(ref fields) => {\n                            if fields.unnamed.len() != 1 {\n                                cx.error_spanned_by(\n                                    variant,\n                                    \"#[serde(tag = \\\"...\\\")] cannot be used with tuple \\\n                                     variants\",\n                                );\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            TagType::Internal { tag: tag }\n        }\n        (Some((untagged_tokens, _)), Some((tag_tokens, _)), None) => {\n            cx.error_spanned_by(\n                untagged_tokens,\n                \"enum cannot be both untagged and internally tagged\",\n            );\n            cx.error_spanned_by(\n                tag_tokens,\n                \"enum cannot be both untagged and internally tagged\",\n            );\n            TagType::External // doesn't matter, will error\n        }\n        (None, None, Some((content_tokens, _))) => {\n            cx.error_spanned_by(\n                content_tokens,\n                \"#[serde(tag = \\\"...\\\", content = \\\"...\\\")] must be used together\",\n            );\n            TagType::External\n        }\n        (Some((untagged_tokens, _)), None, Some((content_tokens, _))) => {\n            cx.error_spanned_by(\n                untagged_tokens,\n                \"untagged enum cannot have #[serde(content = \\\"...\\\")]\",\n            );\n            cx.error_spanned_by(\n                content_tokens,\n                \"untagged enum cannot have #[serde(content = \\\"...\\\")]\",\n            );\n            TagType::External\n        }\n        (None, Some((_, tag)), Some((_, content))) => TagType::Adjacent {\n            tag: tag,\n            content: content,\n        },\n        (Some((untagged_tokens, _)), Some((tag_tokens, _)), Some((content_tokens, _))) => {\n            cx.error_spanned_by(\n                untagged_tokens,\n                \"untagged enum cannot have #[serde(tag = \\\"...\\\", content = \\\"...\\\")]\",\n            );\n            cx.error_spanned_by(\n                tag_tokens,\n                \"untagged enum cannot have #[serde(tag = \\\"...\\\", content = \\\"...\\\")]\",\n            );\n            cx.error_spanned_by(\n                content_tokens,\n                \"untagged enum cannot have #[serde(tag = \\\"...\\\", content = \\\"...\\\")]\",\n            );\n            TagType::External\n        }\n    }\n}\n\nfn decide_identifier(\n    cx: &Ctxt,\n    item: &syn::DeriveInput,\n    field_identifier: BoolAttr,\n    variant_identifier: BoolAttr,\n) -> Identifier {\n    match (\n        &item.data,\n        field_identifier.0.get_with_tokens(),\n        variant_identifier.0.get_with_tokens(),\n    ) {\n        (_, None, None) => Identifier::No,\n        (_, Some((field_identifier_tokens, _)), Some((variant_identifier_tokens, _))) => {\n            cx.error_spanned_by(\n                field_identifier_tokens,\n                \"#[serde(field_identifier)] and #[serde(variant_identifier)] cannot both be set\",\n            );\n            cx.error_spanned_by(\n                variant_identifier_tokens,\n                \"#[serde(field_identifier)] and #[serde(variant_identifier)] cannot both be set\",\n            );\n            Identifier::No\n        }\n        (&syn::Data::Enum(_), Some(_), None) => Identifier::Field,\n        (&syn::Data::Enum(_), None, Some(_)) => Identifier::Variant,\n        (\n            &syn::Data::Struct(syn::DataStruct {\n                ref struct_token, ..\n            }),\n            Some(_),\n            None,\n        ) => {\n            cx.error_spanned_by(\n                struct_token,\n                \"#[serde(field_identifier)] can only be used on an enum\",\n            );\n            Identifier::No\n        }\n        (\n            &syn::Data::Union(syn::DataUnion {\n                ref union_token, ..\n            }),\n            Some(_),\n            None,\n        ) => {\n            cx.error_spanned_by(\n                union_token,\n                \"#[serde(field_identifier)] can only be used on an enum\",\n            );\n            Identifier::No\n        }\n        (\n            &syn::Data::Struct(syn::DataStruct {\n                ref struct_token, ..\n            }),\n            None,\n            Some(_),\n        ) => {\n            cx.error_spanned_by(\n                struct_token,\n                \"#[serde(variant_identifier)] can only be used on an enum\",\n            );\n            Identifier::No\n        }\n        (\n            &syn::Data::Union(syn::DataUnion {\n                ref union_token, ..\n            }),\n            None,\n            Some(_),\n        ) => {\n            cx.error_spanned_by(\n                union_token,\n                \"#[serde(variant_identifier)] can only be used on an enum\",\n            );\n            Identifier::No\n        }\n    }\n}\n\n/// Represents variant attribute information\npub struct Variant {\n    name: Name,\n    rename_all_rules: RenameAllRules,\n    ser_bound: Option<Vec<syn::WherePredicate>>,\n    de_bound: Option<Vec<syn::WherePredicate>>,\n    skip_deserializing: bool,\n    skip_serializing: bool,\n    other: bool,\n    serialize_with: Option<syn::ExprPath>,\n    deserialize_with: Option<syn::ExprPath>,\n    borrow: Option<syn::Meta>,\n}\n\nimpl Variant {\n    pub fn from_ast(cx: &Ctxt, variant: &syn::Variant) -> Self {\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut de_aliases = VecAttr::none(cx, RENAME);\n        let mut skip_deserializing = BoolAttr::none(cx, SKIP_DESERIALIZING);\n        let mut skip_serializing = BoolAttr::none(cx, SKIP_SERIALIZING);\n        let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);\n        let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut other = BoolAttr::none(cx, OTHER);\n        let mut serialize_with = Attr::none(cx, SERIALIZE_WITH);\n        let mut deserialize_with = Attr::none(cx, DESERIALIZE_WITH);\n        let mut borrow = Attr::none(cx, BORROW);\n\n        for meta_items in variant.attrs.iter().filter_map(get_serde_meta_items) {\n            for meta_item in meta_items {\n                match meta_item {\n                    // Parse `#[serde(rename = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME => {\n                        if let Ok(s) = get_lit_str(cx, RENAME, &m.lit) {\n                            ser_name.set(&m.path, s.value());\n                            de_name.set_if_none(s.value());\n                            de_aliases.insert(&m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME => {\n                        if let Ok((ser, de)) = get_multiple_renames(cx, &m.nested) {\n                            ser_name.set_opt(&m.path, ser.map(syn::LitStr::value));\n                            for de_value in de {\n                                de_name.set_if_none(de_value.value());\n                                de_aliases.insert(&m.path, de_value.value());\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(alias = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == ALIAS => {\n                        if let Ok(s) = get_lit_str(cx, ALIAS, &m.lit) {\n                            de_aliases.insert(&m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(rename_all = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME_ALL => {\n                        if let Ok(s) = get_lit_str(cx, RENAME_ALL, &m.lit) {\n                            match RenameRule::from_str(&s.value()) {\n                                Ok(rename_rule) => {\n                                    rename_all_ser_rule.set(&m.path, rename_rule);\n                                    rename_all_de_rule.set(&m.path, rename_rule);\n                                }\n                                Err(()) => cx.error_spanned_by(\n                                    s,\n                                    format!(\n                                        \"unknown rename rule for #[serde(rename_all \\\n                                         = {:?})]\",\n                                        s.value()\n                                    ),\n                                ),\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME_ALL => {\n                        if let Ok((ser, de)) = get_renames(cx, &m.nested) {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(&ser.value()) {\n                                    Ok(rename_rule) => {\n                                        rename_all_ser_rule.set(&m.path, rename_rule)\n                                    }\n                                    Err(()) => cx.error_spanned_by(\n                                        ser,\n                                        format!(\n                                            \"unknown rename rule for #[serde(rename_all \\\n                                             = {:?})]\",\n                                            ser.value(),\n                                        ),\n                                    ),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(&de.value()) {\n                                    Ok(rename_rule) => rename_all_de_rule.set(&m.path, rename_rule),\n                                    Err(()) => cx.error_spanned_by(\n                                        de,\n                                        format!(\n                                            \"unknown rename rule for #[serde(rename_all \\\n                                             = {:?})]\",\n                                            de.value(),\n                                        ),\n                                    ),\n                                }\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(skip)]`\n                    Meta(Path(ref word)) if word == SKIP => {\n                        skip_serializing.set_true(word);\n                        skip_deserializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip_deserializing)]`\n                    Meta(Path(ref word)) if word == SKIP_DESERIALIZING => {\n                        skip_deserializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip_serializing)]`\n                    Meta(Path(ref word)) if word == SKIP_SERIALIZING => {\n                        skip_serializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(other)]`\n                    Meta(Path(ref word)) if word == OTHER => {\n                        other.set_true(word);\n                    }\n\n                    // Parse `#[serde(bound = \"T: SomeBound\")]`\n                    Meta(NameValue(ref m)) if m.path == BOUND => {\n                        if let Ok(where_predicates) = parse_lit_into_where(cx, BOUND, BOUND, &m.lit)\n                        {\n                            ser_bound.set(&m.path, where_predicates.clone());\n                            de_bound.set(&m.path, where_predicates);\n                        }\n                    }\n\n                    // Parse `#[serde(bound(serialize = \"...\", deserialize = \"...\"))]`\n                    Meta(List(ref m)) if m.path == BOUND => {\n                        if let Ok((ser, de)) = get_where_predicates(cx, &m.nested) {\n                            ser_bound.set_opt(&m.path, ser);\n                            de_bound.set_opt(&m.path, de);\n                        }\n                    }\n\n                    // Parse `#[serde(with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == WITH => {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, WITH, &m.lit) {\n                            let mut ser_path = path.clone();\n                            ser_path\n                                .path\n                                .segments\n                                .push(Ident::new(\"serialize\", Span::call_site()).into());\n                            serialize_with.set(&m.path, ser_path);\n                            let mut de_path = path;\n                            de_path\n                                .path\n                                .segments\n                                .push(Ident::new(\"deserialize\", Span::call_site()).into());\n                            deserialize_with.set(&m.path, de_path);\n                        }\n                    }\n\n                    // Parse `#[serde(serialize_with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == SERIALIZE_WITH => {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &m.lit) {\n                            serialize_with.set(&m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(deserialize_with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == DESERIALIZE_WITH => {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &m.lit) {\n                            deserialize_with.set(&m.path, path);\n                        }\n                    }\n\n                    // Defer `#[serde(borrow)]` and `#[serde(borrow = \"'a + 'b\")]`\n                    Meta(ref m) if m.path() == BORROW => match variant.fields {\n                        syn::Fields::Unnamed(ref fields) if fields.unnamed.len() == 1 => {\n                            borrow.set(m.path(), m.clone());\n                        }\n                        _ => {\n                            cx.error_spanned_by(\n                                variant,\n                                \"#[serde(borrow)] may only be used on newtype variants\",\n                            );\n                        }\n                    },\n\n                    Meta(ref meta_item) => {\n                        let path = meta_item\n                            .path()\n                            .into_token_stream()\n                            .to_string()\n                            .replace(' ', \"\");\n                        cx.error_spanned_by(\n                            meta_item.path(),\n                            format!(\"unknown serde variant attribute `{}`\", path),\n                        );\n                    }\n\n                    Lit(ref lit) => {\n                        cx.error_spanned_by(lit, \"unexpected literal in serde variant attribute\");\n                    }\n                }\n            }\n        }\n\n        Variant {\n            name: Name::from_attrs(unraw(&variant.ident), ser_name, de_name, Some(de_aliases)),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing: skip_serializing.get(),\n            other: other.get(),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            borrow: borrow.get(),\n        }\n    }\n\n    pub fn name(&self) -> &Name {\n        &self.name\n    }\n\n    pub fn aliases(&self) -> Vec<String> {\n        self.name.deserialize_aliases()\n    }\n\n    pub fn rename_by_rules(&mut self, rules: &RenameAllRules) {\n        if !self.name.serialize_renamed {\n            self.name.serialize = rules.serialize.apply_to_variant(&self.name.serialize);\n        }\n        if !self.name.deserialize_renamed {\n            self.name.deserialize = rules.deserialize.apply_to_variant(&self.name.deserialize);\n        }\n    }\n\n    pub fn rename_all_rules(&self) -> &RenameAllRules {\n        &self.rename_all_rules\n    }\n\n    pub fn ser_bound(&self) -> Option<&[syn::WherePredicate]> {\n        self.ser_bound.as_ref().map(|vec| &vec[..])\n    }\n\n    pub fn de_bound(&self) -> Option<&[syn::WherePredicate]> {\n        self.de_bound.as_ref().map(|vec| &vec[..])\n    }\n\n    pub fn skip_deserializing(&self) -> bool {\n        self.skip_deserializing\n    }\n\n    pub fn skip_serializing(&self) -> bool {\n        self.skip_serializing\n    }\n\n    pub fn other(&self) -> bool {\n        self.other\n    }\n\n    pub fn serialize_with(&self) -> Option<&syn::ExprPath> {\n        self.serialize_with.as_ref()\n    }\n\n    pub fn deserialize_with(&self) -> Option<&syn::ExprPath> {\n        self.deserialize_with.as_ref()\n    }\n}\n\n/// Represents field attribute information\npub struct Field {\n    name: Name,\n    skip_serializing: bool,\n    skip_deserializing: bool,\n    skip_serializing_if: Option<syn::ExprPath>,\n    default: Default,\n    serialize_with: Option<syn::ExprPath>,\n    deserialize_with: Option<syn::ExprPath>,\n    ser_bound: Option<Vec<syn::WherePredicate>>,\n    de_bound: Option<Vec<syn::WherePredicate>>,\n    borrowed_lifetimes: BTreeSet<syn::Lifetime>,\n    getter: Option<syn::ExprPath>,\n    flatten: bool,\n    transparent: bool,\n}\n\n/// Represents the default to use for a field when deserializing.\npub enum Default {\n    /// Field must always be specified because it does not have a default.\n    None,\n    /// The default is given by `std::default::Default::default()`.\n    Default,\n    /// The default is given by this function.\n    Path(syn::ExprPath),\n}\n\nimpl Default {\n    pub fn is_none(&self) -> bool {\n        match *self {\n            Default::None => true,\n            Default::Default | Default::Path(_) => false,\n        }\n    }\n}\n\nimpl Field {\n    /// Extract out the `#[serde(...)]` attributes from a struct field.\n    pub fn from_ast(\n        cx: &Ctxt,\n        index: usize,\n        field: &syn::Field,\n        attrs: Option<&Variant>,\n        container_default: &Default,\n    ) -> Self {\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut de_aliases = VecAttr::none(cx, RENAME);\n        let mut skip_serializing = BoolAttr::none(cx, SKIP_SERIALIZING);\n        let mut skip_deserializing = BoolAttr::none(cx, SKIP_DESERIALIZING);\n        let mut skip_serializing_if = Attr::none(cx, SKIP_SERIALIZING_IF);\n        let mut default = Attr::none(cx, DEFAULT);\n        let mut serialize_with = Attr::none(cx, SERIALIZE_WITH);\n        let mut deserialize_with = Attr::none(cx, DESERIALIZE_WITH);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut borrowed_lifetimes = Attr::none(cx, BORROW);\n        let mut getter = Attr::none(cx, GETTER);\n        let mut flatten = BoolAttr::none(cx, FLATTEN);\n\n        let ident = match field.ident {\n            Some(ref ident) => unraw(ident),\n            None => index.to_string(),\n        };\n\n        let variant_borrow = attrs\n            .and_then(|variant| variant.borrow.as_ref())\n            .map(|borrow| vec![Meta(borrow.clone())]);\n\n        for meta_items in field\n            .attrs\n            .iter()\n            .filter_map(get_serde_meta_items)\n            .chain(variant_borrow)\n        {\n            for meta_item in meta_items {\n                match meta_item {\n                    // Parse `#[serde(rename = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME => {\n                        if let Ok(s) = get_lit_str(cx, RENAME, &m.lit) {\n                            ser_name.set(&m.path, s.value());\n                            de_name.set_if_none(s.value());\n                            de_aliases.insert(&m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME => {\n                        if let Ok((ser, de)) = get_multiple_renames(cx, &m.nested) {\n                            ser_name.set_opt(&m.path, ser.map(syn::LitStr::value));\n                            for de_value in de {\n                                de_name.set_if_none(de_value.value());\n                                de_aliases.insert(&m.path, de_value.value());\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(alias = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == ALIAS => {\n                        if let Ok(s) = get_lit_str(cx, ALIAS, &m.lit) {\n                            de_aliases.insert(&m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(default)]`\n                    Meta(Path(ref word)) if word == DEFAULT => {\n                        default.set(word, Default::Default);\n                    }\n\n                    // Parse `#[serde(default = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == DEFAULT => {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, DEFAULT, &m.lit) {\n                            default.set(&m.path, Default::Path(path));\n                        }\n                    }\n\n                    // Parse `#[serde(skip_serializing)]`\n                    Meta(Path(ref word)) if word == SKIP_SERIALIZING => {\n                        skip_serializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip_deserializing)]`\n                    Meta(Path(ref word)) if word == SKIP_DESERIALIZING => {\n                        skip_deserializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip)]`\n                    Meta(Path(ref word)) if word == SKIP => {\n                        skip_serializing.set_true(word);\n                        skip_deserializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip_serializing_if = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == SKIP_SERIALIZING_IF => {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, SKIP_SERIALIZING_IF, &m.lit)\n                        {\n                            skip_serializing_if.set(&m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(serialize_with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == SERIALIZE_WITH => {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, &m.lit) {\n                            serialize_with.set(&m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(deserialize_with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == DESERIALIZE_WITH => {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, &m.lit) {\n                            deserialize_with.set(&m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == WITH => {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, WITH, &m.lit) {\n                            let mut ser_path = path.clone();\n                            ser_path\n                                .path\n                                .segments\n                                .push(Ident::new(\"serialize\", Span::call_site()).into());\n                            serialize_with.set(&m.path, ser_path);\n                            let mut de_path = path;\n                            de_path\n                                .path\n                                .segments\n                                .push(Ident::new(\"deserialize\", Span::call_site()).into());\n                            deserialize_with.set(&m.path, de_path);\n                        }\n                    }\n\n                    // Parse `#[serde(bound = \"T: SomeBound\")]`\n                    Meta(NameValue(ref m)) if m.path == BOUND => {\n                        if let Ok(where_predicates) = parse_lit_into_where(cx, BOUND, BOUND, &m.lit)\n                        {\n                            ser_bound.set(&m.path, where_predicates.clone());\n                            de_bound.set(&m.path, where_predicates);\n                        }\n                    }\n\n                    // Parse `#[serde(bound(serialize = \"...\", deserialize = \"...\"))]`\n                    Meta(List(ref m)) if m.path == BOUND => {\n                        if let Ok((ser, de)) = get_where_predicates(cx, &m.nested) {\n                            ser_bound.set_opt(&m.path, ser);\n                            de_bound.set_opt(&m.path, de);\n                        }\n                    }\n\n                    // Parse `#[serde(borrow)]`\n                    Meta(Path(ref word)) if word == BORROW => {\n                        if let Ok(borrowable) = borrowable_lifetimes(cx, &ident, field) {\n                            borrowed_lifetimes.set(word, borrowable);\n                        }\n                    }\n\n                    // Parse `#[serde(borrow = \"'a + 'b\")]`\n                    Meta(NameValue(ref m)) if m.path == BORROW => {\n                        if let Ok(lifetimes) = parse_lit_into_lifetimes(cx, BORROW, &m.lit) {\n                            if let Ok(borrowable) = borrowable_lifetimes(cx, &ident, field) {\n                                for lifetime in &lifetimes {\n                                    if !borrowable.contains(lifetime) {\n                                        cx.error_spanned_by(\n                                            field,\n                                            format!(\n                                                \"field `{}` does not have lifetime {}\",\n                                                ident, lifetime\n                                            ),\n                                        );\n                                    }\n                                }\n                                borrowed_lifetimes.set(&m.path, lifetimes);\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(getter = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == GETTER => {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, GETTER, &m.lit) {\n                            getter.set(&m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(flatten)]`\n                    Meta(Path(ref word)) if word == FLATTEN => {\n                        flatten.set_true(word);\n                    }\n\n                    Meta(ref meta_item) => {\n                        let path = meta_item\n                            .path()\n                            .into_token_stream()\n                            .to_string()\n                            .replace(' ', \"\");\n                        cx.error_spanned_by(\n                            meta_item.path(),\n                            format!(\"unknown serde field attribute `{}`\", path),\n                        );\n                    }\n\n                    Lit(ref lit) => {\n                        cx.error_spanned_by(lit, \"unexpected literal in serde field attribute\");\n                    }\n                }\n            }\n        }\n\n        // Is skip_deserializing, initialize the field to Default::default() unless a\n        // different default is specified by `#[serde(default = \"...\")]` on\n        // ourselves or our container (e.g. the struct we are in).\n        if let Default::None = *container_default {\n            if skip_deserializing.0.value.is_some() {\n                default.set_if_none(Default::Default);\n            }\n        }\n\n        let mut borrowed_lifetimes = borrowed_lifetimes.get().unwrap_or_default();\n        if !borrowed_lifetimes.is_empty() {\n            // Cow<str> and Cow<[u8]> never borrow by default:\n            //\n            //     impl<'de, 'a, T: ?Sized> Deserialize<'de> for Cow<'a, T>\n            //\n            // A #[serde(borrow)] attribute enables borrowing that corresponds\n            // roughly to these impls:\n            //\n            //     impl<'de: 'a, 'a> Deserialize<'de> for Cow<'a, str>\n            //     impl<'de: 'a, 'a> Deserialize<'de> for Cow<'a, [u8]>\n            if is_cow(&field.ty, is_str) {\n                let mut path = syn::Path {\n                    leading_colon: None,\n                    segments: Punctuated::new(),\n                };\n                path.segments\n                    .push(Ident::new(\"_serde\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"private\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"de\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"borrow_cow_str\", Span::call_site()).into());\n                let expr = syn::ExprPath {\n                    attrs: Vec::new(),\n                    qself: None,\n                    path: path,\n                };\n                deserialize_with.set_if_none(expr);\n            } else if is_cow(&field.ty, is_slice_u8) {\n                let mut path = syn::Path {\n                    leading_colon: None,\n                    segments: Punctuated::new(),\n                };\n                path.segments\n                    .push(Ident::new(\"_serde\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"private\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"de\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"borrow_cow_bytes\", Span::call_site()).into());\n                let expr = syn::ExprPath {\n                    attrs: Vec::new(),\n                    qself: None,\n                    path: path,\n                };\n                deserialize_with.set_if_none(expr);\n            }\n        } else if is_implicitly_borrowed(&field.ty) {\n            // Types &str and &[u8] are always implicitly borrowed. No need for\n            // a #[serde(borrow)].\n            collect_lifetimes(&field.ty, &mut borrowed_lifetimes);\n        }\n\n        Field {\n            name: Name::from_attrs(ident, ser_name, de_name, Some(de_aliases)),\n            skip_serializing: skip_serializing.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing_if: skip_serializing_if.get(),\n            default: default.get().unwrap_or(Default::None),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            borrowed_lifetimes: borrowed_lifetimes,\n            getter: getter.get(),\n            flatten: flatten.get(),\n            transparent: false,\n        }\n    }\n\n    pub fn name(&self) -> &Name {\n        &self.name\n    }\n\n    pub fn aliases(&self) -> Vec<String> {\n        self.name.deserialize_aliases()\n    }\n\n    pub fn rename_by_rules(&mut self, rules: &RenameAllRules) {\n        if !self.name.serialize_renamed {\n            self.name.serialize = rules.serialize.apply_to_field(&self.name.serialize);\n        }\n        if !self.name.deserialize_renamed {\n            self.name.deserialize = rules.deserialize.apply_to_field(&self.name.deserialize);\n        }\n    }\n\n    pub fn skip_serializing(&self) -> bool {\n        self.skip_serializing\n    }\n\n    pub fn skip_deserializing(&self) -> bool {\n        self.skip_deserializing\n    }\n\n    pub fn skip_serializing_if(&self) -> Option<&syn::ExprPath> {\n        self.skip_serializing_if.as_ref()\n    }\n\n    pub fn default(&self) -> &Default {\n        &self.default\n    }\n\n    pub fn serialize_with(&self) -> Option<&syn::ExprPath> {\n        self.serialize_with.as_ref()\n    }\n\n    pub fn deserialize_with(&self) -> Option<&syn::ExprPath> {\n        self.deserialize_with.as_ref()\n    }\n\n    pub fn ser_bound(&self) -> Option<&[syn::WherePredicate]> {\n        self.ser_bound.as_ref().map(|vec| &vec[..])\n    }\n\n    pub fn de_bound(&self) -> Option<&[syn::WherePredicate]> {\n        self.de_bound.as_ref().map(|vec| &vec[..])\n    }\n\n    pub fn borrowed_lifetimes(&self) -> &BTreeSet<syn::Lifetime> {\n        &self.borrowed_lifetimes\n    }\n\n    pub fn getter(&self) -> Option<&syn::ExprPath> {\n        self.getter.as_ref()\n    }\n\n    pub fn flatten(&self) -> bool {\n        self.flatten\n    }\n\n    pub fn transparent(&self) -> bool {\n        self.transparent\n    }\n\n    pub fn mark_transparent(&mut self) {\n        self.transparent = true;\n    }\n}\n\ntype SerAndDe<T> = (Option<T>, Option<T>);\n\nfn get_ser_and_de<'a, 'b, T, F>(\n    cx: &'b Ctxt,\n    attr_name: Symbol,\n    metas: &'a Punctuated<syn::NestedMeta, Token![,]>,\n    f: F,\n) -> Result<(VecAttr<'b, T>, VecAttr<'b, T>), ()>\nwhere\n    T: 'a,\n    F: Fn(&Ctxt, Symbol, Symbol, &'a syn::Lit) -> Result<T, ()>,\n{\n    let mut ser_meta = VecAttr::none(cx, attr_name);\n    let mut de_meta = VecAttr::none(cx, attr_name);\n\n    for meta in metas {\n        match *meta {\n            Meta(NameValue(ref meta)) if meta.path == SERIALIZE => {\n                if let Ok(v) = f(cx, attr_name, SERIALIZE, &meta.lit) {\n                    ser_meta.insert(&meta.path, v);\n                }\n            }\n\n            Meta(NameValue(ref meta)) if meta.path == DESERIALIZE => {\n                if let Ok(v) = f(cx, attr_name, DESERIALIZE, &meta.lit) {\n                    de_meta.insert(&meta.path, v);\n                }\n            }\n\n            _ => {\n                cx.error_spanned_by(\n                    meta,\n                    format!(\n                        \"malformed {0} attribute, expected `{0}(serialize = ..., \\\n                         deserialize = ...)`\",\n                        attr_name\n                    ),\n                );\n                return Err(());\n            }\n        }\n    }\n\n    Ok((ser_meta, de_meta))\n}\n\nfn get_renames<'a>(\n    cx: &Ctxt,\n    items: &'a Punctuated<syn::NestedMeta, Token![,]>,\n) -> Result<SerAndDe<&'a syn::LitStr>, ()> {\n    let (ser, de) = get_ser_and_de(cx, RENAME, items, get_lit_str2)?;\n    Ok((ser.at_most_one()?, de.at_most_one()?))\n}\n\nfn get_multiple_renames<'a>(\n    cx: &Ctxt,\n    items: &'a Punctuated<syn::NestedMeta, Token![,]>,\n) -> Result<(Option<&'a syn::LitStr>, Vec<&'a syn::LitStr>), ()> {\n    let (ser, de) = get_ser_and_de(cx, RENAME, items, get_lit_str2)?;\n    Ok((ser.at_most_one()?, de.get()))\n}\n\nfn get_where_predicates(\n    cx: &Ctxt,\n    items: &Punctuated<syn::NestedMeta, Token![,]>,\n) -> Result<SerAndDe<Vec<syn::WherePredicate>>, ()> {\n    let (ser, de) = get_ser_and_de(cx, BOUND, items, parse_lit_into_where)?;\n    Ok((ser.at_most_one()?, de.at_most_one()?))\n}\n\npub fn get_serde_meta_items(attr: &syn::Attribute) -> Option<Vec<syn::NestedMeta>> {\n    if attr.path == SERDE {\n        match attr.parse_meta() {\n            Ok(List(ref meta)) => Some(meta.nested.iter().cloned().collect()),\n            _ => {\n                // TODO: produce an error\n                None\n            }\n        }\n    } else {\n        None\n    }\n}\n\nfn get_lit_str<'a>(cx: &Ctxt, attr_name: Symbol, lit: &'a syn::Lit) -> Result<&'a syn::LitStr, ()> {\n    get_lit_str2(cx, attr_name, attr_name, lit)\n}\n\nfn get_lit_str2<'a>(\n    cx: &Ctxt,\n    attr_name: Symbol,\n    meta_item_name: Symbol,\n    lit: &'a syn::Lit,\n) -> Result<&'a syn::LitStr, ()> {\n    if let syn::Lit::Str(ref lit) = *lit {\n        Ok(lit)\n    } else {\n        cx.error_spanned_by(\n            lit,\n            format!(\n                \"expected serde {} attribute to be a string: `{} = \\\"...\\\"`\",\n                attr_name, meta_item_name\n            ),\n        );\n        Err(())\n    }\n}\n\nfn parse_lit_into_path(cx: &Ctxt, attr_name: Symbol, lit: &syn::Lit) -> Result<syn::Path, ()> {\n    let string = get_lit_str(cx, attr_name, lit)?;\n    parse_lit_str(string).map_err(|_| {\n        cx.error_spanned_by(lit, format!(\"failed to parse path: {:?}\", string.value()))\n    })\n}\n\nfn parse_lit_into_expr_path(\n    cx: &Ctxt,\n    attr_name: Symbol,\n    lit: &syn::Lit,\n) -> Result<syn::ExprPath, ()> {\n    let string = get_lit_str(cx, attr_name, lit)?;\n    parse_lit_str(string).map_err(|_| {\n        cx.error_spanned_by(lit, format!(\"failed to parse path: {:?}\", string.value()))\n    })\n}\n\nfn parse_lit_into_where(\n    cx: &Ctxt,\n    attr_name: Symbol,\n    meta_item_name: Symbol,\n    lit: &syn::Lit,\n) -> Result<Vec<syn::WherePredicate>, ()> {\n    let string = get_lit_str2(cx, attr_name, meta_item_name, lit)?;\n    if string.value().is_empty() {\n        return Ok(Vec::new());\n    }\n\n    let where_string = syn::LitStr::new(&format!(\"where {}\", string.value()), string.span());\n\n    parse_lit_str::<syn::WhereClause>(&where_string)\n        .map(|wh| wh.predicates.into_iter().collect())\n        .map_err(|err| cx.error_spanned_by(lit, err))\n}\n\nfn parse_lit_into_ty(cx: &Ctxt, attr_name: Symbol, lit: &syn::Lit) -> Result<syn::Type, ()> {\n    let string = get_lit_str(cx, attr_name, lit)?;\n\n    parse_lit_str(string).map_err(|_| {\n        cx.error_spanned_by(\n            lit,\n            format!(\"failed to parse type: {} = {:?}\", attr_name, string.value()),\n        )\n    })\n}\n\n// Parses a string literal like \"'a + 'b + 'c\" containing a nonempty list of\n// lifetimes separated by `+`.\nfn parse_lit_into_lifetimes(\n    cx: &Ctxt,\n    attr_name: Symbol,\n    lit: &syn::Lit,\n) -> Result<BTreeSet<syn::Lifetime>, ()> {\n    let string = get_lit_str(cx, attr_name, lit)?;\n    if string.value().is_empty() {\n        cx.error_spanned_by(lit, \"at least one lifetime must be borrowed\");\n        return Err(());\n    }\n\n    struct BorrowedLifetimes(Punctuated<syn::Lifetime, Token![+]>);\n\n    impl Parse for BorrowedLifetimes {\n        fn parse(input: ParseStream) -> parse::Result<Self> {\n            Punctuated::parse_separated_nonempty(input).map(BorrowedLifetimes)\n        }\n    }\n\n    if let Ok(BorrowedLifetimes(lifetimes)) = parse_lit_str(string) {\n        let mut set = BTreeSet::new();\n        for lifetime in lifetimes {\n            if !set.insert(lifetime.clone()) {\n                cx.error_spanned_by(lit, format!(\"duplicate borrowed lifetime `{}`\", lifetime));\n            }\n        }\n        return Ok(set);\n    }\n\n    cx.error_spanned_by(\n        lit,\n        format!(\"failed to parse borrowed lifetimes: {:?}\", string.value()),\n    );\n    Err(())\n}\n\nfn is_implicitly_borrowed(ty: &syn::Type) -> bool {\n    is_implicitly_borrowed_reference(ty) || is_option(ty, is_implicitly_borrowed_reference)\n}\n\nfn is_implicitly_borrowed_reference(ty: &syn::Type) -> bool {\n    is_reference(ty, is_str) || is_reference(ty, is_slice_u8)\n}\n\n// Whether the type looks like it might be `std::borrow::Cow<T>` where elem=\"T\".\n// This can have false negatives and false positives.\n//\n// False negative:\n//\n//     use std::borrow::Cow as Pig;\n//\n//     #[derive(Deserialize)]\n//     struct S<'a> {\n//         #[serde(borrow)]\n//         pig: Pig<'a, str>,\n//     }\n//\n// False positive:\n//\n//     type str = [i16];\n//\n//     #[derive(Deserialize)]\n//     struct S<'a> {\n//         #[serde(borrow)]\n//         cow: Cow<'a, str>,\n//     }\nfn is_cow(ty: &syn::Type, elem: fn(&syn::Type) -> bool) -> bool {\n    let path = match *ty {\n        syn::Type::Path(ref ty) => &ty.path,\n        _ => {\n            return false;\n        }\n    };\n    let seg = match path.segments.last() {\n        Some(seg) => seg,\n        None => {\n            return false;\n        }\n    };\n    let args = match seg.arguments {\n        syn::PathArguments::AngleBracketed(ref bracketed) => &bracketed.args,\n        _ => {\n            return false;\n        }\n    };\n    seg.ident == \"Cow\"\n        && args.len() == 2\n        && match (&args[0], &args[1]) {\n            (&syn::GenericArgument::Lifetime(_), &syn::GenericArgument::Type(ref arg)) => elem(arg),\n            _ => false,\n        }\n}\n\nfn is_option(ty: &syn::Type, elem: fn(&syn::Type) -> bool) -> bool {\n    let path = match *ty {\n        syn::Type::Path(ref ty) => &ty.path,\n        _ => {\n            return false;\n        }\n    };\n    let seg = match path.segments.last() {\n        Some(seg) => seg,\n        None => {\n            return false;\n        }\n    };\n    let args = match seg.arguments {\n        syn::PathArguments::AngleBracketed(ref bracketed) => &bracketed.args,\n        _ => {\n            return false;\n        }\n    };\n    seg.ident == \"Option\"\n        && args.len() == 1\n        && match args[0] {\n            syn::GenericArgument::Type(ref arg) => elem(arg),\n            _ => false,\n        }\n}\n\n// Whether the type looks like it might be `&T` where elem=\"T\". This can have\n// false negatives and false positives.\n//\n// False negative:\n//\n//     type Yarn = str;\n//\n//     #[derive(Deserialize)]\n//     struct S<'a> {\n//         r: &'a Yarn,\n//     }\n//\n// False positive:\n//\n//     type str = [i16];\n//\n//     #[derive(Deserialize)]\n//     struct S<'a> {\n//         r: &'a str,\n//     }\nfn is_reference(ty: &syn::Type, elem: fn(&syn::Type) -> bool) -> bool {\n    match *ty {\n        syn::Type::Reference(ref ty) => ty.mutability.is_none() && elem(&ty.elem),\n        _ => false,\n    }\n}\n\nfn is_str(ty: &syn::Type) -> bool {\n    is_primitive_type(ty, \"str\")\n}\n\nfn is_slice_u8(ty: &syn::Type) -> bool {\n    match *ty {\n        syn::Type::Slice(ref ty) => is_primitive_type(&ty.elem, \"u8\"),\n        _ => false,\n    }\n}\n\nfn is_primitive_type(ty: &syn::Type, primitive: &str) -> bool {\n    match *ty {\n        syn::Type::Path(ref ty) => ty.qself.is_none() && is_primitive_path(&ty.path, primitive),\n        _ => false,\n    }\n}\n\nfn is_primitive_path(path: &syn::Path, primitive: &str) -> bool {\n    path.leading_colon.is_none()\n        && path.segments.len() == 1\n        && path.segments[0].ident == primitive\n        && path.segments[0].arguments.is_empty()\n}\n\n// All lifetimes that this type could borrow from a Deserializer.\n//\n// For example a type `S<'a, 'b>` could borrow `'a` and `'b`. On the other hand\n// a type `for<'a> fn(&'a str)` could not borrow `'a` from the Deserializer.\n//\n// This is used when there is an explicit or implicit `#[serde(borrow)]`\n// attribute on the field so there must be at least one borrowable lifetime.\nfn borrowable_lifetimes(\n    cx: &Ctxt,\n    name: &str,\n    field: &syn::Field,\n) -> Result<BTreeSet<syn::Lifetime>, ()> {\n    let mut lifetimes = BTreeSet::new();\n    collect_lifetimes(&field.ty, &mut lifetimes);\n    if lifetimes.is_empty() {\n        cx.error_spanned_by(\n            field,\n            format!(\"field `{}` has no lifetimes to borrow\", name),\n        );\n        Err(())\n    } else {\n        Ok(lifetimes)\n    }\n}\n\nfn collect_lifetimes(ty: &syn::Type, out: &mut BTreeSet<syn::Lifetime>) {\n    match *ty {\n        syn::Type::Slice(ref ty) => {\n            collect_lifetimes(&ty.elem, out);\n        }\n        syn::Type::Array(ref ty) => {\n            collect_lifetimes(&ty.elem, out);\n        }\n        syn::Type::Ptr(ref ty) => {\n            collect_lifetimes(&ty.elem, out);\n        }\n        syn::Type::Reference(ref ty) => {\n            out.extend(ty.lifetime.iter().cloned());\n            collect_lifetimes(&ty.elem, out);\n        }\n        syn::Type::Tuple(ref ty) => {\n            for elem in &ty.elems {\n                collect_lifetimes(elem, out);\n            }\n        }\n        syn::Type::Path(ref ty) => {\n            if let Some(ref qself) = ty.qself {\n                collect_lifetimes(&qself.ty, out);\n            }\n            for seg in &ty.path.segments {\n                if let syn::PathArguments::AngleBracketed(ref bracketed) = seg.arguments {\n                    for arg in &bracketed.args {\n                        match *arg {\n                            syn::GenericArgument::Lifetime(ref lifetime) => {\n                                out.insert(lifetime.clone());\n                            }\n                            syn::GenericArgument::Type(ref ty) => {\n                                collect_lifetimes(ty, out);\n                            }\n                            syn::GenericArgument::Binding(ref binding) => {\n                                collect_lifetimes(&binding.ty, out);\n                            }\n                            syn::GenericArgument::Constraint(_)\n                            | syn::GenericArgument::Const(_) => {}\n                        }\n                    }\n                }\n            }\n        }\n        syn::Type::Paren(ref ty) => {\n            collect_lifetimes(&ty.elem, out);\n        }\n        syn::Type::Group(ref ty) => {\n            collect_lifetimes(&ty.elem, out);\n        }\n        syn::Type::BareFn(_)\n        | syn::Type::Never(_)\n        | syn::Type::TraitObject(_)\n        | syn::Type::ImplTrait(_)\n        | syn::Type::Infer(_)\n        | syn::Type::Macro(_)\n        | syn::Type::Verbatim(_)\n        | _ => {}\n    }\n}\n\nfn parse_lit_str<T>(s: &syn::LitStr) -> parse::Result<T>\nwhere\n    T: Parse,\n{\n    let tokens = spanned_tokens(s)?;\n    syn::parse2(tokens)\n}\n\nfn spanned_tokens(s: &syn::LitStr) -> parse::Result<TokenStream> {\n    let stream = syn::parse_str(&s.value())?;\n    Ok(respan_token_stream(stream, s.span()))\n}\n\nfn respan_token_stream(stream: TokenStream, span: Span) -> TokenStream {\n    stream\n        .into_iter()\n        .map(|token| respan_token_tree(token, span))\n        .collect()\n}\n\nfn respan_token_tree(mut token: TokenTree, span: Span) -> TokenTree {\n    if let TokenTree::Group(ref mut g) = token {\n        *g = Group::new(g.delimiter(), respan_token_stream(g.stream().clone(), span));\n    }\n    token.set_span(span);\n    token\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","case.rs"],"content":"//! Code to convert the Rust-styled field/variant (e.g. `my_field`, `MyType`) to the\n//! case of the source (e.g. `my-field`, `MY_FIELD`).\n\n// See https://users.rust-lang.org/t/psa-dealing-with-warning-unused-import-std-ascii-asciiext-in-today-s-nightly/13726\n#[allow(deprecated, unused_imports)]\nuse std::ascii::AsciiExt;\n\nuse std::str::FromStr;\n\nuse self::RenameRule::*;\n\n/// The different possible ways to change case of fields in a struct, or variants in an enum.\n#[derive(Copy, Clone, PartialEq)]\npub enum RenameRule {\n    /// Don't apply a default rename rule.\n    None,\n    /// Rename direct children to \"lowercase\" style.\n    LowerCase,\n    /// Rename direct children to \"UPPERCASE\" style.\n    UPPERCASE,\n    /// Rename direct children to \"PascalCase\" style, as typically used for\n    /// enum variants.\n    PascalCase,\n    /// Rename direct children to \"camelCase\" style.\n    CamelCase,\n    /// Rename direct children to \"snake_case\" style, as commonly used for\n    /// fields.\n    SnakeCase,\n    /// Rename direct children to \"SCREAMING_SNAKE_CASE\" style, as commonly\n    /// used for constants.\n    ScreamingSnakeCase,\n    /// Rename direct children to \"kebab-case\" style.\n    KebabCase,\n    /// Rename direct children to \"SCREAMING-KEBAB-CASE\" style.\n    ScreamingKebabCase,\n}\n\nimpl RenameRule {\n    /// Apply a renaming rule to an enum variant, returning the version expected in the source.\n    pub fn apply_to_variant(&self, variant: &str) -> String {\n        match *self {\n            None | PascalCase => variant.to_owned(),\n            LowerCase => variant.to_ascii_lowercase(),\n            UPPERCASE => variant.to_ascii_uppercase(),\n            CamelCase => variant[..1].to_ascii_lowercase() + &variant[1..],\n            SnakeCase => {\n                let mut snake = String::new();\n                for (i, ch) in variant.char_indices() {\n                    if i > 0 && ch.is_uppercase() {\n                        snake.push('_');\n                    }\n                    snake.push(ch.to_ascii_lowercase());\n                }\n                snake\n            }\n            ScreamingSnakeCase => SnakeCase.apply_to_variant(variant).to_ascii_uppercase(),\n            KebabCase => SnakeCase.apply_to_variant(variant).replace('_', \"-\"),\n            ScreamingKebabCase => ScreamingSnakeCase\n                .apply_to_variant(variant)\n                .replace('_', \"-\"),\n        }\n    }\n\n    /// Apply a renaming rule to a struct field, returning the version expected in the source.\n    pub fn apply_to_field(&self, field: &str) -> String {\n        match *self {\n            None | LowerCase | SnakeCase => field.to_owned(),\n            UPPERCASE => field.to_ascii_uppercase(),\n            PascalCase => {\n                let mut pascal = String::new();\n                let mut capitalize = true;\n                for ch in field.chars() {\n                    if ch == '_' {\n                        capitalize = true;\n                    } else if capitalize {\n                        pascal.push(ch.to_ascii_uppercase());\n                        capitalize = false;\n                    } else {\n                        pascal.push(ch);\n                    }\n                }\n                pascal\n            }\n            CamelCase => {\n                let pascal = PascalCase.apply_to_field(field);\n                pascal[..1].to_ascii_lowercase() + &pascal[1..]\n            }\n            ScreamingSnakeCase => field.to_ascii_uppercase(),\n            KebabCase => field.replace('_', \"-\"),\n            ScreamingKebabCase => ScreamingSnakeCase.apply_to_field(field).replace('_', \"-\"),\n        }\n    }\n}\n\nimpl FromStr for RenameRule {\n    type Err = ();\n\n    fn from_str(rename_all_str: &str) -> Result<Self, Self::Err> {\n        match rename_all_str {\n            \"lowercase\" => Ok(LowerCase),\n            \"UPPERCASE\" => Ok(UPPERCASE),\n            \"PascalCase\" => Ok(PascalCase),\n            \"camelCase\" => Ok(CamelCase),\n            \"snake_case\" => Ok(SnakeCase),\n            \"SCREAMING_SNAKE_CASE\" => Ok(ScreamingSnakeCase),\n            \"kebab-case\" => Ok(KebabCase),\n            \"SCREAMING-KEBAB-CASE\" => Ok(ScreamingKebabCase),\n            _ => Err(()),\n        }\n    }\n}\n\n#[test]\nfn rename_variants() {\n    for &(original, lower, upper, camel, snake, screaming, kebab, screaming_kebab) in &[\n        (\n            \"Outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"OUTCOME\",\n        ),\n        (\n            \"VeryTasty\",\n            \"verytasty\",\n            \"VERYTASTY\",\n            \"veryTasty\",\n            \"very_tasty\",\n            \"VERY_TASTY\",\n            \"very-tasty\",\n            \"VERY-TASTY\",\n        ),\n        (\"A\", \"a\", \"A\", \"a\", \"a\", \"A\", \"a\", \"A\"),\n        (\"Z42\", \"z42\", \"Z42\", \"z42\", \"z42\", \"Z42\", \"z42\", \"Z42\"),\n    ] {\n        assert_eq!(None.apply_to_variant(original), original);\n        assert_eq!(LowerCase.apply_to_variant(original), lower);\n        assert_eq!(UPPERCASE.apply_to_variant(original), upper);\n        assert_eq!(PascalCase.apply_to_variant(original), original);\n        assert_eq!(CamelCase.apply_to_variant(original), camel);\n        assert_eq!(SnakeCase.apply_to_variant(original), snake);\n        assert_eq!(ScreamingSnakeCase.apply_to_variant(original), screaming);\n        assert_eq!(KebabCase.apply_to_variant(original), kebab);\n        assert_eq!(\n            ScreamingKebabCase.apply_to_variant(original),\n            screaming_kebab\n        );\n    }\n}\n\n#[test]\nfn rename_fields() {\n    for &(original, upper, pascal, camel, screaming, kebab, screaming_kebab) in &[\n        (\n            \"outcome\", \"OUTCOME\", \"Outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"OUTCOME\",\n        ),\n        (\n            \"very_tasty\",\n            \"VERY_TASTY\",\n            \"VeryTasty\",\n            \"veryTasty\",\n            \"VERY_TASTY\",\n            \"very-tasty\",\n            \"VERY-TASTY\",\n        ),\n        (\"a\", \"A\", \"A\", \"a\", \"A\", \"a\", \"A\"),\n        (\"z42\", \"Z42\", \"Z42\", \"z42\", \"Z42\", \"z42\", \"Z42\"),\n    ] {\n        assert_eq!(None.apply_to_field(original), original);\n        assert_eq!(UPPERCASE.apply_to_field(original), upper);\n        assert_eq!(PascalCase.apply_to_field(original), pascal);\n        assert_eq!(CamelCase.apply_to_field(original), camel);\n        assert_eq!(SnakeCase.apply_to_field(original), original);\n        assert_eq!(ScreamingSnakeCase.apply_to_field(original), screaming);\n        assert_eq!(KebabCase.apply_to_field(original), kebab);\n        assert_eq!(ScreamingKebabCase.apply_to_field(original), screaming_kebab);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","check.rs"],"content":"use internals::ast::{Container, Data, Field, Style};\nuse internals::attr::{Identifier, TagType};\nuse internals::{Ctxt, Derive};\nuse syn::{Member, Type};\n\n/// Cross-cutting checks that require looking at more than a single attrs\n/// object. Simpler checks should happen when parsing and building the attrs.\npub fn check(cx: &Ctxt, cont: &mut Container, derive: Derive) {\n    check_getter(cx, cont);\n    check_flatten(cx, cont);\n    check_identifier(cx, cont);\n    check_variant_skip_attrs(cx, cont);\n    check_internal_tag_field_name_conflict(cx, cont);\n    check_adjacent_tag_conflict(cx, cont);\n    check_transparent(cx, cont, derive);\n    check_from_and_try_from(cx, cont);\n}\n\n/// Getters are only allowed inside structs (not enums) with the `remote`\n/// attribute.\nfn check_getter(cx: &Ctxt, cont: &Container) {\n    match cont.data {\n        Data::Enum(_) => {\n            if cont.data.has_getter() {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(getter = \\\"...\\\")] is not allowed in an enum\",\n                );\n            }\n        }\n        Data::Struct(_, _) => {\n            if cont.data.has_getter() && cont.attrs.remote().is_none() {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(getter = \\\"...\\\")] can only be used in structs \\\n                     that have #[serde(remote = \\\"...\\\")]\",\n                );\n            }\n        }\n    }\n}\n\n/// Flattening has some restrictions we can test.\nfn check_flatten(cx: &Ctxt, cont: &Container) {\n    match cont.data {\n        Data::Enum(ref variants) => {\n            for variant in variants {\n                for field in &variant.fields {\n                    check_flatten_field(cx, variant.style, field);\n                }\n            }\n        }\n        Data::Struct(style, ref fields) => {\n            for field in fields {\n                check_flatten_field(cx, style, field);\n            }\n        }\n    }\n}\n\nfn check_flatten_field(cx: &Ctxt, style: Style, field: &Field) {\n    if !field.attrs.flatten() {\n        return;\n    }\n    match style {\n        Style::Tuple => {\n            cx.error_spanned_by(\n                field.original,\n                \"#[serde(flatten)] cannot be used on tuple structs\",\n            );\n        }\n        Style::Newtype => {\n            cx.error_spanned_by(\n                field.original,\n                \"#[serde(flatten)] cannot be used on newtype structs\",\n            );\n        }\n        _ => {}\n    }\n}\n\n/// The `other` attribute must be used at most once and it must be the last\n/// variant of an enum.\n///\n/// Inside a `variant_identifier` all variants must be unit variants. Inside a\n/// `field_identifier` all but possibly one variant must be unit variants. The\n/// last variant may be a newtype variant which is an implicit \"other\" case.\nfn check_identifier(cx: &Ctxt, cont: &Container) {\n    let variants = match cont.data {\n        Data::Enum(ref variants) => variants,\n        Data::Struct(_, _) => {\n            return;\n        }\n    };\n\n    for (i, variant) in variants.iter().enumerate() {\n        match (\n            variant.style,\n            cont.attrs.identifier(),\n            variant.attrs.other(),\n            cont.attrs.tag(),\n        ) {\n            // The `other` attribute may not be used in a variant_identifier.\n            (_, Identifier::Variant, true, _) => {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(other)] may not be used on a variant identifier\",\n                );\n            }\n\n            // Variant with `other` attribute cannot appear in untagged enum\n            (_, Identifier::No, true, &TagType::None) => {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(other)] cannot appear on untagged enum\",\n                );\n            }\n\n            // Variant with `other` attribute must be the last one.\n            (Style::Unit, Identifier::Field, true, _) | (Style::Unit, Identifier::No, true, _) => {\n                if i < variants.len() - 1 {\n                    cx.error_spanned_by(\n                        variant.original,\n                        \"#[serde(other)] must be on the last variant\",\n                    );\n                }\n            }\n\n            // Variant with `other` attribute must be a unit variant.\n            (_, Identifier::Field, true, _) | (_, Identifier::No, true, _) => {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(other)] must be on a unit variant\",\n                );\n            }\n\n            // Any sort of variant is allowed if this is not an identifier.\n            (_, Identifier::No, false, _) => {}\n\n            // Unit variant without `other` attribute is always fine.\n            (Style::Unit, _, false, _) => {}\n\n            // The last field is allowed to be a newtype catch-all.\n            (Style::Newtype, Identifier::Field, false, _) => {\n                if i < variants.len() - 1 {\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\"`{}` must be the last variant\", variant.ident),\n                    );\n                }\n            }\n\n            (_, Identifier::Field, false, _) => {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(field_identifier)] may only contain unit variants\",\n                );\n            }\n\n            (_, Identifier::Variant, false, _) => {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(variant_identifier)] may only contain unit variants\",\n                );\n            }\n        }\n    }\n}\n\n/// Skip-(de)serializing attributes are not allowed on variants marked\n/// (de)serialize_with.\nfn check_variant_skip_attrs(cx: &Ctxt, cont: &Container) {\n    let variants = match cont.data {\n        Data::Enum(ref variants) => variants,\n        Data::Struct(_, _) => {\n            return;\n        }\n    };\n\n    for variant in variants.iter() {\n        if variant.attrs.serialize_with().is_some() {\n            if variant.attrs.skip_serializing() {\n                cx.error_spanned_by(\n                    variant.original,\n                    format!(\n                        \"variant `{}` cannot have both #[serde(serialize_with)] and \\\n                         #[serde(skip_serializing)]\",\n                        variant.ident\n                    ),\n                );\n            }\n\n            for field in &variant.fields {\n                let member = member_message(&field.member);\n\n                if field.attrs.skip_serializing() {\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\n                            \"variant `{}` cannot have both #[serde(serialize_with)] and \\\n                             a field {} marked with #[serde(skip_serializing)]\",\n                            variant.ident, member\n                        ),\n                    );\n                }\n\n                if field.attrs.skip_serializing_if().is_some() {\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\n                            \"variant `{}` cannot have both #[serde(serialize_with)] and \\\n                             a field {} marked with #[serde(skip_serializing_if)]\",\n                            variant.ident, member\n                        ),\n                    );\n                }\n            }\n        }\n\n        if variant.attrs.deserialize_with().is_some() {\n            if variant.attrs.skip_deserializing() {\n                cx.error_spanned_by(\n                    variant.original,\n                    format!(\n                        \"variant `{}` cannot have both #[serde(deserialize_with)] and \\\n                         #[serde(skip_deserializing)]\",\n                        variant.ident\n                    ),\n                );\n            }\n\n            for field in &variant.fields {\n                if field.attrs.skip_deserializing() {\n                    let member = member_message(&field.member);\n\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\n                            \"variant `{}` cannot have both #[serde(deserialize_with)] \\\n                             and a field {} marked with #[serde(skip_deserializing)]\",\n                            variant.ident, member\n                        ),\n                    );\n                }\n            }\n        }\n    }\n}\n\n/// The tag of an internally-tagged struct variant must not be\n/// the same as either one of its fields, as this would result in\n/// duplicate keys in the serialized output and/or ambiguity in\n/// the to-be-deserialized input.\nfn check_internal_tag_field_name_conflict(cx: &Ctxt, cont: &Container) {\n    let variants = match cont.data {\n        Data::Enum(ref variants) => variants,\n        Data::Struct(_, _) => return,\n    };\n\n    let tag = match *cont.attrs.tag() {\n        TagType::Internal { ref tag } => tag.as_str(),\n        TagType::External | TagType::Adjacent { .. } | TagType::None => return,\n    };\n\n    let diagnose_conflict = || {\n        cx.error_spanned_by(\n            cont.original,\n            format!(\"variant field name `{}` conflicts with internal tag\", tag),\n        )\n    };\n\n    for variant in variants {\n        match variant.style {\n            Style::Struct => {\n                for field in &variant.fields {\n                    let check_ser = !field.attrs.skip_serializing();\n                    let check_de = !field.attrs.skip_deserializing();\n                    let name = field.attrs.name();\n                    let ser_name = name.serialize_name();\n\n                    if check_ser && ser_name == tag {\n                        diagnose_conflict();\n                        return;\n                    }\n\n                    for de_name in field.attrs.aliases() {\n                        if check_de && de_name == tag {\n                            diagnose_conflict();\n                            return;\n                        }\n                    }\n                }\n            }\n            Style::Unit | Style::Newtype | Style::Tuple => {}\n        }\n    }\n}\n\n/// In the case of adjacently-tagged enums, the type and the\n/// contents tag must differ, for the same reason.\nfn check_adjacent_tag_conflict(cx: &Ctxt, cont: &Container) {\n    let (type_tag, content_tag) = match *cont.attrs.tag() {\n        TagType::Adjacent {\n            ref tag,\n            ref content,\n        } => (tag, content),\n        TagType::Internal { .. } | TagType::External | TagType::None => return,\n    };\n\n    if type_tag == content_tag {\n        cx.error_spanned_by(\n            cont.original,\n            format!(\n                \"enum tags `{}` for type and content conflict with each other\",\n                type_tag\n            ),\n        );\n    }\n}\n\n/// Enums and unit structs cannot be transparent.\nfn check_transparent(cx: &Ctxt, cont: &mut Container, derive: Derive) {\n    if !cont.attrs.transparent() {\n        return;\n    }\n\n    if cont.attrs.type_from().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(transparent)] is not allowed with #[serde(from = \\\"...\\\")]\",\n        );\n    }\n\n    if cont.attrs.type_try_from().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(transparent)] is not allowed with #[serde(try_from = \\\"...\\\")]\",\n        );\n    }\n\n    if cont.attrs.type_into().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(transparent)] is not allowed with #[serde(into = \\\"...\\\")]\",\n        );\n    }\n\n    let fields = match cont.data {\n        Data::Enum(_) => {\n            cx.error_spanned_by(\n                cont.original,\n                \"#[serde(transparent)] is not allowed on an enum\",\n            );\n            return;\n        }\n        Data::Struct(Style::Unit, _) => {\n            cx.error_spanned_by(\n                cont.original,\n                \"#[serde(transparent)] is not allowed on a unit struct\",\n            );\n            return;\n        }\n        Data::Struct(_, ref mut fields) => fields,\n    };\n\n    let mut transparent_field = None;\n\n    for field in fields {\n        if allow_transparent(field, derive) {\n            if transparent_field.is_some() {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(transparent)] requires struct to have at most one transparent field\",\n                );\n                return;\n            }\n            transparent_field = Some(field);\n        }\n    }\n\n    match transparent_field {\n        Some(transparent_field) => transparent_field.attrs.mark_transparent(),\n        None => match derive {\n            Derive::Serialize => {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(transparent)] requires at least one field that is not skipped\",\n                );\n            }\n            Derive::Deserialize => {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(transparent)] requires at least one field that is neither skipped nor has a default\",\n                );\n            }\n        },\n    }\n}\n\nfn member_message(member: &Member) -> String {\n    match *member {\n        Member::Named(ref ident) => format!(\"`{}`\", ident),\n        Member::Unnamed(ref i) => format!(\"#{}\", i.index),\n    }\n}\n\nfn allow_transparent(field: &Field, derive: Derive) -> bool {\n    if let Type::Path(ref ty) = *field.ty {\n        if let Some(seg) = ty.path.segments.last() {\n            if seg.ident == \"PhantomData\" {\n                return false;\n            }\n        }\n    }\n\n    match derive {\n        Derive::Serialize => !field.attrs.skip_serializing(),\n        Derive::Deserialize => !field.attrs.skip_deserializing() && field.attrs.default().is_none(),\n    }\n}\n\nfn check_from_and_try_from(cx: &Ctxt, cont: &mut Container) {\n    if cont.attrs.type_from().is_some() && cont.attrs.type_try_from().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(from = \\\"...\\\")] and #[serde(try_from = \\\"...\\\")] conflict with each other\",\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","ctxt.rs"],"content":"use quote::ToTokens;\nuse std::cell::RefCell;\nuse std::fmt::Display;\nuse std::thread;\nuse syn;\n\n/// A type to collect errors together and format them.\n///\n/// Dropping this object will cause a panic. It must be consumed using `check`.\n///\n/// References can be shared since this type uses run-time exclusive mut checking.\n#[derive(Default)]\npub struct Ctxt {\n    // The contents will be set to `None` during checking. This is so that checking can be\n    // enforced.\n    errors: RefCell<Option<Vec<syn::Error>>>,\n}\n\nimpl Ctxt {\n    /// Create a new context object.\n    ///\n    /// This object contains no errors, but will still trigger a panic if it is not `check`ed.\n    pub fn new() -> Self {\n        Ctxt {\n            errors: RefCell::new(Some(Vec::new())),\n        }\n    }\n\n    /// Add an error to the context object with a tokenenizable object.\n    ///\n    /// The object is used for spanning in error messages.\n    pub fn error_spanned_by<A: ToTokens, T: Display>(&self, obj: A, msg: T) {\n        self.errors\n            .borrow_mut()\n            .as_mut()\n            .unwrap()\n            // Curb monomorphization from generating too many identical methods.\n            .push(syn::Error::new_spanned(obj.into_token_stream(), msg));\n    }\n\n    /// Consume this object, producing a formatted error string if there are errors.\n    pub fn check(self) -> Result<(), Vec<syn::Error>> {\n        let errors = self.errors.borrow_mut().take().unwrap();\n        match errors.len() {\n            0 => Ok(()),\n            _ => Err(errors),\n        }\n    }\n}\n\nimpl Drop for Ctxt {\n    fn drop(&mut self) {\n        if !thread::panicking() && self.errors.borrow().is_some() {\n            panic!(\"forgot to check for errors\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","mod.rs"],"content":"pub mod ast;\npub mod attr;\n\nmod ctxt;\npub use self::ctxt::Ctxt;\n\nmod case;\nmod check;\nmod symbol;\n\n#[derive(Copy, Clone)]\npub enum Derive {\n    Serialize,\n    Deserialize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","symbol.rs"],"content":"use std::fmt::{self, Display};\nuse syn::{Ident, Path};\n\n#[derive(Copy, Clone)]\npub struct Symbol(&'static str);\n\npub const ALIAS: Symbol = Symbol(\"alias\");\npub const BORROW: Symbol = Symbol(\"borrow\");\npub const BOUND: Symbol = Symbol(\"bound\");\npub const CONTENT: Symbol = Symbol(\"content\");\npub const CRATE: Symbol = Symbol(\"crate\");\npub const DEFAULT: Symbol = Symbol(\"default\");\npub const DENY_UNKNOWN_FIELDS: Symbol = Symbol(\"deny_unknown_fields\");\npub const DESERIALIZE: Symbol = Symbol(\"deserialize\");\npub const DESERIALIZE_WITH: Symbol = Symbol(\"deserialize_with\");\npub const FIELD_IDENTIFIER: Symbol = Symbol(\"field_identifier\");\npub const FLATTEN: Symbol = Symbol(\"flatten\");\npub const FROM: Symbol = Symbol(\"from\");\npub const GETTER: Symbol = Symbol(\"getter\");\npub const INTO: Symbol = Symbol(\"into\");\npub const OTHER: Symbol = Symbol(\"other\");\npub const REMOTE: Symbol = Symbol(\"remote\");\npub const RENAME: Symbol = Symbol(\"rename\");\npub const RENAME_ALL: Symbol = Symbol(\"rename_all\");\npub const SERDE: Symbol = Symbol(\"serde\");\npub const SERIALIZE: Symbol = Symbol(\"serialize\");\npub const SERIALIZE_WITH: Symbol = Symbol(\"serialize_with\");\npub const SKIP: Symbol = Symbol(\"skip\");\npub const SKIP_DESERIALIZING: Symbol = Symbol(\"skip_deserializing\");\npub const SKIP_SERIALIZING: Symbol = Symbol(\"skip_serializing\");\npub const SKIP_SERIALIZING_IF: Symbol = Symbol(\"skip_serializing_if\");\npub const TAG: Symbol = Symbol(\"tag\");\npub const TRANSPARENT: Symbol = Symbol(\"transparent\");\npub const TRY_FROM: Symbol = Symbol(\"try_from\");\npub const UNTAGGED: Symbol = Symbol(\"untagged\");\npub const VARIANT_IDENTIFIER: Symbol = Symbol(\"variant_identifier\");\npub const WITH: Symbol = Symbol(\"with\");\n\nimpl PartialEq<Symbol> for Ident {\n    fn eq(&self, word: &Symbol) -> bool {\n        self == word.0\n    }\n}\n\nimpl<'a> PartialEq<Symbol> for &'a Ident {\n    fn eq(&self, word: &Symbol) -> bool {\n        *self == word.0\n    }\n}\n\nimpl PartialEq<Symbol> for Path {\n    fn eq(&self, word: &Symbol) -> bool {\n        self.is_ident(word.0)\n    }\n}\n\nimpl<'a> PartialEq<Symbol> for &'a Path {\n    fn eq(&self, word: &Symbol) -> bool {\n        self.is_ident(word.0)\n    }\n}\n\nimpl Display for Symbol {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(self.0)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","lib.rs"],"content":"//! This crate provides Serde's two derive macros.\n//!\n//! ```edition2018\n//! # use serde_derive::{Serialize, Deserialize};\n//! #\n//! #[derive(Serialize, Deserialize)]\n//! # struct S;\n//! #\n//! # fn main() {}\n//! ```\n//!\n//! Please refer to [https://serde.rs/derive.html] for how to set this up.\n//!\n//! [https://serde.rs/derive.html]: https://serde.rs/derive.html\n\n#![doc(html_root_url = \"https://docs.rs/serde_derive/1.0.100\")]\n#![allow(unknown_lints, bare_trait_objects)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(renamed_and_removed_lints))]\n#![cfg_attr(feature = \"cargo-clippy\", deny(clippy, clippy_pedantic))]\n// Ignored clippy lints\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        cognitive_complexity,\n        enum_variant_names,\n        needless_pass_by_value,\n        redundant_field_names,\n        too_many_arguments,\n        trivially_copy_pass_by_ref,\n        used_underscore_binding,\n    )\n)]\n// Ignored clippy_pedantic lints\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        cast_possible_truncation,\n        checked_conversions,\n        doc_markdown,\n        enum_glob_use,\n        filter_map,\n        indexing_slicing,\n        items_after_statements,\n        match_same_arms,\n        module_name_repetitions,\n        similar_names,\n        single_match_else,\n        unseparated_literal_suffix,\n        use_self,\n    )\n)]\n// The `quote!` macro requires deep recursion.\n#![recursion_limit = \"512\"]\n\n#[macro_use]\nextern crate quote;\n#[macro_use]\nextern crate syn;\n\nextern crate proc_macro;\nextern crate proc_macro2;\n\nmod internals;\n\nuse proc_macro::TokenStream;\nuse syn::DeriveInput;\n\n#[macro_use]\nmod bound;\n#[macro_use]\nmod fragment;\n\nmod de;\nmod dummy;\nmod pretend;\nmod ser;\nmod try;\n\n#[proc_macro_derive(Serialize, attributes(serde))]\npub fn derive_serialize(input: TokenStream) -> TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    ser::expand_derive_serialize(&input)\n        .unwrap_or_else(to_compile_errors)\n        .into()\n}\n\n#[proc_macro_derive(Deserialize, attributes(serde))]\npub fn derive_deserialize(input: TokenStream) -> TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    de::expand_derive_deserialize(&input)\n        .unwrap_or_else(to_compile_errors)\n        .into()\n}\n\nfn to_compile_errors(errors: Vec<syn::Error>) -> proc_macro2::TokenStream {\n    let compile_errors = errors.iter().map(syn::Error::to_compile_error);\n    quote!(#(#compile_errors)*)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","pretend.rs"],"content":"use proc_macro2::{Span, TokenStream};\nuse syn::Ident;\n\nuse internals::ast::{Container, Data, Field, Style};\n\n// Suppress dead_code warnings that would otherwise appear when using a remote\n// derive. Other than this pretend code, a struct annotated with remote derive\n// never has its fields referenced and an enum annotated with remote derive\n// never has its variants constructed.\n//\n//     warning: field is never used: `i`\n//      --> src/main.rs:4:20\n//       |\n//     4 | struct StructDef { i: i32 }\n//       |                    ^^^^^^\n//\n//     warning: variant is never constructed: `V`\n//      --> src/main.rs:8:16\n//       |\n//     8 | enum EnumDef { V }\n//       |                ^\n//\npub fn pretend_used(cont: &Container) -> TokenStream {\n    let pretend_fields = pretend_fields_used(cont);\n    let pretend_variants = pretend_variants_used(cont);\n\n    quote! {\n        #pretend_fields\n        #pretend_variants\n    }\n}\n\n// For structs with named fields, expands to:\n//\n//     match None::<T> {\n//         Some(T { a: ref __v0, b: ref __v1 }) => {}\n//         _ => {}\n//     }\n//\n// For enums, expands to the following but only including struct variants:\n//\n//     match None::<T> {\n//         Some(T::A { a: ref __v0 }) => {}\n//         Some(T::B { b: ref __v0 }) => {}\n//         _ => {}\n//     }\n//\n// The `ref` is important in case the user has written a Drop impl on their\n// type. Rust does not allow destructuring a struct or enum that has a Drop\n// impl.\nfn pretend_fields_used(cont: &Container) -> TokenStream {\n    let type_ident = &cont.ident;\n    let (_, ty_generics, _) = cont.generics.split_for_impl();\n\n    let patterns = match cont.data {\n        Data::Enum(ref variants) => variants\n            .iter()\n            .filter_map(|variant| match variant.style {\n                Style::Struct => {\n                    let variant_ident = &variant.ident;\n                    let pat = struct_pattern(&variant.fields);\n                    Some(quote!(#type_ident::#variant_ident #pat))\n                }\n                _ => None,\n            })\n            .collect::<Vec<_>>(),\n        Data::Struct(Style::Struct, ref fields) => {\n            let pat = struct_pattern(fields);\n            vec![quote!(#type_ident #pat)]\n        }\n        Data::Struct(_, _) => {\n            return quote!();\n        }\n    };\n\n    quote! {\n        match _serde::export::None::<#type_ident #ty_generics> {\n            #(\n                _serde::export::Some(#patterns) => {}\n            )*\n            _ => {}\n        }\n    }\n}\n\n// Expands to one of these per enum variant:\n//\n//     match None {\n//         Some((__v0, __v1,)) => {\n//             let _ = E::V { a: __v0, b: __v1 };\n//         }\n//         _ => {}\n//     }\n//\nfn pretend_variants_used(cont: &Container) -> TokenStream {\n    let variants = match cont.data {\n        Data::Enum(ref variants) => variants,\n        Data::Struct(_, _) => {\n            return quote!();\n        }\n    };\n\n    let type_ident = &cont.ident;\n    let (_, ty_generics, _) = cont.generics.split_for_impl();\n    let turbofish = ty_generics.as_turbofish();\n\n    let cases = variants.iter().map(|variant| {\n        let variant_ident = &variant.ident;\n        let placeholders = &(0..variant.fields.len())\n            .map(|i| Ident::new(&format!(\"__v{}\", i), Span::call_site()))\n            .collect::<Vec<_>>();\n\n        let pat = match variant.style {\n            Style::Struct => {\n                let members = variant.fields.iter().map(|field| &field.member);\n                quote!({ #(#members: #placeholders),* })\n            }\n            Style::Tuple | Style::Newtype => quote!(( #(#placeholders),* )),\n            Style::Unit => quote!(),\n        };\n\n        quote! {\n            match _serde::export::None {\n                _serde::export::Some((#(#placeholders,)*)) => {\n                    let _ = #type_ident::#variant_ident #turbofish #pat;\n                }\n                _ => {}\n            }\n        }\n    });\n\n    quote!(#(#cases)*)\n}\n\nfn struct_pattern(fields: &[Field]) -> TokenStream {\n    let members = fields.iter().map(|field| &field.member);\n    let placeholders =\n        (0..fields.len()).map(|i| Ident::new(&format!(\"__v{}\", i), Span::call_site()));\n    quote!({ #(#members: ref #placeholders),* })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","ser.rs"],"content":"use proc_macro2::{Span, TokenStream};\nuse syn::spanned::Spanned;\nuse syn::{self, Ident, Index, Member};\n\nuse bound;\nuse dummy;\nuse fragment::{Fragment, Match, Stmts};\nuse internals::ast::{Container, Data, Field, Style, Variant};\nuse internals::{attr, Ctxt, Derive};\nuse pretend;\n\npub fn expand_derive_serialize(input: &syn::DeriveInput) -> Result<TokenStream, Vec<syn::Error>> {\n    let ctxt = Ctxt::new();\n    let cont = match Container::from_ast(&ctxt, input, Derive::Serialize) {\n        Some(cont) => cont,\n        None => return Err(ctxt.check().unwrap_err()),\n    };\n    precondition(&ctxt, &cont);\n    ctxt.check()?;\n\n    let ident = &cont.ident;\n    let params = Parameters::new(&cont);\n    let (impl_generics, ty_generics, where_clause) = params.generics.split_for_impl();\n    let body = Stmts(serialize_body(&cont, &params));\n    let serde = cont.attrs.serde_path();\n\n    let impl_block = if let Some(remote) = cont.attrs.remote() {\n        let vis = &input.vis;\n        let used = pretend::pretend_used(&cont);\n        quote! {\n            impl #impl_generics #ident #ty_generics #where_clause {\n                #vis fn serialize<__S>(__self: &#remote #ty_generics, __serializer: __S) -> #serde::export::Result<__S::Ok, __S::Error>\n                where\n                    __S: #serde::Serializer,\n                {\n                    #used\n                    #body\n                }\n            }\n        }\n    } else {\n        quote! {\n            #[automatically_derived]\n            impl #impl_generics #serde::Serialize for #ident #ty_generics #where_clause {\n                fn serialize<__S>(&self, __serializer: __S) -> #serde::export::Result<__S::Ok, __S::Error>\n                where\n                    __S: #serde::Serializer,\n                {\n                    #body\n                }\n            }\n        }\n    };\n\n    Ok(dummy::wrap_in_const(\n        cont.attrs.custom_serde_path(),\n        \"SERIALIZE\",\n        ident,\n        impl_block,\n    ))\n}\n\nfn precondition(cx: &Ctxt, cont: &Container) {\n    match cont.attrs.identifier() {\n        attr::Identifier::No => {}\n        attr::Identifier::Field => {\n            cx.error_spanned_by(cont.original, \"field identifiers cannot be serialized\");\n        }\n        attr::Identifier::Variant => {\n            cx.error_spanned_by(cont.original, \"variant identifiers cannot be serialized\");\n        }\n    }\n}\n\nstruct Parameters {\n    /// Variable holding the value being serialized. Either `self` for local\n    /// types or `__self` for remote types.\n    self_var: Ident,\n\n    /// Path to the type the impl is for. Either a single `Ident` for local\n    /// types or `some::remote::Ident` for remote types. Does not include\n    /// generic parameters.\n    this: syn::Path,\n\n    /// Generics including any explicit and inferred bounds for the impl.\n    generics: syn::Generics,\n\n    /// Type has a `serde(remote = \"...\")` attribute.\n    is_remote: bool,\n}\n\nimpl Parameters {\n    fn new(cont: &Container) -> Self {\n        let is_remote = cont.attrs.remote().is_some();\n        let self_var = if is_remote {\n            Ident::new(\"__self\", Span::call_site())\n        } else {\n            Ident::new(\"self\", Span::call_site())\n        };\n\n        let this = match cont.attrs.remote() {\n            Some(remote) => remote.clone(),\n            None => cont.ident.clone().into(),\n        };\n\n        let generics = build_generics(cont);\n\n        Parameters {\n            self_var: self_var,\n            this: this,\n            generics: generics,\n            is_remote: is_remote,\n        }\n    }\n\n    /// Type name to use in error messages and `&'static str` arguments to\n    /// various Serializer methods.\n    fn type_name(&self) -> String {\n        self.this.segments.last().unwrap().ident.to_string()\n    }\n}\n\n// All the generics in the input, plus a bound `T: Serialize` for each generic\n// field type that will be serialized by us.\nfn build_generics(cont: &Container) -> syn::Generics {\n    let generics = bound::without_defaults(cont.generics);\n\n    let generics =\n        bound::with_where_predicates_from_fields(cont, &generics, attr::Field::ser_bound);\n\n    let generics =\n        bound::with_where_predicates_from_variants(cont, &generics, attr::Variant::ser_bound);\n\n    match cont.attrs.ser_bound() {\n        Some(predicates) => bound::with_where_predicates(&generics, predicates),\n        None => bound::with_bound(\n            cont,\n            &generics,\n            needs_serialize_bound,\n            &parse_quote!(_serde::Serialize),\n        ),\n    }\n}\n\n// Fields with a `skip_serializing` or `serialize_with` attribute, or which\n// belong to a variant with a 'skip_serializing` or `serialize_with` attribute,\n// are not serialized by us so we do not generate a bound. Fields with a `bound`\n// attribute specify their own bound so we do not generate one. All other fields\n// may need a `T: Serialize` bound where T is the type of the field.\nfn needs_serialize_bound(field: &attr::Field, variant: Option<&attr::Variant>) -> bool {\n    !field.skip_serializing()\n        && field.serialize_with().is_none()\n        && field.ser_bound().is_none()\n        && variant.map_or(true, |variant| {\n            !variant.skip_serializing()\n                && variant.serialize_with().is_none()\n                && variant.ser_bound().is_none()\n        })\n}\n\nfn serialize_body(cont: &Container, params: &Parameters) -> Fragment {\n    if cont.attrs.transparent() {\n        serialize_transparent(cont, params)\n    } else if let Some(type_into) = cont.attrs.type_into() {\n        serialize_into(params, type_into)\n    } else {\n        match cont.data {\n            Data::Enum(ref variants) => serialize_enum(params, variants, &cont.attrs),\n            Data::Struct(Style::Struct, ref fields) => {\n                serialize_struct(params, fields, &cont.attrs)\n            }\n            Data::Struct(Style::Tuple, ref fields) => {\n                serialize_tuple_struct(params, fields, &cont.attrs)\n            }\n            Data::Struct(Style::Newtype, ref fields) => {\n                serialize_newtype_struct(params, &fields[0], &cont.attrs)\n            }\n            Data::Struct(Style::Unit, _) => serialize_unit_struct(&cont.attrs),\n        }\n    }\n}\n\nfn serialize_transparent(cont: &Container, params: &Parameters) -> Fragment {\n    let fields = match cont.data {\n        Data::Struct(_, ref fields) => fields,\n        Data::Enum(_) => unreachable!(),\n    };\n\n    let self_var = &params.self_var;\n    let transparent_field = fields.iter().find(|f| f.attrs.transparent()).unwrap();\n    let member = &transparent_field.member;\n\n    let path = match transparent_field.attrs.serialize_with() {\n        Some(path) => quote!(#path),\n        None => {\n            let span = transparent_field.original.span();\n            quote_spanned!(span=> _serde::Serialize::serialize)\n        }\n    };\n\n    quote_block! {\n        #path(&#self_var.#member, __serializer)\n    }\n}\n\nfn serialize_into(params: &Parameters, type_into: &syn::Type) -> Fragment {\n    let self_var = &params.self_var;\n    quote_block! {\n        _serde::Serialize::serialize(\n            &_serde::export::Into::<#type_into>::into(_serde::export::Clone::clone(#self_var)),\n            __serializer)\n    }\n}\n\nfn serialize_unit_struct(cattrs: &attr::Container) -> Fragment {\n    let type_name = cattrs.name().serialize_name();\n\n    quote_expr! {\n        _serde::Serializer::serialize_unit_struct(__serializer, #type_name)\n    }\n}\n\nfn serialize_newtype_struct(\n    params: &Parameters,\n    field: &Field,\n    cattrs: &attr::Container,\n) -> Fragment {\n    let type_name = cattrs.name().serialize_name();\n\n    let mut field_expr = get_member(\n        params,\n        field,\n        &Member::Unnamed(Index {\n            index: 0,\n            span: Span::call_site(),\n        }),\n    );\n    if let Some(path) = field.attrs.serialize_with() {\n        field_expr = wrap_serialize_field_with(params, field.ty, path, &field_expr);\n    }\n\n    let span = field.original.span();\n    let func = quote_spanned!(span=> _serde::Serializer::serialize_newtype_struct);\n    quote_expr! {\n        #func(__serializer, #type_name, #field_expr)\n    }\n}\n\nfn serialize_tuple_struct(\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n) -> Fragment {\n    let serialize_stmts =\n        serialize_tuple_struct_visitor(fields, params, false, &TupleTrait::SerializeTupleStruct);\n\n    let type_name = cattrs.name().serialize_name();\n\n    let mut serialized_fields = fields\n        .iter()\n        .enumerate()\n        .filter(|&(_, ref field)| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some());\n\n    let len = serialized_fields\n        .map(|(i, field)| match field.attrs.skip_serializing_if() {\n            None => quote!(1),\n            Some(path) => {\n                let index = syn::Index {\n                    index: i as u32,\n                    span: Span::call_site(),\n                };\n                let field_expr = get_member(params, field, &Member::Unnamed(index));\n                quote!(if #path(#field_expr) { 0 } else { 1 })\n            }\n        })\n        .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n\n    quote_block! {\n        let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple_struct(__serializer, #type_name, #len));\n        #(#serialize_stmts)*\n        _serde::ser::SerializeTupleStruct::end(__serde_state)\n    }\n}\n\nfn serialize_struct(params: &Parameters, fields: &[Field], cattrs: &attr::Container) -> Fragment {\n    assert!(fields.len() as u64 <= u64::from(u32::max_value()));\n\n    if cattrs.has_flatten() {\n        serialize_struct_as_map(params, fields, cattrs)\n    } else {\n        serialize_struct_as_struct(params, fields, cattrs)\n    }\n}\n\nfn serialize_struct_tag_field(cattrs: &attr::Container, struct_trait: &StructTrait) -> TokenStream {\n    match *cattrs.tag() {\n        attr::TagType::Internal { ref tag } => {\n            let type_name = cattrs.name().serialize_name();\n            let func = struct_trait.serialize_field(Span::call_site());\n            quote! {\n                try!(#func(&mut __serde_state, #tag, #type_name));\n            }\n        }\n        _ => quote! {},\n    }\n}\n\nfn serialize_struct_as_struct(\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n) -> Fragment {\n    let serialize_fields =\n        serialize_struct_visitor(fields, params, false, &StructTrait::SerializeStruct);\n\n    let type_name = cattrs.name().serialize_name();\n\n    let tag_field = serialize_struct_tag_field(cattrs, &StructTrait::SerializeStruct);\n    let tag_field_exists = !tag_field.is_empty();\n\n    let mut serialized_fields = fields\n        .iter()\n        .filter(|&field| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some() || tag_field_exists);\n\n    let len = serialized_fields\n        .map(|field| match field.attrs.skip_serializing_if() {\n            None => quote!(1),\n            Some(path) => {\n                let field_expr = get_member(params, field, &field.member);\n                quote!(if #path(#field_expr) { 0 } else { 1 })\n            }\n        })\n        .fold(\n            quote!(#tag_field_exists as usize),\n            |sum, expr| quote!(#sum + #expr),\n        );\n\n    quote_block! {\n        let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct(__serializer, #type_name, #len));\n        #tag_field\n        #(#serialize_fields)*\n        _serde::ser::SerializeStruct::end(__serde_state)\n    }\n}\n\nfn serialize_struct_as_map(\n    params: &Parameters,\n    fields: &[Field],\n    cattrs: &attr::Container,\n) -> Fragment {\n    let serialize_fields =\n        serialize_struct_visitor(fields, params, false, &StructTrait::SerializeMap);\n\n    let tag_field = serialize_struct_tag_field(cattrs, &StructTrait::SerializeMap);\n    let tag_field_exists = !tag_field.is_empty();\n\n    let mut serialized_fields = fields\n        .iter()\n        .filter(|&field| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some() || tag_field_exists);\n\n    let len = if cattrs.has_flatten() {\n        quote!(_serde::export::None)\n    } else {\n        let len = serialized_fields\n            .map(|field| match field.attrs.skip_serializing_if() {\n                None => quote!(1),\n                Some(path) => {\n                    let field_expr = get_member(params, field, &field.member);\n                    quote!(if #path(#field_expr) { 0 } else { 1 })\n                }\n            })\n            .fold(\n                quote!(#tag_field_exists as usize),\n                |sum, expr| quote!(#sum + #expr),\n            );\n        quote!(_serde::export::Some(#len))\n    };\n\n    quote_block! {\n        let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(__serializer, #len));\n        #tag_field\n        #(#serialize_fields)*\n        _serde::ser::SerializeMap::end(__serde_state)\n    }\n}\n\nfn serialize_enum(params: &Parameters, variants: &[Variant], cattrs: &attr::Container) -> Fragment {\n    assert!(variants.len() as u64 <= u64::from(u32::max_value()));\n\n    let self_var = &params.self_var;\n\n    let arms: Vec<_> = variants\n        .iter()\n        .enumerate()\n        .map(|(variant_index, variant)| {\n            serialize_variant(params, variant, variant_index as u32, cattrs)\n        })\n        .collect();\n\n    quote_expr! {\n        match *#self_var {\n            #(#arms)*\n        }\n    }\n}\n\nfn serialize_variant(\n    params: &Parameters,\n    variant: &Variant,\n    variant_index: u32,\n    cattrs: &attr::Container,\n) -> TokenStream {\n    let this = &params.this;\n    let variant_ident = &variant.ident;\n\n    if variant.attrs.skip_serializing() {\n        let skipped_msg = format!(\n            \"the enum variant {}::{} cannot be serialized\",\n            params.type_name(),\n            variant_ident\n        );\n        let skipped_err = quote! {\n            _serde::export::Err(_serde::ser::Error::custom(#skipped_msg))\n        };\n        let fields_pat = match variant.style {\n            Style::Unit => quote!(),\n            Style::Newtype | Style::Tuple => quote!((..)),\n            Style::Struct => quote!({ .. }),\n        };\n        quote! {\n            #this::#variant_ident #fields_pat => #skipped_err,\n        }\n    } else {\n        // variant wasn't skipped\n        let case = match variant.style {\n            Style::Unit => {\n                quote! {\n                    #this::#variant_ident\n                }\n            }\n            Style::Newtype => {\n                quote! {\n                    #this::#variant_ident(ref __field0)\n                }\n            }\n            Style::Tuple => {\n                let field_names = (0..variant.fields.len())\n                    .map(|i| Ident::new(&format!(\"__field{}\", i), Span::call_site()));\n                quote! {\n                    #this::#variant_ident(#(ref #field_names),*)\n                }\n            }\n            Style::Struct => {\n                let members = variant.fields.iter().map(|f| &f.member);\n                quote! {\n                    #this::#variant_ident { #(ref #members),* }\n                }\n            }\n        };\n\n        let body = Match(match *cattrs.tag() {\n            attr::TagType::External => {\n                serialize_externally_tagged_variant(params, variant, variant_index, cattrs)\n            }\n            attr::TagType::Internal { ref tag } => {\n                serialize_internally_tagged_variant(params, variant, cattrs, tag)\n            }\n            attr::TagType::Adjacent {\n                ref tag,\n                ref content,\n            } => serialize_adjacently_tagged_variant(params, variant, cattrs, tag, content),\n            attr::TagType::None => serialize_untagged_variant(params, variant, cattrs),\n        });\n\n        quote! {\n            #case => #body\n        }\n    }\n}\n\nfn serialize_externally_tagged_variant(\n    params: &Parameters,\n    variant: &Variant,\n    variant_index: u32,\n    cattrs: &attr::Container,\n) -> Fragment {\n    let type_name = cattrs.name().serialize_name();\n    let variant_name = variant.attrs.name().serialize_name();\n\n    if let Some(path) = variant.attrs.serialize_with() {\n        let ser = wrap_serialize_variant_with(params, path, variant);\n        return quote_expr! {\n            _serde::Serializer::serialize_newtype_variant(\n                __serializer,\n                #type_name,\n                #variant_index,\n                #variant_name,\n                #ser,\n            )\n        };\n    }\n\n    match variant.style {\n        Style::Unit => {\n            quote_expr! {\n                _serde::Serializer::serialize_unit_variant(\n                    __serializer,\n                    #type_name,\n                    #variant_index,\n                    #variant_name,\n                )\n            }\n        }\n        Style::Newtype => {\n            let field = &variant.fields[0];\n            let mut field_expr = quote!(__field0);\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, &field_expr);\n            }\n\n            let span = field.original.span();\n            let func = quote_spanned!(span=> _serde::Serializer::serialize_newtype_variant);\n            quote_expr! {\n                #func(\n                    __serializer,\n                    #type_name,\n                    #variant_index,\n                    #variant_name,\n                    #field_expr,\n                )\n            }\n        }\n        Style::Tuple => serialize_tuple_variant(\n            TupleVariant::ExternallyTagged {\n                type_name: type_name,\n                variant_index: variant_index,\n                variant_name: variant_name,\n            },\n            params,\n            &variant.fields,\n        ),\n        Style::Struct => serialize_struct_variant(\n            StructVariant::ExternallyTagged {\n                variant_index: variant_index,\n                variant_name: variant_name,\n            },\n            params,\n            &variant.fields,\n            &type_name,\n        ),\n    }\n}\n\nfn serialize_internally_tagged_variant(\n    params: &Parameters,\n    variant: &Variant,\n    cattrs: &attr::Container,\n    tag: &str,\n) -> Fragment {\n    let type_name = cattrs.name().serialize_name();\n    let variant_name = variant.attrs.name().serialize_name();\n\n    let enum_ident_str = params.type_name();\n    let variant_ident_str = variant.ident.to_string();\n\n    if let Some(path) = variant.attrs.serialize_with() {\n        let ser = wrap_serialize_variant_with(params, path, variant);\n        return quote_expr! {\n            _serde::private::ser::serialize_tagged_newtype(\n                __serializer,\n                #enum_ident_str,\n                #variant_ident_str,\n                #tag,\n                #variant_name,\n                #ser,\n            )\n        };\n    }\n\n    match variant.style {\n        Style::Unit => {\n            quote_block! {\n                let mut __struct = try!(_serde::Serializer::serialize_struct(\n                    __serializer, #type_name, 1));\n                try!(_serde::ser::SerializeStruct::serialize_field(\n                    &mut __struct, #tag, #variant_name));\n                _serde::ser::SerializeStruct::end(__struct)\n            }\n        }\n        Style::Newtype => {\n            let field = &variant.fields[0];\n            let mut field_expr = quote!(__field0);\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, &field_expr);\n            }\n\n            let span = field.original.span();\n            let func = quote_spanned!(span=> _serde::private::ser::serialize_tagged_newtype);\n            quote_expr! {\n                #func(\n                    __serializer,\n                    #enum_ident_str,\n                    #variant_ident_str,\n                    #tag,\n                    #variant_name,\n                    #field_expr,\n                )\n            }\n        }\n        Style::Struct => serialize_struct_variant(\n            StructVariant::InternallyTagged {\n                tag: tag,\n                variant_name: variant_name,\n            },\n            params,\n            &variant.fields,\n            &type_name,\n        ),\n        Style::Tuple => unreachable!(\"checked in serde_derive_internals\"),\n    }\n}\n\nfn serialize_adjacently_tagged_variant(\n    params: &Parameters,\n    variant: &Variant,\n    cattrs: &attr::Container,\n    tag: &str,\n    content: &str,\n) -> Fragment {\n    let this = &params.this;\n    let type_name = cattrs.name().serialize_name();\n    let variant_name = variant.attrs.name().serialize_name();\n\n    let inner = Stmts(if let Some(path) = variant.attrs.serialize_with() {\n        let ser = wrap_serialize_variant_with(params, path, variant);\n        quote_expr! {\n            _serde::Serialize::serialize(#ser, __serializer)\n        }\n    } else {\n        match variant.style {\n            Style::Unit => {\n                return quote_block! {\n                    let mut __struct = try!(_serde::Serializer::serialize_struct(\n                        __serializer, #type_name, 1));\n                    try!(_serde::ser::SerializeStruct::serialize_field(\n                        &mut __struct, #tag, #variant_name));\n                    _serde::ser::SerializeStruct::end(__struct)\n                };\n            }\n            Style::Newtype => {\n                let field = &variant.fields[0];\n                let mut field_expr = quote!(__field0);\n                if let Some(path) = field.attrs.serialize_with() {\n                    field_expr = wrap_serialize_field_with(params, field.ty, path, &field_expr);\n                }\n\n                let span = field.original.span();\n                let func = quote_spanned!(span=> _serde::ser::SerializeStruct::serialize_field);\n                return quote_block! {\n                    let mut __struct = try!(_serde::Serializer::serialize_struct(\n                        __serializer, #type_name, 2));\n                    try!(_serde::ser::SerializeStruct::serialize_field(\n                        &mut __struct, #tag, #variant_name));\n                    try!(#func(\n                        &mut __struct, #content, #field_expr));\n                    _serde::ser::SerializeStruct::end(__struct)\n                };\n            }\n            Style::Tuple => {\n                serialize_tuple_variant(TupleVariant::Untagged, params, &variant.fields)\n            }\n            Style::Struct => serialize_struct_variant(\n                StructVariant::Untagged,\n                params,\n                &variant.fields,\n                &variant_name,\n            ),\n        }\n    });\n\n    let fields_ty = variant.fields.iter().map(|f| &f.ty);\n    let fields_ident: &Vec<_> = &match variant.style {\n        Style::Unit => {\n            if variant.attrs.serialize_with().is_some() {\n                vec![]\n            } else {\n                unreachable!()\n            }\n        }\n        Style::Newtype => vec![Member::Named(Ident::new(\"__field0\", Span::call_site()))],\n        Style::Tuple => (0..variant.fields.len())\n            .map(|i| Member::Named(Ident::new(&format!(\"__field{}\", i), Span::call_site())))\n            .collect(),\n        Style::Struct => variant.fields.iter().map(|f| f.member.clone()).collect(),\n    };\n\n    let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n\n    let wrapper_generics = if fields_ident.is_empty() {\n        params.generics.clone()\n    } else {\n        bound::with_lifetime_bound(&params.generics, \"'__a\")\n    };\n    let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n\n    quote_block! {\n        struct __AdjacentlyTagged #wrapper_generics #where_clause {\n            data: (#(&'__a #fields_ty,)*),\n            phantom: _serde::export::PhantomData<#this #ty_generics>,\n        }\n\n        impl #wrapper_impl_generics _serde::Serialize for __AdjacentlyTagged #wrapper_ty_generics #where_clause {\n            fn serialize<__S>(&self, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n            where\n                __S: _serde::Serializer,\n            {\n                let (#(#fields_ident,)*) = self.data;\n                #inner\n            }\n        }\n\n        let mut __struct = try!(_serde::Serializer::serialize_struct(\n            __serializer, #type_name, 2));\n        try!(_serde::ser::SerializeStruct::serialize_field(\n            &mut __struct, #tag, #variant_name));\n        try!(_serde::ser::SerializeStruct::serialize_field(\n            &mut __struct, #content, &__AdjacentlyTagged {\n                data: (#(#fields_ident,)*),\n                phantom: _serde::export::PhantomData::<#this #ty_generics>,\n            }));\n        _serde::ser::SerializeStruct::end(__struct)\n    }\n}\n\nfn serialize_untagged_variant(\n    params: &Parameters,\n    variant: &Variant,\n    cattrs: &attr::Container,\n) -> Fragment {\n    if let Some(path) = variant.attrs.serialize_with() {\n        let ser = wrap_serialize_variant_with(params, path, variant);\n        return quote_expr! {\n            _serde::Serialize::serialize(#ser, __serializer)\n        };\n    }\n\n    match variant.style {\n        Style::Unit => {\n            quote_expr! {\n                _serde::Serializer::serialize_unit(__serializer)\n            }\n        }\n        Style::Newtype => {\n            let field = &variant.fields[0];\n            let mut field_expr = quote!(__field0);\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, &field_expr);\n            }\n\n            let span = field.original.span();\n            let func = quote_spanned!(span=> _serde::Serialize::serialize);\n            quote_expr! {\n                #func(#field_expr, __serializer)\n            }\n        }\n        Style::Tuple => serialize_tuple_variant(TupleVariant::Untagged, params, &variant.fields),\n        Style::Struct => {\n            let type_name = cattrs.name().serialize_name();\n            serialize_struct_variant(StructVariant::Untagged, params, &variant.fields, &type_name)\n        }\n    }\n}\n\nenum TupleVariant {\n    ExternallyTagged {\n        type_name: String,\n        variant_index: u32,\n        variant_name: String,\n    },\n    Untagged,\n}\n\nfn serialize_tuple_variant(\n    context: TupleVariant,\n    params: &Parameters,\n    fields: &[Field],\n) -> Fragment {\n    let tuple_trait = match context {\n        TupleVariant::ExternallyTagged { .. } => TupleTrait::SerializeTupleVariant,\n        TupleVariant::Untagged => TupleTrait::SerializeTuple,\n    };\n\n    let serialize_stmts = serialize_tuple_struct_visitor(fields, params, true, &tuple_trait);\n\n    let mut serialized_fields = fields\n        .iter()\n        .enumerate()\n        .filter(|&(_, ref field)| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some());\n\n    let len = serialized_fields\n        .map(|(i, field)| match field.attrs.skip_serializing_if() {\n            None => quote!(1),\n            Some(path) => {\n                let field_expr = Ident::new(&format!(\"__field{}\", i), Span::call_site());\n                quote!(if #path(#field_expr) { 0 } else { 1 })\n            }\n        })\n        .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n\n    match context {\n        TupleVariant::ExternallyTagged {\n            type_name,\n            variant_index,\n            variant_name,\n        } => {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple_variant(\n                    __serializer,\n                    #type_name,\n                    #variant_index,\n                    #variant_name,\n                    #len));\n                #(#serialize_stmts)*\n                _serde::ser::SerializeTupleVariant::end(__serde_state)\n            }\n        }\n        TupleVariant::Untagged => {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple(\n                    __serializer,\n                    #len));\n                #(#serialize_stmts)*\n                _serde::ser::SerializeTuple::end(__serde_state)\n            }\n        }\n    }\n}\n\nenum StructVariant<'a> {\n    ExternallyTagged {\n        variant_index: u32,\n        variant_name: String,\n    },\n    InternallyTagged {\n        tag: &'a str,\n        variant_name: String,\n    },\n    Untagged,\n}\n\nfn serialize_struct_variant<'a>(\n    context: StructVariant<'a>,\n    params: &Parameters,\n    fields: &[Field],\n    name: &str,\n) -> Fragment {\n    if fields.iter().any(|field| field.attrs.flatten()) {\n        return serialize_struct_variant_with_flatten(context, params, fields, name);\n    }\n\n    let struct_trait = match context {\n        StructVariant::ExternallyTagged { .. } => (StructTrait::SerializeStructVariant),\n        StructVariant::InternallyTagged { .. } | StructVariant::Untagged => {\n            (StructTrait::SerializeStruct)\n        }\n    };\n\n    let serialize_fields = serialize_struct_visitor(fields, params, true, &struct_trait);\n\n    let mut serialized_fields = fields\n        .iter()\n        .filter(|&field| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some());\n\n    let len = serialized_fields\n        .map(|field| {\n            let member = &field.member;\n\n            match field.attrs.skip_serializing_if() {\n                Some(path) => quote!(if #path(#member) { 0 } else { 1 }),\n                None => quote!(1),\n            }\n        })\n        .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n\n    match context {\n        StructVariant::ExternallyTagged {\n            variant_index,\n            variant_name,\n        } => {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct_variant(\n                    __serializer,\n                    #name,\n                    #variant_index,\n                    #variant_name,\n                    #len,\n                ));\n                #(#serialize_fields)*\n                _serde::ser::SerializeStructVariant::end(__serde_state)\n            }\n        }\n        StructVariant::InternallyTagged { tag, variant_name } => {\n            quote_block! {\n                let mut __serde_state = try!(_serde::Serializer::serialize_struct(\n                    __serializer,\n                    #name,\n                    #len + 1,\n                ));\n                try!(_serde::ser::SerializeStruct::serialize_field(\n                    &mut __serde_state,\n                    #tag,\n                    #variant_name,\n                ));\n                #(#serialize_fields)*\n                _serde::ser::SerializeStruct::end(__serde_state)\n            }\n        }\n        StructVariant::Untagged => {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct(\n                    __serializer,\n                    #name,\n                    #len,\n                ));\n                #(#serialize_fields)*\n                _serde::ser::SerializeStruct::end(__serde_state)\n            }\n        }\n    }\n}\n\nfn serialize_struct_variant_with_flatten<'a>(\n    context: StructVariant<'a>,\n    params: &Parameters,\n    fields: &[Field],\n    name: &str,\n) -> Fragment {\n    let struct_trait = StructTrait::SerializeMap;\n    let serialize_fields = serialize_struct_visitor(fields, params, true, &struct_trait);\n\n    let mut serialized_fields = fields\n        .iter()\n        .filter(|&field| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some());\n\n    match context {\n        StructVariant::ExternallyTagged {\n            variant_index,\n            variant_name,\n        } => {\n            let this = &params.this;\n            let fields_ty = fields.iter().map(|f| &f.ty);\n            let members = &fields.iter().map(|f| &f.member).collect::<Vec<_>>();\n\n            let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n            let wrapper_generics = bound::with_lifetime_bound(&params.generics, \"'__a\");\n            let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n\n            quote_block! {\n                struct __EnumFlatten #wrapper_generics #where_clause {\n                    data: (#(&'__a #fields_ty,)*),\n                    phantom: _serde::export::PhantomData<#this #ty_generics>,\n                }\n\n                impl #wrapper_impl_generics _serde::Serialize for __EnumFlatten #wrapper_ty_generics #where_clause {\n                    fn serialize<__S>(&self, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n                    where\n                        __S: _serde::Serializer,\n                    {\n                        let (#(#members,)*) = self.data;\n                        let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(\n                            __serializer,\n                            _serde::export::None));\n                        #(#serialize_fields)*\n                        _serde::ser::SerializeMap::end(__serde_state)\n                    }\n                }\n\n                _serde::Serializer::serialize_newtype_variant(\n                    __serializer,\n                    #name,\n                    #variant_index,\n                    #variant_name,\n                    &__EnumFlatten {\n                        data: (#(#members,)*),\n                        phantom: _serde::export::PhantomData::<#this #ty_generics>,\n                    })\n            }\n        }\n        StructVariant::InternallyTagged { tag, variant_name } => {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(\n                    __serializer,\n                    _serde::export::None));\n                try!(_serde::ser::SerializeMap::serialize_entry(\n                    &mut __serde_state,\n                    #tag,\n                    #variant_name,\n                ));\n                #(#serialize_fields)*\n                _serde::ser::SerializeMap::end(__serde_state)\n            }\n        }\n        StructVariant::Untagged => {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(\n                    __serializer,\n                    _serde::export::None));\n                #(#serialize_fields)*\n                _serde::ser::SerializeMap::end(__serde_state)\n            }\n        }\n    }\n}\n\nfn serialize_tuple_struct_visitor(\n    fields: &[Field],\n    params: &Parameters,\n    is_enum: bool,\n    tuple_trait: &TupleTrait,\n) -> Vec<TokenStream> {\n    fields\n        .iter()\n        .enumerate()\n        .filter(|&(_, ref field)| !field.attrs.skip_serializing())\n        .map(|(i, field)| {\n            let mut field_expr = if is_enum {\n                let id = Ident::new(&format!(\"__field{}\", i), Span::call_site());\n                quote!(#id)\n            } else {\n                get_member(\n                    params,\n                    field,\n                    &Member::Unnamed(Index {\n                        index: i as u32,\n                        span: Span::call_site(),\n                    }),\n                )\n            };\n\n            let skip = field\n                .attrs\n                .skip_serializing_if()\n                .map(|path| quote!(#path(#field_expr)));\n\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, &field_expr);\n            }\n\n            let span = field.original.span();\n            let func = tuple_trait.serialize_element(span);\n            let ser = quote! {\n                try!(#func(&mut __serde_state, #field_expr));\n            };\n\n            match skip {\n                None => ser,\n                Some(skip) => quote!(if !#skip { #ser }),\n            }\n        })\n        .collect()\n}\n\nfn serialize_struct_visitor(\n    fields: &[Field],\n    params: &Parameters,\n    is_enum: bool,\n    struct_trait: &StructTrait,\n) -> Vec<TokenStream> {\n    fields\n        .iter()\n        .filter(|&field| !field.attrs.skip_serializing())\n        .map(|field| {\n            let member = &field.member;\n\n            let mut field_expr = if is_enum {\n                quote!(#member)\n            } else {\n                get_member(params, field, &member)\n            };\n\n            let key_expr = field.attrs.name().serialize_name();\n\n            let skip = field\n                .attrs\n                .skip_serializing_if()\n                .map(|path| quote!(#path(#field_expr)));\n\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, &field_expr);\n            }\n\n            let span = field.original.span();\n            let ser = if field.attrs.flatten() {\n                let func = quote_spanned!(span=> _serde::Serialize::serialize);\n                quote! {\n                    try!(#func(&#field_expr, _serde::private::ser::FlatMapSerializer(&mut __serde_state)));\n                }\n            } else {\n                let func = struct_trait.serialize_field(span);\n                quote! {\n                    try!(#func(&mut __serde_state, #key_expr, #field_expr));\n                }\n            };\n\n            match skip {\n                None => ser,\n                Some(skip) => {\n                    if let Some(skip_func) = struct_trait.skip_field(span) {\n                        quote! {\n                            if !#skip {\n                                #ser\n                            } else {\n                                try!(#skip_func(&mut __serde_state, #key_expr));\n                            }\n                        }\n                    } else {\n                        quote! {\n                            if !#skip {\n                                #ser\n                            }\n                        }\n                    }\n                }\n            }\n        })\n        .collect()\n}\n\nfn wrap_serialize_field_with(\n    params: &Parameters,\n    field_ty: &syn::Type,\n    serialize_with: &syn::ExprPath,\n    field_expr: &TokenStream,\n) -> TokenStream {\n    wrap_serialize_with(params, serialize_with, &[field_ty], &[quote!(#field_expr)])\n}\n\nfn wrap_serialize_variant_with(\n    params: &Parameters,\n    serialize_with: &syn::ExprPath,\n    variant: &Variant,\n) -> TokenStream {\n    let field_tys: Vec<_> = variant.fields.iter().map(|field| field.ty).collect();\n    let field_exprs: Vec<_> = variant\n        .fields\n        .iter()\n        .map(|field| {\n            let id = match field.member {\n                Member::Named(ref ident) => ident.clone(),\n                Member::Unnamed(ref member) => {\n                    Ident::new(&format!(\"__field{}\", member.index), Span::call_site())\n                }\n            };\n            quote!(#id)\n        })\n        .collect();\n    wrap_serialize_with(\n        params,\n        serialize_with,\n        field_tys.as_slice(),\n        field_exprs.as_slice(),\n    )\n}\n\nfn wrap_serialize_with(\n    params: &Parameters,\n    serialize_with: &syn::ExprPath,\n    field_tys: &[&syn::Type],\n    field_exprs: &[TokenStream],\n) -> TokenStream {\n    let this = &params.this;\n    let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n\n    let wrapper_generics = if field_exprs.is_empty() {\n        params.generics.clone()\n    } else {\n        bound::with_lifetime_bound(&params.generics, \"'__a\")\n    };\n    let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n\n    let field_access = (0..field_exprs.len()).map(|n| {\n        Member::Unnamed(Index {\n            index: n as u32,\n            span: Span::call_site(),\n        })\n    });\n\n    quote!({\n        struct __SerializeWith #wrapper_impl_generics #where_clause {\n            values: (#(&'__a #field_tys, )*),\n            phantom: _serde::export::PhantomData<#this #ty_generics>,\n        }\n\n        impl #wrapper_impl_generics _serde::Serialize for __SerializeWith #wrapper_ty_generics #where_clause {\n            fn serialize<__S>(&self, __s: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n            where\n                __S: _serde::Serializer,\n            {\n                #serialize_with(#(self.values.#field_access, )* __s)\n            }\n        }\n\n        &__SerializeWith {\n            values: (#(#field_exprs, )*),\n            phantom: _serde::export::PhantomData::<#this #ty_generics>,\n        }\n    })\n}\n\n// Serialization of an empty struct results in code like:\n//\n//     let mut __serde_state = try!(serializer.serialize_struct(\"S\", 0));\n//     _serde::ser::SerializeStruct::end(__serde_state)\n//\n// where we want to omit the `mut` to avoid a warning.\nfn mut_if(is_mut: bool) -> Option<TokenStream> {\n    if is_mut {\n        Some(quote!(mut))\n    } else {\n        None\n    }\n}\n\nfn get_member(params: &Parameters, field: &Field, member: &Member) -> TokenStream {\n    let self_var = &params.self_var;\n    match (params.is_remote, field.attrs.getter()) {\n        (false, None) => quote!(&#self_var.#member),\n        (true, None) => {\n            let inner = quote!(&#self_var.#member);\n            let ty = field.ty;\n            quote!(_serde::private::ser::constrain::<#ty>(#inner))\n        }\n        (true, Some(getter)) => {\n            let ty = field.ty;\n            quote!(_serde::private::ser::constrain::<#ty>(&#getter(#self_var)))\n        }\n        (false, Some(_)) => {\n            unreachable!(\"getter is only allowed for remote impls\");\n        }\n    }\n}\n\nenum StructTrait {\n    SerializeMap,\n    SerializeStruct,\n    SerializeStructVariant,\n}\n\nimpl StructTrait {\n    fn serialize_field(&self, span: Span) -> TokenStream {\n        match *self {\n            StructTrait::SerializeMap => quote_spanned!(span=> _serde::ser::SerializeMap::serialize_entry),\n            StructTrait::SerializeStruct => quote_spanned!(span=> _serde::ser::SerializeStruct::serialize_field),\n            StructTrait::SerializeStructVariant => quote_spanned!(span=> _serde::ser::SerializeStructVariant::serialize_field),\n        }\n    }\n\n    fn skip_field(&self, span: Span) -> Option<TokenStream> {\n        match *self {\n            StructTrait::SerializeMap => None,\n            StructTrait::SerializeStruct => {\n                Some(quote_spanned!(span=> _serde::ser::SerializeStruct::skip_field))\n            }\n            StructTrait::SerializeStructVariant => {\n                Some(quote_spanned!(span=> _serde::ser::SerializeStructVariant::skip_field))\n            }\n        }\n    }\n}\n\nenum TupleTrait {\n    SerializeTuple,\n    SerializeTupleStruct,\n    SerializeTupleVariant,\n}\n\nimpl TupleTrait {\n    fn serialize_element(&self, span: Span) -> TokenStream {\n        match *self {\n            TupleTrait::SerializeTuple => quote_spanned!(span=> _serde::ser::SerializeTuple::serialize_element),\n            TupleTrait::SerializeTupleStruct => quote_spanned!(span=> _serde::ser::SerializeTupleStruct::serialize_field),\n            TupleTrait::SerializeTupleVariant => quote_spanned!(span=> _serde::ser::SerializeTupleVariant::serialize_field),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","try.rs"],"content":"use proc_macro2::{Punct, Spacing, TokenStream};\n\n// None of our generated code requires the `From::from` error conversion\n// performed by the standard library's `try!` macro. With this simplified macro\n// we see a significant improvement in type checking and borrow checking time of\n// the generated code and a slight improvement in binary size.\npub fn replacement() -> TokenStream {\n    // Cannot pass `$expr` to `quote!` prior to Rust 1.17.0 so interpolate it.\n    let dollar = Punct::new('$', Spacing::Alone);\n\n    quote! {\n        #[allow(unused_macros)]\n        macro_rules! try {\n            (#dollar __expr:expr) => {\n                match #dollar __expr {\n                    _serde::export::Ok(__val) => __val,\n                    _serde::export::Err(__err) => {\n                        return _serde::export::Err(__err);\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive_internals","lib.rs"],"content":"#![doc(html_root_url = \"https://docs.rs/serde_derive_internals/0.25.0\")]\n#![allow(unknown_lints, bare_trait_objects)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(renamed_and_removed_lints))]\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        cognitive_complexity,\n        redundant_field_names,\n        trivially_copy_pass_by_ref\n    )\n)]\n\n#[macro_use]\nextern crate syn;\n\nextern crate proc_macro2;\nextern crate quote;\n\n#[path = \"src/mod.rs\"]\nmod internals;\n\npub use internals::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","assert.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse de::Deserializer;\nuse ser::Serializer;\nuse token::Token;\n\nuse std::fmt::Debug;\n\n/// Runs both `assert_ser_tokens` and `assert_de_tokens`.\n///\n/// ```edition2018\n/// # use serde::{Serialize, Deserialize};\n/// # use serde_test::{assert_tokens, Token};\n/// #\n/// # fn main() {\n/// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n/// struct S {\n///     a: u8,\n///     b: u8,\n/// }\n///\n/// let s = S { a: 0, b: 0 };\n/// assert_tokens(&s, &[\n///     Token::Struct { name: \"S\", len: 2 },\n///     Token::Str(\"a\"),\n///     Token::U8(0),\n///     Token::Str(\"b\"),\n///     Token::U8(0),\n///     Token::StructEnd,\n/// ]);\n/// # }\n/// ```\npub fn assert_tokens<'de, T>(value: &T, tokens: &'de [Token])\nwhere\n    T: Serialize + Deserialize<'de> + PartialEq + Debug,\n{\n    assert_ser_tokens(value, tokens);\n    assert_de_tokens(value, tokens);\n}\n\n/// Asserts that `value` serializes to the given `tokens`.\n///\n/// ```edition2018\n/// # use serde::{Serialize, Deserialize};\n/// # use serde_test::{assert_ser_tokens, Token};\n/// #\n/// # fn main() {\n/// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n/// struct S {\n///     a: u8,\n///     b: u8,\n/// }\n///\n/// let s = S { a: 0, b: 0 };\n/// assert_ser_tokens(&s, &[\n///     Token::Struct { name: \"S\", len: 2 },\n///     Token::Str(\"a\"),\n///     Token::U8(0),\n///     Token::Str(\"b\"),\n///     Token::U8(0),\n///     Token::StructEnd,\n/// ]);\n/// # }\n/// ```\npub fn assert_ser_tokens<T>(value: &T, tokens: &[Token])\nwhere\n    T: Serialize,\n{\n    let mut ser = Serializer::new(tokens);\n    match value.serialize(&mut ser) {\n        Ok(_) => {}\n        Err(err) => panic!(\"value failed to serialize: {}\", err),\n    }\n\n    if ser.remaining() > 0 {\n        panic!(\"{} remaining tokens\", ser.remaining());\n    }\n}\n\n/// Asserts that `value` serializes to the given `tokens`, and then yields\n/// `error`.\n///\n/// ```edition2018\n/// use std::sync::{Arc, Mutex};\n/// use std::thread;\n///\n/// use serde::Serialize;\n/// use serde_test::{assert_ser_tokens_error, Token};\n///\n/// #[derive(Serialize)]\n/// struct Example {\n///     lock: Arc<Mutex<u32>>,\n/// }\n///\n/// fn main() {\n///     let example = Example { lock: Arc::new(Mutex::new(0)) };\n///     let lock = example.lock.clone();\n///\n///     let _ = thread::spawn(move || {\n///         // This thread will acquire the mutex first, unwrapping the result\n///         // of `lock` because the lock has not been poisoned.\n///         let _guard = lock.lock().unwrap();\n///\n///         // This panic while holding the lock (`_guard` is in scope) will\n///         // poison the mutex.\n///         panic!()\n///     }).join();\n///\n///     let expected = &[\n///         Token::Struct { name: \"Example\", len: 1 },\n///         Token::Str(\"lock\"),\n///     ];\n///     let error = \"lock poison error while serializing\";\n///     assert_ser_tokens_error(&example, expected, error);\n/// }\n/// ```\npub fn assert_ser_tokens_error<T>(value: &T, tokens: &[Token], error: &str)\nwhere\n    T: Serialize,\n{\n    let mut ser = Serializer::new(tokens);\n    match value.serialize(&mut ser) {\n        Ok(_) => panic!(\"value serialized successfully\"),\n        Err(e) => assert_eq!(e, *error),\n    }\n\n    if ser.remaining() > 0 {\n        panic!(\"{} remaining tokens\", ser.remaining());\n    }\n}\n\n/// Asserts that the given `tokens` deserialize into `value`.\n///\n/// ```edition2018\n/// # use serde::{Serialize, Deserialize};\n/// # use serde_test::{assert_de_tokens, Token};\n/// #\n/// # fn main() {\n/// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n/// struct S {\n///     a: u8,\n///     b: u8,\n/// }\n///\n/// let s = S { a: 0, b: 0 };\n/// assert_de_tokens(&s, &[\n///     Token::Struct { name: \"S\", len: 2 },\n///     Token::Str(\"a\"),\n///     Token::U8(0),\n///     Token::Str(\"b\"),\n///     Token::U8(0),\n///     Token::StructEnd,\n/// ]);\n/// # }\n/// ```\npub fn assert_de_tokens<'de, T>(value: &T, tokens: &'de [Token])\nwhere\n    T: Deserialize<'de> + PartialEq + Debug,\n{\n    let mut de = Deserializer::new(tokens);\n    let mut deserialized_val = match T::deserialize(&mut de) {\n        Ok(v) => {\n            assert_eq!(v, *value);\n            v\n        }\n        Err(e) => panic!(\"tokens failed to deserialize: {}\", e),\n    };\n    if de.remaining() > 0 {\n        panic!(\"{} remaining tokens\", de.remaining());\n    }\n\n    // Do the same thing for deserialize_in_place. This isn't *great* because a\n    // no-op impl of deserialize_in_place can technically succeed here. Still,\n    // this should catch a lot of junk.\n    let mut de = Deserializer::new(tokens);\n    match T::deserialize_in_place(&mut de, &mut deserialized_val) {\n        Ok(()) => {\n            assert_eq!(deserialized_val, *value);\n        }\n        Err(e) => panic!(\"tokens failed to deserialize_in_place: {}\", e),\n    }\n    if de.remaining() > 0 {\n        panic!(\"{} remaining tokens\", de.remaining());\n    }\n}\n\n/// Asserts that the given `tokens` yield `error` when deserializing.\n///\n/// ```edition2018\n/// # use serde::{Serialize, Deserialize};\n/// # use serde_test::{assert_de_tokens_error, Token};\n/// #\n/// # fn main() {\n/// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n/// #[serde(deny_unknown_fields)]\n/// struct S {\n///     a: u8,\n///     b: u8,\n/// }\n///\n/// assert_de_tokens_error::<S>(\n///     &[\n///         Token::Struct { name: \"S\", len: 2 },\n///         Token::Str(\"x\"),\n///     ],\n///     \"unknown field `x`, expected `a` or `b`\",\n/// );\n/// # }\n/// ```\npub fn assert_de_tokens_error<'de, T>(tokens: &'de [Token], error: &str)\nwhere\n    T: Deserialize<'de>,\n{\n    let mut de = Deserializer::new(tokens);\n    match T::deserialize(&mut de) {\n        Ok(_) => panic!(\"tokens deserialized successfully\"),\n        Err(e) => assert_eq!(e, *error),\n    }\n\n    // There may be one token left if a peek caused the error\n    de.next_token_opt();\n\n    if de.remaining() > 0 {\n        panic!(\"{} remaining tokens\", de.remaining());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","configure.rs"],"content":"use std::fmt;\n\nuse serde::ser::{\n    SerializeMap, SerializeSeq, SerializeStruct, SerializeStructVariant, SerializeTuple,\n    SerializeTupleStruct, SerializeTupleVariant,\n};\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]\npub struct Readable<T: ?Sized>(T);\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]\npub struct Compact<T: ?Sized>(T);\n\n/// Trait to determine whether a value is represented in human-readable or\n/// compact form.\n///\n/// ```edition2018\n/// use serde::{Deserialize, Deserializer, Serialize, Serializer};\n/// use serde_test::{assert_tokens, Configure, Token};\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Example(u8, u8);\n///\n/// impl Serialize for Example {\n///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n///     where\n///         S: Serializer,\n///     {\n///         if serializer.is_human_readable() {\n///             format!(\"{}.{}\", self.0, self.1).serialize(serializer)\n///         } else {\n///             (self.0, self.1).serialize(serializer)\n///         }\n///     }\n/// }\n///\n/// impl<'de> Deserialize<'de> for Example {\n///     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n///     where\n///         D: Deserializer<'de>,\n///     {\n///         use serde::de::Error;\n///         if deserializer.is_human_readable() {\n///             let s = String::deserialize(deserializer)?;\n///             let parts: Vec<_> = s.split('.').collect();\n///             Ok(Example(\n///                 parts[0].parse().map_err(D::Error::custom)?,\n///                 parts[1].parse().map_err(D::Error::custom)?,\n///             ))\n///         } else {\n///             let (x, y) = Deserialize::deserialize(deserializer)?;\n///             Ok(Example(x, y))\n///         }\n///     }\n/// }\n///\n/// fn main() {\n///     assert_tokens(\n///         &Example(1, 0).compact(),\n///         &[\n///             Token::Tuple { len: 2 },\n///             Token::U8(1),\n///             Token::U8(0),\n///             Token::TupleEnd,\n///         ],\n///     );\n///     assert_tokens(&Example(1, 0).readable(), &[Token::Str(\"1.0\")]);\n/// }\n/// ```\npub trait Configure {\n    /// Marks `self` as using `is_human_readable == true`\n    fn readable(self) -> Readable<Self>\n    where\n        Self: Sized,\n    {\n        Readable(self)\n    }\n    /// Marks `self` as using `is_human_readable == false`\n    fn compact(self) -> Compact<Self>\n    where\n        Self: Sized,\n    {\n        Compact(self)\n    }\n}\n\nimpl<T: ?Sized> Configure for T {}\n\nimpl<T: ?Sized> Serialize for Readable<T>\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        self.0.serialize(Readable(serializer))\n    }\n}\nimpl<T: ?Sized> Serialize for Compact<T>\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        self.0.serialize(Compact(serializer))\n    }\n}\nimpl<'de, T> Deserialize<'de> for Readable<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        T::deserialize(Readable(deserializer)).map(Readable)\n    }\n}\nimpl<'de, T> Deserialize<'de> for Compact<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        T::deserialize(Compact(deserializer)).map(Compact)\n    }\n}\n\nimpl<'de, T> DeserializeSeed<'de> for Readable<T>\nwhere\n    T: DeserializeSeed<'de>,\n{\n    type Value = T::Value;\n\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        self.0.deserialize(Readable(deserializer))\n    }\n}\nimpl<'de, T> DeserializeSeed<'de> for Compact<T>\nwhere\n    T: DeserializeSeed<'de>,\n{\n    type Value = T::Value;\n\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        self.0.deserialize(Compact(deserializer))\n    }\n}\n\nmacro_rules! forward_method {\n    ($name: ident (self $(, $arg: ident : $arg_type: ty)* ) -> $return_type: ty) => {\n        fn $name (self $(, $arg : $arg_type)* ) -> $return_type {\n            (self.0).$name( $($arg),* )\n        }\n    };\n}\n\nmacro_rules! forward_serialize_methods {\n    ( $( $name: ident $arg_type: ty ),* ) => {\n        $(\n            forward_method!($name(self, v : $arg_type) -> Result<Self::Ok, Self::Error>);\n        )*\n    };\n}\n\nmacro_rules! impl_serializer {\n    ($wrapper:ident, $is_human_readable:expr) => {\n        impl<S> Serializer for $wrapper<S>\n        where\n            S: Serializer,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n\n            type SerializeSeq = $wrapper<S::SerializeSeq>;\n            type SerializeTuple = $wrapper<S::SerializeTuple>;\n            type SerializeTupleStruct = $wrapper<S::SerializeTupleStruct>;\n            type SerializeTupleVariant = $wrapper<S::SerializeTupleVariant>;\n            type SerializeMap = $wrapper<S::SerializeMap>;\n            type SerializeStruct = $wrapper<S::SerializeStruct>;\n            type SerializeStructVariant = $wrapper<S::SerializeStructVariant>;\n\n            fn is_human_readable(&self) -> bool {\n                $is_human_readable\n            }\n\n            forward_serialize_methods! {\n                serialize_bool bool,\n                serialize_i8 i8,\n                serialize_i16 i16,\n                serialize_i32 i32,\n                serialize_i64 i64,\n                serialize_u8 u8,\n                serialize_u16 u16,\n                serialize_u32 u32,\n                serialize_u64 u64,\n                serialize_f32 f32,\n                serialize_f64 f64,\n                serialize_char char,\n                serialize_str &str,\n                serialize_bytes &[u8],\n                serialize_unit_struct &'static str\n\n            }\n\n            fn serialize_unit(self) -> Result<S::Ok, S::Error> {\n                self.0.serialize_unit()\n            }\n\n            fn serialize_unit_variant(\n                self,\n                name: &'static str,\n                variant_index: u32,\n                variant: &'static str,\n            ) -> Result<S::Ok, S::Error> {\n                self.0.serialize_unit_variant(name, variant_index, variant)\n            }\n\n            fn serialize_newtype_struct<T: ?Sized>(\n                self,\n                name: &'static str,\n                value: &T,\n            ) -> Result<S::Ok, S::Error>\n            where\n                T: Serialize,\n            {\n                self.0.serialize_newtype_struct(name, &$wrapper(value))\n            }\n\n            fn serialize_newtype_variant<T: ?Sized>(\n                self,\n                name: &'static str,\n                variant_index: u32,\n                variant: &'static str,\n                value: &T,\n            ) -> Result<S::Ok, S::Error>\n            where\n                T: Serialize,\n            {\n                self.0\n                    .serialize_newtype_variant(name, variant_index, variant, &$wrapper(value))\n            }\n\n            fn serialize_none(self) -> Result<S::Ok, Self::Error> {\n                self.0.serialize_none()\n            }\n\n            fn serialize_some<T: ?Sized>(self, value: &T) -> Result<S::Ok, Self::Error>\n            where\n                T: Serialize,\n            {\n                self.0.serialize_some(&$wrapper(value))\n            }\n\n            fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {\n                self.0.serialize_seq(len).map($wrapper)\n            }\n\n            fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error> {\n                self.0.serialize_tuple(len).map($wrapper)\n            }\n\n            fn serialize_tuple_struct(\n                self,\n                name: &'static str,\n                len: usize,\n            ) -> Result<Self::SerializeTupleStruct, Self::Error> {\n                self.0.serialize_tuple_struct(name, len).map($wrapper)\n            }\n\n            fn serialize_tuple_variant(\n                self,\n                name: &'static str,\n                variant_index: u32,\n                variant: &'static str,\n                len: usize,\n            ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n                self.0\n                    .serialize_tuple_variant(name, variant_index, variant, len)\n                    .map($wrapper)\n            }\n\n            fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {\n                self.0.serialize_map(len).map($wrapper)\n            }\n\n            fn serialize_struct(\n                self,\n                name: &'static str,\n                len: usize,\n            ) -> Result<Self::SerializeStruct, Self::Error> {\n                self.0.serialize_struct(name, len).map($wrapper)\n            }\n\n            fn serialize_struct_variant(\n                self,\n                name: &'static str,\n                variant_index: u32,\n                variant: &'static str,\n                len: usize,\n            ) -> Result<Self::SerializeStructVariant, Self::Error> {\n                self.0\n                    .serialize_struct_variant(name, variant_index, variant, len)\n                    .map($wrapper)\n            }\n        }\n\n        impl<S> SerializeSeq for $wrapper<S>\n        where\n            S: SerializeSeq,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), S::Error>\n            where\n                T: Serialize,\n            {\n                self.0.serialize_element(&$wrapper(value))\n            }\n            fn end(self) -> Result<S::Ok, S::Error> {\n                self.0.end()\n            }\n        }\n\n        impl<S> SerializeTuple for $wrapper<S>\n        where\n            S: SerializeTuple,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), S::Error>\n            where\n                T: Serialize,\n            {\n                self.0.serialize_element(&$wrapper(value))\n            }\n            fn end(self) -> Result<S::Ok, S::Error> {\n                self.0.end()\n            }\n        }\n\n        impl<S> SerializeTupleStruct for $wrapper<S>\n        where\n            S: SerializeTupleStruct,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), S::Error>\n            where\n                T: Serialize,\n            {\n                self.0.serialize_field(&$wrapper(value))\n            }\n            fn end(self) -> Result<S::Ok, S::Error> {\n                self.0.end()\n            }\n        }\n\n        impl<S> SerializeTupleVariant for $wrapper<S>\n        where\n            S: SerializeTupleVariant,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), S::Error>\n            where\n                T: Serialize,\n            {\n                self.0.serialize_field(&$wrapper(value))\n            }\n            fn end(self) -> Result<S::Ok, S::Error> {\n                self.0.end()\n            }\n        }\n\n        impl<S> SerializeMap for $wrapper<S>\n        where\n            S: SerializeMap,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), S::Error>\n            where\n                T: Serialize,\n            {\n                self.0.serialize_key(&$wrapper(key))\n            }\n            fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), S::Error>\n            where\n                T: Serialize,\n            {\n                self.0.serialize_value(&$wrapper(value))\n            }\n            fn serialize_entry<K: ?Sized, V: ?Sized>(\n                &mut self,\n                key: &K,\n                value: &V,\n            ) -> Result<(), S::Error>\n            where\n                K: Serialize,\n                V: Serialize,\n            {\n                self.0.serialize_entry(key, &$wrapper(value))\n            }\n            fn end(self) -> Result<S::Ok, S::Error> {\n                self.0.end()\n            }\n        }\n\n        impl<S> SerializeStruct for $wrapper<S>\n        where\n            S: SerializeStruct,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_field<T: ?Sized>(\n                &mut self,\n                name: &'static str,\n                field: &T,\n            ) -> Result<(), S::Error>\n            where\n                T: Serialize,\n            {\n                self.0.serialize_field(name, &$wrapper(field))\n            }\n            fn end(self) -> Result<S::Ok, S::Error> {\n                self.0.end()\n            }\n        }\n\n        impl<S> SerializeStructVariant for $wrapper<S>\n        where\n            S: SerializeStructVariant,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_field<T: ?Sized>(\n                &mut self,\n                name: &'static str,\n                field: &T,\n            ) -> Result<(), S::Error>\n            where\n                T: Serialize,\n            {\n                self.0.serialize_field(name, &$wrapper(field))\n            }\n            fn end(self) -> Result<S::Ok, S::Error> {\n                self.0.end()\n            }\n        }\n    };\n}\n\nimpl_serializer!(Readable, true);\nimpl_serializer!(Compact, false);\n\nuse serde::de::{DeserializeSeed, EnumAccess, Error, MapAccess, SeqAccess, VariantAccess, Visitor};\n\nmacro_rules! forward_deserialize_methods {\n    ( $wrapper : ident ( $( $name: ident ),* ) ) => {\n        $(\n            fn $name<V>(self, visitor: V) -> Result<V::Value, D::Error>\n            where\n                V: Visitor<'de>,\n            {\n                (self.0).$name($wrapper(visitor))\n            }\n        )*\n    };\n}\n\nmacro_rules! impl_deserializer {\n    ($wrapper:ident, $is_human_readable:expr) => {\n        impl<'de, D> Deserializer<'de> for $wrapper<D>\n        where\n            D: Deserializer<'de>,\n        {\n            type Error = D::Error;\n\n            forward_deserialize_methods! {\n                $wrapper (\n                    deserialize_any,\n                    deserialize_bool,\n                    deserialize_u8,\n                    deserialize_u16,\n                    deserialize_u32,\n                    deserialize_u64,\n                    deserialize_i8,\n                    deserialize_i16,\n                    deserialize_i32,\n                    deserialize_i64,\n                    deserialize_f32,\n                    deserialize_f64,\n                    deserialize_char,\n                    deserialize_str,\n                    deserialize_string,\n                    deserialize_bytes,\n                    deserialize_byte_buf,\n                    deserialize_option,\n                    deserialize_unit,\n                    deserialize_seq,\n                    deserialize_map,\n                    deserialize_identifier,\n                    deserialize_ignored_any\n                )\n            }\n\n            fn deserialize_unit_struct<V>(\n                self,\n                name: &'static str,\n                visitor: V,\n            ) -> Result<V::Value, D::Error>\n            where\n                V: Visitor<'de>,\n            {\n                self.0.deserialize_unit_struct(name, $wrapper(visitor))\n            }\n            fn deserialize_newtype_struct<V>(\n                self,\n                name: &'static str,\n                visitor: V,\n            ) -> Result<V::Value, D::Error>\n            where\n                V: Visitor<'de>,\n            {\n                self.0.deserialize_newtype_struct(name, $wrapper(visitor))\n            }\n            fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, D::Error>\n            where\n                V: Visitor<'de>,\n            {\n                self.0.deserialize_tuple(len, $wrapper(visitor))\n            }\n            fn deserialize_tuple_struct<V>(\n                self,\n                name: &'static str,\n                len: usize,\n                visitor: V,\n            ) -> Result<V::Value, D::Error>\n            where\n                V: Visitor<'de>,\n            {\n                self.0\n                    .deserialize_tuple_struct(name, len, $wrapper(visitor))\n            }\n            fn deserialize_struct<V>(\n                self,\n                name: &'static str,\n                fields: &'static [&'static str],\n                visitor: V,\n            ) -> Result<V::Value, D::Error>\n            where\n                V: Visitor<'de>,\n            {\n                self.0.deserialize_struct(name, fields, $wrapper(visitor))\n            }\n            fn deserialize_enum<V>(\n                self,\n                name: &'static str,\n                variants: &'static [&'static str],\n                visitor: V,\n            ) -> Result<V::Value, D::Error>\n            where\n                V: Visitor<'de>,\n            {\n                self.0.deserialize_enum(name, variants, $wrapper(visitor))\n            }\n\n            fn is_human_readable(&self) -> bool {\n                $is_human_readable\n            }\n        }\n\n        impl<'de, D> Visitor<'de> for $wrapper<D>\n        where\n            D: Visitor<'de>,\n        {\n            type Value = D::Value;\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                self.0.expecting(formatter)\n            }\n            fn visit_bool<E>(self, v: bool) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_bool(v)\n            }\n            fn visit_i8<E>(self, v: i8) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_i8(v)\n            }\n            fn visit_i16<E>(self, v: i16) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_i16(v)\n            }\n            fn visit_i32<E>(self, v: i32) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_i32(v)\n            }\n            fn visit_i64<E>(self, v: i64) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_i64(v)\n            }\n            fn visit_u8<E>(self, v: u8) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_u8(v)\n            }\n            fn visit_u16<E>(self, v: u16) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_u16(v)\n            }\n            fn visit_u32<E>(self, v: u32) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_u32(v)\n            }\n            fn visit_u64<E>(self, v: u64) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_u64(v)\n            }\n            fn visit_f32<E>(self, v: f32) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_f32(v)\n            }\n            fn visit_f64<E>(self, v: f64) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_f64(v)\n            }\n            fn visit_char<E>(self, v: char) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_char(v)\n            }\n            fn visit_str<E>(self, v: &str) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_str(v)\n            }\n            fn visit_borrowed_str<E>(self, v: &'de str) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_borrowed_str(v)\n            }\n            fn visit_string<E>(self, v: String) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_string(v)\n            }\n            fn visit_bytes<E>(self, v: &[u8]) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_bytes(v)\n            }\n            fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_borrowed_bytes(v)\n            }\n            fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_byte_buf(v)\n            }\n            fn visit_none<E>(self) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_none()\n            }\n            fn visit_some<D2>(self, deserializer: D2) -> Result<Self::Value, D2::Error>\n            where\n                D2: Deserializer<'de>,\n            {\n                self.0.visit_some($wrapper(deserializer))\n            }\n            fn visit_unit<E>(self) -> Result<D::Value, E>\n            where\n                E: Error,\n            {\n                self.0.visit_unit()\n            }\n            fn visit_newtype_struct<D2>(self, deserializer: D2) -> Result<Self::Value, D2::Error>\n            where\n                D2: Deserializer<'de>,\n            {\n                self.0.visit_newtype_struct($wrapper(deserializer))\n            }\n            fn visit_seq<V>(self, seq: V) -> Result<D::Value, V::Error>\n            where\n                V: SeqAccess<'de>,\n            {\n                self.0.visit_seq($wrapper(seq))\n            }\n            fn visit_map<V>(self, map: V) -> Result<D::Value, V::Error>\n            where\n                V: MapAccess<'de>,\n            {\n                self.0.visit_map($wrapper(map))\n            }\n            fn visit_enum<V>(self, data: V) -> Result<D::Value, V::Error>\n            where\n                V: EnumAccess<'de>,\n            {\n                self.0.visit_enum($wrapper(data))\n            }\n        }\n\n        impl<'de, D> SeqAccess<'de> for $wrapper<D>\n        where\n            D: SeqAccess<'de>,\n        {\n            type Error = D::Error;\n            fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, D::Error>\n            where\n                T: DeserializeSeed<'de>,\n            {\n                self.0.next_element_seed($wrapper(seed))\n            }\n            fn size_hint(&self) -> Option<usize> {\n                self.0.size_hint()\n            }\n        }\n\n        impl<'de, D> MapAccess<'de> for $wrapper<D>\n        where\n            D: MapAccess<'de>,\n        {\n            type Error = D::Error;\n            fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, D::Error>\n            where\n                K: DeserializeSeed<'de>,\n            {\n                self.0.next_key_seed($wrapper(seed))\n            }\n            fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, D::Error>\n            where\n                V: DeserializeSeed<'de>,\n            {\n                self.0.next_value_seed($wrapper(seed))\n            }\n            fn size_hint(&self) -> Option<usize> {\n                self.0.size_hint()\n            }\n        }\n\n        impl<'de, D> EnumAccess<'de> for $wrapper<D>\n        where\n            D: EnumAccess<'de>,\n        {\n            type Error = D::Error;\n            type Variant = $wrapper<D::Variant>;\n            fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n            where\n                V: DeserializeSeed<'de>,\n            {\n                self.0\n                    .variant_seed($wrapper(seed))\n                    .map(|(value, variant)| (value, $wrapper(variant)))\n            }\n        }\n\n        impl<'de, D> VariantAccess<'de> for $wrapper<D>\n        where\n            D: VariantAccess<'de>,\n        {\n            type Error = D::Error;\n            fn unit_variant(self) -> Result<(), D::Error> {\n                self.0.unit_variant()\n            }\n            fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, D::Error>\n            where\n                T: DeserializeSeed<'de>,\n            {\n                self.0.newtype_variant_seed($wrapper(seed))\n            }\n            fn tuple_variant<V>(self, len: usize, visitor: V) -> Result<V::Value, D::Error>\n            where\n                V: Visitor<'de>,\n            {\n                self.0.tuple_variant(len, $wrapper(visitor))\n            }\n            fn struct_variant<V>(\n                self,\n                fields: &'static [&'static str],\n                visitor: V,\n            ) -> Result<V::Value, D::Error>\n            where\n                V: Visitor<'de>,\n            {\n                self.0.struct_variant(fields, $wrapper(visitor))\n            }\n        }\n    };\n}\n\nimpl_deserializer!(Readable, true);\nimpl_deserializer!(Compact, false);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","de.rs"],"content":"use serde::de::value::{MapAccessDeserializer, SeqAccessDeserializer};\nuse serde::de::{\n    self, Deserialize, DeserializeSeed, EnumAccess, IntoDeserializer, MapAccess, SeqAccess,\n    VariantAccess, Visitor,\n};\n\nuse error::Error;\nuse token::Token;\n\n#[derive(Debug)]\npub struct Deserializer<'de> {\n    tokens: &'de [Token],\n}\n\nmacro_rules! assert_next_token {\n    ($de:expr, $expected:expr) => {\n        match $de.next_token_opt() {\n            Some(token) if token == $expected => {}\n            Some(other) => panic!(\n                \"expected Token::{} but deserialization wants Token::{}\",\n                other, $expected\n            ),\n            None => panic!(\n                \"end of tokens but deserialization wants Token::{}\",\n                $expected\n            ),\n        }\n    };\n}\n\nmacro_rules! unexpected {\n    ($token:expr) => {\n        panic!(\"deserialization did not expect this token: {}\", $token)\n    };\n}\n\nmacro_rules! end_of_tokens {\n    () => {\n        panic!(\"ran out of tokens to deserialize\")\n    };\n}\n\nimpl<'de> Deserializer<'de> {\n    pub fn new(tokens: &'de [Token]) -> Self {\n        Deserializer { tokens: tokens }\n    }\n\n    fn peek_token_opt(&self) -> Option<Token> {\n        self.tokens.first().cloned()\n    }\n\n    fn peek_token(&self) -> Token {\n        match self.peek_token_opt() {\n            Some(token) => token,\n            None => end_of_tokens!(),\n        }\n    }\n\n    pub fn next_token_opt(&mut self) -> Option<Token> {\n        match self.tokens.split_first() {\n            Some((&first, rest)) => {\n                self.tokens = rest;\n                Some(first)\n            }\n            None => None,\n        }\n    }\n\n    fn next_token(&mut self) -> Token {\n        match self.tokens.split_first() {\n            Some((&first, rest)) => {\n                self.tokens = rest;\n                first\n            }\n            None => end_of_tokens!(),\n        }\n    }\n\n    pub fn remaining(&self) -> usize {\n        self.tokens.len()\n    }\n\n    fn visit_seq<V>(\n        &mut self,\n        len: Option<usize>,\n        end: Token,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        let value = visitor.visit_seq(DeserializerSeqVisitor {\n            de: self,\n            len: len,\n            end: end,\n        })?;\n        assert_next_token!(self, end);\n        Ok(value)\n    }\n\n    fn visit_map<V>(\n        &mut self,\n        len: Option<usize>,\n        end: Token,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        let value = visitor.visit_map(DeserializerMapVisitor {\n            de: self,\n            len: len,\n            end: end,\n        })?;\n        assert_next_token!(self, end);\n        Ok(value)\n    }\n}\n\nimpl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n    type Error = Error;\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf unit seq map identifier ignored_any\n    }\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        let token = self.next_token();\n        match token {\n            Token::Bool(v) => visitor.visit_bool(v),\n            Token::I8(v) => visitor.visit_i8(v),\n            Token::I16(v) => visitor.visit_i16(v),\n            Token::I32(v) => visitor.visit_i32(v),\n            Token::I64(v) => visitor.visit_i64(v),\n            Token::U8(v) => visitor.visit_u8(v),\n            Token::U16(v) => visitor.visit_u16(v),\n            Token::U32(v) => visitor.visit_u32(v),\n            Token::U64(v) => visitor.visit_u64(v),\n            Token::F32(v) => visitor.visit_f32(v),\n            Token::F64(v) => visitor.visit_f64(v),\n            Token::Char(v) => visitor.visit_char(v),\n            Token::Str(v) => visitor.visit_str(v),\n            Token::BorrowedStr(v) => visitor.visit_borrowed_str(v),\n            Token::String(v) => visitor.visit_string(v.to_owned()),\n            Token::Bytes(v) => visitor.visit_bytes(v),\n            Token::BorrowedBytes(v) => visitor.visit_borrowed_bytes(v),\n            Token::ByteBuf(v) => visitor.visit_byte_buf(v.to_vec()),\n            Token::None => visitor.visit_none(),\n            Token::Some => visitor.visit_some(self),\n            Token::Unit | Token::UnitStruct { .. } => visitor.visit_unit(),\n            Token::NewtypeStruct { .. } => visitor.visit_newtype_struct(self),\n            Token::Seq { len } => self.visit_seq(len, Token::SeqEnd, visitor),\n            Token::Tuple { len } => self.visit_seq(Some(len), Token::TupleEnd, visitor),\n            Token::TupleStruct { len, .. } => {\n                self.visit_seq(Some(len), Token::TupleStructEnd, visitor)\n            }\n            Token::Map { len } => self.visit_map(len, Token::MapEnd, visitor),\n            Token::Struct { len, .. } => self.visit_map(Some(len), Token::StructEnd, visitor),\n            Token::Enum { .. } => {\n                let variant = self.next_token();\n                let next = self.peek_token();\n                match (variant, next) {\n                    (Token::Str(variant), Token::Unit) => {\n                        self.next_token();\n                        visitor.visit_str(variant)\n                    }\n                    (Token::Bytes(variant), Token::Unit) => {\n                        self.next_token();\n                        visitor.visit_bytes(variant)\n                    }\n                    (Token::U32(variant), Token::Unit) => {\n                        self.next_token();\n                        visitor.visit_u32(variant)\n                    }\n                    (variant, Token::Unit) => unexpected!(variant),\n                    (variant, _) => {\n                        visitor.visit_map(EnumMapVisitor::new(self, variant, EnumFormat::Any))\n                    }\n                }\n            }\n            Token::UnitVariant { variant, .. } => visitor.visit_str(variant),\n            Token::NewtypeVariant { variant, .. } => visitor.visit_map(EnumMapVisitor::new(\n                self,\n                Token::Str(variant),\n                EnumFormat::Any,\n            )),\n            Token::TupleVariant { variant, .. } => visitor.visit_map(EnumMapVisitor::new(\n                self,\n                Token::Str(variant),\n                EnumFormat::Seq,\n            )),\n            Token::StructVariant { variant, .. } => visitor.visit_map(EnumMapVisitor::new(\n                self,\n                Token::Str(variant),\n                EnumFormat::Map,\n            )),\n            Token::SeqEnd\n            | Token::TupleEnd\n            | Token::TupleStructEnd\n            | Token::MapEnd\n            | Token::StructEnd\n            | Token::TupleVariantEnd\n            | Token::StructVariantEnd => {\n                unexpected!(token);\n            }\n        }\n    }\n\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.peek_token() {\n            Token::Unit | Token::None => {\n                self.next_token();\n                visitor.visit_none()\n            }\n            Token::Some => {\n                self.next_token();\n                visitor.visit_some(self)\n            }\n            _ => self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.peek_token() {\n            Token::Enum { name: n } if name == n => {\n                self.next_token();\n\n                visitor.visit_enum(DeserializerEnumVisitor { de: self })\n            }\n            Token::UnitVariant { name: n, .. }\n            | Token::NewtypeVariant { name: n, .. }\n            | Token::TupleVariant { name: n, .. }\n            | Token::StructVariant { name: n, .. }\n                if name == n =>\n            {\n                visitor.visit_enum(DeserializerEnumVisitor { de: self })\n            }\n            _ => {\n                unexpected!(self.next_token());\n            }\n        }\n    }\n\n    fn deserialize_unit_struct<V>(self, name: &'static str, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.peek_token() {\n            Token::UnitStruct { .. } => {\n                assert_next_token!(self, Token::UnitStruct { name: name });\n                visitor.visit_unit()\n            }\n            _ => self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.peek_token() {\n            Token::NewtypeStruct { .. } => {\n                assert_next_token!(self, Token::NewtypeStruct { name: name });\n                visitor.visit_newtype_struct(self)\n            }\n            _ => self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.peek_token() {\n            Token::Unit | Token::UnitStruct { .. } => {\n                self.next_token();\n                visitor.visit_unit()\n            }\n            Token::Seq { .. } => {\n                self.next_token();\n                self.visit_seq(Some(len), Token::SeqEnd, visitor)\n            }\n            Token::Tuple { .. } => {\n                self.next_token();\n                self.visit_seq(Some(len), Token::TupleEnd, visitor)\n            }\n            Token::TupleStruct { .. } => {\n                self.next_token();\n                self.visit_seq(Some(len), Token::TupleStructEnd, visitor)\n            }\n            _ => self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_tuple_struct<V>(\n        self,\n        name: &'static str,\n        len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.peek_token() {\n            Token::Unit => {\n                self.next_token();\n                visitor.visit_unit()\n            }\n            Token::UnitStruct { .. } => {\n                assert_next_token!(self, Token::UnitStruct { name: name });\n                visitor.visit_unit()\n            }\n            Token::Seq { .. } => {\n                self.next_token();\n                self.visit_seq(Some(len), Token::SeqEnd, visitor)\n            }\n            Token::Tuple { .. } => {\n                self.next_token();\n                self.visit_seq(Some(len), Token::TupleEnd, visitor)\n            }\n            Token::TupleStruct { len: n, .. } => {\n                assert_next_token!(self, Token::TupleStruct { name: name, len: n });\n                self.visit_seq(Some(len), Token::TupleStructEnd, visitor)\n            }\n            _ => self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.peek_token() {\n            Token::Struct { len: n, .. } => {\n                assert_next_token!(self, Token::Struct { name: name, len: n });\n                self.visit_map(Some(fields.len()), Token::StructEnd, visitor)\n            }\n            Token::Map { .. } => {\n                self.next_token();\n                self.visit_map(Some(fields.len()), Token::MapEnd, visitor)\n            }\n            _ => self.deserialize_any(visitor),\n        }\n    }\n\n    fn is_human_readable(&self) -> bool {\n        panic!(\n            \"Types which have different human-readable and compact representations \\\n             must explicitly mark their test cases with `serde_test::Configure`\"\n        );\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nstruct DeserializerSeqVisitor<'a, 'de: 'a> {\n    de: &'a mut Deserializer<'de>,\n    len: Option<usize>,\n    end: Token,\n}\n\nimpl<'de, 'a> SeqAccess<'de> for DeserializerSeqVisitor<'a, 'de> {\n    type Error = Error;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        if self.de.peek_token_opt() == Some(self.end) {\n            return Ok(None);\n        }\n        self.len = self.len.map(|len| len.saturating_sub(1));\n        seed.deserialize(&mut *self.de).map(Some)\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        self.len\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nstruct DeserializerMapVisitor<'a, 'de: 'a> {\n    de: &'a mut Deserializer<'de>,\n    len: Option<usize>,\n    end: Token,\n}\n\nimpl<'de, 'a> MapAccess<'de> for DeserializerMapVisitor<'a, 'de> {\n    type Error = Error;\n\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n    where\n        K: DeserializeSeed<'de>,\n    {\n        if self.de.peek_token_opt() == Some(self.end) {\n            return Ok(None);\n        }\n        self.len = self.len.map(|len| len.saturating_sub(1));\n        seed.deserialize(&mut *self.de).map(Some)\n    }\n\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        seed.deserialize(&mut *self.de)\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        self.len\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nstruct DeserializerEnumVisitor<'a, 'de: 'a> {\n    de: &'a mut Deserializer<'de>,\n}\n\nimpl<'de, 'a> EnumAccess<'de> for DeserializerEnumVisitor<'a, 'de> {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self), Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        match self.de.peek_token() {\n            Token::UnitVariant { variant: v, .. }\n            | Token::NewtypeVariant { variant: v, .. }\n            | Token::TupleVariant { variant: v, .. }\n            | Token::StructVariant { variant: v, .. } => {\n                let de = v.into_deserializer();\n                let value = seed.deserialize(de)?;\n                Ok((value, self))\n            }\n            _ => {\n                let value = seed.deserialize(&mut *self.de)?;\n                Ok((value, self))\n            }\n        }\n    }\n}\n\nimpl<'de, 'a> VariantAccess<'de> for DeserializerEnumVisitor<'a, 'de> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Error> {\n        match self.de.peek_token() {\n            Token::UnitVariant { .. } => {\n                self.de.next_token();\n                Ok(())\n            }\n            _ => Deserialize::deserialize(self.de),\n        }\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        match self.de.peek_token() {\n            Token::NewtypeVariant { .. } => {\n                self.de.next_token();\n                seed.deserialize(self.de)\n            }\n            _ => seed.deserialize(self.de),\n        }\n    }\n\n    fn tuple_variant<V>(self, len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.de.peek_token() {\n            Token::TupleVariant { len: enum_len, .. } => {\n                let token = self.de.next_token();\n\n                if len == enum_len {\n                    self.de\n                        .visit_seq(Some(len), Token::TupleVariantEnd, visitor)\n                } else {\n                    unexpected!(token);\n                }\n            }\n            Token::Seq {\n                len: Some(enum_len),\n            } => {\n                let token = self.de.next_token();\n\n                if len == enum_len {\n                    self.de.visit_seq(Some(len), Token::SeqEnd, visitor)\n                } else {\n                    unexpected!(token);\n                }\n            }\n            _ => de::Deserializer::deserialize_any(self.de, visitor),\n        }\n    }\n\n    fn struct_variant<V>(\n        self,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.de.peek_token() {\n            Token::StructVariant { len: enum_len, .. } => {\n                let token = self.de.next_token();\n\n                if fields.len() == enum_len {\n                    self.de\n                        .visit_map(Some(fields.len()), Token::StructVariantEnd, visitor)\n                } else {\n                    unexpected!(token);\n                }\n            }\n            Token::Map {\n                len: Some(enum_len),\n            } => {\n                let token = self.de.next_token();\n\n                if fields.len() == enum_len {\n                    self.de\n                        .visit_map(Some(fields.len()), Token::MapEnd, visitor)\n                } else {\n                    unexpected!(token);\n                }\n            }\n            _ => de::Deserializer::deserialize_any(self.de, visitor),\n        }\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nstruct EnumMapVisitor<'a, 'de: 'a> {\n    de: &'a mut Deserializer<'de>,\n    variant: Option<Token>,\n    format: EnumFormat,\n}\n\nenum EnumFormat {\n    Seq,\n    Map,\n    Any,\n}\n\nimpl<'a, 'de> EnumMapVisitor<'a, 'de> {\n    fn new(de: &'a mut Deserializer<'de>, variant: Token, format: EnumFormat) -> Self {\n        EnumMapVisitor {\n            de: de,\n            variant: Some(variant),\n            format: format,\n        }\n    }\n}\n\nimpl<'de, 'a> MapAccess<'de> for EnumMapVisitor<'a, 'de> {\n    type Error = Error;\n\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n    where\n        K: DeserializeSeed<'de>,\n    {\n        match self.variant.take() {\n            Some(Token::Str(variant)) => seed.deserialize(variant.into_deserializer()).map(Some),\n            Some(Token::Bytes(variant)) => seed\n                .deserialize(BytesDeserializer { value: variant })\n                .map(Some),\n            Some(Token::U32(variant)) => seed.deserialize(variant.into_deserializer()).map(Some),\n            Some(other) => unexpected!(other),\n            None => Ok(None),\n        }\n    }\n\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        match self.format {\n            EnumFormat::Seq => {\n                let value = {\n                    let visitor = DeserializerSeqVisitor {\n                        de: self.de,\n                        len: None,\n                        end: Token::TupleVariantEnd,\n                    };\n                    seed.deserialize(SeqAccessDeserializer::new(visitor))?\n                };\n                assert_next_token!(self.de, Token::TupleVariantEnd);\n                Ok(value)\n            }\n            EnumFormat::Map => {\n                let value = {\n                    let visitor = DeserializerMapVisitor {\n                        de: self.de,\n                        len: None,\n                        end: Token::StructVariantEnd,\n                    };\n                    seed.deserialize(MapAccessDeserializer::new(visitor))?\n                };\n                assert_next_token!(self.de, Token::StructVariantEnd);\n                Ok(value)\n            }\n            EnumFormat::Any => seed.deserialize(&mut *self.de),\n        }\n    }\n}\n\nstruct BytesDeserializer {\n    value: &'static [u8],\n}\n\nimpl<'de> de::Deserializer<'de> for BytesDeserializer {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: de::Visitor<'de>,\n    {\n        visitor.visit_bytes(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","error.rs"],"content":"use std::error;\nuse std::fmt::{self, Display};\n\nuse serde::{de, ser};\n\n#[derive(Clone, Debug)]\npub struct Error {\n    msg: String,\n}\n\nimpl ser::Error for Error {\n    fn custom<T: Display>(msg: T) -> Self {\n        Error {\n            msg: msg.to_string(),\n        }\n    }\n}\n\nimpl de::Error for Error {\n    fn custom<T: Display>(msg: T) -> Self {\n        Error {\n            msg: msg.to_string(),\n        }\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(&self.msg)\n    }\n}\n\nimpl error::Error for Error {\n    fn description(&self) -> &str {\n        &self.msg\n    }\n}\n\nimpl PartialEq<str> for Error {\n    fn eq(&self, other: &str) -> bool {\n        self.msg == other\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","lib.rs"],"content":"//! This crate provides a convenient concise way to write unit tests for\n//! implementations of [`Serialize`] and [`Deserialize`].\n//!\n//! [`Serialize`]: https://docs.serde.rs/serde/ser/trait.Serialize.html\n//! [`Deserialize`]: https://docs.serde.rs/serde/de/trait.Deserialize.html\n//!\n//! The `Serialize` impl for a value can be characterized by the sequence of\n//! [`Serializer`] calls that are made in the course of serializing the value,\n//! so `serde_test` provides a [`Token`] abstraction which corresponds roughly\n//! to `Serializer` method calls. There is an [`assert_ser_tokens`] function to\n//! test that a value serializes to a particular sequence of method calls, an\n//! [`assert_de_tokens`] function to test that a value can be deserialized from\n//! a particular sequence of method calls, and an [`assert_tokens`] function to\n//! test both directions. There are also functions to test expected failure\n//! conditions.\n//!\n//! [`Serializer`]: https://docs.serde.rs/serde/ser/trait.Serializer.html\n//! [`Token`]: https://docs.serde.rs/serde_test/enum.Token.html\n//! [`assert_ser_tokens`]: https://docs.serde.rs/serde_test/fn.assert_ser_tokens.html\n//! [`assert_de_tokens`]: https://docs.serde.rs/serde_test/fn.assert_de_tokens.html\n//! [`assert_tokens`]: https://docs.serde.rs/serde_test/fn.assert_tokens.html\n//!\n//! Here is an example from the [`linked-hash-map`] crate.\n//!\n//! [`linked-hash-map`]: https://github.com/contain-rs/linked-hash-map\n//!\n//! ```edition2018\n//! # const IGNORE: &str = stringify! {\n//! use linked_hash_map::LinkedHashMap;\n//! # };\n//! use serde_test::{Token, assert_tokens};\n//!\n//! # use std::fmt;\n//! # use std::marker::PhantomData;\n//! #\n//! # use serde::ser::{Serialize, Serializer, SerializeMap};\n//! # use serde::de::{Deserialize, Deserializer, Visitor, MapAccess};\n//! #\n//! # // Dumb imitation of LinkedHashMap.\n//! # #[derive(PartialEq, Debug)]\n//! # struct LinkedHashMap<K, V>(Vec<(K, V)>);\n//! #\n//! # impl<K, V> LinkedHashMap<K, V> {\n//! #     fn new() -> Self {\n//! #         LinkedHashMap(Vec::new())\n//! #     }\n//! #\n//! #     fn insert(&mut self, k: K, v: V) {\n//! #         self.0.push((k, v));\n//! #     }\n//! # }\n//! #\n//! # impl<K, V> Serialize for LinkedHashMap<K, V>\n//! # where\n//! #     K: Serialize,\n//! #     V: Serialize,\n//! # {\n//! #     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n//! #     where\n//! #         S: Serializer,\n//! #     {\n//! #         let mut map = serializer.serialize_map(Some(self.0.len()))?;\n//! #         for &(ref k, ref v) in &self.0 {\n//! #             map.serialize_entry(k, v)?;\n//! #         }\n//! #         map.end()\n//! #     }\n//! # }\n//! #\n//! # struct LinkedHashMapVisitor<K, V>(PhantomData<(K, V)>);\n//! #\n//! # impl<'de, K, V> Visitor<'de> for LinkedHashMapVisitor<K, V>\n//! # where\n//! #     K: Deserialize<'de>,\n//! #     V: Deserialize<'de>,\n//! # {\n//! #     type Value = LinkedHashMap<K, V>;\n//! #\n//! #     fn expecting(&self, _: &mut fmt::Formatter) -> fmt::Result {\n//! #         unimplemented!()\n//! #     }\n//! #\n//! #     fn visit_map<M>(self, mut access: M) -> Result<Self::Value, M::Error>\n//! #     where\n//! #         M: MapAccess<'de>,\n//! #     {\n//! #         let mut map = LinkedHashMap::new();\n//! #         while let Some((key, value)) = access.next_entry()? {\n//! #             map.insert(key, value);\n//! #         }\n//! #         Ok(map)\n//! #     }\n//! # }\n//! #\n//! # impl<'de, K, V> Deserialize<'de> for LinkedHashMap<K, V>\n//! # where\n//! #     K: Deserialize<'de>,\n//! #     V: Deserialize<'de>,\n//! # {\n//! #     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n//! #     where\n//! #         D: Deserializer<'de>,\n//! #     {\n//! #         deserializer.deserialize_map(LinkedHashMapVisitor(PhantomData))\n//! #     }\n//! # }\n//! #\n//! #[test]\n//! # fn not_a_test_ser_de_empty() {}\n//! fn test_ser_de_empty() {\n//!     let map = LinkedHashMap::<char, u32>::new();\n//!\n//!     assert_tokens(&map, &[\n//!         Token::Map { len: Some(0) },\n//!         Token::MapEnd,\n//!     ]);\n//! }\n//!\n//! #[test]\n//! # fn not_a_test_ser_de() {}\n//! fn test_ser_de() {\n//!     let mut map = LinkedHashMap::new();\n//!     map.insert('b', 20);\n//!     map.insert('a', 10);\n//!     map.insert('c', 30);\n//!\n//!     assert_tokens(&map, &[\n//!         Token::Map { len: Some(3) },\n//!         Token::Char('b'),\n//!         Token::I32(20),\n//!\n//!         Token::Char('a'),\n//!         Token::I32(10),\n//!\n//!         Token::Char('c'),\n//!         Token::I32(30),\n//!         Token::MapEnd,\n//!     ]);\n//! }\n//! #\n//! # fn main() {\n//! #     test_ser_de_empty();\n//! #     test_ser_de();\n//! # }\n//! ```\n\n#![doc(html_root_url = \"https://docs.rs/serde_test/1.0.100\")]\n#![cfg_attr(feature = \"cargo-clippy\", allow(renamed_and_removed_lints))]\n#![cfg_attr(feature = \"cargo-clippy\", deny(clippy, clippy_pedantic))]\n// Ignored clippy lints\n#![cfg_attr(feature = \"cargo-clippy\", allow(float_cmp))]\n// Ignored clippy_pedantic lints\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        empty_line_after_outer_attr,\n        missing_docs_in_private_items,\n        module_name_repetitions,\n        redundant_field_names,\n        use_debug,\n        use_self\n    )\n)]\n\n#[macro_use]\nextern crate serde;\n\nmod de;\nmod error;\nmod ser;\n\nmod assert;\nmod configure;\nmod token;\n\npub use assert::{\n    assert_de_tokens, assert_de_tokens_error, assert_ser_tokens, assert_ser_tokens_error,\n    assert_tokens,\n};\npub use token::Token;\n\npub use configure::{Compact, Configure, Readable};\n\n// Not public API.\n#[doc(hidden)]\npub use de::Deserializer;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","ser.rs"],"content":"use serde::{ser, Serialize};\n\nuse error::Error;\nuse token::Token;\n\n/// A `Serializer` that ensures that a value serializes to a given list of\n/// tokens.\n#[derive(Debug)]\npub struct Serializer<'a> {\n    tokens: &'a [Token],\n}\n\nimpl<'a> Serializer<'a> {\n    /// Creates the serializer.\n    pub fn new(tokens: &'a [Token]) -> Self {\n        Serializer { tokens: tokens }\n    }\n\n    /// Pulls the next token off of the serializer, ignoring it.\n    fn next_token(&mut self) -> Option<Token> {\n        if let Some((&first, rest)) = self.tokens.split_first() {\n            self.tokens = rest;\n            Some(first)\n        } else {\n            None\n        }\n    }\n\n    pub fn remaining(&self) -> usize {\n        self.tokens.len()\n    }\n}\n\nmacro_rules! assert_next_token {\n    ($ser:expr, $expected:ident) => {\n        assert_next_token!($ser, stringify!($expected), Token::$expected, true);\n    };\n    ($ser:expr, $expected:ident($v:expr)) => {\n        assert_next_token!(\n            $ser,\n            format_args!(concat!(stringify!($expected), \"({:?})\"), $v),\n            Token::$expected(v),\n            v == $v\n        );\n    };\n    ($ser:expr, $expected:ident { $($k:ident),* }) => {\n        let compare = ($($k,)*);\n        let field_format = || {\n            use std::fmt::Write;\n            let mut buffer = String::new();\n            $(\n                write!(&mut buffer, concat!(stringify!($k), \": {:?}, \"), $k).unwrap();\n            )*\n            buffer\n        };\n        assert_next_token!(\n            $ser,\n            format_args!(concat!(stringify!($expected), \" {{ {}}}\"), field_format()),\n            Token::$expected { $($k),* },\n            ($($k,)*) == compare\n        );\n    };\n    ($ser:expr, $expected:expr, $pat:pat, $guard:expr) => {\n        match $ser.next_token() {\n            Some($pat) if $guard => {}\n            Some(other) => {\n                panic!(\"expected Token::{} but serialized as {}\",\n                       $expected, other);\n            }\n            None => {\n                panic!(\"expected Token::{} after end of serialized tokens\",\n                       $expected);\n            }\n        }\n    };\n}\n\nimpl<'s, 'a> ser::Serializer for &'s mut Serializer<'a> {\n    type Ok = ();\n    type Error = Error;\n\n    type SerializeSeq = Self;\n    type SerializeTuple = Self;\n    type SerializeTupleStruct = Self;\n    type SerializeTupleVariant = Variant<'s, 'a>;\n    type SerializeMap = Self;\n    type SerializeStruct = Self;\n    type SerializeStructVariant = Variant<'s, 'a>;\n\n    fn serialize_bool(self, v: bool) -> Result<(), Error> {\n        assert_next_token!(self, Bool(v));\n        Ok(())\n    }\n\n    fn serialize_i8(self, v: i8) -> Result<(), Error> {\n        assert_next_token!(self, I8(v));\n        Ok(())\n    }\n\n    fn serialize_i16(self, v: i16) -> Result<(), Error> {\n        assert_next_token!(self, I16(v));\n        Ok(())\n    }\n\n    fn serialize_i32(self, v: i32) -> Result<(), Error> {\n        assert_next_token!(self, I32(v));\n        Ok(())\n    }\n\n    fn serialize_i64(self, v: i64) -> Result<(), Error> {\n        assert_next_token!(self, I64(v));\n        Ok(())\n    }\n\n    fn serialize_u8(self, v: u8) -> Result<(), Error> {\n        assert_next_token!(self, U8(v));\n        Ok(())\n    }\n\n    fn serialize_u16(self, v: u16) -> Result<(), Error> {\n        assert_next_token!(self, U16(v));\n        Ok(())\n    }\n\n    fn serialize_u32(self, v: u32) -> Result<(), Error> {\n        assert_next_token!(self, U32(v));\n        Ok(())\n    }\n\n    fn serialize_u64(self, v: u64) -> Result<(), Error> {\n        assert_next_token!(self, U64(v));\n        Ok(())\n    }\n\n    fn serialize_f32(self, v: f32) -> Result<(), Error> {\n        assert_next_token!(self, F32(v));\n        Ok(())\n    }\n\n    fn serialize_f64(self, v: f64) -> Result<(), Error> {\n        assert_next_token!(self, F64(v));\n        Ok(())\n    }\n\n    fn serialize_char(self, v: char) -> Result<(), Error> {\n        assert_next_token!(self, Char(v));\n        Ok(())\n    }\n\n    fn serialize_str(self, v: &str) -> Result<(), Error> {\n        match self.tokens.first() {\n            Some(&Token::BorrowedStr(_)) => assert_next_token!(self, BorrowedStr(v)),\n            Some(&Token::String(_)) => assert_next_token!(self, String(v)),\n            _ => assert_next_token!(self, Str(v)),\n        }\n        Ok(())\n    }\n\n    fn serialize_bytes(self, v: &[u8]) -> Result<(), Self::Error> {\n        match self.tokens.first() {\n            Some(&Token::BorrowedBytes(_)) => assert_next_token!(self, BorrowedBytes(v)),\n            Some(&Token::ByteBuf(_)) => assert_next_token!(self, ByteBuf(v)),\n            _ => assert_next_token!(self, Bytes(v)),\n        }\n        Ok(())\n    }\n\n    fn serialize_unit(self) -> Result<(), Error> {\n        assert_next_token!(self, Unit);\n        Ok(())\n    }\n\n    fn serialize_unit_struct(self, name: &'static str) -> Result<(), Error> {\n        assert_next_token!(self, UnitStruct { name });\n        Ok(())\n    }\n\n    fn serialize_unit_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n    ) -> Result<(), Error> {\n        if self.tokens.first() == Some(&Token::Enum { name: name }) {\n            self.next_token();\n            assert_next_token!(self, Str(variant));\n            assert_next_token!(self, Unit);\n        } else {\n            assert_next_token!(self, UnitVariant { name, variant });\n        }\n        Ok(())\n    }\n\n    fn serialize_newtype_struct<T: ?Sized>(self, name: &'static str, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        assert_next_token!(self, NewtypeStruct { name });\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant<T: ?Sized>(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        if self.tokens.first() == Some(&Token::Enum { name: name }) {\n            self.next_token();\n            assert_next_token!(self, Str(variant));\n        } else {\n            assert_next_token!(self, NewtypeVariant { name, variant });\n        }\n        value.serialize(self)\n    }\n\n    fn serialize_none(self) -> Result<(), Error> {\n        assert_next_token!(self, None);\n        Ok(())\n    }\n\n    fn serialize_some<T: ?Sized>(self, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        assert_next_token!(self, Some);\n        value.serialize(self)\n    }\n\n    fn serialize_seq(self, len: Option<usize>) -> Result<Self, Error> {\n        assert_next_token!(self, Seq { len });\n        Ok(self)\n    }\n\n    fn serialize_tuple(self, len: usize) -> Result<Self, Error> {\n        assert_next_token!(self, Tuple { len });\n        Ok(self)\n    }\n\n    fn serialize_tuple_struct(self, name: &'static str, len: usize) -> Result<Self, Error> {\n        assert_next_token!(self, TupleStruct { name, len });\n        Ok(self)\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Error> {\n        if self.tokens.first() == Some(&Token::Enum { name: name }) {\n            self.next_token();\n            assert_next_token!(self, Str(variant));\n            let len = Some(len);\n            assert_next_token!(self, Seq { len });\n            Ok(Variant {\n                ser: self,\n                end: Token::SeqEnd,\n            })\n        } else {\n            assert_next_token!(self, TupleVariant { name, variant, len });\n            Ok(Variant {\n                ser: self,\n                end: Token::TupleVariantEnd,\n            })\n        }\n    }\n\n    fn serialize_map(self, len: Option<usize>) -> Result<Self, Error> {\n        assert_next_token!(self, Map { len });\n        Ok(self)\n    }\n\n    fn serialize_struct(self, name: &'static str, len: usize) -> Result<Self, Error> {\n        assert_next_token!(self, Struct { name, len });\n        Ok(self)\n    }\n\n    fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        _variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStructVariant, Error> {\n        if self.tokens.first() == Some(&Token::Enum { name: name }) {\n            self.next_token();\n            assert_next_token!(self, Str(variant));\n            let len = Some(len);\n            assert_next_token!(self, Map { len });\n            Ok(Variant {\n                ser: self,\n                end: Token::MapEnd,\n            })\n        } else {\n            assert_next_token!(self, StructVariant { name, variant, len });\n            Ok(Variant {\n                ser: self,\n                end: Token::StructVariantEnd,\n            })\n        }\n    }\n\n    fn is_human_readable(&self) -> bool {\n        panic!(\n            \"Types which have different human-readable and compact representations \\\n             must explicitly mark their test cases with `serde_test::Configure`\"\n        );\n    }\n}\n\npub struct Variant<'s, 'a: 's> {\n    ser: &'s mut Serializer<'a>,\n    end: Token,\n}\n\nimpl<'s, 'a> ser::SerializeSeq for &'s mut Serializer<'a> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        value.serialize(&mut **self)\n    }\n\n    fn end(self) -> Result<(), Error> {\n        assert_next_token!(self, SeqEnd);\n        Ok(())\n    }\n}\n\nimpl<'s, 'a> ser::SerializeTuple for &'s mut Serializer<'a> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        value.serialize(&mut **self)\n    }\n\n    fn end(self) -> Result<(), Error> {\n        assert_next_token!(self, TupleEnd);\n        Ok(())\n    }\n}\n\nimpl<'s, 'a> ser::SerializeTupleStruct for &'s mut Serializer<'a> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        value.serialize(&mut **self)\n    }\n\n    fn end(self) -> Result<(), Error> {\n        assert_next_token!(self, TupleStructEnd);\n        Ok(())\n    }\n}\n\nimpl<'s, 'a> ser::SerializeTupleVariant for Variant<'s, 'a> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n    where\n        T: Serialize,\n    {\n        value.serialize(&mut *self.ser)\n    }\n\n    fn end(self) -> Result<(), Error> {\n        match self.end {\n            Token::TupleVariantEnd => assert_next_token!(self.ser, TupleVariantEnd),\n            Token::SeqEnd => assert_next_token!(self.ser, SeqEnd),\n            _ => unreachable!(),\n        }\n        Ok(())\n    }\n}\n\nimpl<'s, 'a> ser::SerializeMap for &'s mut Serializer<'a> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        key.serialize(&mut **self)\n    }\n\n    fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        value.serialize(&mut **self)\n    }\n\n    fn end(self) -> Result<(), Self::Error> {\n        assert_next_token!(self, MapEnd);\n        Ok(())\n    }\n}\n\nimpl<'s, 'a> ser::SerializeStruct for &'s mut Serializer<'a> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        key.serialize(&mut **self)?;\n        value.serialize(&mut **self)\n    }\n\n    fn end(self) -> Result<(), Self::Error> {\n        assert_next_token!(self, StructEnd);\n        Ok(())\n    }\n}\n\nimpl<'s, 'a> ser::SerializeStructVariant for Variant<'s, 'a> {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field<T: ?Sized>(\n        &mut self,\n        key: &'static str,\n        value: &T,\n    ) -> Result<(), Self::Error>\n    where\n        T: Serialize,\n    {\n        key.serialize(&mut *self.ser)?;\n        value.serialize(&mut *self.ser)\n    }\n\n    fn end(self) -> Result<(), Self::Error> {\n        match self.end {\n            Token::StructVariantEnd => assert_next_token!(self.ser, StructVariantEnd),\n            Token::MapEnd => assert_next_token!(self.ser, MapEnd),\n            _ => unreachable!(),\n        }\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","token.rs"],"content":"use std::fmt::{self, Debug, Display};\n\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum Token {\n    /// A serialized `bool`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&true, &[Token::Bool(true)]);\n    /// ```\n    Bool(bool),\n\n    /// A serialized `i8`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&0i8, &[Token::I8(0)]);\n    /// ```\n    I8(i8),\n\n    /// A serialized `i16`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&0i16, &[Token::I16(0)]);\n    /// ```\n    I16(i16),\n\n    /// A serialized `i32`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&0i32, &[Token::I32(0)]);\n    /// ```\n    I32(i32),\n\n    /// A serialized `i64`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&0i64, &[Token::I64(0)]);\n    /// ```\n    I64(i64),\n\n    /// A serialized `u8`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&0u8, &[Token::U8(0)]);\n    /// ```\n    U8(u8),\n\n    /// A serialized `u16`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&0u16, &[Token::U16(0)]);\n    /// ```\n    U16(u16),\n\n    /// A serialized `u32`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&0u32, &[Token::U32(0)]);\n    /// ```\n    U32(u32),\n\n    /// A serialized `u64`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&0u64, &[Token::U64(0)]);\n    /// ```\n    U64(u64),\n\n    /// A serialized `f32`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&0f32, &[Token::F32(0.0)]);\n    /// ```\n    F32(f32),\n\n    /// A serialized `f64`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&0f64, &[Token::F64(0.0)]);\n    /// ```\n    F64(f64),\n\n    /// A serialized `char`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&'\\n', &[Token::Char('\\n')]);\n    /// ```\n    Char(char),\n\n    /// A serialized `str`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let s = String::from(\"transient\");\n    /// assert_tokens(&s, &[Token::Str(\"transient\")]);\n    /// ```\n    Str(&'static str),\n\n    /// A borrowed `str`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let s: &str = \"borrowed\";\n    /// assert_tokens(&s, &[Token::BorrowedStr(\"borrowed\")]);\n    /// ```\n    BorrowedStr(&'static str),\n\n    /// A serialized `String`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let s = String::from(\"owned\");\n    /// assert_tokens(&s, &[Token::String(\"owned\")]);\n    /// ```\n    String(&'static str),\n\n    /// A serialized `[u8]`\n    Bytes(&'static [u8]),\n\n    /// A borrowed `[u8]`.\n    BorrowedBytes(&'static [u8]),\n\n    /// A serialized `ByteBuf`\n    ByteBuf(&'static [u8]),\n\n    /// A serialized `Option<T>` containing none.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let opt = None::<char>;\n    /// assert_tokens(&opt, &[Token::None]);\n    /// ```\n    None,\n\n    /// The header to a serialized `Option<T>` containing some value.\n    ///\n    /// The tokens of the value follow after this header.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let opt = Some('c');\n    /// assert_tokens(&opt, &[\n    ///     Token::Some,\n    ///     Token::Char('c'),\n    /// ]);\n    /// ```\n    Some,\n\n    /// A serialized `()`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(&(), &[Token::Unit]);\n    /// ```\n    Unit,\n\n    /// A serialized unit struct of the given name.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// struct X;\n    ///\n    /// assert_tokens(&X, &[Token::UnitStruct { name: \"X\" }]);\n    /// # }\n    /// ```\n    UnitStruct { name: &'static str },\n\n    /// A unit variant of an enum.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     A,\n    /// }\n    ///\n    /// let a = E::A;\n    /// assert_tokens(&a, &[Token::UnitVariant { name: \"E\", variant: \"A\" }]);\n    /// # }\n    /// ```\n    UnitVariant {\n        name: &'static str,\n        variant: &'static str,\n    },\n\n    /// The header to a serialized newtype struct of the given name.\n    ///\n    /// After this header is the value contained in the newtype struct.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// struct N(String);\n    ///\n    /// let n = N(\"newtype\".to_owned());\n    /// assert_tokens(&n, &[\n    ///     Token::NewtypeStruct { name: \"N\" },\n    ///     Token::String(\"newtype\"),\n    /// ]);\n    /// # }\n    /// ```\n    NewtypeStruct { name: &'static str },\n\n    /// The header to a newtype variant of an enum.\n    ///\n    /// After this header is the value contained in the newtype variant.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     B(u8),\n    /// }\n    ///\n    /// let b = E::B(0);\n    /// assert_tokens(&b, &[\n    ///     Token::NewtypeVariant { name: \"E\", variant: \"B\" },\n    ///     Token::U8(0),\n    /// ]);\n    /// # }\n    /// ```\n    NewtypeVariant {\n        name: &'static str,\n        variant: &'static str,\n    },\n\n    /// The header to a sequence.\n    ///\n    /// After this header are the elements of the sequence, followed by\n    /// `SeqEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let vec = vec!['a', 'b', 'c'];\n    /// assert_tokens(&vec, &[\n    ///     Token::Seq { len: Some(3) },\n    ///     Token::Char('a'),\n    ///     Token::Char('b'),\n    ///     Token::Char('c'),\n    ///     Token::SeqEnd,\n    /// ]);\n    /// ```\n    Seq { len: Option<usize> },\n\n    /// An indicator of the end of a sequence.\n    SeqEnd,\n\n    /// The header to a tuple.\n    ///\n    /// After this header are the elements of the tuple, followed by `TupleEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let tuple = ('a', 100);\n    /// assert_tokens(&tuple, &[\n    ///     Token::Tuple { len: 2 },\n    ///     Token::Char('a'),\n    ///     Token::I32(100),\n    ///     Token::TupleEnd,\n    /// ]);\n    /// ```\n    Tuple { len: usize },\n\n    /// An indicator of the end of a tuple.\n    TupleEnd,\n\n    /// The header to a tuple struct.\n    ///\n    /// After this header are the fields of the tuple struct, followed by\n    /// `TupleStructEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// struct T(u8, u8);\n    ///\n    /// let t = T(0, 0);\n    /// assert_tokens(&t, &[\n    ///     Token::TupleStruct { name: \"T\", len: 2 },\n    ///     Token::U8(0),\n    ///     Token::U8(0),\n    ///     Token::TupleStructEnd,\n    /// ]);\n    /// # }\n    /// ```\n    TupleStruct { name: &'static str, len: usize },\n\n    /// An indicator of the end of a tuple struct.\n    TupleStructEnd,\n\n    /// The header to a tuple variant of an enum.\n    ///\n    /// After this header are the fields of the tuple variant, followed by\n    /// `TupleVariantEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     C(u8, u8),\n    /// }\n    ///\n    /// let c = E::C(0, 0);\n    /// assert_tokens(&c, &[\n    ///     Token::TupleVariant { name: \"E\", variant: \"C\", len: 2 },\n    ///     Token::U8(0),\n    ///     Token::U8(0),\n    ///     Token::TupleVariantEnd,\n    /// ]);\n    /// # }\n    /// ```\n    TupleVariant {\n        name: &'static str,\n        variant: &'static str,\n        len: usize,\n    },\n\n    /// An indicator of the end of a tuple variant.\n    TupleVariantEnd,\n\n    /// The header to a map.\n    ///\n    /// After this header are the entries of the map, followed by `MapEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert('A', 65);\n    /// map.insert('Z', 90);\n    ///\n    /// assert_tokens(&map, &[\n    ///     Token::Map { len: Some(2) },\n    ///     Token::Char('A'),\n    ///     Token::I32(65),\n    ///     Token::Char('Z'),\n    ///     Token::I32(90),\n    ///     Token::MapEnd,\n    /// ]);\n    /// ```\n    Map { len: Option<usize> },\n\n    /// An indicator of the end of a map.\n    MapEnd,\n\n    /// The header of a struct.\n    ///\n    /// After this header are the fields of the struct, followed by `StructEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// struct S {\n    ///     a: u8,\n    ///     b: u8,\n    /// }\n    ///\n    /// let s = S { a: 0, b: 0 };\n    /// assert_tokens(&s, &[\n    ///     Token::Struct { name: \"S\", len: 2 },\n    ///     Token::Str(\"a\"),\n    ///     Token::U8(0),\n    ///     Token::Str(\"b\"),\n    ///     Token::U8(0),\n    ///     Token::StructEnd,\n    /// ]);\n    /// # }\n    /// ```\n    Struct { name: &'static str, len: usize },\n\n    /// An indicator of the end of a struct.\n    StructEnd,\n\n    /// The header of a struct variant of an enum.\n    ///\n    /// After this header are the fields of the struct variant, followed by\n    /// `StructVariantEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     D { d: u8 },\n    /// }\n    ///\n    /// let d = E::D { d: 0 };\n    /// assert_tokens(&d, &[\n    ///     Token::StructVariant { name: \"E\", variant: \"D\", len: 1 },\n    ///     Token::Str(\"d\"),\n    ///     Token::U8(0),\n    ///     Token::StructVariantEnd,\n    /// ]);\n    /// # }\n    /// ```\n    StructVariant {\n        name: &'static str,\n        variant: &'static str,\n        len: usize,\n    },\n\n    /// An indicator of the end of a struct variant.\n    StructVariantEnd,\n\n    /// The header to an enum of the given name.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     A,\n    ///     B(u8),\n    ///     C(u8, u8),\n    ///     D { d: u8 },\n    /// }\n    ///\n    /// let a = E::A;\n    /// assert_tokens(&a, &[\n    ///     Token::Enum { name: \"E\" },\n    ///     Token::Str(\"A\"),\n    ///     Token::Unit,\n    /// ]);\n    ///\n    /// let b = E::B(0);\n    /// assert_tokens(&b, &[\n    ///     Token::Enum { name: \"E\" },\n    ///     Token::Str(\"B\"),\n    ///     Token::U8(0),\n    /// ]);\n    ///\n    /// let c = E::C(0, 0);\n    /// assert_tokens(&c, &[\n    ///     Token::Enum { name: \"E\" },\n    ///     Token::Str(\"C\"),\n    ///     Token::Seq { len: Some(2) },\n    ///     Token::U8(0),\n    ///     Token::U8(0),\n    ///     Token::SeqEnd,\n    /// ]);\n    ///\n    /// let d = E::D { d: 0 };\n    /// assert_tokens(&d, &[\n    ///     Token::Enum { name: \"E\" },\n    ///     Token::Str(\"D\"),\n    ///     Token::Map { len: Some(1) },\n    ///     Token::Str(\"d\"),\n    ///     Token::U8(0),\n    ///     Token::MapEnd,\n    /// ]);\n    /// # }\n    /// ```\n    Enum { name: &'static str },\n}\n\nimpl Display for Token {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        Debug::fmt(self, formatter)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","no_std","src","main.rs"],"content":"#![feature(lang_items, start)]\n#![no_std]\n\n#[start]\nfn start(_argc: isize, _argv: *const *const u8) -> isize {\n    0\n}\n\n#[lang = \"eh_personality\"]\n#[no_mangle]\npub extern \"C\" fn rust_eh_personality() {}\n\n#[panic_handler]\nfn panic(_info: &core::panic::PanicInfo) -> ! {\n    unsafe {\n        libc::abort();\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize)]\nstruct Unit;\n\n#[derive(Serialize, Deserialize)]\nstruct Newtype(u8);\n\n#[derive(Serialize, Deserialize)]\nstruct Tuple(u8, u8);\n\n#[derive(Serialize, Deserialize)]\nstruct Struct {\n    f: u8,\n}\n\n#[derive(Serialize, Deserialize)]\nenum Enum {\n    Unit,\n    Newtype(u8),\n    Tuple(u8, u8),\n    Struct { f: u8 },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","bytes","mod.rs"],"content":"use serde::de::{Deserializer, Error, SeqAccess, Visitor};\nuse std::fmt;\n\npub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<u8>, D::Error>\nwhere\n    D: Deserializer<'de>,\n{\n    deserializer.deserialize_byte_buf(ByteBufVisitor)\n}\n\nstruct ByteBufVisitor;\n\nimpl<'de> Visitor<'de> for ByteBufVisitor {\n    type Value = Vec<u8>;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"byte array\")\n    }\n\n    fn visit_seq<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n    where\n        V: SeqAccess<'de>,\n    {\n        let mut values = Vec::new();\n        while let Some(value) = visitor.next_element()? {\n            values.push(value);\n        }\n        Ok(values)\n    }\n\n    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v.to_vec())\n    }\n\n    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v.as_bytes().to_vec())\n    }\n\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v.into_bytes())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","compiletest.rs"],"content":"#[cfg(not(target_os = \"emscripten\"))]\n#[rustversion::attr(not(nightly), ignore)]\n#[test]\nfn ui() {\n    let t = trybuild::TestCases::new();\n    t.compile_fail(\"tests/ui/**/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","macros","mod.rs"],"content":"macro_rules! btreeset {\n    () => {\n        BTreeSet::new()\n    };\n    ($($value:expr),+) => {\n        {\n            let mut set = BTreeSet::new();\n            $(set.insert($value);)+\n            set\n        }\n    }\n}\n\nmacro_rules! btreemap {\n    () => {\n        BTreeMap::new()\n    };\n    ($($key:expr => $value:expr),+) => {\n        {\n            let mut map = BTreeMap::new();\n            $(map.insert($key, $value);)+\n            map\n        }\n    }\n}\n\nmacro_rules! hashset {\n    () => {\n        HashSet::new()\n    };\n    ($($value:expr),+) => {\n        {\n            let mut set = HashSet::new();\n            $(set.insert($value);)+\n            set\n        }\n    };\n    ($hasher:ident @ $($value:expr),+) => {\n        {\n            use std::hash::BuildHasherDefault;\n            let mut set = HashSet::with_hasher(BuildHasherDefault::<$hasher>::default());\n            $(set.insert($value);)+\n            set\n        }\n    }\n}\n\nmacro_rules! hashmap {\n    () => {\n        HashMap::new()\n    };\n    ($($key:expr => $value:expr),+) => {\n        {\n            let mut map = HashMap::new();\n            $(map.insert($key, $value);)+\n            map\n        }\n    };\n    ($hasher:ident @ $($key:expr => $value:expr),+) => {\n        {\n            use std::hash::BuildHasherDefault;\n            let mut map = HashMap::with_hasher(BuildHasherDefault::<$hasher>::default());\n            $(map.insert($key, $value);)+\n            map\n        }\n    }\n}\n\nmacro_rules! seq_impl {\n    (seq $first:expr,) => {\n        seq_impl!(seq $first)\n    };\n    ($first:expr,) => {\n        seq_impl!($first)\n    };\n    (seq $first:expr) => {\n        $first.into_iter()\n    };\n    ($first:expr) => {\n        Some($first).into_iter()\n    };\n    (seq $first:expr , $( $elem: tt)*) => {\n        $first.into_iter().chain(seq!( $($elem)* ))\n    };\n    ($first:expr , $($elem: tt)*) => {\n        Some($first).into_iter().chain(seq!( $($elem)* ))\n    }\n}\nmacro_rules! seq {\n    ($($tt: tt)*) => {\n        seq_impl!($($tt)*).collect::<Vec<_>>()\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_annotations.rs"],"content":"#![allow(clippy::cast_lossless, clippy::trivially_copy_pass_by_ref)]\n\nuse serde::de::{self, MapAccess, Unexpected, Visitor};\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\nuse std::collections::{BTreeMap, HashMap};\nuse std::convert::TryFrom;\nuse std::fmt;\nuse std::marker::PhantomData;\n\nuse serde_test::{\n    assert_de_tokens, assert_de_tokens_error, assert_ser_tokens, assert_ser_tokens_error,\n    assert_tokens, Token,\n};\n\ntrait MyDefault: Sized {\n    fn my_default() -> Self;\n}\n\ntrait ShouldSkip: Sized {\n    fn should_skip(&self) -> bool;\n}\n\ntrait SerializeWith: Sized {\n    fn serialize_with<S>(&self, ser: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer;\n}\n\ntrait DeserializeWith: Sized {\n    fn deserialize_with<'de, D>(de: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>;\n}\n\nimpl MyDefault for i32 {\n    fn my_default() -> Self {\n        123\n    }\n}\n\nimpl ShouldSkip for i32 {\n    fn should_skip(&self) -> bool {\n        *self == 123\n    }\n}\n\nimpl SerializeWith for i32 {\n    fn serialize_with<S>(&self, ser: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        if *self == 123 {\n            true.serialize(ser)\n        } else {\n            false.serialize(ser)\n        }\n    }\n}\n\nimpl DeserializeWith for i32 {\n    fn deserialize_with<'de, D>(de: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        if Deserialize::deserialize(de)? {\n            Ok(123)\n        } else {\n            Ok(2)\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct DefaultStruct<A, B, C, D, E>\nwhere\n    C: MyDefault,\n    E: MyDefault,\n{\n    a1: A,\n    #[serde(default)]\n    a2: B,\n    #[serde(default = \"MyDefault::my_default\")]\n    a3: C,\n    #[serde(skip_deserializing)]\n    a4: D,\n    #[serde(skip_deserializing, default = \"MyDefault::my_default\")]\n    a5: E,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct DefaultTupleStruct<A, B, C>(\n    A,\n    #[serde(default)] B,\n    #[serde(default = \"MyDefault::my_default\")] C,\n)\nwhere\n    C: MyDefault;\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct CollectOther {\n    a: u32,\n    b: u32,\n    #[serde(flatten)]\n    extra: HashMap<String, u32>,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct FlattenStructEnumWrapper {\n    #[serde(flatten)]\n    data: FlattenStructEnum,\n    #[serde(flatten)]\n    extra: HashMap<String, String>,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\nenum FlattenStructEnum {\n    InsertInteger { index: u32, value: u32 },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct FlattenStructTagContentEnumWrapper {\n    outer: u32,\n    #[serde(flatten)]\n    data: FlattenStructTagContentEnumNewtype,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct FlattenStructTagContentEnumNewtype(pub FlattenStructTagContentEnum);\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\", tag = \"type\", content = \"value\")]\nenum FlattenStructTagContentEnum {\n    InsertInteger { index: u32, value: u32 },\n    NewtypeVariant(FlattenStructTagContentEnumNewtypeVariant),\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct FlattenStructTagContentEnumNewtypeVariant {\n    value: u32,\n}\n\n#[test]\nfn test_default_struct() {\n    assert_de_tokens(\n        &DefaultStruct {\n            a1: 1,\n            a2: 2,\n            a3: 3,\n            a4: 0,\n            a5: 123,\n        },\n        &[\n            Token::Struct {\n                name: \"DefaultStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a2\"),\n            Token::I32(2),\n            Token::Str(\"a3\"),\n            Token::I32(3),\n            Token::Str(\"a4\"),\n            Token::I32(4),\n            Token::Str(\"a5\"),\n            Token::I32(5),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &DefaultStruct {\n            a1: 1,\n            a2: 0,\n            a3: 123,\n            a4: 0,\n            a5: 123,\n        },\n        &[\n            Token::Struct {\n                name: \"DefaultStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_default_tuple() {\n    assert_de_tokens(\n        &DefaultTupleStruct(1, 2, 3),\n        &[\n            Token::TupleStruct {\n                name: \"DefaultTupleStruct\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::I32(2),\n            Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &DefaultTupleStruct(1, 0, 123),\n        &[\n            Token::TupleStruct {\n                name: \"DefaultTupleStruct\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum DefaultStructVariant<A, B, C, D, E>\nwhere\n    C: MyDefault,\n    E: MyDefault,\n{\n    Struct {\n        a1: A,\n        #[serde(default)]\n        a2: B,\n        #[serde(default = \"MyDefault::my_default\")]\n        a3: C,\n        #[serde(skip_deserializing)]\n        a4: D,\n        #[serde(skip_deserializing, default = \"MyDefault::my_default\")]\n        a5: E,\n    },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum DefaultTupleVariant<A, B, C>\nwhere\n    C: MyDefault,\n{\n    Tuple(\n        A,\n        #[serde(default)] B,\n        #[serde(default = \"MyDefault::my_default\")] C,\n    ),\n}\n\n#[test]\nfn test_default_struct_variant() {\n    assert_de_tokens(\n        &DefaultStructVariant::Struct {\n            a1: 1,\n            a2: 2,\n            a3: 3,\n            a4: 0,\n            a5: 123,\n        },\n        &[\n            Token::StructVariant {\n                name: \"DefaultStructVariant\",\n                variant: \"Struct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a2\"),\n            Token::I32(2),\n            Token::Str(\"a3\"),\n            Token::I32(3),\n            Token::Str(\"a4\"),\n            Token::I32(4),\n            Token::Str(\"a5\"),\n            Token::I32(5),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &DefaultStructVariant::Struct {\n            a1: 1,\n            a2: 0,\n            a3: 123,\n            a4: 0,\n            a5: 123,\n        },\n        &[\n            Token::StructVariant {\n                name: \"DefaultStructVariant\",\n                variant: \"Struct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_default_tuple_variant() {\n    assert_de_tokens(\n        &DefaultTupleVariant::Tuple(1, 2, 3),\n        &[\n            Token::TupleVariant {\n                name: \"DefaultTupleVariant\",\n                variant: \"Tuple\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::I32(2),\n            Token::I32(3),\n            Token::TupleVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &DefaultTupleVariant::Tuple(1, 0, 123),\n        &[\n            Token::TupleVariant {\n                name: \"DefaultTupleVariant\",\n                variant: \"Tuple\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n// Does not implement std::default::Default.\n#[derive(Debug, PartialEq, Deserialize)]\nstruct NoStdDefault(i8);\n\nimpl MyDefault for NoStdDefault {\n    fn my_default() -> Self {\n        NoStdDefault(123)\n    }\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct ContainsNoStdDefault<A: MyDefault> {\n    #[serde(default = \"MyDefault::my_default\")]\n    a: A,\n}\n\n// Tests that a struct field does not need to implement std::default::Default if\n// it is annotated with `default=...`.\n#[test]\nfn test_no_std_default() {\n    assert_de_tokens(\n        &ContainsNoStdDefault {\n            a: NoStdDefault(123),\n        },\n        &[\n            Token::Struct {\n                name: \"ContainsNoStdDefault\",\n                len: 1,\n            },\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &ContainsNoStdDefault { a: NoStdDefault(8) },\n        &[\n            Token::Struct {\n                name: \"ContainsNoStdDefault\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::NewtypeStruct {\n                name: \"NoStdDefault\",\n            },\n            Token::I8(8),\n            Token::StructEnd,\n        ],\n    );\n}\n\n// Does not implement Deserialize.\n#[derive(Debug, PartialEq)]\nstruct NotDeserializeStruct(i8);\n\nimpl Default for NotDeserializeStruct {\n    fn default() -> Self {\n        NotDeserializeStruct(123)\n    }\n}\n\nimpl DeserializeWith for NotDeserializeStruct {\n    fn deserialize_with<'de, D>(_: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        panic!()\n    }\n}\n\n// Does not implement Deserialize.\n#[derive(Debug, PartialEq)]\nenum NotDeserializeEnum {\n    Trouble,\n}\n\nimpl MyDefault for NotDeserializeEnum {\n    fn my_default() -> Self {\n        NotDeserializeEnum::Trouble\n    }\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct ContainsNotDeserialize<A, B, C: DeserializeWith, E: MyDefault> {\n    #[serde(skip_deserializing)]\n    a: A,\n    #[serde(skip_deserializing, default)]\n    b: B,\n    #[serde(deserialize_with = \"DeserializeWith::deserialize_with\", default)]\n    c: C,\n    #[serde(skip_deserializing, default = \"MyDefault::my_default\")]\n    e: E,\n}\n\n// Tests that a struct field does not need to implement Deserialize if it is\n// annotated with skip_deserializing, whether using the std Default or a\n// custom default.\n#[test]\nfn test_elt_not_deserialize() {\n    assert_de_tokens(\n        &ContainsNotDeserialize {\n            a: NotDeserializeStruct(123),\n            b: NotDeserializeStruct(123),\n            c: NotDeserializeStruct(123),\n            e: NotDeserializeEnum::Trouble,\n        },\n        &[\n            Token::Struct {\n                name: \"ContainsNotDeserialize\",\n                len: 1,\n            },\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(deny_unknown_fields)]\nstruct DenyUnknown {\n    a1: i32,\n}\n\n#[test]\nfn test_ignore_unknown() {\n    // 'Default' allows unknown. Basic smoke test of ignore...\n    assert_de_tokens(\n        &DefaultStruct {\n            a1: 1,\n            a2: 2,\n            a3: 3,\n            a4: 0,\n            a5: 123,\n        },\n        &[\n            Token::Struct {\n                name: \"DefaultStruct\",\n                len: 3,\n            },\n            Token::Str(\"whoops1\"),\n            Token::I32(2),\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"whoops2\"),\n            Token::Seq { len: Some(1) },\n            Token::I32(2),\n            Token::SeqEnd,\n            Token::Str(\"a2\"),\n            Token::I32(2),\n            Token::Str(\"whoops3\"),\n            Token::I32(2),\n            Token::Str(\"a3\"),\n            Token::I32(3),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens_error::<DenyUnknown>(\n        &[\n            Token::Struct {\n                name: \"DenyUnknown\",\n                len: 1,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"whoops\"),\n        ],\n        \"unknown field `whoops`, expected `a1`\",\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename = \"Superhero\")]\nstruct RenameStruct {\n    a1: i32,\n    #[serde(rename = \"a3\")]\n    a2: i32,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename(serialize = \"SuperheroSer\", deserialize = \"SuperheroDe\"))]\nstruct RenameStructSerializeDeserialize {\n    a1: i32,\n    #[serde(rename(serialize = \"a4\", deserialize = \"a5\"))]\n    a2: i32,\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\n#[serde(deny_unknown_fields)]\nstruct AliasStruct {\n    a1: i32,\n    #[serde(alias = \"a3\")]\n    a2: i32,\n    #[serde(alias = \"a5\", rename = \"a6\")]\n    a4: i32,\n}\n\n#[test]\nfn test_rename_struct() {\n    assert_tokens(\n        &RenameStruct { a1: 1, a2: 2 },\n        &[\n            Token::Struct {\n                name: \"Superhero\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a3\"),\n            Token::I32(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        &RenameStructSerializeDeserialize { a1: 1, a2: 2 },\n        &[\n            Token::Struct {\n                name: \"SuperheroSer\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a4\"),\n            Token::I32(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &RenameStructSerializeDeserialize { a1: 1, a2: 2 },\n        &[\n            Token::Struct {\n                name: \"SuperheroDe\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a5\"),\n            Token::I32(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &AliasStruct {\n            a1: 1,\n            a2: 2,\n            a4: 3,\n        },\n        &[\n            Token::Struct {\n                name: \"AliasStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a2\"),\n            Token::I32(2),\n            Token::Str(\"a5\"),\n            Token::I32(3),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &AliasStruct {\n            a1: 1,\n            a2: 2,\n            a4: 3,\n        },\n        &[\n            Token::Struct {\n                name: \"AliasStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a3\"),\n            Token::I32(2),\n            Token::Str(\"a6\"),\n            Token::I32(3),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_unknown_field_rename_struct() {\n    assert_de_tokens_error::<AliasStruct>(\n        &[\n            Token::Struct {\n                name: \"AliasStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a3\"),\n            Token::I32(2),\n            Token::Str(\"a4\"),\n            Token::I32(3),\n        ],\n        \"unknown field `a4`, expected one of `a1`, `a2`, `a6`\",\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename = \"Superhero\")]\nenum RenameEnum {\n    #[serde(rename = \"bruce_wayne\")]\n    Batman,\n    #[serde(rename = \"clark_kent\")]\n    Superman(i8),\n    #[serde(rename = \"diana_prince\")]\n    WonderWoman(i8, i8),\n    #[serde(rename = \"barry_allan\")]\n    Flash {\n        #[serde(rename = \"b\")]\n        a: i32,\n    },\n}\n\n#[derive(Debug, PartialEq, Deserialize, Serialize)]\n#[serde(rename(serialize = \"SuperheroSer\", deserialize = \"SuperheroDe\"))]\nenum RenameEnumSerializeDeserialize<A> {\n    #[serde(rename(serialize = \"dick_grayson\", deserialize = \"jason_todd\"))]\n    Robin {\n        a: i8,\n        #[serde(rename(serialize = \"c\"))]\n        #[serde(rename(deserialize = \"d\"))]\n        b: A,\n    },\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\n#[serde(deny_unknown_fields)]\nenum AliasEnum {\n    #[serde(rename = \"sailor_moon\", alias = \"usagi_tsukino\")]\n    SailorMoon {\n        a: i8,\n        #[serde(alias = \"c\")]\n        b: i8,\n        #[serde(alias = \"e\", rename = \"f\")]\n        d: i8,\n    },\n}\n\n#[test]\nfn test_rename_enum() {\n    assert_tokens(\n        &RenameEnum::Batman,\n        &[Token::UnitVariant {\n            name: \"Superhero\",\n            variant: \"bruce_wayne\",\n        }],\n    );\n\n    assert_tokens(\n        &RenameEnum::Superman(0),\n        &[\n            Token::NewtypeVariant {\n                name: \"Superhero\",\n                variant: \"clark_kent\",\n            },\n            Token::I8(0),\n        ],\n    );\n\n    assert_tokens(\n        &RenameEnum::WonderWoman(0, 1),\n        &[\n            Token::TupleVariant {\n                name: \"Superhero\",\n                variant: \"diana_prince\",\n                len: 2,\n            },\n            Token::I8(0),\n            Token::I8(1),\n            Token::TupleVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        &RenameEnum::Flash { a: 1 },\n        &[\n            Token::StructVariant {\n                name: \"Superhero\",\n                variant: \"barry_allan\",\n                len: 1,\n            },\n            Token::Str(\"b\"),\n            Token::I32(1),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        &RenameEnumSerializeDeserialize::Robin {\n            a: 0,\n            b: String::new(),\n        },\n        &[\n            Token::StructVariant {\n                name: \"SuperheroSer\",\n                variant: \"dick_grayson\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"c\"),\n            Token::Str(\"\"),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &RenameEnumSerializeDeserialize::Robin {\n            a: 0,\n            b: String::new(),\n        },\n        &[\n            Token::StructVariant {\n                name: \"SuperheroDe\",\n                variant: \"jason_todd\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"d\"),\n            Token::Str(\"\"),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &AliasEnum::SailorMoon { a: 0, b: 1, d: 2 },\n        &[\n            Token::StructVariant {\n                name: \"AliasEnum\",\n                variant: \"sailor_moon\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"b\"),\n            Token::I8(1),\n            Token::Str(\"e\"),\n            Token::I8(2),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &AliasEnum::SailorMoon { a: 0, b: 1, d: 2 },\n        &[\n            Token::StructVariant {\n                name: \"AliasEnum\",\n                variant: \"usagi_tsukino\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"c\"),\n            Token::I8(1),\n            Token::Str(\"f\"),\n            Token::I8(2),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_unknown_field_rename_enum() {\n    assert_de_tokens_error::<AliasEnum>(\n        &[Token::StructVariant {\n            name: \"AliasEnum\",\n            variant: \"SailorMoon\",\n            len: 3,\n        }],\n        \"unknown variant `SailorMoon`, expected `sailor_moon`\",\n    );\n\n    assert_de_tokens_error::<AliasEnum>(\n        &[\n            Token::StructVariant {\n                name: \"AliasEnum\",\n                variant: \"usagi_tsukino\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"c\"),\n            Token::I8(1),\n            Token::Str(\"d\"),\n            Token::I8(2),\n        ],\n        \"unknown field `d`, expected one of `a`, `b`, `f`\",\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SkipSerializingStruct<'a, B, C>\nwhere\n    C: ShouldSkip,\n{\n    a: &'a i8,\n    #[serde(skip_serializing)]\n    b: B,\n    #[serde(skip_serializing_if = \"ShouldSkip::should_skip\")]\n    c: C,\n}\n\n#[test]\nfn test_skip_serializing_struct() {\n    let a = 1;\n    assert_ser_tokens(\n        &SkipSerializingStruct { a: &a, b: 2, c: 3 },\n        &[\n            Token::Struct {\n                name: \"SkipSerializingStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"c\"),\n            Token::I32(3),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        &SkipSerializingStruct {\n            a: &a,\n            b: 2,\n            c: 123,\n        },\n        &[\n            Token::Struct {\n                name: \"SkipSerializingStruct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SkipSerializingTupleStruct<'a, B, C>(\n    &'a i8,\n    #[serde(skip_serializing)] B,\n    #[serde(skip_serializing_if = \"ShouldSkip::should_skip\")] C,\n)\nwhere\n    C: ShouldSkip;\n\n#[test]\nfn test_skip_serializing_tuple_struct() {\n    let a = 1;\n    assert_ser_tokens(\n        &SkipSerializingTupleStruct(&a, 2, 3),\n        &[\n            Token::TupleStruct {\n                name: \"SkipSerializingTupleStruct\",\n                len: 2,\n            },\n            Token::I8(1),\n            Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        &SkipSerializingTupleStruct(&a, 2, 123),\n        &[\n            Token::TupleStruct {\n                name: \"SkipSerializingTupleStruct\",\n                len: 1,\n            },\n            Token::I8(1),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct SkipStruct<B> {\n    a: i8,\n    #[serde(skip)]\n    b: B,\n}\n\n#[test]\nfn test_skip_struct() {\n    assert_ser_tokens(\n        &SkipStruct { a: 1, b: 2 },\n        &[\n            Token::Struct {\n                name: \"SkipStruct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &SkipStruct { a: 1, b: 0 },\n        &[\n            Token::Struct {\n                name: \"SkipStruct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nenum SkipSerializingEnum<'a, B, C>\nwhere\n    C: ShouldSkip,\n{\n    Struct {\n        a: &'a i8,\n        #[serde(skip_serializing)]\n        _b: B,\n        #[serde(skip_serializing_if = \"ShouldSkip::should_skip\")]\n        c: C,\n    },\n    Tuple(\n        &'a i8,\n        #[serde(skip_serializing)] B,\n        #[serde(skip_serializing_if = \"ShouldSkip::should_skip\")] C,\n    ),\n}\n\n#[test]\nfn test_skip_serializing_enum() {\n    let a = 1;\n    assert_ser_tokens(\n        &SkipSerializingEnum::Struct { a: &a, _b: 2, c: 3 },\n        &[\n            Token::StructVariant {\n                name: \"SkipSerializingEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"c\"),\n            Token::I32(3),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        &SkipSerializingEnum::Struct {\n            a: &a,\n            _b: 2,\n            c: 123,\n        },\n        &[\n            Token::StructVariant {\n                name: \"SkipSerializingEnum\",\n                variant: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        &SkipSerializingEnum::Tuple(&a, 2, 3),\n        &[\n            Token::TupleVariant {\n                name: \"SkipSerializingEnum\",\n                variant: \"Tuple\",\n                len: 2,\n            },\n            Token::I8(1),\n            Token::I32(3),\n            Token::TupleVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        &SkipSerializingEnum::Tuple(&a, 2, 123),\n        &[\n            Token::TupleVariant {\n                name: \"SkipSerializingEnum\",\n                variant: \"Tuple\",\n                len: 1,\n            },\n            Token::I8(1),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq)]\nstruct NotSerializeStruct(i8);\n\n#[derive(Debug, PartialEq)]\nenum NotSerializeEnum {\n    Trouble,\n}\n\nimpl SerializeWith for NotSerializeEnum {\n    fn serialize_with<S>(&self, ser: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        \"trouble\".serialize(ser)\n    }\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct ContainsNotSerialize<'a, B, C, D>\nwhere\n    B: 'a,\n    D: SerializeWith,\n{\n    a: &'a Option<i8>,\n    #[serde(skip_serializing)]\n    b: &'a B,\n    #[serde(skip_serializing)]\n    c: Option<C>,\n    #[serde(serialize_with = \"SerializeWith::serialize_with\")]\n    d: D,\n}\n\n#[test]\nfn test_elt_not_serialize() {\n    let a = 1;\n    assert_ser_tokens(\n        &ContainsNotSerialize {\n            a: &Some(a),\n            b: &NotSerializeStruct(2),\n            c: Some(NotSerializeEnum::Trouble),\n            d: NotSerializeEnum::Trouble,\n        },\n        &[\n            Token::Struct {\n                name: \"ContainsNotSerialize\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::Some,\n            Token::I8(1),\n            Token::Str(\"d\"),\n            Token::Str(\"trouble\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SerializeWithStruct<'a, B>\nwhere\n    B: SerializeWith,\n{\n    a: &'a i8,\n    #[serde(serialize_with = \"SerializeWith::serialize_with\")]\n    b: B,\n}\n\n#[test]\nfn test_serialize_with_struct() {\n    let a = 1;\n    assert_ser_tokens(\n        &SerializeWithStruct { a: &a, b: 2 },\n        &[\n            Token::Struct {\n                name: \"SerializeWithStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(false),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        &SerializeWithStruct { a: &a, b: 123 },\n        &[\n            Token::Struct {\n                name: \"SerializeWithStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nenum SerializeWithEnum<'a, B>\nwhere\n    B: SerializeWith,\n{\n    Struct {\n        a: &'a i8,\n        #[serde(serialize_with = \"SerializeWith::serialize_with\")]\n        b: B,\n    },\n}\n\n#[test]\nfn test_serialize_with_enum() {\n    let a = 1;\n    assert_ser_tokens(\n        &SerializeWithEnum::Struct { a: &a, b: 2 },\n        &[\n            Token::StructVariant {\n                name: \"SerializeWithEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(false),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        &SerializeWithEnum::Struct { a: &a, b: 123 },\n        &[\n            Token::StructVariant {\n                name: \"SerializeWithEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum WithVariant {\n    #[serde(serialize_with = \"serialize_unit_variant_as_i8\")]\n    #[serde(deserialize_with = \"deserialize_i8_as_unit_variant\")]\n    Unit,\n\n    #[serde(serialize_with = \"SerializeWith::serialize_with\")]\n    #[serde(deserialize_with = \"DeserializeWith::deserialize_with\")]\n    Newtype(i32),\n\n    #[serde(serialize_with = \"serialize_variant_as_string\")]\n    #[serde(deserialize_with = \"deserialize_string_as_variant\")]\n    Tuple(String, u8),\n\n    #[serde(serialize_with = \"serialize_variant_as_string\")]\n    #[serde(deserialize_with = \"deserialize_string_as_variant\")]\n    Struct { f1: String, f2: u8 },\n}\n\nfn serialize_unit_variant_as_i8<S>(serializer: S) -> Result<S::Ok, S::Error>\nwhere\n    S: Serializer,\n{\n    serializer.serialize_i8(0)\n}\n\nfn deserialize_i8_as_unit_variant<'de, D>(deserializer: D) -> Result<(), D::Error>\nwhere\n    D: Deserializer<'de>,\n{\n    let n = i8::deserialize(deserializer)?;\n    match n {\n        0 => Ok(()),\n        _ => Err(de::Error::invalid_value(Unexpected::Signed(n as i64), &\"0\")),\n    }\n}\n\nfn serialize_variant_as_string<S>(f1: &str, f2: &u8, serializer: S) -> Result<S::Ok, S::Error>\nwhere\n    S: Serializer,\n{\n    serializer.serialize_str(format!(\"{};{:?}\", f1, f2).as_str())\n}\n\nfn deserialize_string_as_variant<'de, D>(deserializer: D) -> Result<(String, u8), D::Error>\nwhere\n    D: Deserializer<'de>,\n{\n    let s = String::deserialize(deserializer)?;\n    let mut pieces = s.split(';');\n    let f1 = match pieces.next() {\n        Some(x) => x,\n        None => return Err(de::Error::invalid_length(0, &\"2\")),\n    };\n    let f2 = match pieces.next() {\n        Some(x) => x,\n        None => return Err(de::Error::invalid_length(1, &\"2\")),\n    };\n    let f2 = match f2.parse() {\n        Ok(n) => n,\n        Err(_) => {\n            return Err(de::Error::invalid_value(\n                Unexpected::Str(f2),\n                &\"an 8-bit signed integer\",\n            ));\n        }\n    };\n    Ok((f1.into(), f2))\n}\n\n#[test]\nfn test_serialize_with_variant() {\n    assert_ser_tokens(\n        &WithVariant::Unit,\n        &[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Unit\",\n            },\n            Token::I8(0),\n        ],\n    );\n\n    assert_ser_tokens(\n        &WithVariant::Newtype(123),\n        &[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Newtype\",\n            },\n            Token::Bool(true),\n        ],\n    );\n\n    assert_ser_tokens(\n        &WithVariant::Tuple(\"hello\".into(), 0),\n        &[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Tuple\",\n            },\n            Token::Str(\"hello;0\"),\n        ],\n    );\n\n    assert_ser_tokens(\n        &WithVariant::Struct {\n            f1: \"world\".into(),\n            f2: 1,\n        },\n        &[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Struct\",\n            },\n            Token::Str(\"world;1\"),\n        ],\n    );\n}\n\n#[test]\nfn test_deserialize_with_variant() {\n    assert_de_tokens(\n        &WithVariant::Unit,\n        &[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Unit\",\n            },\n            Token::I8(0),\n        ],\n    );\n\n    assert_de_tokens(\n        &WithVariant::Newtype(123),\n        &[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Newtype\",\n            },\n            Token::Bool(true),\n        ],\n    );\n\n    assert_de_tokens(\n        &WithVariant::Tuple(\"hello\".into(), 0),\n        &[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Tuple\",\n            },\n            Token::Str(\"hello;0\"),\n        ],\n    );\n\n    assert_de_tokens(\n        &WithVariant::Struct {\n            f1: \"world\".into(),\n            f2: 1,\n        },\n        &[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Struct\",\n            },\n            Token::Str(\"world;1\"),\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct DeserializeWithStruct<B>\nwhere\n    B: DeserializeWith,\n{\n    a: i8,\n    #[serde(deserialize_with = \"DeserializeWith::deserialize_with\")]\n    b: B,\n}\n\n#[test]\nfn test_deserialize_with_struct() {\n    assert_de_tokens(\n        &DeserializeWithStruct { a: 1, b: 2 },\n        &[\n            Token::Struct {\n                name: \"DeserializeWithStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(false),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &DeserializeWithStruct { a: 1, b: 123 },\n        &[\n            Token::Struct {\n                name: \"DeserializeWithStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nenum DeserializeWithEnum<B>\nwhere\n    B: DeserializeWith,\n{\n    Struct {\n        a: i8,\n        #[serde(deserialize_with = \"DeserializeWith::deserialize_with\")]\n        b: B,\n    },\n}\n\n#[test]\nfn test_deserialize_with_enum() {\n    assert_de_tokens(\n        &DeserializeWithEnum::Struct { a: 1, b: 2 },\n        &[\n            Token::StructVariant {\n                name: \"DeserializeWithEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(false),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &DeserializeWithEnum::Struct { a: 1, b: 123 },\n        &[\n            Token::StructVariant {\n                name: \"DeserializeWithEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_missing_renamed_field_struct() {\n    assert_de_tokens_error::<RenameStruct>(\n        &[\n            Token::Struct {\n                name: \"Superhero\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::StructEnd,\n        ],\n        \"missing field `a3`\",\n    );\n\n    assert_de_tokens_error::<RenameStructSerializeDeserialize>(\n        &[\n            Token::Struct {\n                name: \"SuperheroDe\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::StructEnd,\n        ],\n        \"missing field `a5`\",\n    );\n}\n\n#[test]\nfn test_missing_renamed_field_enum() {\n    assert_de_tokens_error::<RenameEnum>(\n        &[\n            Token::StructVariant {\n                name: \"Superhero\",\n                variant: \"barry_allan\",\n                len: 1,\n            },\n            Token::StructVariantEnd,\n        ],\n        \"missing field `b`\",\n    );\n\n    assert_de_tokens_error::<RenameEnumSerializeDeserialize<i8>>(\n        &[\n            Token::StructVariant {\n                name: \"SuperheroDe\",\n                variant: \"jason_todd\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::StructVariantEnd,\n        ],\n        \"missing field `d`\",\n    );\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nenum InvalidLengthEnum {\n    A(i32, i32, i32),\n    B(#[serde(skip_deserializing)] i32, i32, i32),\n}\n\n#[test]\nfn test_invalid_length_enum() {\n    assert_de_tokens_error::<InvalidLengthEnum>(\n        &[\n            Token::TupleVariant {\n                name: \"InvalidLengthEnum\",\n                variant: \"A\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::TupleVariantEnd,\n        ],\n        \"invalid length 1, expected tuple variant InvalidLengthEnum::A with 3 elements\",\n    );\n    assert_de_tokens_error::<InvalidLengthEnum>(\n        &[\n            Token::TupleVariant {\n                name: \"InvalidLengthEnum\",\n                variant: \"B\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::TupleVariantEnd,\n        ],\n        \"invalid length 1, expected tuple variant InvalidLengthEnum::B with 2 elements\",\n    );\n}\n\n#[derive(Clone, Serialize, Deserialize, PartialEq, Debug)]\n#[serde(into = \"EnumToU32\", from = \"EnumToU32\")]\nstruct StructFromEnum(Option<u32>);\n\nimpl Into<EnumToU32> for StructFromEnum {\n    fn into(self) -> EnumToU32 {\n        match self {\n            StructFromEnum(v) => v.into(),\n        }\n    }\n}\n\nimpl From<EnumToU32> for StructFromEnum {\n    fn from(v: EnumToU32) -> Self {\n        StructFromEnum(v.into())\n    }\n}\n\n#[derive(Clone, Serialize, Deserialize, PartialEq, Debug)]\n#[serde(into = \"Option<u32>\", from = \"Option<u32>\")]\nenum EnumToU32 {\n    One,\n    Two,\n    Three,\n    Four,\n    Nothing,\n}\n\nimpl Into<Option<u32>> for EnumToU32 {\n    fn into(self) -> Option<u32> {\n        match self {\n            EnumToU32::One => Some(1),\n            EnumToU32::Two => Some(2),\n            EnumToU32::Three => Some(3),\n            EnumToU32::Four => Some(4),\n            EnumToU32::Nothing => None,\n        }\n    }\n}\n\nimpl From<Option<u32>> for EnumToU32 {\n    fn from(v: Option<u32>) -> Self {\n        match v {\n            Some(1) => EnumToU32::One,\n            Some(2) => EnumToU32::Two,\n            Some(3) => EnumToU32::Three,\n            Some(4) => EnumToU32::Four,\n            _ => EnumToU32::Nothing,\n        }\n    }\n}\n\n#[derive(Clone, Deserialize, PartialEq, Debug)]\n#[serde(try_from = \"u32\")]\nenum TryFromU32 {\n    One,\n    Two,\n}\n\nimpl TryFrom<u32> for TryFromU32 {\n    type Error = String;\n\n    fn try_from(value: u32) -> Result<Self, Self::Error> {\n        match value {\n            1 => Ok(TryFromU32::One),\n            2 => Ok(TryFromU32::Two),\n            _ => Err(\"out of range\".to_owned()),\n        }\n    }\n}\n\n#[test]\nfn test_from_into_traits() {\n    assert_ser_tokens(&EnumToU32::One, &[Token::Some, Token::U32(1)]);\n    assert_ser_tokens(&EnumToU32::Nothing, &[Token::None]);\n    assert_de_tokens(&EnumToU32::Two, &[Token::Some, Token::U32(2)]);\n    assert_ser_tokens(&StructFromEnum(Some(5)), &[Token::None]);\n    assert_ser_tokens(&StructFromEnum(None), &[Token::None]);\n    assert_de_tokens(&StructFromEnum(Some(2)), &[Token::Some, Token::U32(2)]);\n    assert_de_tokens(&TryFromU32::Two, &[Token::U32(2)]);\n    assert_de_tokens_error::<TryFromU32>(&[Token::U32(5)], \"out of range\");\n}\n\n#[test]\nfn test_collect_other() {\n    let mut extra = HashMap::new();\n    extra.insert(\"c\".into(), 3);\n    assert_tokens(\n        &CollectOther { a: 1, b: 2, extra },\n        &[\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::U32(1),\n            Token::Str(\"b\"),\n            Token::U32(2),\n            Token::Str(\"c\"),\n            Token::U32(3),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_struct_enum() {\n    let mut extra = HashMap::new();\n    extra.insert(\"extra_key\".into(), \"extra value\".into());\n    let change_request = FlattenStructEnumWrapper {\n        data: FlattenStructEnum::InsertInteger {\n            index: 0,\n            value: 42,\n        },\n        extra,\n    };\n    assert_de_tokens(\n        &change_request,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"insert_integer\"),\n            Token::Map { len: None },\n            Token::Str(\"index\"),\n            Token::U32(0),\n            Token::Str(\"value\"),\n            Token::U32(42),\n            Token::MapEnd,\n            Token::Str(\"extra_key\"),\n            Token::Str(\"extra value\"),\n            Token::MapEnd,\n        ],\n    );\n    assert_ser_tokens(\n        &change_request,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"insert_integer\"),\n            Token::Struct {\n                len: 2,\n                name: \"insert_integer\",\n            },\n            Token::Str(\"index\"),\n            Token::U32(0),\n            Token::Str(\"value\"),\n            Token::U32(42),\n            Token::StructEnd,\n            Token::Str(\"extra_key\"),\n            Token::Str(\"extra value\"),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_struct_tag_content_enum() {\n    let change_request = FlattenStructTagContentEnumWrapper {\n        outer: 42,\n        data: FlattenStructTagContentEnumNewtype(FlattenStructTagContentEnum::InsertInteger {\n            index: 0,\n            value: 42,\n        }),\n    };\n    assert_de_tokens(\n        &change_request,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::U32(42),\n            Token::Str(\"type\"),\n            Token::Str(\"insert_integer\"),\n            Token::Str(\"value\"),\n            Token::Map { len: None },\n            Token::Str(\"index\"),\n            Token::U32(0),\n            Token::Str(\"value\"),\n            Token::U32(42),\n            Token::MapEnd,\n            Token::MapEnd,\n        ],\n    );\n    assert_ser_tokens(\n        &change_request,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::U32(42),\n            Token::Str(\"type\"),\n            Token::Str(\"insert_integer\"),\n            Token::Str(\"value\"),\n            Token::Struct {\n                len: 2,\n                name: \"insert_integer\",\n            },\n            Token::Str(\"index\"),\n            Token::U32(0),\n            Token::Str(\"value\"),\n            Token::U32(42),\n            Token::StructEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_struct_tag_content_enum_newtype() {\n    let change_request = FlattenStructTagContentEnumWrapper {\n        outer: 42,\n        data: FlattenStructTagContentEnumNewtype(FlattenStructTagContentEnum::NewtypeVariant(\n            FlattenStructTagContentEnumNewtypeVariant { value: 23 },\n        )),\n    };\n    assert_de_tokens(\n        &change_request,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::U32(42),\n            Token::Str(\"type\"),\n            Token::Str(\"newtype_variant\"),\n            Token::Str(\"value\"),\n            Token::Map { len: None },\n            Token::Str(\"value\"),\n            Token::U32(23),\n            Token::MapEnd,\n            Token::MapEnd,\n        ],\n    );\n    assert_ser_tokens(\n        &change_request,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::U32(42),\n            Token::Str(\"type\"),\n            Token::Str(\"newtype_variant\"),\n            Token::Str(\"value\"),\n            Token::Struct {\n                len: 1,\n                name: \"FlattenStructTagContentEnumNewtypeVariant\",\n            },\n            Token::Str(\"value\"),\n            Token::U32(23),\n            Token::StructEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_unknown_field_in_flatten() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct Outer {\n        dummy: String,\n        #[serde(flatten)]\n        inner: Inner,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Inner {\n        foo: HashMap<String, u32>,\n    }\n\n    assert_de_tokens_error::<Outer>(\n        &[\n            Token::Struct {\n                name: \"Outer\",\n                len: 1,\n            },\n            Token::Str(\"dummy\"),\n            Token::Str(\"23\"),\n            Token::Str(\"foo\"),\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::U32(1),\n            Token::Str(\"b\"),\n            Token::U32(2),\n            Token::MapEnd,\n            Token::Str(\"bar\"),\n            Token::U32(23),\n            Token::StructEnd,\n        ],\n        \"unknown field `bar`\",\n    );\n}\n\n#[test]\nfn test_complex_flatten() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Outer {\n        y: u32,\n        #[serde(flatten)]\n        first: First,\n        #[serde(flatten)]\n        second: Second,\n        z: u32,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct First {\n        a: u32,\n        b: bool,\n        c: Vec<String>,\n        d: String,\n        e: Option<u64>,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Second {\n        f: u32,\n    }\n\n    assert_de_tokens(\n        &Outer {\n            y: 0,\n            first: First {\n                a: 1,\n                b: true,\n                c: vec![\"a\".into(), \"b\".into()],\n                d: \"c\".into(),\n                e: Some(2),\n            },\n            second: Second { f: 3 },\n            z: 4,\n        },\n        &[\n            Token::Map { len: None },\n            Token::Str(\"y\"),\n            Token::U32(0),\n            Token::Str(\"a\"),\n            Token::U32(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::Str(\"c\"),\n            Token::Seq { len: Some(2) },\n            Token::Str(\"a\"),\n            Token::Str(\"b\"),\n            Token::SeqEnd,\n            Token::Str(\"d\"),\n            Token::Str(\"c\"),\n            Token::Str(\"e\"),\n            Token::U64(2),\n            Token::Str(\"f\"),\n            Token::U32(3),\n            Token::Str(\"z\"),\n            Token::U32(4),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        &Outer {\n            y: 0,\n            first: First {\n                a: 1,\n                b: true,\n                c: vec![\"a\".into(), \"b\".into()],\n                d: \"c\".into(),\n                e: Some(2),\n            },\n            second: Second { f: 3 },\n            z: 4,\n        },\n        &[\n            Token::Map { len: None },\n            Token::Str(\"y\"),\n            Token::U32(0),\n            Token::Str(\"a\"),\n            Token::U32(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::Str(\"c\"),\n            Token::Seq { len: Some(2) },\n            Token::Str(\"a\"),\n            Token::Str(\"b\"),\n            Token::SeqEnd,\n            Token::Str(\"d\"),\n            Token::Str(\"c\"),\n            Token::Str(\"e\"),\n            Token::Some,\n            Token::U64(2),\n            Token::Str(\"f\"),\n            Token::U32(3),\n            Token::Str(\"z\"),\n            Token::U32(4),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_map_twice() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    struct Outer {\n        #[serde(flatten)]\n        first: BTreeMap<String, String>,\n        #[serde(flatten)]\n        between: Inner,\n        #[serde(flatten)]\n        second: BTreeMap<String, String>,\n    }\n\n    #[derive(Debug, PartialEq, Deserialize)]\n    struct Inner {\n        y: String,\n    }\n\n    assert_de_tokens(\n        &Outer {\n            first: {\n                let mut first = BTreeMap::new();\n                first.insert(\"x\".to_owned(), \"X\".to_owned());\n                first.insert(\"y\".to_owned(), \"Y\".to_owned());\n                first\n            },\n            between: Inner { y: \"Y\".to_owned() },\n            second: {\n                let mut second = BTreeMap::new();\n                second.insert(\"x\".to_owned(), \"X\".to_owned());\n                second\n            },\n        },\n        &[\n            Token::Map { len: None },\n            Token::Str(\"x\"),\n            Token::Str(\"X\"),\n            Token::Str(\"y\"),\n            Token::Str(\"Y\"),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_unsupported_type() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Outer {\n        outer: String,\n        #[serde(flatten)]\n        inner: String,\n    }\n\n    assert_ser_tokens_error(\n        &Outer {\n            outer: \"foo\".into(),\n            inner: \"bar\".into(),\n        },\n        &[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::Str(\"foo\"),\n        ],\n        \"can only flatten structs and maps (got a string)\",\n    );\n    assert_de_tokens_error::<Outer>(\n        &[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::Str(\"foo\"),\n            Token::Str(\"a\"),\n            Token::Str(\"b\"),\n            Token::MapEnd,\n        ],\n        \"can only flatten structs and maps\",\n    );\n}\n\n#[test]\nfn test_non_string_keys() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct TestStruct {\n        name: String,\n        age: u32,\n        #[serde(flatten)]\n        mapping: HashMap<u32, u32>,\n    }\n\n    let mut mapping = HashMap::new();\n    mapping.insert(0, 42);\n    assert_tokens(\n        &TestStruct {\n            name: \"peter\".into(),\n            age: 3,\n            mapping,\n        },\n        &[\n            Token::Map { len: None },\n            Token::Str(\"name\"),\n            Token::Str(\"peter\"),\n            Token::Str(\"age\"),\n            Token::U32(3),\n            Token::U32(0),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_lifetime_propagation_for_flatten() {\n    #[derive(Deserialize, Serialize, Debug, PartialEq)]\n    struct A<T> {\n        #[serde(flatten)]\n        t: T,\n    }\n\n    #[derive(Deserialize, Serialize, Debug, PartialEq)]\n    struct B<'a> {\n        #[serde(flatten, borrow)]\n        t: HashMap<&'a str, u32>,\n    }\n\n    #[derive(Deserialize, Serialize, Debug, PartialEq)]\n    struct C<'a> {\n        #[serde(flatten, borrow)]\n        t: HashMap<&'a [u8], u32>,\n    }\n\n    let mut owned_map = HashMap::new();\n    owned_map.insert(\"x\".to_string(), 42u32);\n    assert_tokens(\n        &A { t: owned_map },\n        &[\n            Token::Map { len: None },\n            Token::Str(\"x\"),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n\n    let mut borrowed_map = HashMap::new();\n    borrowed_map.insert(\"x\", 42u32);\n    assert_ser_tokens(\n        &B {\n            t: borrowed_map.clone(),\n        },\n        &[\n            Token::Map { len: None },\n            Token::BorrowedStr(\"x\"),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &B { t: borrowed_map },\n        &[\n            Token::Map { len: None },\n            Token::BorrowedStr(\"x\"),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n\n    let mut borrowed_map = HashMap::new();\n    borrowed_map.insert(&b\"x\"[..], 42u32);\n    assert_ser_tokens(\n        &C {\n            t: borrowed_map.clone(),\n        },\n        &[\n            Token::Map { len: None },\n            Token::Seq { len: Some(1) },\n            Token::U8(120),\n            Token::SeqEnd,\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &C { t: borrowed_map },\n        &[\n            Token::Map { len: None },\n            Token::BorrowedBytes(b\"x\"),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_enum_newtype() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct S {\n        #[serde(flatten)]\n        flat: E,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    enum E {\n        Q(HashMap<String, String>),\n    }\n\n    let e = E::Q({\n        let mut map = HashMap::new();\n        map.insert(\"k\".to_owned(), \"v\".to_owned());\n        map\n    });\n    let s = S { flat: e };\n\n    assert_tokens(\n        &s,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"Q\"),\n            Token::Map { len: Some(1) },\n            Token::Str(\"k\"),\n            Token::Str(\"v\"),\n            Token::MapEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_internally_tagged() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct S {\n        #[serde(flatten)]\n        x: X,\n        #[serde(flatten)]\n        y: Y,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"typeX\")]\n    enum X {\n        A { a: i32 },\n        B { b: i32 },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"typeY\")]\n    enum Y {\n        C { c: i32 },\n        D { d: i32 },\n    }\n\n    let s = S {\n        x: X::B { b: 1 },\n        y: Y::D { d: 2 },\n    };\n\n    assert_tokens(\n        &s,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"typeX\"),\n            Token::Str(\"B\"),\n            Token::Str(\"b\"),\n            Token::I32(1),\n            Token::Str(\"typeY\"),\n            Token::Str(\"D\"),\n            Token::Str(\"d\"),\n            Token::I32(2),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_externally_tagged_enum_containing_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        &data,\n        &[\n            Token::NewtypeVariant {\n                name: \"Data\",\n                variant: \"A\",\n            },\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_enum_containing_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"t\")]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        &data,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"t\"),\n            Token::Str(\"A\"),\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_adjacently_tagged_enum_containing_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        &data,\n        &[\n            Token::Struct {\n                name: \"Data\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"A\"),\n            Token::Str(\"c\"),\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_enum_containing_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(untagged)]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        &data,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_untagged_enum() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Outer {\n        #[serde(flatten)]\n        inner: Inner,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(untagged)]\n    enum Inner {\n        Variant { a: i32 },\n    }\n\n    let data = Outer {\n        inner: Inner::Variant { a: 0 },\n    };\n\n    assert_tokens(\n        &data,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_option() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Outer {\n        #[serde(flatten)]\n        inner1: Option<Inner1>,\n        #[serde(flatten)]\n        inner2: Option<Inner2>,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Inner1 {\n        inner1: i32,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Inner2 {\n        inner2: i32,\n    }\n\n    assert_tokens(\n        &Outer {\n            inner1: Some(Inner1 { inner1: 1 }),\n            inner2: Some(Inner2 { inner2: 2 }),\n        },\n        &[\n            Token::Map { len: None },\n            Token::Str(\"inner1\"),\n            Token::I32(1),\n            Token::Str(\"inner2\"),\n            Token::I32(2),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        &Outer {\n            inner1: Some(Inner1 { inner1: 1 }),\n            inner2: None,\n        },\n        &[\n            Token::Map { len: None },\n            Token::Str(\"inner1\"),\n            Token::I32(1),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        &Outer {\n            inner1: None,\n            inner2: Some(Inner2 { inner2: 2 }),\n        },\n        &[\n            Token::Map { len: None },\n            Token::Str(\"inner2\"),\n            Token::I32(2),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        &Outer {\n            inner1: None,\n            inner2: None,\n        },\n        &[Token::Map { len: None }, Token::MapEnd],\n    );\n}\n\n#[test]\nfn test_transparent_struct() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(transparent)]\n    struct Transparent {\n        #[serde(skip)]\n        a: bool,\n        b: u32,\n        #[serde(skip)]\n        c: bool,\n        d: PhantomData<()>,\n    }\n\n    assert_tokens(\n        &Transparent {\n            a: false,\n            b: 1,\n            c: false,\n            d: PhantomData,\n        },\n        &[Token::U32(1)],\n    );\n}\n\n#[test]\nfn test_transparent_tuple_struct() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(transparent)]\n    struct Transparent(\n        #[serde(skip)] bool,\n        u32,\n        #[serde(skip)] bool,\n        PhantomData<()>,\n    );\n\n    assert_tokens(&Transparent(false, 1, false, PhantomData), &[Token::U32(1)]);\n}\n\n#[test]\nfn test_internally_tagged_unit_enum_with_unknown_fields() {\n    #[derive(Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"t\")]\n    enum Data {\n        A,\n    }\n\n    let data = Data::A;\n\n    assert_de_tokens(\n        &data,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"t\"),\n            Token::Str(\"A\"),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flattened_internally_tagged_unit_enum_with_unknown_fields() {\n    #[derive(Deserialize, PartialEq, Debug)]\n    struct S {\n        #[serde(flatten)]\n        x: X,\n        #[serde(flatten)]\n        y: Y,\n    }\n\n    #[derive(Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"typeX\")]\n    enum X {\n        A,\n    }\n\n    #[derive(Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"typeY\")]\n    enum Y {\n        B { c: u32 },\n    }\n\n    let s = S {\n        x: X::A,\n        y: Y::B { c: 0 },\n    };\n\n    assert_de_tokens(\n        &s,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"typeX\"),\n            Token::Str(\"A\"),\n            Token::Str(\"typeY\"),\n            Token::Str(\"B\"),\n            Token::Str(\"c\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_any_after_flatten_struct() {\n    #[derive(PartialEq, Debug)]\n    struct Any;\n\n    impl<'de> Deserialize<'de> for Any {\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            struct AnyVisitor;\n\n            impl<'de> Visitor<'de> for AnyVisitor {\n                type Value = Any;\n\n                fn expecting(&self, _formatter: &mut fmt::Formatter) -> fmt::Result {\n                    unimplemented!()\n                }\n\n                fn visit_map<M>(self, mut map: M) -> Result<Self::Value, M::Error>\n                where\n                    M: MapAccess<'de>,\n                {\n                    while let Some((Any, Any)) = map.next_entry()? {}\n                    Ok(Any)\n                }\n            }\n\n            deserializer.deserialize_any(AnyVisitor)\n        }\n    }\n\n    #[derive(Deserialize, PartialEq, Debug)]\n    struct Outer {\n        #[serde(flatten)]\n        inner: Inner,\n        #[serde(flatten)]\n        extra: Any,\n    }\n\n    #[derive(Deserialize, PartialEq, Debug)]\n    struct Inner {\n        inner: i32,\n    }\n\n    let s = Outer {\n        inner: Inner { inner: 0 },\n        extra: Any,\n    };\n\n    assert_de_tokens(\n        &s,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"inner\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_borrow.rs"],"content":"use serde::{Deserialize, Deserializer};\nuse serde_test::{assert_de_tokens, assert_de_tokens_error, Token};\n\nuse std::borrow::Cow;\n\n#[test]\nfn test_borrowed_str() {\n    assert_de_tokens(&\"borrowed\", &[Token::BorrowedStr(\"borrowed\")]);\n}\n\n#[test]\nfn test_borrowed_str_from_string() {\n    assert_de_tokens_error::<&str>(\n        &[Token::String(\"borrowed\")],\n        \"invalid type: string \\\"borrowed\\\", expected a borrowed string\",\n    );\n}\n\n#[test]\nfn test_borrowed_str_from_str() {\n    assert_de_tokens_error::<&str>(\n        &[Token::Str(\"borrowed\")],\n        \"invalid type: string \\\"borrowed\\\", expected a borrowed string\",\n    );\n}\n\n#[test]\nfn test_string_from_borrowed_str() {\n    assert_de_tokens(&\"owned\".to_owned(), &[Token::BorrowedStr(\"owned\")]);\n}\n\n#[test]\nfn test_borrowed_bytes() {\n    assert_de_tokens(&&b\"borrowed\"[..], &[Token::BorrowedBytes(b\"borrowed\")]);\n}\n\n#[test]\nfn test_borrowed_bytes_from_bytebuf() {\n    assert_de_tokens_error::<&[u8]>(\n        &[Token::ByteBuf(b\"borrowed\")],\n        \"invalid type: byte array, expected a borrowed byte array\",\n    );\n}\n\n#[test]\nfn test_borrowed_bytes_from_bytes() {\n    assert_de_tokens_error::<&[u8]>(\n        &[Token::Bytes(b\"borrowed\")],\n        \"invalid type: byte array, expected a borrowed byte array\",\n    );\n}\n\n#[test]\nfn test_tuple() {\n    assert_de_tokens(\n        &(\"str\", &b\"bytes\"[..]),\n        &[\n            Token::Tuple { len: 2 },\n            Token::BorrowedStr(\"str\"),\n            Token::BorrowedBytes(b\"bytes\"),\n            Token::TupleEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_struct() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    struct Borrowing<'a, 'b> {\n        bs: &'a str,\n        bb: &'b [u8],\n    }\n\n    assert_de_tokens(\n        &Borrowing {\n            bs: \"str\",\n            bb: b\"bytes\",\n        },\n        &[\n            Token::Struct {\n                name: \"Borrowing\",\n                len: 2,\n            },\n            Token::BorrowedStr(\"bs\"),\n            Token::BorrowedStr(\"str\"),\n            Token::BorrowedStr(\"bb\"),\n            Token::BorrowedBytes(b\"bytes\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_cow() {\n    #[derive(Deserialize)]\n    struct Cows<'a, 'b> {\n        copied: Cow<'a, str>,\n\n        #[serde(borrow)]\n        borrowed: Cow<'b, str>,\n    }\n\n    let tokens = &[\n        Token::Struct {\n            name: \"Cows\",\n            len: 2,\n        },\n        Token::Str(\"copied\"),\n        Token::BorrowedStr(\"copied\"),\n        Token::Str(\"borrowed\"),\n        Token::BorrowedStr(\"borrowed\"),\n        Token::StructEnd,\n    ];\n\n    let mut de = serde_test::Deserializer::new(tokens);\n    let cows = Cows::deserialize(&mut de).unwrap();\n\n    match cows.copied {\n        Cow::Owned(ref s) if s == \"copied\" => {}\n        _ => panic!(\"expected a copied string\"),\n    }\n\n    match cows.borrowed {\n        Cow::Borrowed(\"borrowed\") => {}\n        _ => panic!(\"expected a borrowed string\"),\n    }\n}\n\n#[test]\nfn test_lifetimes() {\n    #[derive(Deserialize)]\n    struct Cows<'a, 'b> {\n        _copied: Cow<'a, str>,\n\n        #[serde(borrow)]\n        _borrowed: Cow<'b, str>,\n    }\n\n    // Tests that `'de: 'a` is not required by the Deserialize impl.\n    fn _cows_lifetimes<'de: 'b, 'a, 'b, D>(deserializer: D) -> Cows<'a, 'b>\n    where\n        D: Deserializer<'de>,\n    {\n        Deserialize::deserialize(deserializer).unwrap()\n    }\n\n    #[derive(Deserialize)]\n    struct Wrap<'a, 'b> {\n        #[serde(borrow = \"'b\")]\n        _cows: Cows<'a, 'b>,\n    }\n\n    // Tests that `'de: 'a` is not required by the Deserialize impl.\n    fn _wrap_lifetimes<'de: 'b, 'a, 'b, D>(deserializer: D) -> Wrap<'a, 'b>\n    where\n        D: Deserializer<'de>,\n    {\n        Deserialize::deserialize(deserializer).unwrap()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_de.rs"],"content":"#![allow(clippy::decimal_literal_representation, clippy::unreadable_literal)]\n#![cfg_attr(feature = \"unstable\", feature(never_type))]\n\nuse std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\nuse std::default::Default;\nuse std::ffi::{CStr, CString, OsString};\nuse std::fmt::Debug;\nuse std::net;\nuse std::num::Wrapping;\nuse std::ops::Bound;\nuse std::path::{Path, PathBuf};\nuse std::rc::{Rc, Weak as RcWeak};\nuse std::sync::atomic::{\n    AtomicBool, AtomicI16, AtomicI32, AtomicI8, AtomicIsize, AtomicU16, AtomicU32, AtomicU8,\n    AtomicUsize, Ordering,\n};\nuse std::sync::{Arc, Weak as ArcWeak};\nuse std::time::{Duration, UNIX_EPOCH};\n\n#[cfg(target_arch = \"x86_64\")]\nuse std::sync::atomic::{AtomicI64, AtomicU64};\n\nuse fnv::FnvHasher;\nuse serde::de::DeserializeOwned;\nuse serde::{Deserialize, Deserializer};\nuse serde_test::{assert_de_tokens, assert_de_tokens_error, Configure, Token};\n\n#[macro_use]\nmod macros;\n\n//////////////////////////////////////////////////////////////////////////\n\n#[derive(Copy, Clone, PartialEq, Debug, Deserialize)]\nstruct UnitStruct;\n\n#[derive(PartialEq, Debug, Deserialize)]\nstruct NewtypeStruct(i32);\n\n#[derive(PartialEq, Debug, Deserialize)]\nstruct TupleStruct(i32, i32, i32);\n\n#[derive(PartialEq, Debug, Deserialize)]\nstruct Struct {\n    a: i32,\n    b: i32,\n    #[serde(skip_deserializing)]\n    c: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(deny_unknown_fields)]\nstruct StructDenyUnknown {\n    a: i32,\n    #[serde(skip_deserializing)]\n    b: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(default)]\nstruct StructDefault<T> {\n    a: i32,\n    b: T,\n}\n\nimpl Default for StructDefault<String> {\n    fn default() -> Self {\n        StructDefault {\n            a: 100,\n            b: \"default\".to_string(),\n        }\n    }\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\nstruct StructSkipAll {\n    #[serde(skip_deserializing)]\n    a: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(default)]\nstruct StructSkipDefault {\n    #[serde(skip_deserializing)]\n    a: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(default)]\nstruct StructSkipDefaultGeneric<T> {\n    #[serde(skip_deserializing)]\n    t: T,\n}\n\nimpl Default for StructSkipDefault {\n    fn default() -> Self {\n        StructSkipDefault { a: 16 }\n    }\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(deny_unknown_fields)]\nstruct StructSkipAllDenyUnknown {\n    #[serde(skip_deserializing)]\n    a: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\nenum Enum {\n    #[allow(dead_code)]\n    #[serde(skip_deserializing)]\n    Skipped,\n    Unit,\n    Simple(i32),\n    Seq(i32, i32, i32),\n    Map {\n        a: i32,\n        b: i32,\n        c: i32,\n    },\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\nenum EnumSkipAll {\n    #[allow(dead_code)]\n    #[serde(skip_deserializing)]\n    Skipped,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\nenum EnumOther {\n    Unit,\n    #[serde(other)]\n    Other,\n}\n\n#[derive(PartialEq, Debug)]\nstruct IgnoredAny;\n\nimpl<'de> Deserialize<'de> for IgnoredAny {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        serde::de::IgnoredAny::deserialize(deserializer)?;\n        Ok(IgnoredAny)\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nmacro_rules! declare_tests {\n    (\n        $readable:tt\n        $($name:ident { $($value:expr => $tokens:expr,)+ })+\n    ) => {\n        $(\n            #[test]\n            fn $name() {\n                $(\n                    // Test ser/de roundtripping\n                    assert_de_tokens(&$value.$readable(), $tokens);\n\n                    // Test that the tokens are ignorable\n                    assert_de_tokens_ignore($tokens);\n                )+\n            }\n        )+\n    };\n\n    ($(\n        $(#[$cfg:meta])*\n        $name:ident { $($value:expr => $tokens:expr,)+ }\n    )+) => {\n        $(\n            $(#[$cfg])*\n            #[test]\n            fn $name() {\n                $(\n                    // Test ser/de roundtripping\n                    assert_de_tokens(&$value, $tokens);\n\n                    // Test that the tokens are ignorable\n                    assert_de_tokens_ignore($tokens);\n                )+\n            }\n        )+\n    }\n}\n\nmacro_rules! declare_error_tests {\n    ($($name:ident<$target:ty> { $tokens:expr, $expected:expr, })+) => {\n        $(\n            #[test]\n            fn $name() {\n                assert_de_tokens_error::<$target>($tokens, $expected);\n            }\n        )+\n    }\n}\n\n#[derive(Debug)]\nstruct SkipPartialEq<T>(T);\n\nimpl<'de, T> Deserialize<'de> for SkipPartialEq<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(SkipPartialEq)\n    }\n}\n\nimpl<T> PartialEq for SkipPartialEq<T> {\n    fn eq(&self, _other: &Self) -> bool {\n        true\n    }\n}\n\nfn assert_de_tokens_ignore(ignorable_tokens: &[Token]) {\n    #[derive(PartialEq, Debug, Deserialize)]\n    struct IgnoreBase {\n        a: i32,\n    }\n\n    // Embed the tokens to be ignored in the normal token\n    // stream for an IgnoreBase type\n    let concated_tokens: Vec<Token> = vec![\n        Token::Map { len: Some(2) },\n        Token::Str(\"a\"),\n        Token::I32(1),\n        Token::Str(\"ignored\"),\n    ]\n    .into_iter()\n    .chain(ignorable_tokens.to_vec().into_iter())\n    .chain(vec![Token::MapEnd].into_iter())\n    .collect();\n\n    let mut de = serde_test::Deserializer::new(&concated_tokens);\n    let base = IgnoreBase::deserialize(&mut de).unwrap();\n    assert_eq!(base, IgnoreBase { a: 1 });\n}\n\n//////////////////////////////////////////////////////////////////////////\n\ndeclare_tests! {\n    test_bool {\n        true => &[Token::Bool(true)],\n        false => &[Token::Bool(false)],\n    }\n    test_isize {\n        0isize => &[Token::I8(0)],\n        0isize => &[Token::I16(0)],\n        0isize => &[Token::I32(0)],\n        0isize => &[Token::I64(0)],\n        0isize => &[Token::U8(0)],\n        0isize => &[Token::U16(0)],\n        0isize => &[Token::U32(0)],\n        0isize => &[Token::U64(0)],\n    }\n    test_ints {\n        0i8 => &[Token::I8(0)],\n        0i16 => &[Token::I16(0)],\n        0i32 => &[Token::I32(0)],\n        0i64 => &[Token::I64(0)],\n    }\n    test_uints {\n        0u8 => &[Token::U8(0)],\n        0u16 => &[Token::U16(0)],\n        0u32 => &[Token::U32(0)],\n        0u64 => &[Token::U64(0)],\n    }\n    test_floats {\n        0f32 => &[Token::F32(0.)],\n        0f64 => &[Token::F64(0.)],\n    }\n    #[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n    test_small_int_to_128 {\n        1i128 => &[Token::I8(1)],\n        1i128 => &[Token::I16(1)],\n        1i128 => &[Token::I32(1)],\n        1i128 => &[Token::I64(1)],\n\n        1i128 => &[Token::U8(1)],\n        1i128 => &[Token::U16(1)],\n        1i128 => &[Token::U32(1)],\n        1i128 => &[Token::U64(1)],\n\n        1u128 => &[Token::I8(1)],\n        1u128 => &[Token::I16(1)],\n        1u128 => &[Token::I32(1)],\n        1u128 => &[Token::I64(1)],\n\n        1u128 => &[Token::U8(1)],\n        1u128 => &[Token::U16(1)],\n        1u128 => &[Token::U32(1)],\n        1u128 => &[Token::U64(1)],\n    }\n    test_char {\n        'a' => &[Token::Char('a')],\n        'a' => &[Token::Str(\"a\")],\n        'a' => &[Token::String(\"a\")],\n    }\n    test_string {\n        \"abc\".to_owned() => &[Token::Str(\"abc\")],\n        \"abc\".to_owned() => &[Token::String(\"abc\")],\n        \"a\".to_owned() => &[Token::Char('a')],\n    }\n    test_option {\n        None::<i32> => &[Token::Unit],\n        None::<i32> => &[Token::None],\n        Some(1) => &[\n            Token::Some,\n            Token::I32(1),\n        ],\n    }\n    test_result {\n        Ok::<i32, i32>(0) => &[\n            Token::Enum { name: \"Result\" },\n            Token::Str(\"Ok\"),\n            Token::I32(0),\n        ],\n        Err::<i32, i32>(1) => &[\n            Token::Enum { name: \"Result\" },\n            Token::Str(\"Err\"),\n            Token::I32(1),\n        ],\n    }\n    test_unit {\n        () => &[Token::Unit],\n    }\n    test_unit_struct {\n        UnitStruct => &[Token::Unit],\n        UnitStruct => &[\n            Token::UnitStruct { name: \"UnitStruct\" },\n        ],\n    }\n    test_newtype_struct {\n        NewtypeStruct(1) => &[\n            Token::NewtypeStruct { name: \"NewtypeStruct\" },\n            Token::I32(1),\n        ],\n    }\n    test_tuple_struct {\n        TupleStruct(1, 2, 3) => &[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n        TupleStruct(1, 2, 3) => &[\n            Token::Seq { len: None },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n        TupleStruct(1, 2, 3) => &[\n            Token::TupleStruct { name: \"TupleStruct\", len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n        TupleStruct(1, 2, 3) => &[\n            Token::TupleStruct { name: \"TupleStruct\", len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n    }\n    test_btreeset {\n        BTreeSet::<isize>::new() => &[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        btreeset![btreeset![], btreeset![1], btreeset![2, 3]] => &[\n            Token::Seq { len: Some(3) },\n                Token::Seq { len: Some(0) },\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(1) },\n                    Token::I32(1),\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(2) },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::SeqEnd,\n            Token::SeqEnd,\n        ],\n        BTreeSet::<isize>::new() => &[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n    }\n    test_hashset {\n        HashSet::<isize>::new() => &[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        hashset![1, 2, 3] => &[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n        HashSet::<isize>::new() => &[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n        hashset![FnvHasher @ 1, 2, 3] => &[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n    }\n    test_vec {\n        Vec::<isize>::new() => &[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        vec![vec![], vec![1], vec![2, 3]] => &[\n            Token::Seq { len: Some(3) },\n                Token::Seq { len: Some(0) },\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(1) },\n                    Token::I32(1),\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(2) },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::SeqEnd,\n            Token::SeqEnd,\n        ],\n        Vec::<isize>::new() => &[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n    }\n    test_array {\n        [0; 0] => &[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        [0; 0] => &[\n            Token::Tuple { len: 0 },\n            Token::TupleEnd,\n        ],\n        ([0; 0], [1], [2, 3]) => &[\n            Token::Seq { len: Some(3) },\n                Token::Seq { len: Some(0) },\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(1) },\n                    Token::I32(1),\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(2) },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::SeqEnd,\n            Token::SeqEnd,\n        ],\n        ([0; 0], [1], [2, 3]) => &[\n            Token::Tuple { len: 3 },\n                Token::Tuple { len: 0 },\n                Token::TupleEnd,\n\n                Token::Tuple { len: 1 },\n                    Token::I32(1),\n                Token::TupleEnd,\n\n                Token::Tuple { len: 2 },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::TupleEnd,\n            Token::TupleEnd,\n        ],\n        [0; 0] => &[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n    }\n    test_tuple {\n        (1,) => &[\n            Token::Seq { len: Some(1) },\n                Token::I32(1),\n            Token::SeqEnd,\n        ],\n        (1, 2, 3) => &[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n        (1,) => &[\n            Token::Tuple { len: 1 },\n                Token::I32(1),\n            Token::TupleEnd,\n        ],\n        (1, 2, 3) => &[\n            Token::Tuple { len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleEnd,\n        ],\n    }\n    test_btreemap {\n        BTreeMap::<isize, isize>::new() => &[\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n        ],\n        btreemap![1 => 2] => &[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        btreemap![1 => 2, 3 => 4] => &[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::I32(2),\n\n                Token::I32(3),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n        btreemap![1 => btreemap![], 2 => btreemap![3 => 4, 5 => 6]] => &[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::Map { len: Some(0) },\n                Token::MapEnd,\n\n                Token::I32(2),\n                Token::Map { len: Some(2) },\n                    Token::I32(3),\n                    Token::I32(4),\n\n                    Token::I32(5),\n                    Token::I32(6),\n                Token::MapEnd,\n            Token::MapEnd,\n        ],\n        BTreeMap::<isize, isize>::new() => &[\n            Token::Struct { name: \"Anything\", len: 0 },\n            Token::StructEnd,\n        ],\n    }\n    test_hashmap {\n        HashMap::<isize, isize>::new() => &[\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n        ],\n        hashmap![1 => 2] => &[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        hashmap![1 => 2, 3 => 4] => &[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::I32(2),\n\n                Token::I32(3),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n        hashmap![1 => hashmap![], 2 => hashmap![3 => 4, 5 => 6]] => &[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::Map { len: Some(0) },\n                Token::MapEnd,\n\n                Token::I32(2),\n                Token::Map { len: Some(2) },\n                    Token::I32(3),\n                    Token::I32(4),\n\n                    Token::I32(5),\n                    Token::I32(6),\n                Token::MapEnd,\n            Token::MapEnd,\n        ],\n        HashMap::<isize, isize>::new() => &[\n            Token::Struct { name: \"Anything\", len: 0 },\n            Token::StructEnd,\n        ],\n        hashmap![FnvHasher @ 1 => 2, 3 => 4] => &[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::I32(2),\n\n                Token::I32(3),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n    }\n    test_struct {\n        Struct { a: 1, b: 2, c: 0 } => &[\n            Token::Map { len: Some(3) },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        Struct { a: 1, b: 2, c: 0 } => &[\n            Token::Map { len: Some(3) },\n                Token::U32(0),\n                Token::I32(1),\n\n                Token::U32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        Struct { a: 1, b: 2, c: 0 } => &[\n            Token::Struct { name: \"Struct\", len: 2 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n            Token::StructEnd,\n        ],\n        Struct { a: 1, b: 2, c: 0 } => &[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_struct_with_skip {\n        Struct { a: 1, b: 2, c: 0 } => &[\n            Token::Map { len: Some(3) },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n\n                Token::Str(\"c\"),\n                Token::I32(3),\n\n                Token::Str(\"d\"),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n        Struct { a: 1, b: 2, c: 0 } => &[\n            Token::Struct { name: \"Struct\", len: 2 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n\n                Token::Str(\"c\"),\n                Token::I32(3),\n\n                Token::Str(\"d\"),\n                Token::I32(4),\n            Token::StructEnd,\n        ],\n    }\n    test_struct_skip_all {\n        StructSkipAll { a: 0 } => &[\n            Token::Struct { name: \"StructSkipAll\", len: 0 },\n            Token::StructEnd,\n        ],\n        StructSkipAll { a: 0 } => &[\n            Token::Struct { name: \"StructSkipAll\", len: 0 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n            Token::StructEnd,\n        ],\n    }\n    test_struct_skip_default {\n        StructSkipDefault { a: 16 } => &[\n            Token::Struct { name: \"StructSkipDefault\", len: 0 },\n            Token::StructEnd,\n        ],\n    }\n    test_struct_skip_all_deny_unknown {\n        StructSkipAllDenyUnknown { a: 0 } => &[\n            Token::Struct { name: \"StructSkipAllDenyUnknown\", len: 0 },\n            Token::StructEnd,\n        ],\n    }\n    test_struct_default {\n        StructDefault { a: 50, b: \"overwritten\".to_string() } => &[\n            Token::Struct { name: \"StructDefault\", len: 2 },\n                Token::Str(\"a\"),\n                Token::I32(50),\n\n                Token::Str(\"b\"),\n                Token::String(\"overwritten\"),\n            Token::StructEnd,\n        ],\n        StructDefault { a: 100, b: \"default\".to_string() } => &[\n            Token::Struct { name: \"StructDefault\",  len: 2 },\n            Token::StructEnd,\n        ],\n    }\n    test_enum_unit {\n        Enum::Unit => &[\n            Token::UnitVariant { name: \"Enum\", variant: \"Unit\" },\n        ],\n    }\n    test_enum_simple {\n        Enum::Simple(1) => &[\n            Token::NewtypeVariant { name: \"Enum\", variant: \"Simple\" },\n            Token::I32(1),\n        ],\n    }\n    test_enum_seq {\n        Enum::Seq(1, 2, 3) => &[\n            Token::TupleVariant { name: \"Enum\", variant: \"Seq\", len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleVariantEnd,\n        ],\n    }\n    test_enum_map {\n        Enum::Map { a: 1, b: 2, c: 3 } => &[\n            Token::StructVariant { name: \"Enum\", variant: \"Map\", len: 3 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n\n                Token::Str(\"c\"),\n                Token::I32(3),\n            Token::StructVariantEnd,\n        ],\n    }\n    test_enum_unit_usize {\n        Enum::Unit => &[\n            Token::Enum { name: \"Enum\" },\n            Token::U32(0),\n            Token::Unit,\n        ],\n    }\n    test_enum_unit_bytes {\n        Enum::Unit => &[\n            Token::Enum { name: \"Enum\" },\n            Token::Bytes(b\"Unit\"),\n            Token::Unit,\n        ],\n    }\n    test_enum_other_unit {\n        EnumOther::Unit => &[\n            Token::Enum { name: \"EnumOther\" },\n            Token::Str(\"Unit\"),\n            Token::Unit,\n        ],\n    }\n    test_enum_other {\n        EnumOther::Other => &[\n            Token::Enum { name: \"EnumOther\" },\n            Token::Str(\"Foo\"),\n            Token::Unit,\n        ],\n    }\n    test_box {\n        Box::new(0i32) => &[Token::I32(0)],\n    }\n    test_boxed_slice {\n        Box::new([0, 1, 2]) => &[\n            Token::Seq { len: Some(3) },\n            Token::I32(0),\n            Token::I32(1),\n            Token::I32(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_duration {\n        Duration::new(1, 2) => &[\n            Token::Struct { name: \"Duration\", len: 2 },\n                Token::Str(\"secs\"),\n                Token::U64(1),\n\n                Token::Str(\"nanos\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n        Duration::new(1, 2) => &[\n            Token::Seq { len: Some(2) },\n                Token::I64(1),\n                Token::I64(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_system_time {\n        UNIX_EPOCH + Duration::new(1, 2) => &[\n            Token::Struct { name: \"SystemTime\", len: 2 },\n                Token::Str(\"secs_since_epoch\"),\n                Token::U64(1),\n\n                Token::Str(\"nanos_since_epoch\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n        UNIX_EPOCH + Duration::new(1, 2) => &[\n            Token::Seq { len: Some(2) },\n                Token::I64(1),\n                Token::I64(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_range {\n        1u32..2u32 => &[\n            Token::Struct { name: \"Range\", len: 2 },\n                Token::Str(\"start\"),\n                Token::U32(1),\n\n                Token::Str(\"end\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n        1u32..2u32 => &[\n            Token::Seq { len: Some(2) },\n                Token::U64(1),\n                Token::U64(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_range_inclusive {\n        1u32..=2u32 => &[\n            Token::Struct { name: \"RangeInclusive\", len: 2 },\n                Token::Str(\"start\"),\n                Token::U32(1),\n\n                Token::Str(\"end\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n        1u32..=2u32 => &[\n            Token::Seq { len: Some(2) },\n                Token::U64(1),\n                Token::U64(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_bound {\n        Bound::Unbounded::<()> => &[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Unbounded\"),\n            Token::Unit,\n        ],\n        Bound::Included(0) => &[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Included\"),\n            Token::U8(0),\n        ],\n        Bound::Excluded(0) => &[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Excluded\"),\n            Token::U8(0),\n        ],\n    }\n    test_path {\n        Path::new(\"/usr/local/lib\") => &[\n            Token::BorrowedStr(\"/usr/local/lib\"),\n        ],\n    }\n    test_path_buf {\n        PathBuf::from(\"/usr/local/lib\") => &[\n            Token::String(\"/usr/local/lib\"),\n        ],\n    }\n    test_cstring {\n        CString::new(\"abc\").unwrap() => &[\n            Token::Bytes(b\"abc\"),\n        ],\n    }\n    test_rc {\n        Rc::new(true) => &[\n            Token::Bool(true),\n        ],\n    }\n    test_rc_weak_some {\n        SkipPartialEq(RcWeak::<bool>::new()) => &[\n            Token::Some,\n            Token::Bool(true),\n        ],\n    }\n    test_rc_weak_none {\n        SkipPartialEq(RcWeak::<bool>::new()) => &[\n            Token::None,\n        ],\n    }\n    test_arc {\n        Arc::new(true) => &[\n            Token::Bool(true),\n        ],\n    }\n    test_arc_weak_some {\n        SkipPartialEq(ArcWeak::<bool>::new()) => &[\n            Token::Some,\n            Token::Bool(true),\n        ],\n    }\n    test_arc_weak_none {\n        SkipPartialEq(ArcWeak::<bool>::new()) => &[\n            Token::None,\n        ],\n    }\n    test_wrapping {\n        Wrapping(1usize) => &[\n            Token::U32(1),\n        ],\n        Wrapping(1usize) => &[\n            Token::U64(1),\n        ],\n    }\n    test_rc_dst {\n        Rc::<str>::from(\"s\") => &[\n            Token::Str(\"s\"),\n        ],\n        Rc::<[bool]>::from(&[true][..]) => &[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n    }\n    test_arc_dst {\n        Arc::<str>::from(\"s\") => &[\n            Token::Str(\"s\"),\n        ],\n        Arc::<[bool]>::from(&[true][..]) => &[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n    }\n    test_ignored_any {\n        IgnoredAny => &[\n            Token::Str(\"s\"),\n        ],\n        IgnoredAny => &[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n        IgnoredAny => &[\n            Token::Enum { name: \"E\" },\n            Token::Str(\"Rust\"),\n            Token::Unit,\n        ],\n    }\n}\n\ndeclare_tests! {\n    readable\n\n    test_net_ipv4addr_readable {\n        \"1.2.3.4\".parse::<net::Ipv4Addr>().unwrap() => &[Token::Str(\"1.2.3.4\")],\n    }\n    test_net_ipv6addr_readable {\n        \"::1\".parse::<net::Ipv6Addr>().unwrap() => &[Token::Str(\"::1\")],\n    }\n    test_net_ipaddr_readable {\n        \"1.2.3.4\".parse::<net::IpAddr>().unwrap() => &[Token::Str(\"1.2.3.4\")],\n    }\n    test_net_socketaddr_readable {\n        \"1.2.3.4:1234\".parse::<net::SocketAddr>().unwrap() => &[Token::Str(\"1.2.3.4:1234\")],\n        \"1.2.3.4:1234\".parse::<net::SocketAddrV4>().unwrap() => &[Token::Str(\"1.2.3.4:1234\")],\n        \"[::1]:1234\".parse::<net::SocketAddrV6>().unwrap() => &[Token::Str(\"[::1]:1234\")],\n    }\n}\n\ndeclare_tests! {\n    compact\n\n    test_net_ipv4addr_compact {\n        net::Ipv4Addr::from(*b\"1234\") => &seq![\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd\n        ],\n    }\n    test_net_ipv6addr_compact {\n        net::Ipv6Addr::from(*b\"1234567890123456\") => &seq![\n            Token::Tuple { len: 4 },\n            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd\n        ],\n    }\n    test_net_ipaddr_compact {\n        net::IpAddr::from(*b\"1234\") => &seq![\n            Token::NewtypeVariant { name: \"IpAddr\", variant: \"V4\" },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd\n        ],\n    }\n    test_net_socketaddr_compact {\n        net::SocketAddr::from((*b\"1234567890123456\", 1234)) => &seq![\n            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V6\" },\n\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd\n        ],\n        net::SocketAddr::from((*b\"1234\", 1234)) => &seq![\n            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V4\" },\n\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd\n        ],\n        net::SocketAddrV4::new(net::Ipv4Addr::from(*b\"1234\"), 1234) => &seq![\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd\n        ],\n        net::SocketAddrV6::new(net::Ipv6Addr::from(*b\"1234567890123456\"), 1234, 0, 0) => &seq![\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd\n        ],\n    }\n}\n\n#[cfg(feature = \"unstable\")]\ndeclare_tests! {\n    test_never_result {\n        Ok::<u8, !>(0) => &[\n            Token::NewtypeVariant { name: \"Result\", variant: \"Ok\" },\n            Token::U8(0),\n        ],\n    }\n}\n\n#[cfg(unix)]\n#[test]\nfn test_osstring() {\n    use std::os::unix::ffi::OsStringExt;\n\n    let value = OsString::from_vec(vec![1, 2, 3]);\n    let tokens = [\n        Token::Enum { name: \"OsString\" },\n        Token::Str(\"Unix\"),\n        Token::Seq { len: Some(2) },\n        Token::U8(1),\n        Token::U8(2),\n        Token::U8(3),\n        Token::SeqEnd,\n    ];\n\n    assert_de_tokens(&value, &tokens);\n    assert_de_tokens_ignore(&tokens);\n}\n\n#[cfg(windows)]\n#[test]\nfn test_osstring() {\n    use std::os::windows::ffi::OsStringExt;\n\n    let value = OsString::from_wide(&[1, 2, 3]);\n    let tokens = [\n        Token::Enum { name: \"OsString\" },\n        Token::Str(\"Windows\"),\n        Token::Seq { len: Some(2) },\n        Token::U16(1),\n        Token::U16(2),\n        Token::U16(3),\n        Token::SeqEnd,\n    ];\n\n    assert_de_tokens(&value, &tokens);\n    assert_de_tokens_ignore(&tokens);\n}\n\n#[test]\nfn test_cstr() {\n    assert_de_tokens::<Box<CStr>>(\n        &CString::new(\"abc\").unwrap().into_boxed_c_str(),\n        &[Token::Bytes(b\"abc\")],\n    );\n}\n\n#[test]\nfn test_cstr_internal_null() {\n    assert_de_tokens_error::<Box<CStr>>(\n        &[Token::Bytes(b\"a\\0c\")],\n        \"nul byte found in provided data at position: 1\",\n    );\n}\n\n#[test]\nfn test_cstr_internal_null_end() {\n    assert_de_tokens_error::<Box<CStr>>(\n        &[Token::Bytes(b\"ac\\0\")],\n        \"nul byte found in provided data at position: 2\",\n    );\n}\n\n#[cfg(feature = \"unstable\")]\n#[test]\nfn test_never_type() {\n    assert_de_tokens_error::<!>(&[], \"cannot deserialize `!`\");\n\n    assert_de_tokens_error::<Result<u8, !>>(\n        &[Token::NewtypeVariant {\n            name: \"Result\",\n            variant: \"Err\",\n        }],\n        \"cannot deserialize `!`\",\n    );\n}\n\n#[test]\nfn test_atomics() {\n    fn test<L, A, T>(load: L, val: T, token: Token)\n    where\n        L: Fn(&A, Ordering) -> T,\n        A: DeserializeOwned,\n        T: PartialEq + Debug,\n    {\n        let tokens = &[token];\n        let mut de = serde_test::Deserializer::new(tokens);\n        match A::deserialize(&mut de) {\n            Ok(v) => {\n                let loaded = load(&v, Ordering::SeqCst);\n                assert_eq!(val, loaded);\n            }\n            Err(e) => panic!(\"tokens failed to deserialize: {}\", e),\n        };\n        if de.remaining() > 0 {\n            panic!(\"{} remaining tokens\", de.remaining());\n        }\n    }\n\n    test(AtomicBool::load, true, Token::Bool(true));\n    test(AtomicI8::load, -127, Token::I8(-127i8));\n    test(AtomicI16::load, -510, Token::I16(-510i16));\n    test(AtomicI32::load, -131072, Token::I32(-131072i32));\n    test(AtomicIsize::load, -131072isize, Token::I32(-131072));\n    test(AtomicU8::load, 127, Token::U8(127u8));\n    test(AtomicU16::load, 510u16, Token::U16(510u16));\n    test(AtomicU32::load, 131072u32, Token::U32(131072u32));\n    test(AtomicUsize::load, 131072usize, Token::U32(131072));\n\n    #[cfg(target_arch = \"x86_64\")]\n    {\n        test(AtomicI64::load, -8589934592, Token::I64(-8589934592));\n        test(AtomicU64::load, 8589934592u64, Token::U64(8589934592));\n    }\n}\n\ndeclare_error_tests! {\n    test_unknown_field<StructDenyUnknown> {\n        &[\n            Token::Struct { name: \"StructDenyUnknown\", len: 1 },\n                Token::Str(\"a\"),\n                Token::I32(0),\n\n                Token::Str(\"d\"),\n        ],\n        \"unknown field `d`, expected `a`\",\n    }\n    test_skipped_field_is_unknown<StructDenyUnknown> {\n        &[\n            Token::Struct { name: \"StructDenyUnknown\", len: 1 },\n                Token::Str(\"b\"),\n        ],\n        \"unknown field `b`, expected `a`\",\n    }\n    test_skip_all_deny_unknown<StructSkipAllDenyUnknown> {\n        &[\n            Token::Struct { name: \"StructSkipAllDenyUnknown\", len: 0 },\n                Token::Str(\"a\"),\n        ],\n        \"unknown field `a`, there are no fields\",\n    }\n    test_unknown_variant<Enum> {\n        &[\n            Token::UnitVariant { name: \"Enum\", variant: \"Foo\" },\n        ],\n        \"unknown variant `Foo`, expected one of `Unit`, `Simple`, `Seq`, `Map`\",\n    }\n    test_enum_skipped_variant<Enum> {\n        &[\n            Token::UnitVariant { name: \"Enum\", variant: \"Skipped\" },\n        ],\n        \"unknown variant `Skipped`, expected one of `Unit`, `Simple`, `Seq`, `Map`\",\n    }\n    test_enum_skip_all<EnumSkipAll> {\n        &[\n            Token::UnitVariant { name: \"EnumSkipAll\", variant: \"Skipped\" },\n        ],\n        \"unknown variant `Skipped`, there are no variants\",\n    }\n    test_duplicate_field_struct<Struct> {\n        &[\n            Token::Map { len: Some(3) },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"a\"),\n        ],\n        \"duplicate field `a`\",\n    }\n    test_duplicate_field_enum<Enum> {\n        &[\n            Token::StructVariant { name: \"Enum\", variant: \"Map\", len: 3 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"a\"),\n        ],\n        \"duplicate field `a`\",\n    }\n    test_enum_out_of_range<Enum> {\n        &[\n            Token::Enum { name: \"Enum\" },\n            Token::U32(4),\n            Token::Unit,\n        ],\n        \"invalid value: integer `4`, expected variant index 0 <= i < 4\",\n    }\n    test_short_tuple<(u8, u8, u8)> {\n        &[\n            Token::Tuple { len: 1 },\n            Token::U8(1),\n            Token::TupleEnd,\n        ],\n        \"invalid length 1, expected a tuple of size 3\",\n    }\n    test_short_array<[u8; 3]> {\n        &[\n            Token::Seq { len: Some(1) },\n            Token::U8(1),\n            Token::SeqEnd,\n        ],\n        \"invalid length 1, expected an array of length 3\",\n    }\n    test_cstring_internal_null<CString> {\n        &[\n            Token::Bytes(b\"a\\0c\"),\n        ],\n        \"nul byte found in provided data at position: 1\",\n    }\n    test_cstring_internal_null_end<CString> {\n        &[\n            Token::Bytes(b\"ac\\0\"),\n        ],\n        \"nul byte found in provided data at position: 2\",\n    }\n    test_unit_from_empty_seq<()> {\n        &[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected unit\",\n    }\n    test_unit_from_empty_seq_without_len<()> {\n        &[\n            Token::Seq { len: None },\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected unit\",\n    }\n    test_unit_from_tuple_struct<()> {\n        &[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n        \"invalid type: sequence, expected unit\",\n    }\n    test_string_from_unit<String> {\n        &[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a string\",\n    }\n    test_btreeset_from_unit<BTreeSet<isize>> {\n        &[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_btreeset_from_unit_struct<BTreeSet<isize>> {\n        &[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_hashset_from_unit<HashSet<isize>> {\n        &[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_hashset_from_unit_struct<HashSet<isize>> {\n        &[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_vec_from_unit<Vec<isize>> {\n        &[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_vec_from_unit_struct<Vec<isize>> {\n        &[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_zero_array_from_unit<[isize; 0]> {\n        &[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected an empty array\",\n    }\n    test_zero_array_from_unit_struct<[isize; 0]> {\n        &[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected an empty array\",\n    }\n    test_btreemap_from_unit<BTreeMap<isize, isize>> {\n        &[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a map\",\n    }\n    test_btreemap_from_unit_struct<BTreeMap<isize, isize>> {\n        &[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a map\",\n    }\n    test_hashmap_from_unit<HashMap<isize, isize>> {\n        &[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a map\",\n    }\n    test_hashmap_from_unit_struct<HashMap<isize, isize>> {\n        &[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a map\",\n    }\n    test_bool_from_string<bool> {\n        &[\n            Token::Str(\"false\"),\n        ],\n        \"invalid type: string \\\"false\\\", expected a boolean\",\n    }\n    test_number_from_string<isize> {\n        &[\n            Token::Str(\"1\"),\n        ],\n        \"invalid type: string \\\"1\\\", expected isize\",\n    }\n    test_integer_from_float<isize> {\n        &[\n            Token::F32(0.0),\n        ],\n        \"invalid type: floating point `0`, expected isize\",\n    }\n    test_unit_struct_from_seq<UnitStruct> {\n        &[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected unit struct UnitStruct\",\n    }\n    test_wrapping_overflow<Wrapping<u16>> {\n        &[\n            Token::U32(65_536),\n        ],\n        \"invalid value: integer `65536`, expected u16\",\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_gen.rs"],"content":"// These just test that serde_derive is able to produce code that compiles\n// successfully when there are a variety of generics and non-(de)serializable\n// types involved.\n\n#![deny(warnings)]\n#![cfg_attr(feature = \"unstable\", feature(non_ascii_idents))]\n#![allow(clippy::trivially_copy_pass_by_ref)]\n\nuse serde::de::DeserializeOwned;\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\nuse std::borrow::Cow;\nuse std::marker::PhantomData;\nuse std::option::Option as StdOption;\nuse std::result::Result as StdResult;\n\n// Try to trip up the generated code if it fails to use fully qualified paths.\n#[allow(dead_code)]\nstruct Result;\n#[allow(dead_code)]\nstruct Ok;\n#[allow(dead_code)]\nstruct Err;\n#[allow(dead_code)]\nstruct Option;\n#[allow(dead_code)]\nstruct Some;\n#[allow(dead_code)]\nstruct None;\n\n//////////////////////////////////////////////////////////////////////////\n\n#[test]\nfn test_gen() {\n    #[derive(Serialize, Deserialize)]\n    struct With<T> {\n        t: T,\n        #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n        x: X,\n    }\n    assert::<With<i32>>();\n\n    #[derive(Serialize, Deserialize)]\n    struct WithTogether<T> {\n        t: T,\n        #[serde(with = \"both_x\")]\n        x: X,\n    }\n    assert::<WithTogether<i32>>();\n\n    #[derive(Serialize, Deserialize)]\n    struct WithRef<'a, T: 'a> {\n        #[serde(skip_deserializing)]\n        t: StdOption<&'a T>,\n        #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n        x: X,\n    }\n    assert::<WithRef<i32>>();\n\n    #[derive(Serialize, Deserialize)]\n    struct PhantomX {\n        x: PhantomData<X>,\n    }\n    assert::<PhantomX>();\n\n    #[derive(Serialize, Deserialize)]\n    struct PhantomT<T> {\n        t: PhantomData<T>,\n    }\n    assert::<PhantomT<X>>();\n\n    #[derive(Serialize, Deserialize)]\n    struct NoBounds<T> {\n        t: T,\n        option: StdOption<T>,\n        boxed: Box<T>,\n        option_boxed: StdOption<Box<T>>,\n    }\n    assert::<NoBounds<i32>>();\n\n    #[derive(Serialize, Deserialize)]\n    enum EnumWith<T> {\n        Unit,\n        Newtype(#[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")] X),\n        Tuple(\n            T,\n            #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")] X,\n        ),\n        Struct {\n            t: T,\n            #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n            x: X,\n        },\n    }\n    assert::<EnumWith<i32>>();\n\n    #[derive(Serialize)]\n    struct MultipleRef<'a, 'b, 'c, T>\n    where\n        T: 'c,\n        'c: 'b,\n        'b: 'a,\n    {\n        t: T,\n        rrrt: &'a &'b &'c T,\n    }\n    assert_ser::<MultipleRef<i32>>();\n\n    #[derive(Serialize, Deserialize)]\n    struct Newtype(#[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")] X);\n    assert::<Newtype>();\n\n    #[derive(Serialize, Deserialize)]\n    struct Tuple<T>(\n        T,\n        #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")] X,\n    );\n    assert::<Tuple<i32>>();\n\n    #[derive(Serialize, Deserialize)]\n    enum TreeNode<D> {\n        Split {\n            left: Box<TreeNode<D>>,\n            right: Box<TreeNode<D>>,\n        },\n        Leaf {\n            data: D,\n        },\n    }\n    assert::<TreeNode<i32>>();\n\n    #[derive(Serialize, Deserialize)]\n    struct ListNode<D> {\n        data: D,\n        next: Box<ListNode<D>>,\n    }\n    assert::<ListNode<i32>>();\n\n    #[derive(Serialize, Deserialize)]\n    struct RecursiveA {\n        b: Box<RecursiveB>,\n    }\n    assert::<RecursiveA>();\n\n    #[derive(Serialize, Deserialize)]\n    enum RecursiveB {\n        A(RecursiveA),\n    }\n    assert::<RecursiveB>();\n\n    #[derive(Serialize, Deserialize)]\n    struct RecursiveGenericA<T> {\n        t: T,\n        b: Box<RecursiveGenericB<T>>,\n    }\n    assert::<RecursiveGenericA<i32>>();\n\n    #[derive(Serialize, Deserialize)]\n    enum RecursiveGenericB<T> {\n        T(T),\n        A(RecursiveGenericA<T>),\n    }\n    assert::<RecursiveGenericB<i32>>();\n\n    #[derive(Serialize)]\n    struct OptionStatic<'a> {\n        a: StdOption<&'a str>,\n        b: StdOption<&'static str>,\n    }\n    assert_ser::<OptionStatic>();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound = \"D: SerializeWith + DeserializeWith\")]\n    struct WithTraits1<D, E> {\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\"\n        )]\n        d: D,\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\",\n            bound = \"E: SerializeWith + DeserializeWith\"\n        )]\n        e: E,\n    }\n    assert::<WithTraits1<X, X>>();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound(serialize = \"D: SerializeWith\", deserialize = \"D: DeserializeWith\"))]\n    struct WithTraits2<D, E> {\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\"\n        )]\n        d: D,\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            bound(serialize = \"E: SerializeWith\")\n        )]\n        #[serde(\n            deserialize_with = \"DeserializeWith::deserialize_with\",\n            bound(deserialize = \"E: DeserializeWith\")\n        )]\n        e: E,\n    }\n    assert::<WithTraits2<X, X>>();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound = \"D: SerializeWith + DeserializeWith\")]\n    enum VariantWithTraits1<D, E> {\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\"\n        )]\n        D(D),\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\",\n            bound = \"E: SerializeWith + DeserializeWith\"\n        )]\n        E(E),\n    }\n    assert::<VariantWithTraits1<X, X>>();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound(serialize = \"D: SerializeWith\", deserialize = \"D: DeserializeWith\"))]\n    enum VariantWithTraits2<D, E> {\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\"\n        )]\n        D(D),\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            bound(serialize = \"E: SerializeWith\")\n        )]\n        #[serde(\n            deserialize_with = \"DeserializeWith::deserialize_with\",\n            bound(deserialize = \"E: DeserializeWith\")\n        )]\n        E(E),\n    }\n    assert::<VariantWithTraits2<X, X>>();\n\n    #[derive(Serialize, Deserialize)]\n    struct CowStr<'a>(Cow<'a, str>);\n    assert::<CowStr>();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound(deserialize = \"T::Owned: DeserializeOwned\"))]\n    struct CowT<'a, T: ?Sized + 'a + ToOwned>(Cow<'a, T>);\n    assert::<CowT<str>>();\n\n    #[derive(Serialize, Deserialize)]\n    struct EmptyStruct {}\n    assert::<EmptyStruct>();\n\n    #[derive(Serialize, Deserialize)]\n    enum EmptyEnumVariant {\n        EmptyStruct {},\n    }\n    assert::<EmptyEnumVariant>();\n\n    #[cfg(feature = \"unstable\")]\n    #[derive(Serialize, Deserialize)]\n    struct NonAsciiIdents {\n        :  f64,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct EmptyBraced {}\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct EmptyBracedDenyUnknown {}\n\n    #[derive(Serialize, Deserialize)]\n    struct BracedSkipAll {\n        #[serde(skip_deserializing)]\n        f: u8,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct BracedSkipAllDenyUnknown {\n        #[serde(skip_deserializing)]\n        f: u8,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct EmptyTuple();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct EmptyTupleDenyUnknown();\n\n    #[derive(Serialize, Deserialize)]\n    struct TupleSkipAll(#[serde(skip_deserializing)] u8);\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct TupleSkipAllDenyUnknown(#[serde(skip_deserializing)] u8);\n\n    #[derive(Serialize, Deserialize)]\n    enum EmptyEnum {}\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    enum EmptyEnumDenyUnknown {}\n\n    #[derive(Serialize, Deserialize)]\n    enum EnumSkipAll {\n        #[serde(skip_deserializing)]\n        #[allow(dead_code)]\n        Variant,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    enum EmptyVariants {\n        Braced {},\n        Tuple(),\n        BracedSkip {\n            #[serde(skip_deserializing)]\n            f: u8,\n        },\n        TupleSkip(#[serde(skip_deserializing)] u8),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    enum EmptyVariantsDenyUnknown {\n        Braced {},\n        Tuple(),\n        BracedSkip {\n            #[serde(skip_deserializing)]\n            f: u8,\n        },\n        TupleSkip(#[serde(skip_deserializing)] u8),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct UnitDenyUnknown;\n\n    #[derive(Serialize, Deserialize)]\n    struct EmptyArray {\n        empty: [X; 0],\n    }\n\n    enum Or<A, B> {\n        A(A),\n        B(B),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(untagged, remote = \"Or\")]\n    enum OrDef<A, B> {\n        A(A),\n        B(B),\n    }\n\n    struct Str<'a>(&'a str);\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(remote = \"Str\")]\n    struct StrDef<'a>(&'a str);\n\n    #[derive(Serialize, Deserialize)]\n    struct Remote<'a> {\n        #[serde(with = \"OrDef\")]\n        or: Or<u8, bool>,\n        #[serde(borrow, with = \"StrDef\")]\n        s: Str<'a>,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    enum BorrowVariant<'a> {\n        #[serde(borrow, with = \"StrDef\")]\n        S(Str<'a>),\n    }\n\n    mod vis {\n        use serde::{Deserialize, Serialize};\n\n        pub struct S;\n\n        #[derive(Serialize, Deserialize)]\n        #[serde(remote = \"S\")]\n        pub struct SDef;\n    }\n\n    // This would not work if SDef::serialize / deserialize are private.\n    #[derive(Serialize, Deserialize)]\n    struct RemoteVisibility {\n        #[serde(with = \"vis::SDef\")]\n        s: vis::S,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(remote = \"Self\")]\n    struct RemoteSelf;\n\n    #[derive(Serialize, Deserialize)]\n    enum ExternallyTaggedVariantWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Newtype(X),\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Tuple(String, u8),\n\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Struct1 { x: X },\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Struct { f1: String, f2: u8 },\n\n        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n        #[allow(dead_code)]\n        Unit,\n    }\n    assert_ser::<ExternallyTaggedVariantWith>();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(tag = \"t\")]\n    enum InternallyTaggedVariantWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Newtype(X),\n\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Struct1 { x: X },\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Struct { f1: String, f2: u8 },\n\n        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n        #[allow(dead_code)]\n        Unit,\n    }\n    assert_ser::<InternallyTaggedVariantWith>();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum AdjacentlyTaggedVariantWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Newtype(X),\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Tuple(String, u8),\n\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Struct1 { x: X },\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Struct { f1: String, f2: u8 },\n\n        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n        #[allow(dead_code)]\n        Unit,\n    }\n    assert_ser::<AdjacentlyTaggedVariantWith>();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum UntaggedVariantWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Newtype(X),\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Tuple(String, u8),\n\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Struct1 { x: X },\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Struct { f1: String, f2: u8 },\n\n        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n        #[allow(dead_code)]\n        Unit,\n    }\n    assert_ser::<UntaggedVariantWith>();\n\n    #[derive(Serialize, Deserialize)]\n    struct FlattenWith {\n        #[serde(flatten, serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n        x: X,\n    }\n    assert::<FlattenWith>();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct FlattenDenyUnknown<T> {\n        #[serde(flatten)]\n        t: T,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct StaticStrStruct<'a> {\n        a: &'a str,\n        b: &'static str,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct StaticStrTupleStruct<'a>(&'a str, &'static str);\n\n    #[derive(Serialize, Deserialize)]\n    struct StaticStrNewtypeStruct(&'static str);\n\n    #[derive(Serialize, Deserialize)]\n    enum StaticStrEnum<'a> {\n        Struct { a: &'a str, b: &'static str },\n        Tuple(&'a str, &'static str),\n        Newtype(&'static str),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct SkippedStaticStr {\n        #[serde(skip_deserializing)]\n        skipped: &'static str,\n        other: isize,\n    }\n    assert::<SkippedStaticStr>();\n\n    macro_rules! T {\n        () => {\n            ()\n        };\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct TypeMacro<T> {\n        mac: T!(),\n        marker: PhantomData<T>,\n    }\n    assert::<TypeMacro<X>>();\n\n    #[derive(Serialize)]\n    struct BigArray {\n        #[serde(serialize_with = \"<[_]>::serialize\")]\n        array: [u8; 256],\n    }\n    assert_ser::<BigArray>();\n\n    trait AssocSerde {\n        type Assoc;\n    }\n\n    struct NoSerdeImpl;\n    impl AssocSerde for NoSerdeImpl {\n        type Assoc = u32;\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct AssocDerive<T: AssocSerde> {\n        assoc: T::Assoc,\n    }\n\n    assert::<AssocDerive<NoSerdeImpl>>();\n\n    #[derive(Serialize, Deserialize)]\n    struct AssocDeriveMulti<S, T: AssocSerde> {\n        s: S,\n        assoc: T::Assoc,\n    }\n\n    assert::<AssocDeriveMulti<i32, NoSerdeImpl>>();\n\n    #[derive(Serialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum EmptyAdjacentlyTagged {\n        #[allow(dead_code)]\n        Struct {},\n        #[allow(dead_code)]\n        Tuple(),\n    }\n\n    assert_ser::<EmptyAdjacentlyTagged>();\n\n    mod restricted {\n        mod inner {\n            use serde::{Deserialize, Serialize};\n\n            #[derive(Serialize, Deserialize)]\n            struct Restricted {\n                pub(super) a: usize,\n                pub(in super::inner) b: usize,\n            }\n        }\n    }\n\n    #[derive(Deserialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum AdjacentlyTaggedVoid {}\n\n    #[derive(Serialize, Deserialize)]\n    enum SkippedVariant<T> {\n        #[serde(skip)]\n        #[allow(dead_code)]\n        T(T),\n        Unit,\n    }\n\n    assert::<SkippedVariant<X>>();\n\n    #[derive(Deserialize)]\n    struct ImpliciltyBorrowedOption<'a> {\n        option: std::option::Option<&'a str>,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum UntaggedNewtypeVariantWith {\n        Newtype(\n            #[serde(serialize_with = \"ser_x\")]\n            #[serde(deserialize_with = \"de_x\")]\n            X,\n        ),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(transparent)]\n    struct TransparentWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        x: X,\n    }\n\n    #[derive(Deserialize)]\n    #[serde(untagged)]\n    enum UntaggedWithBorrow<'a> {\n        Single(#[serde(borrow)] RelObject<'a>),\n        Many(#[serde(borrow)] Vec<RelObject<'a>>),\n    }\n\n    #[derive(Deserialize)]\n    struct RelObject<'a> {\n        ty: &'a str,\n        id: String,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct FlattenSkipSerializing<T> {\n        #[serde(flatten, skip_serializing)]\n        #[allow(dead_code)]\n        flat: T,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct FlattenSkipSerializingIf<T> {\n        #[serde(flatten, skip_serializing_if = \"StdOption::is_none\")]\n        flat: StdOption<T>,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct FlattenSkipDeserializing<T> {\n        #[serde(flatten, skip_deserializing)]\n        flat: T,\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nfn assert<T: Serialize + DeserializeOwned>() {}\nfn assert_ser<T: Serialize>() {}\n\ntrait SerializeWith {\n    fn serialize_with<S: Serializer>(_: &Self, _: S) -> StdResult<S::Ok, S::Error>;\n}\n\ntrait DeserializeWith: Sized {\n    fn deserialize_with<'de, D: Deserializer<'de>>(_: D) -> StdResult<Self, D::Error>;\n}\n\n// Implements neither Serialize nor Deserialize\npub struct X;\n\npub fn ser_x<S: Serializer>(_: &X, _: S) -> StdResult<S::Ok, S::Error> {\n    unimplemented!()\n}\n\npub fn de_x<'de, D: Deserializer<'de>>(_: D) -> StdResult<X, D::Error> {\n    unimplemented!()\n}\n\nmod both_x {\n    pub use super::{de_x as deserialize, ser_x as serialize};\n}\n\nimpl SerializeWith for X {\n    fn serialize_with<S: Serializer>(_: &Self, _: S) -> StdResult<S::Ok, S::Error> {\n        unimplemented!()\n    }\n}\n\nimpl DeserializeWith for X {\n    fn deserialize_with<'de, D: Deserializer<'de>>(_: D) -> StdResult<Self, D::Error> {\n        unimplemented!()\n    }\n}\n\npub fn serialize_some_unit_variant<S>(_: S) -> StdResult<S::Ok, S::Error>\nwhere\n    S: Serializer,\n{\n    unimplemented!()\n}\n\npub fn deserialize_some_unit_variant<'de, D>(_: D) -> StdResult<(), D::Error>\nwhere\n    D: Deserializer<'de>,\n{\n    unimplemented!()\n}\n\npub fn serialize_some_other_variant<S>(_: &str, _: &u8, _: S) -> StdResult<S::Ok, S::Error>\nwhere\n    S: Serializer,\n{\n    unimplemented!()\n}\n\npub fn deserialize_some_other_variant<'de, D>(_: D) -> StdResult<(String, u8), D::Error>\nwhere\n    D: Deserializer<'de>,\n{\n    unimplemented!()\n}\n\npub fn is_zero(n: &u8) -> bool {\n    *n == 0\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_identifier.rs"],"content":"use serde::Deserialize;\nuse serde_test::{assert_de_tokens, Token};\n\n#[test]\nfn test_variant_identifier() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(variant_identifier)]\n    enum V {\n        Aaa,\n        Bbb,\n    }\n\n    assert_de_tokens(&V::Aaa, &[Token::U8(0)]);\n    assert_de_tokens(&V::Aaa, &[Token::U16(0)]);\n    assert_de_tokens(&V::Aaa, &[Token::U32(0)]);\n    assert_de_tokens(&V::Aaa, &[Token::U64(0)]);\n    assert_de_tokens(&V::Aaa, &[Token::Str(\"Aaa\")]);\n    assert_de_tokens(&V::Aaa, &[Token::Bytes(b\"Aaa\")]);\n}\n\n#[test]\nfn test_field_identifier() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(field_identifier, rename_all = \"snake_case\")]\n    enum F {\n        Aaa,\n        Bbb,\n    }\n\n    assert_de_tokens(&F::Aaa, &[Token::Str(\"aaa\")]);\n    assert_de_tokens(&F::Aaa, &[Token::Bytes(b\"aaa\")]);\n}\n\n#[test]\nfn test_unit_fallthrough() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(field_identifier, rename_all = \"snake_case\")]\n    enum F {\n        Aaa,\n        Bbb,\n        #[serde(other)]\n        Other,\n    }\n\n    assert_de_tokens(&F::Other, &[Token::Str(\"x\")]);\n}\n\n#[test]\nfn test_newtype_fallthrough() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(field_identifier, rename_all = \"snake_case\")]\n    enum F {\n        Aaa,\n        Bbb,\n        Other(String),\n    }\n\n    assert_de_tokens(&F::Other(\"x\".to_owned()), &[Token::Str(\"x\")]);\n}\n\n#[test]\nfn test_newtype_fallthrough_generic() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(field_identifier, rename_all = \"snake_case\")]\n    enum F<T> {\n        Aaa,\n        Bbb,\n        Other(T),\n    }\n\n    assert_de_tokens(&F::Other(\"x\".to_owned()), &[Token::Str(\"x\")]);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_ignored_any.rs"],"content":"use serde::de::value::{Error, MapDeserializer, SeqDeserializer};\nuse serde::de::{\n    DeserializeSeed, EnumAccess, IgnoredAny, IntoDeserializer, VariantAccess, Visitor,\n};\nuse serde::{forward_to_deserialize_any, Deserialize, Deserializer};\n\n#[derive(PartialEq, Debug, Deserialize)]\nenum Target {\n    Unit,\n    Newtype(i32),\n    Tuple(i32, i32),\n    Struct { a: i32 },\n}\n\nstruct Enum(&'static str);\n\nimpl<'de> Deserializer<'de> for Enum {\n    type Error = Error;\n\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\nimpl<'de> EnumAccess<'de> for Enum {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: DeserializeSeed<'de>,\n    {\n        let v = seed.deserialize(self.0.into_deserializer())?;\n        Ok((v, self))\n    }\n}\n\nimpl<'de> VariantAccess<'de> for Enum {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n    where\n        T: DeserializeSeed<'de>,\n    {\n        seed.deserialize(10i32.into_deserializer())\n    }\n\n    fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        let seq = SeqDeserializer::new(vec![1i32, 2].into_iter());\n        visitor.visit_seq(seq)\n    }\n\n    fn struct_variant<V>(\n        self,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        let map = MapDeserializer::new(vec![(\"a\", 10i32)].into_iter());\n        visitor.visit_map(map)\n    }\n}\n\n#[test]\nfn test_deserialize_enum() {\n    // First just make sure the Deserializer impl works\n    assert_eq!(Target::Unit, Target::deserialize(Enum(\"Unit\")).unwrap());\n    assert_eq!(\n        Target::Newtype(10),\n        Target::deserialize(Enum(\"Newtype\")).unwrap()\n    );\n    assert_eq!(\n        Target::Tuple(1, 2),\n        Target::deserialize(Enum(\"Tuple\")).unwrap()\n    );\n    assert_eq!(\n        Target::Struct { a: 10 },\n        Target::deserialize(Enum(\"Struct\")).unwrap()\n    );\n\n    // Now try IgnoredAny\n    IgnoredAny::deserialize(Enum(\"Unit\")).unwrap();\n    IgnoredAny::deserialize(Enum(\"Newtype\")).unwrap();\n    IgnoredAny::deserialize(Enum(\"Tuple\")).unwrap();\n    IgnoredAny::deserialize(Enum(\"Struct\")).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_macros.rs"],"content":"#![deny(trivial_numeric_casts)]\n#![allow(clippy::redundant_field_names)]\n\nmod bytes;\n\nuse serde::{Deserialize, Serialize};\nuse serde_test::{\n    assert_de_tokens, assert_de_tokens_error, assert_ser_tokens, assert_tokens, Token,\n};\n\nuse std::collections::BTreeMap;\nuse std::marker::PhantomData;\n\n// That tests that the derived Serialize implementation doesn't trigger\n// any warning about `serializer` not being used, in case of empty enums.\n#[derive(Serialize)]\n#[allow(dead_code)]\n#[deny(unused_variables)]\nenum Void {}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct NamedUnit;\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SerNamedTuple<'a, 'b, A: 'a, B: 'b, C>(&'a A, &'b mut B, C);\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct DeNamedTuple<A, B, C>(A, B, C);\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SerNamedMap<'a, 'b, A: 'a, B: 'b, C> {\n    a: &'a A,\n    b: &'b mut B,\n    c: C,\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct DeNamedMap<A, B, C> {\n    a: A,\n    b: B,\n    c: C,\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nenum SerEnum<'a, B: 'a, C: 'a, D>\nwhere\n    D: 'a,\n{\n    Unit,\n    Seq(i8, B, &'a C, &'a mut D),\n    Map { a: i8, b: B, c: &'a C, d: &'a mut D },\n\n    // Make sure we can support more than one variant.\n    _Unit2,\n    _Seq2(i8, B, &'a C, &'a mut D),\n    _Map2 { a: i8, b: B, c: &'a C, d: &'a mut D },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum DeEnum<B, C, D> {\n    Unit,\n    Seq(i8, B, C, D),\n    Map { a: i8, b: B, c: C, d: D },\n\n    // Make sure we can support more than one variant.\n    _Unit2,\n    _Seq2(i8, B, C, D),\n    _Map2 { a: i8, b: B, c: C, d: D },\n}\n\n#[derive(Serialize)]\nenum Lifetimes<'a> {\n    LifetimeSeq(&'a i32),\n    NoLifetimeSeq(i32),\n    LifetimeMap { a: &'a i32 },\n    NoLifetimeMap { a: i32 },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub struct GenericStruct<T> {\n    x: T,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub struct GenericNewTypeStruct<T>(T);\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub struct GenericTupleStruct<T, U>(T, U);\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub enum GenericEnum<T, U> {\n    Unit,\n    NewType(T),\n    Seq(T, U),\n    Map { x: T, y: U },\n}\n\ntrait AssociatedType {\n    type X;\n}\n\nimpl AssociatedType for i32 {\n    type X = i32;\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct DefaultTyParam<T: AssociatedType<X = i32> = i32> {\n    phantom: PhantomData<T>,\n}\n\n#[test]\nfn test_named_unit() {\n    assert_tokens(&NamedUnit, &[Token::UnitStruct { name: \"NamedUnit\" }]);\n}\n\n#[test]\nfn test_ser_named_tuple() {\n    let a = 5;\n    let mut b = 6;\n    let c = 7;\n    assert_ser_tokens(\n        &SerNamedTuple(&a, &mut b, c),\n        &[\n            Token::TupleStruct {\n                name: \"SerNamedTuple\",\n                len: 3,\n            },\n            Token::I32(5),\n            Token::I32(6),\n            Token::I32(7),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_de_named_tuple() {\n    assert_de_tokens(\n        &DeNamedTuple(5, 6, 7),\n        &[\n            Token::Seq { len: Some(3) },\n            Token::I32(5),\n            Token::I32(6),\n            Token::I32(7),\n            Token::SeqEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &DeNamedTuple(5, 6, 7),\n        &[\n            Token::TupleStruct {\n                name: \"DeNamedTuple\",\n                len: 3,\n            },\n            Token::I32(5),\n            Token::I32(6),\n            Token::I32(7),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_ser_named_map() {\n    let a = 5;\n    let mut b = 6;\n    let c = 7;\n\n    assert_ser_tokens(\n        &SerNamedMap {\n            a: &a,\n            b: &mut b,\n            c: c,\n        },\n        &[\n            Token::Struct {\n                name: \"SerNamedMap\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I32(5),\n            Token::Str(\"b\"),\n            Token::I32(6),\n            Token::Str(\"c\"),\n            Token::I32(7),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_de_named_map() {\n    assert_de_tokens(\n        &DeNamedMap { a: 5, b: 6, c: 7 },\n        &[\n            Token::Struct {\n                name: \"DeNamedMap\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I32(5),\n            Token::Str(\"b\"),\n            Token::I32(6),\n            Token::Str(\"c\"),\n            Token::I32(7),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_ser_enum_unit() {\n    assert_ser_tokens(\n        &SerEnum::Unit::<u32, u32, u32>,\n        &[Token::UnitVariant {\n            name: \"SerEnum\",\n            variant: \"Unit\",\n        }],\n    );\n}\n\n#[test]\nfn test_ser_enum_seq() {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let mut d = 4;\n\n    assert_ser_tokens(\n        &SerEnum::Seq(a, b, &c, &mut d),\n        &[\n            Token::TupleVariant {\n                name: \"SerEnum\",\n                variant: \"Seq\",\n                len: 4,\n            },\n            Token::I8(1),\n            Token::I32(2),\n            Token::I32(3),\n            Token::I32(4),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_ser_enum_map() {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let mut d = 4;\n\n    assert_ser_tokens(\n        &SerEnum::Map {\n            a: a,\n            b: b,\n            c: &c,\n            d: &mut d,\n        },\n        &[\n            Token::StructVariant {\n                name: \"SerEnum\",\n                variant: \"Map\",\n                len: 4,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::I32(2),\n            Token::Str(\"c\"),\n            Token::I32(3),\n            Token::Str(\"d\"),\n            Token::I32(4),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_de_enum_unit() {\n    assert_tokens(\n        &DeEnum::Unit::<u32, u32, u32>,\n        &[Token::UnitVariant {\n            name: \"DeEnum\",\n            variant: \"Unit\",\n        }],\n    );\n}\n\n#[test]\nfn test_de_enum_seq() {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let d = 4;\n\n    assert_tokens(\n        &DeEnum::Seq(a, b, c, d),\n        &[\n            Token::TupleVariant {\n                name: \"DeEnum\",\n                variant: \"Seq\",\n                len: 4,\n            },\n            Token::I8(1),\n            Token::I32(2),\n            Token::I32(3),\n            Token::I32(4),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_de_enum_map() {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let d = 4;\n\n    assert_tokens(\n        &DeEnum::Map {\n            a: a,\n            b: b,\n            c: c,\n            d: d,\n        },\n        &[\n            Token::StructVariant {\n                name: \"DeEnum\",\n                variant: \"Map\",\n                len: 4,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::I32(2),\n            Token::Str(\"c\"),\n            Token::I32(3),\n            Token::Str(\"d\"),\n            Token::I32(4),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_lifetimes() {\n    let value = 5;\n\n    assert_ser_tokens(\n        &Lifetimes::LifetimeSeq(&value),\n        &[\n            Token::NewtypeVariant {\n                name: \"Lifetimes\",\n                variant: \"LifetimeSeq\",\n            },\n            Token::I32(5),\n        ],\n    );\n\n    assert_ser_tokens(\n        &Lifetimes::NoLifetimeSeq(5),\n        &[\n            Token::NewtypeVariant {\n                name: \"Lifetimes\",\n                variant: \"NoLifetimeSeq\",\n            },\n            Token::I32(5),\n        ],\n    );\n\n    assert_ser_tokens(\n        &Lifetimes::LifetimeMap { a: &value },\n        &[\n            Token::StructVariant {\n                name: \"Lifetimes\",\n                variant: \"LifetimeMap\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I32(5),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        &Lifetimes::NoLifetimeMap { a: 5 },\n        &[\n            Token::StructVariant {\n                name: \"Lifetimes\",\n                variant: \"NoLifetimeMap\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I32(5),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_struct() {\n    assert_tokens(\n        &GenericStruct { x: 5u32 },\n        &[\n            Token::Struct {\n                name: \"GenericStruct\",\n                len: 1,\n            },\n            Token::Str(\"x\"),\n            Token::U32(5),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_newtype_struct() {\n    assert_tokens(\n        &GenericNewTypeStruct(5u32),\n        &[\n            Token::NewtypeStruct {\n                name: \"GenericNewTypeStruct\",\n            },\n            Token::U32(5),\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_newtype_struct() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum E {\n        Newtype(GenericNewTypeStruct<u32>),\n        Null,\n    }\n\n    assert_tokens(\n        &E::Newtype(GenericNewTypeStruct(5u32)),\n        &[\n            Token::NewtypeStruct {\n                name: \"GenericNewTypeStruct\",\n            },\n            Token::U32(5),\n        ],\n    );\n}\n\n#[test]\nfn test_adjacently_tagged_newtype_struct() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum E {\n        Newtype(GenericNewTypeStruct<u32>),\n        Null,\n    }\n\n    assert_de_tokens(\n        &E::Newtype(GenericNewTypeStruct(5u32)),\n        &[\n            Token::Struct { name: \"E\", len: 2 },\n            Token::Str(\"c\"),\n            Token::NewtypeStruct {\n                name: \"GenericNewTypeStruct\",\n            },\n            Token::U32(5),\n            Token::Str(\"t\"),\n            Token::Str(\"Newtype\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_tuple_struct() {\n    assert_tokens(\n        &GenericTupleStruct(5u32, 6u32),\n        &[\n            Token::TupleStruct {\n                name: \"GenericTupleStruct\",\n                len: 2,\n            },\n            Token::U32(5),\n            Token::U32(6),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_enum_unit() {\n    assert_tokens(\n        &GenericEnum::Unit::<u32, u32>,\n        &[Token::UnitVariant {\n            name: \"GenericEnum\",\n            variant: \"Unit\",\n        }],\n    );\n}\n\n#[test]\nfn test_generic_enum_newtype() {\n    assert_tokens(\n        &GenericEnum::NewType::<u32, u32>(5),\n        &[\n            Token::NewtypeVariant {\n                name: \"GenericEnum\",\n                variant: \"NewType\",\n            },\n            Token::U32(5),\n        ],\n    );\n}\n\n#[test]\nfn test_generic_enum_seq() {\n    assert_tokens(\n        &GenericEnum::Seq::<u32, u32>(5, 6),\n        &[\n            Token::TupleVariant {\n                name: \"GenericEnum\",\n                variant: \"Seq\",\n                len: 2,\n            },\n            Token::U32(5),\n            Token::U32(6),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_enum_map() {\n    assert_tokens(\n        &GenericEnum::Map::<u32, u32> { x: 5, y: 6 },\n        &[\n            Token::StructVariant {\n                name: \"GenericEnum\",\n                variant: \"Map\",\n                len: 2,\n            },\n            Token::Str(\"x\"),\n            Token::U32(5),\n            Token::Str(\"y\"),\n            Token::U32(6),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_default_ty_param() {\n    assert_tokens(\n        &DefaultTyParam::<i32> {\n            phantom: PhantomData,\n        },\n        &[\n            Token::Struct {\n                name: \"DefaultTyParam\",\n                len: 1,\n            },\n            Token::Str(\"phantom\"),\n            Token::UnitStruct {\n                name: \"PhantomData\",\n            },\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_enum_state_field() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    enum SomeEnum {\n        Key { key: char, state: bool },\n    }\n\n    assert_tokens(\n        &SomeEnum::Key {\n            key: 'a',\n            state: true,\n        },\n        &[\n            Token::StructVariant {\n                name: \"SomeEnum\",\n                variant: \"Key\",\n                len: 2,\n            },\n            Token::Str(\"key\"),\n            Token::Char('a'),\n            Token::Str(\"state\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum Untagged {\n        A { a: u8 },\n        B { b: u8 },\n        C,\n        D(u8),\n        E(String),\n        F(u8, u8),\n    }\n\n    assert_tokens(\n        &Untagged::A { a: 1 },\n        &[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_tokens(\n        &Untagged::B { b: 2 },\n        &[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"b\"),\n            Token::U8(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_tokens(&Untagged::C, &[Token::Unit]);\n\n    assert_tokens(&Untagged::D(4), &[Token::U8(4)]);\n    assert_tokens(&Untagged::E(\"e\".to_owned()), &[Token::Str(\"e\")]);\n\n    assert_tokens(\n        &Untagged::F(1, 2),\n        &[\n            Token::Tuple { len: 2 },\n            Token::U8(1),\n            Token::U8(2),\n            Token::TupleEnd,\n        ],\n    );\n\n    assert_de_tokens_error::<Untagged>(\n        &[Token::None],\n        \"data did not match any variant of untagged enum Untagged\",\n    );\n\n    assert_de_tokens_error::<Untagged>(\n        &[Token::Tuple { len: 1 }, Token::U8(1), Token::TupleEnd],\n        \"data did not match any variant of untagged enum Untagged\",\n    );\n\n    assert_de_tokens_error::<Untagged>(\n        &[\n            Token::Tuple { len: 3 },\n            Token::U8(1),\n            Token::U8(2),\n            Token::U8(3),\n            Token::TupleEnd,\n        ],\n        \"data did not match any variant of untagged enum Untagged\",\n    );\n}\n\n#[test]\nfn test_internally_tagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Newtype(BTreeMap<String, String>);\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Struct {\n        f: u8,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    enum InternallyTagged {\n        A { a: u8 },\n        B,\n        C(BTreeMap<String, String>),\n        D(Newtype),\n        E(Struct),\n    }\n\n    assert_tokens(\n        &InternallyTagged::A { a: 1 },\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"A\"),\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::A { a: 1 },\n        &[\n            Token::Seq { len: Some(2) },\n            Token::Str(\"A\"),\n            Token::U8(1),\n            Token::SeqEnd,\n        ],\n    );\n\n    assert_tokens(\n        &InternallyTagged::B,\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 1,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"B\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::B,\n        &[Token::Seq { len: Some(1) }, Token::Str(\"B\"), Token::SeqEnd],\n    );\n\n    assert_tokens(\n        &InternallyTagged::C(BTreeMap::new()),\n        &[\n            Token::Map { len: Some(1) },\n            Token::Str(\"type\"),\n            Token::Str(\"C\"),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens_error::<InternallyTagged>(\n        &[\n            Token::Seq { len: Some(2) },\n            Token::Str(\"C\"),\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected a map\",\n    );\n\n    assert_tokens(\n        &InternallyTagged::D(Newtype(BTreeMap::new())),\n        &[\n            Token::Map { len: Some(1) },\n            Token::Str(\"type\"),\n            Token::Str(\"D\"),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        &InternallyTagged::E(Struct { f: 6 }),\n        &[\n            Token::Struct {\n                name: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"E\"),\n            Token::Str(\"f\"),\n            Token::U8(6),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::E(Struct { f: 6 }),\n        &[\n            Token::Seq { len: Some(2) },\n            Token::Str(\"E\"),\n            Token::U8(6),\n            Token::SeqEnd,\n        ],\n    );\n\n    assert_de_tokens_error::<InternallyTagged>(\n        &[Token::Map { len: Some(0) }, Token::MapEnd],\n        \"missing field `type`\",\n    );\n\n    assert_de_tokens_error::<InternallyTagged>(\n        &[\n            Token::Map { len: Some(1) },\n            Token::Str(\"type\"),\n            Token::Str(\"Z\"),\n            Token::MapEnd,\n        ],\n        \"unknown variant `Z`, expected one of `A`, `B`, `C`, `D`, `E`\",\n    );\n}\n\n#[test]\nfn test_internally_tagged_bytes() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    #[serde(tag = \"type\")]\n    enum InternallyTagged {\n        String {\n            string: String,\n        },\n        Bytes {\n            #[serde(with = \"bytes\")]\n            bytes: Vec<u8>,\n        },\n    }\n\n    assert_de_tokens(\n        &InternallyTagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        &[\n            Token::Struct {\n                name: \"String\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"String\"),\n            Token::Str(\"string\"),\n            Token::Str(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        &[\n            Token::Struct {\n                name: \"String\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"String\"),\n            Token::Str(\"string\"),\n            Token::String(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        &[\n            Token::Struct {\n                name: \"String\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"String\"),\n            Token::Str(\"string\"),\n            Token::Bytes(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        &[\n            Token::Struct {\n                name: \"String\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"String\"),\n            Token::Str(\"string\"),\n            Token::ByteBuf(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::Bytes { bytes: vec![0] },\n        &[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::Str(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::Bytes { bytes: vec![0] },\n        &[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::String(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::Bytes { bytes: vec![0] },\n        &[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::Bytes(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::Bytes { bytes: vec![0] },\n        &[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::ByteBuf(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::Bytes { bytes: vec![0] },\n        &[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::Seq { len: Some(1) },\n            Token::U8(0),\n            Token::SeqEnd,\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_struct_variant_containing_unit_variant() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    pub enum Level {\n        Info,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"action\")]\n    pub enum Message {\n        Log { level: Level },\n    }\n\n    assert_de_tokens(\n        &Message::Log { level: Level::Info },\n        &[\n            Token::Struct {\n                name: \"Message\",\n                len: 2,\n            },\n            Token::Str(\"action\"),\n            Token::Str(\"Log\"),\n            Token::Str(\"level\"),\n            Token::BorrowedStr(\"Info\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_borrow() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    pub enum Input<'a> {\n        Package { name: &'a str },\n    }\n\n    assert_tokens(\n        &Input::Package { name: \"borrowed\" },\n        &[\n            Token::Struct {\n                name: \"Input\",\n                len: 2,\n            },\n            Token::BorrowedStr(\"type\"),\n            Token::BorrowedStr(\"Package\"),\n            Token::BorrowedStr(\"name\"),\n            Token::BorrowedStr(\"borrowed\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_adjacently_tagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum AdjacentlyTagged<T> {\n        Unit,\n        Newtype(T),\n        Tuple(u8, u8),\n        Struct { f: u8 },\n    }\n\n    // unit with no content\n    assert_ser_tokens(\n        &AdjacentlyTagged::Unit::<u8>,\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 1,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // unit with no content\n    assert_de_tokens(\n        &AdjacentlyTagged::Unit::<u8>,\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // unit with tag first\n    assert_de_tokens(\n        &AdjacentlyTagged::Unit::<u8>,\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::StructEnd,\n        ],\n    );\n\n    // unit with content first\n    assert_de_tokens(\n        &AdjacentlyTagged::Unit::<u8>,\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // unit with excess content (f, g, h)\n    assert_de_tokens(\n        &AdjacentlyTagged::Unit::<u8>,\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"f\"),\n            Token::Unit,\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"g\"),\n            Token::Unit,\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"h\"),\n            Token::Unit,\n            Token::StructEnd,\n        ],\n    );\n\n    // newtype with tag first\n    assert_tokens(\n        &AdjacentlyTagged::Newtype::<u8>(1),\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Newtype\"),\n            Token::Str(\"c\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    // newtype with content first\n    assert_de_tokens(\n        &AdjacentlyTagged::Newtype::<u8>(1),\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::U8(1),\n            Token::Str(\"t\"),\n            Token::Str(\"Newtype\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // tuple with tag first\n    assert_tokens(\n        &AdjacentlyTagged::Tuple::<u8>(1, 1),\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Tuple\"),\n            Token::Str(\"c\"),\n            Token::Tuple { len: 2 },\n            Token::U8(1),\n            Token::U8(1),\n            Token::TupleEnd,\n            Token::StructEnd,\n        ],\n    );\n\n    // tuple with content first\n    assert_de_tokens(\n        &AdjacentlyTagged::Tuple::<u8>(1, 1),\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Tuple { len: 2 },\n            Token::U8(1),\n            Token::U8(1),\n            Token::TupleEnd,\n            Token::Str(\"t\"),\n            Token::Str(\"Tuple\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // struct with tag first\n    assert_tokens(\n        &AdjacentlyTagged::Struct::<u8> { f: 1 },\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Struct\"),\n            Token::Str(\"c\"),\n            Token::Struct {\n                name: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"f\"),\n            Token::U8(1),\n            Token::StructEnd,\n            Token::StructEnd,\n        ],\n    );\n\n    // struct with content first\n    assert_de_tokens(\n        &AdjacentlyTagged::Struct::<u8> { f: 1 },\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Struct {\n                name: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"f\"),\n            Token::U8(1),\n            Token::StructEnd,\n            Token::Str(\"t\"),\n            Token::Str(\"Struct\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_adjacently_tagged_enum_deny_unknown_fields() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\", deny_unknown_fields)]\n    enum AdjacentlyTagged {\n        Unit,\n    }\n\n    assert_de_tokens(\n        &AdjacentlyTagged::Unit,\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens_error::<AdjacentlyTagged>(\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"h\"),\n        ],\n        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#,\n    );\n\n    assert_de_tokens_error::<AdjacentlyTagged>(\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"h\"),\n        ],\n        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#,\n    );\n\n    assert_de_tokens_error::<AdjacentlyTagged>(\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"h\"),\n        ],\n        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#,\n    );\n}\n\n#[test]\nfn test_enum_in_internally_tagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    enum Outer {\n        Inner(Inner),\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    enum Inner {\n        Unit,\n        Newtype(u8),\n        Tuple(u8, u8),\n        Struct { f: u8 },\n    }\n\n    assert_tokens(\n        &Outer::Inner(Inner::Unit),\n        &[\n            Token::Map { len: Some(2) },\n            Token::Str(\"type\"),\n            Token::Str(\"Inner\"),\n            Token::Str(\"Unit\"),\n            Token::Unit,\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        &Outer::Inner(Inner::Newtype(1)),\n        &[\n            Token::Map { len: Some(2) },\n            Token::Str(\"type\"),\n            Token::Str(\"Inner\"),\n            Token::Str(\"Newtype\"),\n            Token::U8(1),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        &Outer::Inner(Inner::Tuple(1, 1)),\n        &[\n            Token::Map { len: Some(2) },\n            Token::Str(\"type\"),\n            Token::Str(\"Inner\"),\n            Token::Str(\"Tuple\"),\n            Token::TupleStruct {\n                name: \"Tuple\",\n                len: 2,\n            },\n            Token::U8(1),\n            Token::U8(1),\n            Token::TupleStructEnd,\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        &Outer::Inner(Inner::Struct { f: 1 }),\n        &[\n            Token::Map { len: Some(2) },\n            Token::Str(\"type\"),\n            Token::Str(\"Inner\"),\n            Token::Str(\"Struct\"),\n            Token::Struct {\n                name: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"f\"),\n            Token::U8(1),\n            Token::StructEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_struct() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    pub struct Struct {\n        a: u8,\n    }\n\n    assert_tokens(\n        &Struct { a: 1 },\n        &[\n            Token::Struct {\n                name: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Struct\"),\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &Struct { a: 1 },\n        &[\n            Token::Struct {\n                name: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_braced_struct_with_zero_fields() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    struct S {}\n\n    assert_tokens(\n        &S {},\n        &[\n            Token::Struct { name: \"S\", len: 1 },\n            Token::Str(\"type\"),\n            Token::Str(\"S\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_struct_with_flattened_field() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"tag_struct\")]\n    pub struct Struct {\n        #[serde(flatten)]\n        pub flat: Enum,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"tag_enum\", content = \"content\")]\n    pub enum Enum {\n        A(u64),\n    }\n\n    assert_tokens(\n        &Struct { flat: Enum::A(0) },\n        &[\n            Token::Map { len: None },\n            Token::Str(\"tag_struct\"),\n            Token::Str(\"Struct\"),\n            Token::Str(\"tag_enum\"),\n            Token::Str(\"A\"),\n            Token::Str(\"content\"),\n            Token::U64(0),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &Struct { flat: Enum::A(0) },\n        &[\n            Token::Map { len: None },\n            Token::Str(\"tag_enum\"),\n            Token::Str(\"A\"),\n            Token::Str(\"content\"),\n            Token::U64(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_enum_with_flattened_integer_key() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    pub enum Untagged {\n        Variant {\n            #[serde(flatten)]\n            map: BTreeMap<u64, String>,\n        },\n    }\n\n    assert_tokens(\n        &Untagged::Variant {\n            map: {\n                let mut map = BTreeMap::new();\n                map.insert(100, \"BTreeMap\".to_owned());\n                map\n            },\n        },\n        &[\n            Token::Map { len: None },\n            Token::U64(100),\n            Token::Str(\"BTreeMap\"),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_enum_in_untagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum Outer {\n        Inner(Inner),\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    enum Inner {\n        Unit,\n        Newtype(u8),\n        Tuple(u8, u8),\n        Struct { f: u8 },\n    }\n\n    assert_tokens(\n        &Outer::Inner(Inner::Unit),\n        &[Token::UnitVariant {\n            name: \"Inner\",\n            variant: \"Unit\",\n        }],\n    );\n\n    assert_tokens(\n        &Outer::Inner(Inner::Newtype(1)),\n        &[\n            Token::NewtypeVariant {\n                name: \"Inner\",\n                variant: \"Newtype\",\n            },\n            Token::U8(1),\n        ],\n    );\n\n    assert_tokens(\n        &Outer::Inner(Inner::Tuple(1, 1)),\n        &[\n            Token::TupleVariant {\n                name: \"Inner\",\n                variant: \"Tuple\",\n                len: 2,\n            },\n            Token::U8(1),\n            Token::U8(1),\n            Token::TupleVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        &Outer::Inner(Inner::Struct { f: 1 }),\n        &[\n            Token::StructVariant {\n                name: \"Inner\",\n                variant: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"f\"),\n            Token::U8(1),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_bytes() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    #[serde(untagged)]\n    enum Untagged {\n        String {\n            string: String,\n        },\n        Bytes {\n            #[serde(with = \"bytes\")]\n            bytes: Vec<u8>,\n        },\n    }\n\n    assert_de_tokens(\n        &Untagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        &[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"string\"),\n            Token::Str(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &Untagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        &[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"string\"),\n            Token::String(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &Untagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        &[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"string\"),\n            Token::Bytes(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &Untagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        &[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"string\"),\n            Token::ByteBuf(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &Untagged::Bytes { bytes: vec![0] },\n        &[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::Str(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &Untagged::Bytes { bytes: vec![0] },\n        &[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::String(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &Untagged::Bytes { bytes: vec![0] },\n        &[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::Bytes(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &Untagged::Bytes { bytes: vec![0] },\n        &[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::ByteBuf(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &Untagged::Bytes { bytes: vec![0] },\n        &[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::Seq { len: Some(1) },\n            Token::U8(0),\n            Token::SeqEnd,\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_rename_all() {\n    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n    #[serde(rename_all = \"snake_case\")]\n    enum E {\n        #[serde(rename_all = \"camelCase\")]\n        Serialize {\n            serialize: bool,\n            serialize_seq: bool,\n        },\n        #[serde(rename_all = \"kebab-case\")]\n        SerializeSeq {\n            serialize: bool,\n            serialize_seq: bool,\n        },\n        #[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\n        SerializeMap {\n            serialize: bool,\n            serialize_seq: bool,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n    #[serde(rename_all = \"PascalCase\")]\n    struct S {\n        serialize: bool,\n        serialize_seq: bool,\n    }\n\n    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n    #[serde(rename_all = \"SCREAMING-KEBAB-CASE\")]\n    struct ScreamingKebab {\n        serialize: bool,\n        serialize_seq: bool,\n    }\n\n    assert_tokens(\n        &E::Serialize {\n            serialize: true,\n            serialize_seq: true,\n        },\n        &[\n            Token::StructVariant {\n                name: \"E\",\n                variant: \"serialize\",\n                len: 2,\n            },\n            Token::Str(\"serialize\"),\n            Token::Bool(true),\n            Token::Str(\"serializeSeq\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        &E::SerializeSeq {\n            serialize: true,\n            serialize_seq: true,\n        },\n        &[\n            Token::StructVariant {\n                name: \"E\",\n                variant: \"serialize_seq\",\n                len: 2,\n            },\n            Token::Str(\"serialize\"),\n            Token::Bool(true),\n            Token::Str(\"serialize-seq\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        &E::SerializeMap {\n            serialize: true,\n            serialize_seq: true,\n        },\n        &[\n            Token::StructVariant {\n                name: \"E\",\n                variant: \"serialize_map\",\n                len: 2,\n            },\n            Token::Str(\"SERIALIZE\"),\n            Token::Bool(true),\n            Token::Str(\"SERIALIZE_SEQ\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        &S {\n            serialize: true,\n            serialize_seq: true,\n        },\n        &[\n            Token::Struct { name: \"S\", len: 2 },\n            Token::Str(\"Serialize\"),\n            Token::Bool(true),\n            Token::Str(\"SerializeSeq\"),\n            Token::Bool(true),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_tokens(\n        &ScreamingKebab {\n            serialize: true,\n            serialize_seq: true,\n        },\n        &[\n            Token::Struct {\n                name: \"ScreamingKebab\",\n                len: 2,\n            },\n            Token::Str(\"SERIALIZE\"),\n            Token::Bool(true),\n            Token::Str(\"SERIALIZE-SEQ\"),\n            Token::Bool(true),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_newtype_variant_containing_unit_struct_not_map() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Unit;\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum Message {\n        Unit(Unit),\n        Map(BTreeMap<String, String>),\n    }\n\n    assert_tokens(\n        &Message::Map(BTreeMap::new()),\n        &[Token::Map { len: Some(0) }, Token::MapEnd],\n    );\n}\n\n#[test]\nfn test_internally_tagged_newtype_variant_containing_unit_struct() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Info;\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"topic\")]\n    enum Message {\n        Info(Info),\n    }\n\n    assert_tokens(\n        &Message::Info(Info),\n        &[\n            Token::Map { len: Some(1) },\n            Token::Str(\"topic\"),\n            Token::Str(\"Info\"),\n            Token::MapEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_remote.rs"],"content":"#![allow(clippy::redundant_field_names)]\n\nuse serde::{Deserialize, Serialize};\n\nmod remote {\n    pub struct Unit;\n\n    pub struct PrimitivePriv(u8);\n\n    pub struct PrimitivePub(pub u8);\n\n    pub struct NewtypePriv(Unit);\n\n    pub struct NewtypePub(pub Unit);\n\n    pub struct TuplePriv(u8, Unit);\n\n    pub struct TuplePub(pub u8, pub Unit);\n\n    pub struct StructPriv {\n        a: u8,\n        b: Unit,\n    }\n\n    pub struct StructPub {\n        pub a: u8,\n        pub b: Unit,\n    }\n\n    impl PrimitivePriv {\n        pub fn new(a: u8) -> Self {\n            PrimitivePriv(a)\n        }\n\n        pub fn get(&self) -> u8 {\n            self.0\n        }\n    }\n\n    impl NewtypePriv {\n        pub fn new(a: Unit) -> Self {\n            NewtypePriv(a)\n        }\n\n        pub fn get(&self) -> &Unit {\n            &self.0\n        }\n    }\n\n    impl TuplePriv {\n        pub fn new(a: u8, b: Unit) -> Self {\n            TuplePriv(a, b)\n        }\n\n        pub fn first(&self) -> u8 {\n            self.0\n        }\n\n        pub fn second(&self) -> &Unit {\n            &self.1\n        }\n    }\n\n    impl StructPriv {\n        pub fn new(a: u8, b: Unit) -> Self {\n            StructPriv { a: a, b: b }\n        }\n\n        pub fn a(&self) -> u8 {\n            self.a\n        }\n\n        pub fn b(&self) -> &Unit {\n            &self.b\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize)]\nstruct Test {\n    #[serde(with = \"UnitDef\")]\n    unit: remote::Unit,\n\n    #[serde(with = \"PrimitivePrivDef\")]\n    primitive_priv: remote::PrimitivePriv,\n\n    #[serde(with = \"PrimitivePubDef\")]\n    primitive_pub: remote::PrimitivePub,\n\n    #[serde(with = \"NewtypePrivDef\")]\n    newtype_priv: remote::NewtypePriv,\n\n    #[serde(with = \"NewtypePubDef\")]\n    newtype_pub: remote::NewtypePub,\n\n    #[serde(with = \"TuplePrivDef\")]\n    tuple_priv: remote::TuplePriv,\n\n    #[serde(with = \"TuplePubDef\")]\n    tuple_pub: remote::TuplePub,\n\n    #[serde(with = \"StructPrivDef\")]\n    struct_priv: remote::StructPriv,\n\n    #[serde(with = \"StructPubDef\")]\n    struct_pub: remote::StructPub,\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::Unit\")]\nstruct UnitDef;\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::PrimitivePriv\")]\nstruct PrimitivePrivDef(#[serde(getter = \"remote::PrimitivePriv::get\")] u8);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::PrimitivePub\")]\nstruct PrimitivePubDef(u8);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::NewtypePriv\")]\nstruct NewtypePrivDef(#[serde(getter = \"remote::NewtypePriv::get\", with = \"UnitDef\")] remote::Unit);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::NewtypePub\")]\nstruct NewtypePubDef(#[serde(with = \"UnitDef\")] remote::Unit);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::TuplePriv\")]\nstruct TuplePrivDef(\n    #[serde(getter = \"remote::TuplePriv::first\")] u8,\n    #[serde(getter = \"remote::TuplePriv::second\", with = \"UnitDef\")] remote::Unit,\n);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::TuplePub\")]\nstruct TuplePubDef(u8, #[serde(with = \"UnitDef\")] remote::Unit);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::StructPriv\")]\nstruct StructPrivDef {\n    #[serde(getter = \"remote::StructPriv::a\")]\n    a: u8,\n\n    #[serde(getter = \"remote::StructPriv::b\")]\n    #[serde(with = \"UnitDef\")]\n    b: remote::Unit,\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::StructPub\")]\nstruct StructPubDef {\n    a: u8,\n\n    #[serde(with = \"UnitDef\")]\n    b: remote::Unit,\n}\n\nimpl From<PrimitivePrivDef> for remote::PrimitivePriv {\n    fn from(def: PrimitivePrivDef) -> Self {\n        remote::PrimitivePriv::new(def.0)\n    }\n}\n\nimpl From<NewtypePrivDef> for remote::NewtypePriv {\n    fn from(def: NewtypePrivDef) -> Self {\n        remote::NewtypePriv::new(def.0)\n    }\n}\n\nimpl From<TuplePrivDef> for remote::TuplePriv {\n    fn from(def: TuplePrivDef) -> Self {\n        remote::TuplePriv::new(def.0, def.1)\n    }\n}\n\nimpl From<StructPrivDef> for remote::StructPriv {\n    fn from(def: StructPrivDef) -> Self {\n        remote::StructPriv::new(def.a, def.b)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_roundtrip.rs"],"content":"use serde_test::{assert_tokens, Configure, Token};\n\nuse std::net;\n\n#[macro_use]\n#[allow(unused_macros)]\nmod macros;\n\n#[test]\nfn ip_addr_roundtrip() {\n    assert_tokens(\n        &net::IpAddr::from(*b\"1234\").compact(),\n        &seq![\n            Token::NewtypeVariant { name: \"IpAddr\", variant: \"V4\" },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd,\n        ],\n    );\n}\n\n#[test]\nfn socket_addr_roundtrip() {\n    assert_tokens(\n        &net::SocketAddr::from((*b\"1234567890123456\", 1234)).compact(),\n        &seq![\n            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V6\" },\n\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_ser.rs"],"content":"#![allow(clippy::unreadable_literal)]\n#![cfg_attr(feature = \"unstable\", feature(never_type))]\n\nuse std::cell::RefCell;\nuse std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\nuse std::ffi::CString;\nuse std::mem;\nuse std::net;\nuse std::num::Wrapping;\nuse std::ops::Bound;\nuse std::path::{Path, PathBuf};\nuse std::rc::{Rc, Weak as RcWeak};\nuse std::sync::atomic::{\n    AtomicBool, AtomicI16, AtomicI32, AtomicI8, AtomicIsize, AtomicU16, AtomicU32, AtomicU8,\n    AtomicUsize,\n};\nuse std::sync::{Arc, Weak as ArcWeak};\nuse std::time::{Duration, UNIX_EPOCH};\n\n#[cfg(unix)]\nuse std::str;\n#[cfg(target_arch = \"x86_64\")]\nuse std::sync::atomic::{AtomicI64, AtomicU64};\n\nuse fnv::FnvHasher;\nuse serde::Serialize;\nuse serde_test::{assert_ser_tokens, assert_ser_tokens_error, Configure, Token};\n\n#[macro_use]\nmod macros;\n\n//////////////////////////////////////////////////////////////////////////\n\n#[derive(Serialize)]\nstruct UnitStruct;\n\n#[derive(Serialize)]\nstruct TupleStruct(i32, i32, i32);\n\n#[derive(Serialize)]\nstruct Struct {\n    a: i32,\n    b: i32,\n    c: i32,\n}\n\n#[derive(Serialize, PartialEq, Debug)]\nenum Enum {\n    Unit,\n    One(i32),\n    Seq(i32, i32),\n    Map {\n        a: i32,\n        b: i32,\n    },\n    #[serde(skip_serializing)]\n    SkippedUnit,\n    #[serde(skip_serializing)]\n    SkippedOne(i32),\n    #[serde(skip_serializing)]\n    SkippedSeq(i32, i32),\n    #[serde(skip_serializing)]\n    SkippedMap {\n        _a: i32,\n        _b: i32,\n    },\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nmacro_rules! declare_tests {\n    (\n        $readable:tt\n        $($name:ident { $($value:expr => $tokens:expr,)+ })+\n    ) => {\n        $(\n            #[test]\n            fn $name() {\n                $(\n                    assert_ser_tokens(&$value.$readable(), $tokens);\n                )+\n            }\n        )+\n    };\n\n    ($($name:ident { $($value:expr => $tokens:expr,)+ })+) => {\n        $(\n            #[test]\n            fn $name() {\n                $(\n                    assert_ser_tokens(&$value, $tokens);\n                )+\n            }\n        )+\n    }\n}\n\ndeclare_tests! {\n    test_unit {\n        () => &[Token::Unit],\n    }\n    test_bool {\n        true => &[Token::Bool(true)],\n        false => &[Token::Bool(false)],\n    }\n    test_isizes {\n        0i8 => &[Token::I8(0)],\n        0i16 => &[Token::I16(0)],\n        0i32 => &[Token::I32(0)],\n        0i64 => &[Token::I64(0)],\n    }\n    test_usizes {\n        0u8 => &[Token::U8(0)],\n        0u16 => &[Token::U16(0)],\n        0u32 => &[Token::U32(0)],\n        0u64 => &[Token::U64(0)],\n    }\n    test_floats {\n        0f32 => &[Token::F32(0.)],\n        0f64 => &[Token::F64(0.)],\n    }\n    test_char {\n        'a' => &[Token::Char('a')],\n    }\n    test_str {\n        \"abc\" => &[Token::Str(\"abc\")],\n        \"abc\".to_owned() => &[Token::Str(\"abc\")],\n    }\n    test_option {\n        None::<i32> => &[Token::None],\n        Some(1) => &[\n            Token::Some,\n            Token::I32(1),\n        ],\n    }\n    test_result {\n        Ok::<i32, i32>(0) => &[\n            Token::NewtypeVariant { name: \"Result\", variant: \"Ok\" },\n            Token::I32(0),\n        ],\n        Err::<i32, i32>(1) => &[\n            Token::NewtypeVariant { name: \"Result\", variant: \"Err\" },\n            Token::I32(1),\n        ],\n    }\n    test_slice {\n        &[0][..0] => &[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        &[1, 2, 3][..] => &[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n    }\n    test_array {\n        [0; 0] => &[\n            Token::Tuple { len: 0 },\n            Token::TupleEnd,\n        ],\n        [1, 2, 3] => &[\n            Token::Tuple { len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleEnd,\n        ],\n    }\n    test_vec {\n        Vec::<isize>::new() => &[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        vec![vec![], vec![1], vec![2, 3]] => &[\n            Token::Seq { len: Some(3) },\n                Token::Seq { len: Some(0) },\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(1) },\n                    Token::I32(1),\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(2) },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::SeqEnd,\n            Token::SeqEnd,\n        ],\n    }\n    test_btreeset {\n        BTreeSet::<isize>::new() => &[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        btreeset![1] => &[\n            Token::Seq { len: Some(1) },\n                Token::I32(1),\n            Token::SeqEnd,\n        ],\n    }\n    test_hashset {\n        HashSet::<isize>::new() => &[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        hashset![1] => &[\n            Token::Seq { len: Some(1) },\n                Token::I32(1),\n            Token::SeqEnd,\n        ],\n        hashset![FnvHasher @ 1] => &[\n            Token::Seq { len: Some(1) },\n                Token::I32(1),\n            Token::SeqEnd,\n        ],\n    }\n    test_tuple {\n        (1,) => &[\n            Token::Tuple { len: 1 },\n                Token::I32(1),\n            Token::TupleEnd,\n        ],\n        (1, 2, 3) => &[\n            Token::Tuple { len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleEnd,\n        ],\n    }\n    test_btreemap {\n        btreemap![1 => 2] => &[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        btreemap![1 => 2, 3 => 4] => &[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::I32(2),\n\n                Token::I32(3),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n        btreemap![1 => btreemap![], 2 => btreemap![3 => 4, 5 => 6]] => &[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::Map { len: Some(0) },\n                Token::MapEnd,\n\n                Token::I32(2),\n                Token::Map { len: Some(2) },\n                    Token::I32(3),\n                    Token::I32(4),\n\n                    Token::I32(5),\n                    Token::I32(6),\n                Token::MapEnd,\n            Token::MapEnd,\n        ],\n    }\n    test_hashmap {\n        HashMap::<isize, isize>::new() => &[\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n        ],\n        hashmap![1 => 2] => &[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        hashmap![FnvHasher @ 1 => 2] => &[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n    }\n    test_unit_struct {\n        UnitStruct => &[Token::UnitStruct { name: \"UnitStruct\" }],\n    }\n    test_tuple_struct {\n        TupleStruct(1, 2, 3) => &[\n            Token::TupleStruct { name: \"TupleStruct\", len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n    }\n    test_struct {\n        Struct { a: 1, b: 2, c: 3 } => &[\n            Token::Struct { name: \"Struct\", len: 3 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n\n                Token::Str(\"c\"),\n                Token::I32(3),\n            Token::StructEnd,\n        ],\n    }\n    test_enum {\n        Enum::Unit => &[Token::UnitVariant { name: \"Enum\", variant: \"Unit\" }],\n        Enum::One(42) => &[Token::NewtypeVariant { name: \"Enum\", variant: \"One\" }, Token::I32(42)],\n        Enum::Seq(1, 2) => &[\n            Token::TupleVariant { name: \"Enum\", variant: \"Seq\", len: 2 },\n                Token::I32(1),\n                Token::I32(2),\n            Token::TupleVariantEnd,\n        ],\n        Enum::Map { a: 1, b: 2 } => &[\n            Token::StructVariant { name: \"Enum\", variant: \"Map\", len: 2 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n            Token::StructVariantEnd,\n        ],\n    }\n    test_box {\n        Box::new(0i32) => &[Token::I32(0)],\n    }\n    test_boxed_slice {\n        Box::new([0, 1, 2]) => &[\n            Token::Tuple { len: 3 },\n            Token::I32(0),\n            Token::I32(1),\n            Token::I32(2),\n            Token::TupleEnd,\n        ],\n    }\n    test_duration {\n        Duration::new(1, 2) => &[\n            Token::Struct { name: \"Duration\", len: 2 },\n                Token::Str(\"secs\"),\n                Token::U64(1),\n\n                Token::Str(\"nanos\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n    }\n    test_system_time {\n        UNIX_EPOCH + Duration::new(1, 200) => &[\n            Token::Struct { name: \"SystemTime\", len: 2 },\n                Token::Str(\"secs_since_epoch\"),\n                Token::U64(1),\n\n                Token::Str(\"nanos_since_epoch\"),\n                Token::U32(200),\n            Token::StructEnd,\n        ],\n    }\n    test_range {\n        1u32..2u32 => &[\n            Token::Struct { name: \"Range\", len: 2 },\n                Token::Str(\"start\"),\n                Token::U32(1),\n\n                Token::Str(\"end\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n    }\n    test_range_inclusive {\n        1u32..=2u32 => &[\n            Token::Struct { name: \"RangeInclusive\", len: 2 },\n                Token::Str(\"start\"),\n                Token::U32(1),\n\n                Token::Str(\"end\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n    }\n    test_bound {\n        Bound::Unbounded::<()> => &[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Unbounded\"),\n            Token::Unit,\n        ],\n        Bound::Included(0u8) => &[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Included\"),\n            Token::U8(0),\n        ],\n        Bound::Excluded(0u8) => &[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Excluded\"),\n            Token::U8(0),\n        ],\n    }\n    test_path {\n        Path::new(\"/usr/local/lib\") => &[\n            Token::Str(\"/usr/local/lib\"),\n        ],\n    }\n    test_path_buf {\n        PathBuf::from(\"/usr/local/lib\") => &[\n            Token::Str(\"/usr/local/lib\"),\n        ],\n    }\n    test_cstring {\n        CString::new(\"abc\").unwrap() => &[\n            Token::Bytes(b\"abc\"),\n        ],\n    }\n    test_cstr {\n        (&*CString::new(\"abc\").unwrap()) => &[\n            Token::Bytes(b\"abc\"),\n        ],\n    }\n    test_rc {\n        Rc::new(true) => &[\n            Token::Bool(true),\n        ],\n    }\n    test_rc_weak_some {\n        {\n            let rc = Rc::new(true);\n            mem::forget(rc.clone());\n            Rc::downgrade(&rc)\n        } => &[\n            Token::Some,\n            Token::Bool(true),\n        ],\n    }\n    test_rc_weak_none {\n        RcWeak::<bool>::new() => &[\n            Token::None,\n        ],\n    }\n    test_arc {\n        Arc::new(true) => &[\n            Token::Bool(true),\n        ],\n    }\n    test_arc_weak_some {\n        {\n            let arc = Arc::new(true);\n            mem::forget(arc.clone());\n            Arc::downgrade(&arc)\n        } => &[\n            Token::Some,\n            Token::Bool(true),\n        ],\n    }\n    test_arc_weak_none {\n        ArcWeak::<bool>::new() => &[\n            Token::None,\n        ],\n    }\n    test_wrapping {\n        Wrapping(1usize) => &[\n            Token::U64(1),\n        ],\n    }\n    test_rc_dst {\n        Rc::<str>::from(\"s\") => &[\n            Token::Str(\"s\"),\n        ],\n        Rc::<[bool]>::from(&[true][..]) => &[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n    }\n    test_arc_dst {\n        Arc::<str>::from(\"s\") => &[\n            Token::Str(\"s\"),\n        ],\n        Arc::<[bool]>::from(&[true][..]) => &[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n    }\n    test_fmt_arguments {\n        format_args!(\"{}{}\", 1, 'a') => &[\n            Token::Str(\"1a\"),\n        ],\n    }\n    test_atomic {\n        AtomicBool::new(false) => &[Token::Bool(false)],\n        AtomicBool::new(true) => &[Token::Bool(true)],\n        AtomicI8::new(63i8) => &[Token::I8(63i8)],\n        AtomicI16::new(-318i16) => &[Token::I16(-318i16)],\n        AtomicI32::new(65792i32) => &[Token::I32(65792i32)],\n        AtomicIsize::new(-65792isize) => &[Token::I64(-65792i64)],\n        AtomicU8::new(192u8) => &[Token::U8(192u8)],\n        AtomicU16::new(510u16) => &[Token::U16(510u16)],\n        AtomicU32::new(131072u32) => &[Token::U32(131072u32)],\n        AtomicUsize::new(655360usize) => &[Token::U64(655360u64)],\n    }\n}\n\n#[cfg(target_arch = \"x86_64\")]\ndeclare_tests! {\n    test_atomic64 {\n        AtomicI64::new(-4295032832i64) => &[Token::I64(-4295032832i64)],\n        AtomicU64::new(12884901888u64) => &[Token::U64(12884901888u64)],\n    }\n}\n\ndeclare_tests! {\n    readable\n\n    test_net_ipv4addr_readable {\n        \"1.2.3.4\".parse::<net::Ipv4Addr>().unwrap() => &[Token::Str(\"1.2.3.4\")],\n    }\n    test_net_ipv6addr_readable {\n        \"::1\".parse::<net::Ipv6Addr>().unwrap() => &[Token::Str(\"::1\")],\n    }\n    test_net_ipaddr_readable {\n        \"1.2.3.4\".parse::<net::IpAddr>().unwrap() => &[Token::Str(\"1.2.3.4\")],\n    }\n    test_net_socketaddr_readable {\n        \"1.2.3.4:1234\".parse::<net::SocketAddr>().unwrap() => &[Token::Str(\"1.2.3.4:1234\")],\n        \"1.2.3.4:1234\".parse::<net::SocketAddrV4>().unwrap() => &[Token::Str(\"1.2.3.4:1234\")],\n        \"[::1]:1234\".parse::<net::SocketAddrV6>().unwrap() => &[Token::Str(\"[::1]:1234\")],\n    }\n}\n\ndeclare_tests! {\n    compact\n\n    test_net_ipv4addr_compact {\n        net::Ipv4Addr::from(*b\"1234\") => &seq![\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd,\n        ],\n    }\n    test_net_ipv6addr_compact {\n        net::Ipv6Addr::from(*b\"1234567890123456\") => &seq![\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd,\n        ],\n    }\n    test_net_ipaddr_compact {\n        net::IpAddr::from(*b\"1234\") => &seq![\n            Token::NewtypeVariant { name: \"IpAddr\", variant: \"V4\" },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd,\n        ],\n    }\n    test_net_socketaddr_compact {\n        net::SocketAddr::from((*b\"1234567890123456\", 1234)) => &seq![\n            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V6\" },\n\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd,\n        ],\n        net::SocketAddrV4::new(net::Ipv4Addr::from(*b\"1234\"), 1234) => &seq![\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd,\n        ],\n        net::SocketAddrV6::new(net::Ipv6Addr::from(*b\"1234567890123456\"), 1234, 0, 0) => &seq![\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd,\n        ],\n    }\n}\n\n#[cfg(feature = \"unstable\")]\ndeclare_tests! {\n    test_never_result {\n        Ok::<u8, !>(0) => &[\n            Token::NewtypeVariant { name: \"Result\", variant: \"Ok\" },\n            Token::U8(0),\n        ],\n    }\n}\n\n#[test]\n#[cfg(unix)]\nfn test_cannot_serialize_paths() {\n    let path = unsafe { str::from_utf8_unchecked(b\"Hello \\xF0\\x90\\x80World\") };\n    assert_ser_tokens_error(\n        &Path::new(path),\n        &[],\n        \"path contains invalid UTF-8 characters\",\n    );\n\n    let mut path_buf = PathBuf::new();\n    path_buf.push(path);\n\n    assert_ser_tokens_error(&path_buf, &[], \"path contains invalid UTF-8 characters\");\n}\n\n#[test]\nfn test_cannot_serialize_mutably_borrowed_ref_cell() {\n    let ref_cell = RefCell::new(42);\n    let _reference = ref_cell.borrow_mut();\n    assert_ser_tokens_error(&ref_cell, &[], \"already mutably borrowed\");\n}\n\n#[test]\nfn test_enum_skipped() {\n    assert_ser_tokens_error(\n        &Enum::SkippedUnit,\n        &[],\n        \"the enum variant Enum::SkippedUnit cannot be serialized\",\n    );\n    assert_ser_tokens_error(\n        &Enum::SkippedOne(42),\n        &[],\n        \"the enum variant Enum::SkippedOne cannot be serialized\",\n    );\n    assert_ser_tokens_error(\n        &Enum::SkippedSeq(1, 2),\n        &[],\n        \"the enum variant Enum::SkippedSeq cannot be serialized\",\n    );\n    assert_ser_tokens_error(\n        &Enum::SkippedMap { _a: 1, _b: 2 },\n        &[],\n        \"the enum variant Enum::SkippedMap cannot be serialized\",\n    );\n}\n\n#[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n#[test]\nfn test_integer128() {\n    assert_ser_tokens_error(&1i128, &[], \"i128 is not supported\");\n\n    assert_ser_tokens_error(&1u128, &[], \"u128 is not supported\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_serde_path.rs"],"content":"#[test]\nfn test_gen_custom_serde() {\n    #[derive(serde::Serialize, serde::Deserialize)]\n    #[serde(crate = \"fake_serde\")]\n    struct Foo;\n\n    // Would be overlapping if serde::Serialize were implemented\n    impl AssertNotSerdeSerialize for Foo {}\n    // Would be overlapping if serde::Deserialize were implemented\n    impl<'a> AssertNotSerdeDeserialize<'a> for Foo {}\n\n    fake_serde::assert::<Foo>();\n}\n\nmod fake_serde {\n    pub use serde::*;\n\n    pub fn assert<T>()\n    where\n        T: Serialize,\n        T: for<'a> Deserialize<'a>,\n    {\n    }\n\n    pub trait Serialize {\n        fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error>;\n    }\n\n    pub trait Deserialize<'a>: Sized {\n        fn deserialize<D: Deserializer<'a>>(deserializer: D) -> Result<Self, D::Error>;\n    }\n}\n\ntrait AssertNotSerdeSerialize {}\n\nimpl<T: serde::Serialize> AssertNotSerdeSerialize for T {}\n\ntrait AssertNotSerdeDeserialize<'a> {}\n\nimpl<'a, T: serde::Deserialize<'a>> AssertNotSerdeDeserialize<'a> for T {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_unstable.rs"],"content":"#![deny(warnings)]\n\n// This test target is convoluted with the actual #[test] in a separate file to\n// get it so that the stable compiler does not need to parse the code of the\n// test. If the test were written with #[cfg(feature = \"unstable\")] #[test]\n// right here, the stable compiler would fail to parse those raw identifiers\n// even if the cfg were not enabled.\n#[cfg(feature = \"unstable\")]\nmod unstable;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_value.rs"],"content":"use serde::de::value::{self, MapAccessDeserializer};\nuse serde::de::{IntoDeserializer, MapAccess, Visitor};\nuse serde::{Deserialize, Deserializer};\nuse serde_test::{assert_de_tokens, Token};\nuse std::fmt;\n\n#[test]\nfn test_u32_to_enum() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    enum E {\n        A,\n        B,\n    }\n\n    let deserializer = IntoDeserializer::<value::Error>::into_deserializer(1u32);\n    let e: E = E::deserialize(deserializer).unwrap();\n    assert_eq!(E::B, e);\n}\n\n#[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n#[test]\nfn test_integer128() {\n    let de_u128 = IntoDeserializer::<value::Error>::into_deserializer(1u128);\n    let de_i128 = IntoDeserializer::<value::Error>::into_deserializer(1i128);\n\n    // u128 to u128\n    assert_eq!(1u128, u128::deserialize(de_u128).unwrap());\n\n    // u128 to i128\n    assert_eq!(1i128, i128::deserialize(de_u128).unwrap());\n\n    // i128 to u128\n    assert_eq!(1u128, u128::deserialize(de_i128).unwrap());\n\n    // i128 to i128\n    assert_eq!(1i128, i128::deserialize(de_i128).unwrap());\n}\n\n#[test]\nfn test_map_access_to_enum() {\n    #[derive(PartialEq, Debug)]\n    struct Potential(PotentialKind);\n\n    #[derive(PartialEq, Debug, Deserialize)]\n    enum PotentialKind {\n        Airebo(Airebo),\n    }\n\n    #[derive(PartialEq, Debug, Deserialize)]\n    struct Airebo {\n        lj_sigma: f64,\n    }\n\n    impl<'de> Deserialize<'de> for Potential {\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            struct PotentialVisitor;\n\n            impl<'de> Visitor<'de> for PotentialVisitor {\n                type Value = Potential;\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    write!(formatter, \"a map\")\n                }\n\n                fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>\n                where\n                    A: MapAccess<'de>,\n                {\n                    Deserialize::deserialize(MapAccessDeserializer::new(map)).map(Potential)\n                }\n            }\n\n            deserializer.deserialize_any(PotentialVisitor)\n        }\n    }\n\n    let expected = Potential(PotentialKind::Airebo(Airebo { lj_sigma: 14.0 }));\n\n    assert_de_tokens(\n        &expected,\n        &[\n            Token::Map { len: Some(1) },\n            Token::Str(\"Airebo\"),\n            Token::Map { len: Some(1) },\n            Token::Str(\"lj_sigma\"),\n            Token::F64(14.0),\n            Token::MapEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","bad_lifetimes.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test<'a> {\n    #[serde(borrow = \"zzz\")]\n    s: &'a str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","duplicate_lifetime.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test<'a> {\n    #[serde(borrow = \"'a + 'a\")]\n    s: &'a str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","duplicate_variant.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Str<'a>(&'a str);\n\n#[derive(Deserialize)]\nenum Test<'a> {\n    #[serde(borrow)]\n    S(#[serde(borrow)] Str<'a>),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","empty_lifetimes.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test<'a> {\n    #[serde(borrow = \"\")]\n    s: &'a str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","no_lifetimes.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test {\n    #[serde(borrow)]\n    s: String,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","struct_variant.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Str<'a>(&'a str);\n\n#[derive(Deserialize)]\nenum Test<'a> {\n    #[serde(borrow)]\n    S { s: Str<'a> },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","wrong_lifetime.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test<'a> {\n    #[serde(borrow = \"'b\")]\n    s: &'a str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","adjacent-tag.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"conflict\", content = \"conflict\")]\nenum E {\n    A,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","flatten-newtype-struct.rs"],"content":"use serde_derive::Serialize;\n\nuse std::collections::HashMap;\n\n#[derive(Serialize)]\nstruct Foo(#[serde(flatten)] HashMap<String, String>);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","flatten-tuple-struct.rs"],"content":"use serde_derive::Serialize;\n\nuse std::collections::HashMap;\n\n#[derive(Serialize)]\nstruct Foo(u32, #[serde(flatten)] HashMap<String, String>);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","from-try-from.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(from = \"u64\", try_from = \"u64\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","internal-tag-alias.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"conflict\")]\nenum E {\n    A {\n        #[serde(alias = \"conflict\")]\n        x: (),\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","internal-tag.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"conflict\")]\nenum E {\n    A {\n        #[serde(rename = \"conflict\")]\n        x: (),\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","default-attribute","enum.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default)]\nenum E {\n    S { f: u8 },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","default-attribute","enum_path.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default = \"default_e\")]\nenum E {\n    S { f: u8 },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","default-attribute","nameless_struct_fields.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default)]\nstruct T(u8, u8);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","default-attribute","nameless_struct_fields_path.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default = \"default_t\")]\nstruct T(u8, u8);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","rename-and-ser.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = \"x\", serialize = \"y\")]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","rename-ser-rename-ser.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(serialize = \"x\"), rename(serialize = \"y\"))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","rename-ser-rename.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(serialize = \"x\"))]\n    #[serde(rename = \"y\")]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","rename-ser-ser.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(serialize = \"x\", serialize = \"y\"))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","two-rename-ser.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(serialize = \"x\"))]\n    #[serde(rename(serialize = \"y\"))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","with-and-serialize-with.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(with = \"w\", serialize_with = \"s\")]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","content-no-tag.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(content = \"c\")]\nenum E {\n    A(u8),\n    B(String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","internal-tuple-variant.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"type\")]\nenum E {\n    Tuple(u8, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","untagged-and-adjacent.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(untagged)]\n#[serde(tag = \"t\", content = \"c\")]\nenum E {\n    A(u8),\n    B(String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","untagged-and-content.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(untagged)]\n#[serde(content = \"c\")]\nenum E {\n    A(u8),\n    B(String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","untagged-and-internal.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(untagged)]\n#[serde(tag = \"type\")]\nenum E {\n    A(u8),\n    B(String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","untagged-struct.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(untagged)]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","boolean.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = true)]\n    boolean: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","byte_character.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = b'a')]\n    byte_character: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","byte_string.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = b\"byte string\")]\n    byte_string: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","character.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = 'a')]\n    character: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","float.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = 3.14)]\n    float: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","integer.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = 100)]\n    integer: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","both.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier, variant_identifier)]\nenum F {\n    A,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","field_struct.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","field_tuple.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    B(u8, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","newtype_not_last.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    Other(String),\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","not_unit.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    #[serde(other)]\n    Other(u8, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","other_not_last.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    #[serde(other)]\n    Other,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","other_untagged.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(untagged)]\nenum F {\n    #[serde(other)]\n    Other,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","other_variant.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(variant_identifier)]\nenum F {\n    #[serde(other)]\n    Other,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","variant_struct.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(variant_identifier)]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","variant_tuple.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(variant_identifier)]\nenum F {\n    A,\n    B(u8, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","malformed","bound.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(bound(unknown))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","malformed","rename.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(unknown))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","precondition","deserialize_de_lifetime.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct S<'de> {\n    s: &'de str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","precondition","deserialize_dst.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct S {\n    string: String,\n    slice: [u8],\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","precondition","serialize_field_identifier.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","precondition","serialize_variant_identifier.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(variant_identifier)]\nenum F {\n    A,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","bad_getter.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub struct S {\n        a: u8,\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    #[serde(getter = \"~~~\")]\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","bad_remote.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub struct S {\n        a: u8,\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"~~~\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","enum_getter.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub enum E {\n        A { a: u8 },\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::E\")]\npub enum E {\n    A {\n        #[serde(getter = \"get_a\")]\n        a: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","missing_field.rs"],"content":"use serde_derive::{Serialize, Deserialize};\n\nmod remote {\n    pub struct S {\n        pub a: u8,\n        pub b: u8,\n    }\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","nonremote_getter.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(getter = \"S::get\")]\n    a: u8,\n}\n\nimpl S {\n    fn get(&self) -> u8 {\n        self.a\n    }\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","unknown_field.rs"],"content":"use serde_derive::{Serialize, Deserialize};\n\nmod remote {\n    pub struct S {\n        pub a: u8,\n    }\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    b: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","wrong_de.rs"],"content":"use serde_derive::Deserialize;\n\nmod remote {\n    pub struct S(pub u16);\n}\n\n#[derive(Deserialize)]\n#[serde(remote = \"remote::S\")]\nstruct S(u8);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","wrong_getter.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub struct S {\n        a: u8,\n    }\n\n    impl S {\n        pub fn get(&self) -> u16 {\n            self.a as u16\n        }\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    #[serde(getter = \"remote::S::get\")]\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","wrong_ser.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub struct S {\n        pub a: u16,\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","rename","container_unknown_rename_rule.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(rename_all = \"abc\")]\nstruct S {\n    name: u8,\n    long_name: u8,\n    very_long_name: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","rename","variant_unknown_rename_rule.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum S {\n    #[serde(rename_all = \"abc\")]\n    V {\n        name: u8,\n        long_name: u8,\n        very_long_name: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","struct-representation","internally-tagged-tuple.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"type\")]\nstruct S(u8, u8);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","struct-representation","internally-tagged-unit.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"type\")]\nstruct U;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","at_most_one.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nstruct S {\n    a: u8,\n    b: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","de_at_least_one.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(transparent)]\nstruct S {\n    #[serde(skip)]\n    a: u8,\n    #[serde(default)]\n    b: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","enum.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nenum E {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","ser_at_least_one.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nstruct S {\n    #[serde(skip)]\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","unit_struct.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","with_from.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent, from = \"u64\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","with_into.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent, into = \"u64\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","with_try_from.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent, try_from = \"u64\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","type-attribute","from.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(from = \"Option<T\")]\nenum TestOne {\n    Testing,\n    One,\n    Two,\n    Three,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","type-attribute","into.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(into = \"Option<T\")]\nenum TestOne {\n    Testing,\n    One,\n    Two,\n    Three,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","type-attribute","try_from.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(try_from = \"Option<T\")]\nenum TestOne {\n    Testing,\n    One,\n    Two,\n    Three,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unexpected-literal","container.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(\"literal\")]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unexpected-literal","field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(\"literal\")]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unexpected-literal","variant.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum E {\n    #[serde(\"literal\")]\n    V,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unknown-attribute","container.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(abc = \"xyz\")]\nstruct A {\n    x: u32,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unknown-attribute","field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct C {\n    #[serde(abc = \"xyz\")]\n    x: u32,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unknown-attribute","variant.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum E {\n    #[serde(abc = \"xyz\")]\n    V,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unsupported","union_de.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nunion Union {\n    x: u8,\n    y: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unsupported","union_ser.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nunion Union {\n    x: u8,\n    y: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_de_newtype_field.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nenum Enum {\n    #[serde(deserialize_with = \"deserialize_some_newtype_variant\")]\n    Newtype(#[serde(skip_deserializing)] String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_de_struct_field.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nenum Enum {\n    #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n    Struct {\n        #[serde(skip_deserializing)]\n        f1: String,\n        f2: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_de_tuple_field.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nenum Enum {\n    #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n    Tuple(#[serde(skip_deserializing)] String, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_de_whole_variant.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nenum Enum {\n    #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n    #[serde(skip_deserializing)]\n    Unit,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_newtype_field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n    Newtype(#[serde(skip_serializing)] String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_newtype_field_if.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n    Newtype(#[serde(skip_serializing_if = \"always\")] String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_struct_field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_other_variant\")]\n    Struct {\n        #[serde(skip_serializing)]\n        f1: String,\n        f2: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_struct_field_if.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n    Struct {\n        #[serde(skip_serializing_if = \"always\")]\n        f1: String,\n        f2: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_tuple_field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_other_variant\")]\n    Tuple(#[serde(skip_serializing)] String, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_tuple_field_if.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_other_variant\")]\n    Tuple(#[serde(skip_serializing_if = \"always\")] String, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_whole_variant.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_unit_variant\")]\n    #[serde(skip_serializing)]\n    Unit,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","unstable","mod.rs"],"content":"use serde::{Deserialize, Serialize};\nuse serde_test::{assert_tokens, Token};\n\n#[test]\nfn test_raw_identifiers() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[allow(non_camel_case_types)]\n    enum r#type {\n        r#type { r#type: () },\n    }\n\n    assert_tokens(\n        &r#type::r#type { r#type: () },\n        &[\n            Token::StructVariant {\n                name: \"type\",\n                variant: \"type\",\n                len: 1,\n            },\n            Token::Str(\"type\"),\n            Token::Unit,\n            Token::StructVariantEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","src","impls.rs"],"content":"use crate::{OpenapiSchema, OpenapiType};\n#[cfg(feature = \"chrono\")]\nuse chrono::{offset::TimeZone, Date, DateTime, NaiveDate, NaiveDateTime};\nuse indexmap::{IndexMap, IndexSet};\nuse openapiv3::{\n\tAdditionalProperties, ArrayType, IntegerType, NumberFormat, NumberType, ObjectType, ReferenceOr, SchemaKind,\n\tStringFormat, StringType, Type, VariantOrUnknownOrEmpty\n};\nuse serde_json::Value;\nuse std::{\n\tcollections::{BTreeMap, BTreeSet, HashMap, HashSet},\n\thash::BuildHasher,\n\tnum::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize}\n};\n#[cfg(feature = \"uuid\")]\nuse uuid::Uuid;\n\nmacro_rules! impl_openapi_type {\n\t($($ty:ident $(<$($generic:ident : $bound:path),+>)*),* => $schema:expr) => {\n\t\t$(\n\t\t\timpl $(<$($generic : $bound),+>)* OpenapiType for $ty $(<$($generic),+>)* {\n\t\t\t\tfn schema() -> OpenapiSchema {\n\t\t\t\t\t$schema\n\t\t\t\t}\n\t\t\t}\n\t\t)*\n\t};\n}\n\ntype Unit = ();\nimpl_openapi_type!(Unit => {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Object(ObjectType {\n\t\tadditional_properties: Some(AdditionalProperties::Any(false)),\n\t\t..Default::default()\n\t})))\n});\n\nimpl_openapi_type!(Value => {\n\tOpenapiSchema {\n\t\tnullable: true,\n\t\tname: None,\n\t\tschema: SchemaKind::Any(Default::default()),\n\t\tdependencies: Default::default()\n\t}\n});\n\nimpl_openapi_type!(bool => OpenapiSchema::new(SchemaKind::Type(Type::Boolean {})));\n\n#[inline]\nfn int_schema(minimum: Option<i64>, bits: Option<i64>) -> OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Integer(IntegerType {\n\t\tminimum,\n\t\tformat: bits\n\t\t\t.map(|bits| VariantOrUnknownOrEmpty::Unknown(format!(\"int{}\", bits)))\n\t\t\t.unwrap_or(VariantOrUnknownOrEmpty::Empty),\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(isize => int_schema(None, None));\nimpl_openapi_type!(i8 => int_schema(None, Some(8)));\nimpl_openapi_type!(i16 => int_schema(None, Some(16)));\nimpl_openapi_type!(i32 => int_schema(None, Some(32)));\nimpl_openapi_type!(i64 => int_schema(None, Some(64)));\nimpl_openapi_type!(i128 => int_schema(None, Some(128)));\n\nimpl_openapi_type!(usize => int_schema(Some(0), None));\nimpl_openapi_type!(u8 => int_schema(Some(0), Some(8)));\nimpl_openapi_type!(u16 => int_schema(Some(0), Some(16)));\nimpl_openapi_type!(u32 => int_schema(Some(0), Some(32)));\nimpl_openapi_type!(u64 => int_schema(Some(0), Some(64)));\nimpl_openapi_type!(u128 => int_schema(Some(0), Some(128)));\n\nimpl_openapi_type!(NonZeroUsize => int_schema(Some(1), None));\nimpl_openapi_type!(NonZeroU8 => int_schema(Some(1), Some(8)));\nimpl_openapi_type!(NonZeroU16 => int_schema(Some(1), Some(16)));\nimpl_openapi_type!(NonZeroU32 => int_schema(Some(1), Some(32)));\nimpl_openapi_type!(NonZeroU64 => int_schema(Some(1), Some(64)));\nimpl_openapi_type!(NonZeroU128 => int_schema(Some(1), Some(128)));\n\n#[inline]\nfn float_schema(format: NumberFormat) -> OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Number(NumberType {\n\t\tformat: VariantOrUnknownOrEmpty::Item(format),\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(f32 => float_schema(NumberFormat::Float));\nimpl_openapi_type!(f64 => float_schema(NumberFormat::Double));\n\n#[inline]\nfn str_schema(format: VariantOrUnknownOrEmpty<StringFormat>) -> OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::String(StringType {\n\t\tformat,\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(String, str => str_schema(VariantOrUnknownOrEmpty::Empty));\n\n#[cfg(feature = \"chrono\")]\nimpl_openapi_type!(Date<T: TimeZone>, NaiveDate => {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::Date))\n});\n\n#[cfg(feature = \"chrono\")]\nimpl_openapi_type!(DateTime<T: TimeZone>, NaiveDateTime => {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::DateTime))\n});\n\n#[cfg(feature = \"uuid\")]\nimpl_openapi_type!(Uuid => {\n\tstr_schema(VariantOrUnknownOrEmpty::Unknown(\"uuid\".to_owned()))\n});\n\nimpl_openapi_type!(Option<T: OpenapiType> => {\n\tlet schema = T::schema();\n\tlet mut dependencies = schema.dependencies.clone();\n\tlet schema = match schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\tSchemaKind::AllOf { all_of: vec![reference] }\n\t\t},\n\t\tNone => schema.schema\n\t};\n\n\tOpenapiSchema {\n\t\tnullable: true,\n\t\tname: None,\n\t\tschema,\n\t\tdependencies\n\t}\n});\n\n#[inline]\nfn array_schema<T: OpenapiType>(unique_items: bool) -> OpenapiSchema {\n\tlet schema = T::schema();\n\tlet mut dependencies = schema.dependencies.clone();\n\n\tlet items = match schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\treference\n\t\t},\n\t\tNone => ReferenceOr::Item(Box::new(schema.into_schema()))\n\t};\n\n\tOpenapiSchema {\n\t\tnullable: false,\n\t\tname: None,\n\t\tschema: SchemaKind::Type(Type::Array(ArrayType {\n\t\t\titems,\n\t\t\tmin_items: None,\n\t\t\tmax_items: None,\n\t\t\tunique_items\n\t\t})),\n\t\tdependencies\n\t}\n}\n\nimpl_openapi_type!(Vec<T: OpenapiType> => array_schema::<T>(false));\nimpl_openapi_type!(BTreeSet<T: OpenapiType>, IndexSet<T: OpenapiType>, HashSet<T: OpenapiType, S: BuildHasher> => {\n\tarray_schema::<T>(true)\n});\n\n#[inline]\nfn map_schema<K: OpenapiType, T: OpenapiType>() -> OpenapiSchema {\n\tlet key_schema = K::schema();\n\tlet mut dependencies = key_schema.dependencies.clone();\n\n\tlet keys = match key_schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, key_schema);\n\t\t\treference\n\t\t},\n\t\tNone => ReferenceOr::Item(Box::new(key_schema.into_schema()))\n\t};\n\n\tlet schema = T::schema();\n\tdependencies.extend(schema.dependencies.iter().map(|(k, v)| (k.clone(), v.clone())));\n\n\tlet items = Box::new(match schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\treference\n\t\t},\n\t\tNone => ReferenceOr::Item(schema.into_schema())\n\t});\n\n\tlet mut properties = IndexMap::new();\n\tproperties.insert(\"default\".to_owned(), keys);\n\n\tOpenapiSchema {\n\t\tnullable: false,\n\t\tname: None,\n\t\tschema: SchemaKind::Type(Type::Object(ObjectType {\n\t\t\tproperties,\n\t\t\trequired: vec![\"default\".to_owned()],\n\t\t\tadditional_properties: Some(AdditionalProperties::Schema(items)),\n\t\t\t..Default::default()\n\t\t})),\n\t\tdependencies\n\t}\n}\n\nimpl_openapi_type!(\n\tBTreeMap<K: OpenapiType, T: OpenapiType>,\n\tIndexMap<K: OpenapiType, T: OpenapiType>,\n\tHashMap<K: OpenapiType, T: OpenapiType, S: BuildHasher>\n\t=> map_schema::<K, T>()\n);\n","traces":[{"line":22,"address":[286912],"length":1,"stats":{"Line":43},"fn_name":"schema"},{"line":32,"address":[302054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[301994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[302039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[288295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[288202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[288224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[288288],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[302490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[302599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[302663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[302743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[302823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[302903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[302983],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[303063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[303143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[303239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[303335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[303431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[303527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[295783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[295863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[295959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[296055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[296151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[296247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[303623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[303671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[286919],"length":1,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[340775],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[304071],"length":1,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[286974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[490346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[490427],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[490552,490454],"length":1,"stats":{"Line":4},"fn_name":null},{"line":121,"address":[490559,490481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[490798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[490607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[490850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[491032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[490506],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[491389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[491281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[491293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[491341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[392474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[479188],"length":1,"stats":{"Line":3},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[334712],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":80,"coverable":95},{"path":["/","home","runner","work","openapi_type","openapi_type","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms)]\n#![forbid(unsafe_code)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(clippy::tabs_in_doc_comments))]\n#![doc = r##\"\nThis crate gives static type information for primitives and commonly used types from the standard\nlibrary and a few other commonly used libraries like `chrono` and `uuid`. Also, it provides a\nderive macro for structs and enums to gain access to their static type information at runtime.\n\nThe core of this crate is the [`OpenapiType`] trait. It has one static function,\n[`schema`](OpenapiType::schema), which returns an [`OpenapiSchema`]. This assembles the static\ntype information in a way that is convenient to use for a generated OpenAPI specification, but\ncan also be utilized in other use cases as well.\n\n# Custom Types\nTo gain access to the static type information of your custom types at runtime, the easiest way\nis to use the derive macro:\n\n```rust\n# use openapi_type::OpenapiType;\n#[derive(OpenapiType)]\nstruct FooBar {\n\tfoo: String,\n\tbar: u64\n}\n# let schema = FooBar::schema().into_schema();\n# let schema_json = serde_json::to_value(&schema).unwrap();\n# assert_eq!(schema_json, serde_json::json!({\n#   \"type\": \"object\",\n#   \"title\": \"FooBar\",\n#   \"properties\": {\n#     \"foo\": {\n#       \"type\": \"string\"\n#     },\n#     \"bar\": {\n#       \"type\": \"integer\",\n#       \"format\": \"int64\",\n#       \"minimum\": 0\n#     }\n#   },\n#   \"required\": [\"foo\", \"bar\"]\n# }));\n```\n\n# OpenAPI specification\nUsing above type, running `FooBar::schema().into_schema()` yields\n\n```yaml\ntype: object\ntitle: FooBar\nproperties:\n  foo:\n    type: string\n  bar:\n    type: integer\n    format: int64\n    minimum: 0\nrequired:\n  - foo\n  - bar\n```\n\nNote, however, that this is not sufficient for more complex types. If one of your structs fields\nis a type that has a name (that is, `Type::schema().name` is not `None`), above schema will contain\na reference to that schema. Therefore, always remember to put the\n[`dependencies`](OpenapiSchema::dependencies) into the specification alongside the type you are\ninterested in.\n\"##]\n\npub use indexmap;\npub use openapi_type_derive::OpenapiType;\npub use openapiv3 as openapi;\n\nmod impls;\n#[doc(hidden)]\npub mod private;\n\nuse indexmap::IndexMap;\nuse openapi::{Schema, SchemaData, SchemaKind};\n\n// TODO update the documentation\n/**\nThis struct needs to be available for every type that can be part of an OpenAPI Spec. It is\nalready implemented for primitive types, String, Vec, Option and the like. To have it available\nfor your type, simply derive from [OpenapiType].\n*/\n#[derive(Debug, Clone, PartialEq)]\npub struct OpenapiSchema {\n\t/// The name of this schema. If it is None, the schema will be inlined.\n\tpub name: Option<String>,\n\t/// Whether this particular schema is nullable. Note that there is no guarantee that this will\n\t/// make it into the final specification, it might just be interpreted as a hint to make it\n\t/// an optional parameter.\n\tpub nullable: bool,\n\t/// The actual OpenAPI schema.\n\tpub schema: SchemaKind,\n\t/// Other schemas that this schema depends on. They will be included in the final OpenAPI Spec\n\t/// along with this schema.\n\tpub dependencies: IndexMap<String, OpenapiSchema>\n}\n\nimpl OpenapiSchema {\n\t/// Create a new schema that has no name.\n\tpub fn new(schema: SchemaKind) -> Self {\n\t\tSelf {\n\t\t\tname: None,\n\t\t\tnullable: false,\n\t\t\tschema,\n\t\t\tdependencies: IndexMap::new()\n\t\t}\n\t}\n\n\t/// Convert this schema to a [Schema] that can be serialized to the OpenAPI Spec.\n\tpub fn into_schema(self) -> Schema {\n\t\tSchema {\n\t\t\tschema_data: SchemaData {\n\t\t\t\tnullable: self.nullable,\n\t\t\t\ttitle: self.name,\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tschema_kind: self.schema\n\t\t}\n\t}\n}\n\n/**\nThis trait needs to be implemented by every type that is being used in the OpenAPI Spec. It gives\naccess to the [OpenapiSchema] of this type. It is provided for primitive types, String and the\nlike. For use on your own types, there is a derive macro:\n\n```\n# #[macro_use] extern crate openapi_type_derive;\n#\n#[derive(OpenapiType)]\nstruct MyResponse {\n\tmessage: String\n}\n```\n*/\npub trait OpenapiType {\n\tfn schema() -> OpenapiSchema;\n}\n\nimpl<'a, T: ?Sized + OpenapiType> OpenapiType for &'a T {\n\tfn schema() -> OpenapiSchema {\n\t\tT::schema()\n\t}\n}\n","traces":[{"line":103,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[981328,981915],"length":1,"stats":{"Line":3},"fn_name":"into_schema"},{"line":115,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","runner","work","openapi_type","openapi_type","src","private.rs"],"content":"use crate::OpenapiSchema;\nuse indexmap::IndexMap;\n\npub type Dependencies = IndexMap<String, OpenapiSchema>;\n\npub fn add_dependencies(dependencies: &mut Dependencies, other: &mut Dependencies) {\n\twhile let Some((dep_name, dep_schema)) = other.pop() {\n\t\tif !dependencies.contains_key(&dep_name) {\n\t\t\tdependencies.insert(dep_name, dep_schema);\n\t\t}\n\t}\n}\n","traces":[{"line":6,"address":[318528,318954],"length":1,"stats":{"Line":2},"fn_name":"add_dependencies"},{"line":7,"address":[318561,318642,318931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[318729,318893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[318755],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":4},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","custom_types.rs"],"content":"#![allow(dead_code)]\nuse openapi_type::OpenapiType;\n\nmacro_rules! test_type {\n\t($ty:ty = $json:tt) => {\n\t\tpaste::paste! {\n\t\t\t#[test]\n\t\t\tfn [< $ty:lower >]() {\n\t\t\t\tlet schema = <$ty as OpenapiType>::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(&schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t}\n\t\t}\n\t};\n}\n\n#[derive(OpenapiType)]\nstruct UnitStruct;\ntest_type!(UnitStruct = {\n\t\"type\": \"object\",\n\t\"title\": \"UnitStruct\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\nstruct SimpleStruct {\n\tfoo: String,\n\tbar: isize\n}\ntest_type!(SimpleStruct = {\n\t\"type\": \"object\",\n\t\"title\": \"SimpleStruct\",\n\t\"properties\": {\n\t\t\"foo\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"bar\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"foo\", \"bar\"]\n});\n\n#[derive(OpenapiType)]\n#[openapi(rename = \"FooBar\")]\nstruct StructRename;\ntest_type!(StructRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FooBar\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\nenum EnumWithoutFields {\n\tSuccess,\n\tError\n}\ntest_type!(EnumWithoutFields = {\n\t\"type\": \"string\",\n\t\"title\": \"EnumWithoutFields\",\n\t\"enum\": [\n\t\t\"Success\",\n\t\t\"Error\"\n\t]\n});\n\n#[derive(OpenapiType)]\nenum EnumWithOneField {\n\tSuccess { value: isize }\n}\ntest_type!(EnumWithOneField = {\n\t\"type\": \"object\",\n\t\"title\": \"EnumWithOneField\",\n\t\"properties\": {\n\t\t\"Success\": {\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"value\": {\n\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"value\"]\n\t\t}\n\t},\n\t\"required\": [\"Success\"]\n});\n\n#[derive(OpenapiType)]\nenum EnumWithFields {\n\tSuccess { value: isize },\n\tError { msg: String }\n}\ntest_type!(EnumWithFields = {\n\t\"title\": \"EnumWithFields\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Success\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Success\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Error\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"msg\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"msg\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Error\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\nenum EnumExternallyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumExternallyTagged = {\n\t\"title\": \"EnumExternallyTagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Success\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Success\"]\n\t}, {\n\t\t\"type\": \"string\",\n\t\t\"enum\": [\"Empty\", \"Error\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\n#[openapi(tag = \"ty\")]\nenum EnumInternallyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumInternallyTagged = {\n\t\"title\": \"EnumInternallyTagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t},\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Success\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\", \"ty\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Empty\", \"Error\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\n#[openapi(tag = \"ty\", content = \"ct\")]\nenum EnumAdjacentlyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumAdjacentlyTagged = {\n\t\"title\": \"EnumAdjacentlyTagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Success\"]\n\t\t\t},\n\t\t\t\"ct\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\", \"ct\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Empty\", \"Error\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\n#[openapi(untagged)]\nenum EnumUntagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumUntagged = {\n\t\"title\": \"EnumUntagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"additionalProperties\": false\n\t}]\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","custom_types_attrs.rs"],"content":"#![allow(dead_code)]\nuse openapi_type::OpenapiType;\n\nmacro_rules! test_type {\n\t($ty:ty = $json:tt) => {\n\t\tpaste::paste! {\n\t\t\t#[test]\n\t\t\tfn [< $ty:lower >]() {\n\t\t\t\tlet schema = <$ty as OpenapiType>::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(&schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t}\n\t\t}\n\t};\n}\n\n#[derive(OpenapiType)]\n#[openapi(rename = \"FooBar\")]\nstruct ContainerRename;\ntest_type!(ContainerRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FooBar\",\n\t\"additionalProperties\": false\n});\n\nmacro_rules! test_rename_all {\n\t(rename_all = $rename_all:literal, foo_bar = $foo_bar:literal) => {\n\t\tpaste::paste! {\n\t\t\t#[derive(OpenapiType, serde::Serialize)]\n\t\t\t#[openapi(rename = \"FooBar\")]\n\t\t\t#[serde(rename_all = $rename_all)]\n\t\t\t#[allow(non_camel_case_types, non_snake_case)]\n\t\t\tstruct [< ContainerRenameAll_ $rename_all >] {\n\t\t\t\tfoo_bar: Option<&'static str>,\n\t\t\t}\n\t\t\ttest_type!([< ContainerRenameAll_ $rename_all >] = {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"title\": \"FooBar\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t$foo_bar: {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t});\n\t\t\t#[test]\n\t\t\tfn [< containerrenameall_ $rename_all:lower _serde >]() {\n\t\t\t\tlet value = [< ContainerRenameAll_ $rename_all >] {\n\t\t\t\t\tfoo_bar: Some(\"foo_bar\"),\n\t\t\t\t};\n\t\t\t\tlet json = serde_json::to_value(&value).unwrap();\n\t\t\t\tlet expected = serde_json::json!({\n\t\t\t\t\t$foo_bar: \"foo_bar\",\n\t\t\t\t});\n\t\t\t\tpretty_assertions::assert_eq!(json, expected);\n\t\t\t}\n\t\t}\n\t};\n}\n\ntest_rename_all!(rename_all = \"lowercase\", foo_bar = \"foo_bar\");\ntest_rename_all!(rename_all = \"UPPERCASE\", foo_bar = \"FOO_BAR\");\ntest_rename_all!(rename_all = \"PascalCase\", foo_bar = \"FooBar\");\ntest_rename_all!(rename_all = \"camelCase\", foo_bar = \"fooBar\");\ntest_rename_all!(rename_all = \"snake_case\", foo_bar = \"foo_bar\");\ntest_rename_all!(rename_all = \"SCREAMING_SNAKE_CASE\", foo_bar = \"FOO_BAR\");\ntest_rename_all!(rename_all = \"kebab-case\", foo_bar = \"foo-bar\");\ntest_rename_all!(rename_all = \"SCREAMING-KEBAB-CASE\", foo_bar = \"FOO-BAR\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","enum_with_no_variants.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nenum Foo {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","not_openapitype.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo {\n\tbar: Bar\n}\n\nstruct Bar;\n\nfn main() {\n\tFoo::schema();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","not_openapitype_generics.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo<T> {\n\tbar: T\n}\n\nstruct Bar;\n\nfn main() {\n\t<Foo<Bar>>::schema();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","tuple_struct.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo(i64, i64);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","tuple_variant.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nenum Foo {\n\tPair(i64, i64)\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","union.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nunion Foo {\n\tsigned: i64,\n\tunsigned: u64\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","unknown_attribute.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\n#[openapi(pizza)]\nstruct Foo;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","std_types.rs"],"content":"#[cfg(feature = \"chrono\")]\nuse chrono::{Date, DateTime, FixedOffset, NaiveDate, NaiveDateTime, Utc};\nuse indexmap::{IndexMap, IndexSet};\nuse openapi_type::OpenapiType;\nuse serde_json::Value;\nuse std::{\n\tcollections::{BTreeMap, BTreeSet, HashMap, HashSet},\n\tnum::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize}\n};\n#[cfg(feature = \"uuid\")]\nuse uuid::Uuid;\n\nmacro_rules! test_type {\n\t($($ty:ident $(<$($generic:ident),+>)*),* = $json:tt) => {\n\t\tpaste::paste! { $(\n\t\t\t#[test]\n\t\t\tfn [< $ty:lower $($(_ $generic:lower)+)* >]() {\n\t\t\t\tlet schema = <$ty $(<$($generic),+>)* as OpenapiType>::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(&schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t}\n\t\t)* }\n\t};\n}\n\ntype Unit = ();\ntest_type!(Unit = {\n\t\"type\": \"object\",\n\t\"additionalProperties\": false\n});\n\ntest_type!(Value = {\n\t\"nullable\": true\n});\n\ntest_type!(bool = {\n\t\"type\": \"boolean\"\n});\n\n// ### integer types\n\ntest_type!(isize = {\n\t\"type\": \"integer\"\n});\n\ntest_type!(usize = {\n\t\"type\": \"integer\",\n\t\"minimum\": 0\n});\n\ntest_type!(i8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\"\n});\n\ntest_type!(u8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\",\n\t\"minimum\": 0\n});\n\ntest_type!(i16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\"\n});\n\ntest_type!(u16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\",\n\t\"minimum\": 0\n});\n\ntest_type!(i32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\"\n});\n\ntest_type!(u32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\",\n\t\"minimum\": 0\n});\n\ntest_type!(i64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\"\n});\n\ntest_type!(u64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\",\n\t\"minimum\": 0\n});\n\ntest_type!(i128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\"\n});\n\ntest_type!(u128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\",\n\t\"minimum\": 0\n});\n\n// ### non-zero integer types\n\ntest_type!(NonZeroUsize = {\n\t\"type\": \"integer\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\",\n\t\"minimum\": 1\n});\n\n// ### floats\n\ntest_type!(f32 = {\n\t\"type\": \"number\",\n\t\"format\": \"float\"\n});\n\ntest_type!(f64 = {\n\t\"type\": \"number\",\n\t\"format\": \"double\"\n});\n\n// ### string\n\ntest_type!(String = {\n\t\"type\": \"string\"\n});\n\n#[cfg(feature = \"uuid\")]\ntest_type!(Uuid = {\n\t\"type\": \"string\",\n\t\"format\": \"uuid\"\n});\n\n// ### date/time\n\n#[cfg(feature = \"chrono\")]\ntest_type!(Date<FixedOffset>, Date<Utc>, NaiveDate = {\n\t\"type\": \"string\",\n\t\"format\": \"date\"\n});\n\n#[cfg(feature = \"chrono\")]\ntest_type!(DateTime<FixedOffset>, DateTime<Utc>, NaiveDateTime = {\n\t\"type\": \"string\",\n\t\"format\": \"date-time\"\n});\n\n// ### some std types\n\ntest_type!(Option<String> = {\n\t\"type\": \"string\",\n\t\"nullable\": true\n});\n\ntest_type!(Vec<String> = {\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"string\"\n\t}\n});\n\ntest_type!(BTreeSet<String>, IndexSet<String>, HashSet<String> = {\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"string\"\n\t},\n\t\"uniqueItems\": true\n});\n\ntest_type!(BTreeMap<isize, String>, IndexMap<isize, String>, HashMap<isize, String> = {\n\t\"type\": \"object\",\n\t\"properties\": {\n\t\t\"default\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"default\"],\n\t\"additionalProperties\": {\n\t\t\"type\": \"string\"\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","trybuild.rs"],"content":"use trybuild::TestCases;\n\n#[test]\nfn trybuild() {\n\tlet t = TestCases::new();\n\tt.compile_fail(\"tests/fail/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0}]}