{"files":[{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","attrs.rs"],"content":"use crate::util::ExpectLit;\nuse syn::{punctuated::Punctuated, spanned::Spanned as _, Attribute, LitStr, Meta, Token};\n\npub(super) fn parse_doc_attr(input: &Attribute) -> syn::Result<Option<LitStr>> {\n\tinput.parse_meta().and_then(|meta| {\n\t\tOk(match meta {\n\t\t\tMeta::NameValue(kv) => Some(kv.lit.expect_str()?),\n\t\t\t_ => None\n\t\t})\n\t})\n}\n\nfn unknown(meta: Meta, error_on_unknown: bool) -> syn::Result<()> {\n\tif error_on_unknown {\n\t\tErr(syn::Error::new(\n\t\t\tmatch meta {\n\t\t\t\tMeta::Path(path) => path.span(),\n\t\t\t\tMeta::List(list) => list.span(),\n\t\t\t\tMeta::NameValue(kv) => kv.path.span()\n\t\t\t},\n\t\t\t\"Unexpected token\"\n\t\t))\n\t} else {\n\t\tOk(())\n\t}\n}\n\n#[derive(Default)]\npub(super) struct ContainerAttributes {\n\tpub(super) rename: Option<LitStr>,\n\tpub(super) rename_all: Option<LitStr>,\n\tpub(super) tag: Option<LitStr>,\n\tpub(super) content: Option<LitStr>,\n\tpub(super) untagged: bool\n}\n\nimpl ContainerAttributes {\n\tpub(super) fn parse_from(&mut self, input: &Attribute, error_on_unknown: bool) -> syn::Result<()> {\n\t\tlet tokens: Punctuated<Meta, Token![,]> = input.parse_args_with(Punctuated::parse_terminated)?;\n\t\tfor token in tokens {\n\t\t\tmatch token {\n\t\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"rename\") => {\n\t\t\t\t\tself.rename = Some(kv.lit.expect_str()?);\n\t\t\t\t},\n\n\t\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"rename_all\") => {\n\t\t\t\t\tself.rename_all = Some(kv.lit.expect_str()?);\n\t\t\t\t},\n\n\t\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"tag\") => {\n\t\t\t\t\tself.tag = Some(kv.lit.expect_str()?);\n\t\t\t\t},\n\n\t\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"content\") => {\n\t\t\t\t\tself.content = Some(kv.lit.expect_str()?);\n\t\t\t\t},\n\n\t\t\t\tMeta::Path(path) if path.is_ident(\"untagged\") => {\n\t\t\t\t\tself.untagged = true;\n\t\t\t\t},\n\n\t\t\t\tmeta => unknown(meta, error_on_unknown)?\n\t\t\t}\n\t\t}\n\t\tOk(())\n\t}\n}\n\n#[derive(Default)]\npub(super) struct FieldAttributes {\n\t/// Use a different name for the spec than in Rust code.\n\tpub(super) rename: Option<LitStr>,\n\t/// This field can be skipped during either serialization or deserialization.\n\tpub(super) nullable: bool,\n\t/// This field's fields will be flattened into this field.\n\tpub(super) flatten: bool,\n\t/// This field will always be skipped during serialization.\n\tpub(super) skip_serializing: bool,\n\t/// This field will always be skipped during deserialization.\n\tpub(super) skip_deserializing: bool\n}\n\nimpl FieldAttributes {\n\tpub(super) fn parse_from(&mut self, input: &Attribute, error_on_unknown: bool) -> syn::Result<()> {\n\t\tlet tokens: Punctuated<Meta, Token![,]> = input.parse_args_with(Punctuated::parse_terminated)?;\n\t\tfor token in tokens {\n\t\t\tmatch token {\n\t\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"rename\") => {\n\t\t\t\t\tself.rename = Some(kv.lit.expect_str()?);\n\t\t\t\t},\n\n\t\t\t\tMeta::Path(path) if path.is_ident(\"default\") => {\n\t\t\t\t\tself.nullable = true;\n\t\t\t\t},\n\n\t\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"default\") => {\n\t\t\t\t\tself.nullable = true;\n\t\t\t\t},\n\n\t\t\t\tMeta::Path(path) if path.is_ident(\"flatten\") => {\n\t\t\t\t\tself.flatten = true;\n\t\t\t\t},\n\n\t\t\t\tMeta::Path(path) if path.is_ident(\"skip\") => {\n\t\t\t\t\tself.nullable = true;\n\t\t\t\t\tself.skip_serializing = true;\n\t\t\t\t\tself.skip_deserializing = true;\n\t\t\t\t},\n\n\t\t\t\tMeta::Path(path) if path.is_ident(\"skip_serializing\") => {\n\t\t\t\t\tself.nullable = true;\n\t\t\t\t\tself.skip_serializing = true;\n\t\t\t\t},\n\n\t\t\t\tMeta::Path(path) if path.is_ident(\"skip_deserializing\") => {\n\t\t\t\t\tself.nullable = true;\n\t\t\t\t\tself.skip_deserializing = true;\n\t\t\t\t},\n\n\t\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"skip_serializing_if\") => {\n\t\t\t\t\tself.nullable = true;\n\t\t\t\t},\n\n\t\t\t\tmeta => unknown(meta, error_on_unknown)?\n\t\t\t}\n\t\t}\n\t\tOk(())\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","codegen.rs"],"content":"use crate::parser::{ParseData, ParseDataField, TypeOrInline};\nuse proc_macro2::TokenStream;\nuse quote::{quote, quote_spanned};\nuse syn::{spanned::Spanned, LitStr};\n\npub(super) fn gen_doc_option(doc: &[String]) -> TokenStream {\n\tlet doc = doc.join(\"\\n\");\n\tlet doc = doc.trim();\n\tif doc.is_empty() {\n\t\tquote!(::core::option::Option::None)\n\t} else {\n\t\tquote!(::core::option::Option::Some(#doc))\n\t}\n}\n\nimpl ParseData {\n\tpub(super) fn gen_schema(&self) -> TokenStream {\n\t\tmatch self {\n\t\t\tSelf::Struct { name, fields } => gen_struct(name.as_ref(), fields),\n\t\t\tSelf::Enum(variants) => gen_enum(variants),\n\t\t\tSelf::Alternatives(alt) => gen_alt(alt),\n\t\t\tSelf::Unit => gen_unit()\n\t\t}\n\t}\n}\n\nfn gen_struct(name: Option<&LitStr>, fields: &[ParseDataField]) -> TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tlet option = path!(::core::option::Option);\n\n\tlet name = match name {\n\t\tSome(name) => quote!(#option::Some(::std::string::String::from(#name))),\n\t\tNone => quote!(#option::None)\n\t};\n\n\tlet fields = fields.iter().map(|f| {\n\t\tlet name = &f.name;\n\t\tlet doc = gen_doc_option(&f.doc);\n\t\tlet schema = match &f.ty {\n\t\t\tTypeOrInline::Type(ty) => {\n\t\t\t\tquote_spanned!(ty.span() => <#ty as ::openapi_type::OpenapiType>::schema())\n\t\t\t},\n\t\t\tTypeOrInline::Inline(data) => data.gen_schema()\n\t\t};\n\n\t\tif f.flatten {\n\t\t\tquote!({\n\t\t\t\tlet field_schema = #schema;\n\t\t\t\t::openapi_type::private::flatten(\n\t\t\t\t\t&mut dependencies,\n\t\t\t\t\t&mut properties,\n\t\t\t\t\t&mut required,\n\t\t\t\t\tfield_schema\n\t\t\t\t);\n\t\t\t})\n\t\t} else {\n\t\t\tquote!({\n\t\t\t\tconst FIELD_NAME: &::core::primitive::str = #name;\n\t\t\t\tconst FIELD_DOC: #option<&'static ::core::primitive::str> = #doc;\n\n\t\t\t\tlet mut field_schema = #schema;\n\n\t\t\t\t// fields in OpenAPI are nullable by default\n\t\t\t\tmatch field_schema.nullable {\n\t\t\t\t\ttrue => field_schema.nullable = false,\n\t\t\t\t\tfalse => required.push(::std::string::String::from(FIELD_NAME))\n\t\t\t\t};\n\n\t\t\t\tlet field_schema = ::openapi_type::private::inline_if_unnamed(\n\t\t\t\t\t&mut dependencies, field_schema, FIELD_DOC\n\t\t\t\t);\n\t\t\t\tlet field_schema = match field_schema {\n\t\t\t\t\t#openapi::ReferenceOr::Item(schema) => {\n\t\t\t\t\t\t#openapi::ReferenceOr::Item(::std::boxed::Box::new(schema))\n\t\t\t\t\t},\n\t\t\t\t\t#openapi::ReferenceOr::Reference { reference } => {\n\t\t\t\t\t\t#openapi::ReferenceOr::Reference { reference }\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tproperties.insert(\n\t\t\t\t\t::std::string::String::from(FIELD_NAME),\n\t\t\t\t\tfield_schema\n\t\t\t\t);\n\t\t\t})\n\t\t}\n\t});\n\n\tquote! {\n\t\t{\n\t\t\tlet mut properties = ::openapi_type::private::Properties::new();\n\t\t\tlet mut required = ::openapi_type::private::Required::new();\n\n\t\t\t#(#fields)*\n\n\t\t\tlet mut schema = ::openapi_type::OpenapiSchema::new(\n\t\t\t\t#openapi::SchemaKind::Type(\n\t\t\t\t\t#openapi::Type::Object(\n\t\t\t\t\t\t#openapi::ObjectType {\n\t\t\t\t\t\t\tproperties,\n\t\t\t\t\t\t\trequired,\n\t\t\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t\tschema.name = #name;\n\t\t\tschema\n\t\t}\n\t}\n}\n\nfn gen_enum(variants: &[LitStr]) -> TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t{\n\t\t\tlet mut enumeration = <::std::vec::Vec<::std::string::String>>::new();\n\t\t\t#(enumeration.push(::std::string::String::from(#variants));)*\n\t\t\t::openapi_type::OpenapiSchema::new(\n\t\t\t\t#openapi::SchemaKind::Type(\n\t\t\t\t\t#openapi::Type::String(\n\t\t\t\t\t\t#openapi::StringType {\n\t\t\t\t\t\t\tenumeration,\n\t\t\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}\n}\n\nfn gen_alt(alt: &[ParseData]) -> TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tlet schema = alt.iter().map(|data| data.gen_schema());\n\tquote! {\n\t\t{\n\t\t\tlet mut alternatives = <::std::vec::Vec<\n\t\t\t\t#openapi::ReferenceOr<#openapi::Schema>\n\t\t\t>>::new();\n\t\t\t#(alternatives.push({\n\t\t\t\tlet alt_schema = #schema;\n\t\t\t\t::openapi_type::private::inline_if_unnamed(&mut dependencies, alt_schema, None)\n\t\t\t});)*\n\n\t\t\t::openapi_type::OpenapiSchema::new(\n\t\t\t\t#openapi::SchemaKind::OneOf {\n\t\t\t\t\tone_of: alternatives\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}\n}\n\nfn gen_unit() -> TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t::openapi_type::OpenapiSchema::new(\n\t\t\t#openapi::SchemaKind::Type(\n\t\t\t\t#openapi::Type::Object(\n\t\t\t\t\t#openapi::ObjectType {\n\t\t\t\t\t\tadditional_properties: ::std::option::Option::Some(\n\t\t\t\t\t\t\t#openapi::AdditionalProperties::Any(false)\n\t\t\t\t\t\t),\n\t\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms)]\n#![deny(broken_intra_doc_links)]\n#![forbid(unsafe_code)]\n//! This crate defines the macros for `#[derive(OpenapiType)]`.\n\nuse proc_macro::TokenStream;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::quote;\nuse syn::{parse_macro_input, Data, DeriveInput, LitStr, TraitBound, TraitBoundModifier, TypeParamBound};\n\n#[macro_use]\nmod util;\n\nmod attrs;\nuse attrs::*;\nmod codegen;\nuse codegen::*;\nmod parser;\nuse parser::*;\n\n/// The derive macro for [OpenapiType](https://docs.rs/openapi_type/*/openapi_type/trait.OpenapiType.html).\n#[proc_macro_derive(OpenapiType, attributes(openapi))]\npub fn derive_openapi_type(input: TokenStream) -> TokenStream {\n\tlet input = parse_macro_input!(input);\n\texpand_openapi_type(input).unwrap_or_else(|err| err.to_compile_error()).into()\n}\n\nfn expand_openapi_type(mut input: DeriveInput) -> syn::Result<TokenStream2> {\n\t// parse #[serde] and #[openapi] attributes\n\tlet mut attrs = ContainerAttributes::default();\n\tfor attr in &input.attrs {\n\t\tif attr.path.is_ident(\"serde\") {\n\t\t\tattrs.parse_from(attr, false)?;\n\t\t}\n\t}\n\tfor attr in &input.attrs {\n\t\tif attr.path.is_ident(\"openapi\") {\n\t\t\tattrs.parse_from(attr, true)?;\n\t\t}\n\t}\n\n\t// parse #[doc] attributes\n\tlet mut doc: Vec<String> = Vec::new();\n\tfor attr in &input.attrs {\n\t\tif attr.path.is_ident(\"doc\") {\n\t\t\tif let Some(lit) = parse_doc_attr(attr)? {\n\t\t\t\tdoc.push(lit.value());\n\t\t\t}\n\t\t}\n\t}\n\tlet doc = gen_doc_option(&doc);\n\n\t// prepare impl block for codegen\n\tlet ident = &input.ident;\n\tlet name = ident.to_string();\n\tlet mut name = LitStr::new(&name, ident.span());\n\tif let Some(rename) = &attrs.rename {\n\t\tname = rename.clone();\n\t}\n\n\t// prepare the generics - all impl generics will get `OpenapiType` requirement\n\tlet (impl_generics, ty_generics, where_clause) = {\n\t\tlet generics = &mut input.generics;\n\t\tgenerics.type_params_mut().for_each(|param| {\n\t\t\tparam.colon_token.get_or_insert_with(Default::default);\n\t\t\tparam.bounds.push(TypeParamBound::Trait(TraitBound {\n\t\t\t\tparen_token: None,\n\t\t\t\tmodifier: TraitBoundModifier::None,\n\t\t\t\tlifetimes: None,\n\t\t\t\tpath: path!(::openapi_type::OpenapiType)\n\t\t\t}));\n\t\t});\n\t\tgenerics.split_for_impl()\n\t};\n\n\t// parse the input data\n\tlet parsed = match &input.data {\n\t\tData::Struct(strukt) => parse_struct(ident, strukt, &attrs)?,\n\t\tData::Enum(inum) => parse_enum(ident, inum, &attrs)?,\n\t\tData::Union(union) => parse_union(union)?\n\t};\n\n\t// run the codegen\n\tlet schema_code = parsed.gen_schema();\n\n\t// put the code together\n\tOk(quote! {\n\t\t#[allow(unused_mut)]\n\t\timpl #impl_generics ::openapi_type::OpenapiType for #ident #ty_generics #where_clause {\n\t\t\tfn schema() -> ::openapi_type::OpenapiSchema {\n\t\t\t\t// this will be used by the schema code\n\t\t\t\tlet mut dependencies = ::openapi_type::private::Dependencies::new();\n\n\t\t\t\tlet mut schema: ::openapi_type::OpenapiSchema = #schema_code;\n\t\t\t\tschema.nullable = false;\n\t\t\t\tschema.dependencies = dependencies;\n\n\t\t\t\tconst NAME: &::core::primitive::str = #name;\n\t\t\t\tschema.name = ::std::option::Option::Some(::std::string::String::from(NAME));\n\n\t\t\t\tconst DESCRIPTION: ::core::option::Option<&'static ::core::primitive::str> = #doc;\n\t\t\t\tschema.description = DESCRIPTION.map(|desc| ::std::string::String::from(desc));\n\n\t\t\t\tschema\n\t\t\t}\n\t\t}\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","parser.rs"],"content":"use crate::{\n\tattrs::{parse_doc_attr, ContainerAttributes, FieldAttributes},\n\tutil::ToLitStr\n};\nuse proc_macro2::{Ident, Span};\nuse serde_derive_internals::attr::RenameRule;\nuse syn::{\n\tpunctuated::Punctuated, spanned::Spanned as _, AngleBracketedGenericArguments, DataEnum, DataStruct, DataUnion, Fields,\n\tFieldsNamed, GenericArgument, LitStr, PathArguments, Type, TypePath\n};\n\npub(super) enum TypeOrInline {\n\tType(Type),\n\tInline(ParseData)\n}\n\npub(super) struct ParseDataField {\n\tpub(super) name: LitStr,\n\tpub(super) doc: Vec<String>,\n\tpub(super) ty: TypeOrInline,\n\tpub(super) flatten: bool\n}\n\n#[allow(dead_code)]\npub(super) enum ParseData {\n\tStruct {\n\t\tname: Option<LitStr>,\n\t\tfields: Vec<ParseDataField>\n\t},\n\tEnum(Vec<LitStr>),\n\tAlternatives(Vec<ParseData>),\n\tUnit\n}\n\nfn parse_named_fields(named_fields: &FieldsNamed, rename_all: Option<&LitStr>) -> syn::Result<Vec<ParseDataField>> {\n\tlet mut fields: Vec<ParseDataField> = Vec::new();\n\tfor f in &named_fields.named {\n\t\t// parse #[serde] and #[openapi] attributes\n\t\tlet mut attrs = FieldAttributes::default();\n\t\tfor attr in &f.attrs {\n\t\t\tif attr.path.is_ident(\"serde\") {\n\t\t\t\tattrs.parse_from(attr, false)?;\n\t\t\t}\n\t\t}\n\t\tfor attr in &f.attrs {\n\t\t\tif attr.path.is_ident(\"openapi\") {\n\t\t\t\tattrs.parse_from(attr, true)?;\n\t\t\t}\n\t\t}\n\n\t\t// skip this field if desired\n\t\tif attrs.skip_serializing && attrs.skip_deserializing {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// parse #[doc] attributes\n\t\tlet mut doc = Vec::new();\n\t\tfor attr in &f.attrs {\n\t\t\tif attr.path.is_ident(\"doc\") {\n\t\t\t\tif let Some(lit) = parse_doc_attr(attr)? {\n\t\t\t\t\tdoc.push(lit.value());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// get the name of the field\n\t\tlet ident = f\n\t\t\t.ident\n\t\t\t.as_ref()\n\t\t\t.ok_or_else(|| syn::Error::new(f.span(), \"#[derive(OpenapiType)] does not support fields without an ident\"))?;\n\t\tlet mut name = ident.to_lit_str();\n\t\tif let Some(rename) = attrs.rename {\n\t\t\tname = rename;\n\t\t} else if let Some(rename_all) = rename_all {\n\t\t\tlet rule = RenameRule::from_str(&rename_all.value())\n\t\t\t\t.map_err(|_| syn::Error::new(rename_all.span(), \"Unknown rename_all rule\"))?;\n\t\t\tlet rename = rule.apply_to_field(&name.value());\n\t\t\tname = LitStr::new(&rename, name.span());\n\t\t}\n\n\t\t// get the type of the field\n\t\tlet mut ty = f.ty.to_owned();\n\t\tif attrs.nullable {\n\t\t\tlet mut args = Punctuated::new();\n\t\t\targs.push(GenericArgument::Type(ty));\n\t\t\tlet mut path = path!(::core::option::Option);\n\t\t\tlet last = path.segments.last_mut().unwrap();\n\t\t\tlast.arguments = PathArguments::AngleBracketed(AngleBracketedGenericArguments {\n\t\t\t\tcolon2_token: None,\n\t\t\t\tlt_token: Default::default(),\n\t\t\t\targs,\n\t\t\t\tgt_token: Default::default()\n\t\t\t});\n\t\t\tty = Type::Path(TypePath { qself: None, path })\n\t\t}\n\n\t\tfields.push(ParseDataField {\n\t\t\tname,\n\t\t\tdoc,\n\t\t\tty: TypeOrInline::Type(ty),\n\t\t\tflatten: attrs.flatten\n\t\t});\n\t}\n\tOk(fields)\n}\n\npub(super) fn parse_struct(ident: &Ident, strukt: &DataStruct, attrs: &ContainerAttributes) -> syn::Result<ParseData> {\n\tmatch &strukt.fields {\n\t\tFields::Named(named_fields) => {\n\t\t\tlet fields = parse_named_fields(named_fields, attrs.rename_all.as_ref())?;\n\t\t\tOk(ParseData::Struct {\n\t\t\t\tname: Some(ident.to_lit_str()),\n\t\t\t\tfields\n\t\t\t})\n\t\t},\n\t\tFields::Unnamed(unnamed_fields) => Err(syn::Error::new(\n\t\t\tunnamed_fields.span(),\n\t\t\t\"#[derive(OpenapiType)] does not support tuple structs\"\n\t\t)),\n\t\tFields::Unit => Ok(ParseData::Unit)\n\t}\n}\n\npub(super) fn parse_enum(ident: &Ident, inum: &DataEnum, attrs: &ContainerAttributes) -> syn::Result<ParseData> {\n\tlet mut strings: Vec<LitStr> = Vec::new();\n\tlet mut types: Vec<(LitStr, ParseData)> = Vec::new();\n\n\tfor v in &inum.variants {\n\t\tlet name = v.ident.to_lit_str();\n\t\tmatch &v.fields {\n\t\t\tFields::Named(named_fields) => {\n\t\t\t\tlet fields = parse_named_fields(named_fields, attrs.rename_all.as_ref())?;\n\t\t\t\tlet struct_name = format!(\"{}::{}\", ident, name.value());\n\t\t\t\ttypes.push((name, ParseData::Struct {\n\t\t\t\t\tname: Some(struct_name.to_lit_str()),\n\t\t\t\t\tfields\n\t\t\t\t}));\n\t\t\t},\n\t\t\tFields::Unnamed(unnamed_fields) => {\n\t\t\t\treturn Err(syn::Error::new(\n\t\t\t\t\tunnamed_fields.span(),\n\t\t\t\t\t\"#[derive(OpenapiType)] does not support tuple variants\"\n\t\t\t\t))\n\t\t\t},\n\t\t\tFields::Unit => strings.push(name)\n\t\t}\n\t}\n\n\tlet data_strings = if strings.is_empty() {\n\t\tNone\n\t} else {\n\t\tmatch (&attrs.tag, &attrs.content, attrs.untagged) {\n\t\t\t// externally tagged (default)\n\t\t\t(None, None, false) => Some(ParseData::Enum(strings)),\n\t\t\t// internally tagged or adjacently tagged\n\t\t\t(Some(tag), _, false) => Some(ParseData::Struct {\n\t\t\t\tname: None,\n\t\t\t\tfields: vec![ParseDataField {\n\t\t\t\t\tname: tag.clone(),\n\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\tty: TypeOrInline::Inline(ParseData::Enum(strings)),\n\t\t\t\t\tflatten: false\n\t\t\t\t}]\n\t\t\t}),\n\t\t\t// untagged\n\t\t\t(None, None, true) => Some(ParseData::Unit),\n\t\t\t// unknown\n\t\t\t_ => return Err(syn::Error::new(Span::call_site(), \"Unknown enum representation\"))\n\t\t}\n\t};\n\n\tlet data_types =\n\t\tif types.is_empty() {\n\t\t\tNone\n\t\t} else {\n\t\t\tSome(ParseData::Alternatives(\n\t\t\t\ttypes\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|(name, mut data)| {\n\t\t\t\t\t\tOk(match (&attrs.tag, &attrs.content, attrs.untagged) {\n\t\t\t\t\t\t\t// externally tagged (default)\n\t\t\t\t\t\t\t(None, None, false) => {\n\t\t\t\t\t\t\t\tlet struct_name = format!(\"{}::{}::ExtTagWrapper\", ident, name.value());\n\t\t\t\t\t\t\t\tParseData::Struct {\n\t\t\t\t\t\t\t\t\tname: Some(struct_name.to_lit_str()),\n\t\t\t\t\t\t\t\t\tfields: vec![ParseDataField {\n\t\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\t\t\t\t\t\tty: TypeOrInline::Inline(data),\n\t\t\t\t\t\t\t\t\t\tflatten: false\n\t\t\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t// internally tagged\n\t\t\t\t\t\t\t(Some(tag), None, false) => {\n\t\t\t\t\t\t\t\tmatch &mut data {\n\t\t\t\t\t\t\t\t\tParseData::Struct { fields, .. } => fields.push(ParseDataField {\n\t\t\t\t\t\t\t\t\t\tname: tag.clone(),\n\t\t\t\t\t\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\t\t\t\t\t\tty: TypeOrInline::Inline(ParseData::Enum(vec![name])),\n\t\t\t\t\t\t\t\t\t\tflatten: false\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t_ => return Err(syn::Error::new(\n\t\t\t\t\t\t\t\t\t\ttag.span(),\n\t\t\t\t\t\t\t\t\t\t\"#[derive(OpenapiType)] does not support tuple variants on internally tagged enums\"\n\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t// adjacently tagged\n\t\t\t\t\t\t\t(Some(tag), Some(content), false) => {\n\t\t\t\t\t\t\t\tlet struct_name = format!(\"{}::{}::AdjTagWrapper\", ident, name.value());\n\t\t\t\t\t\t\t\tParseData::Struct {\n\t\t\t\t\t\t\t\t\tname: Some(struct_name.to_lit_str()),\n\t\t\t\t\t\t\t\t\tfields: vec![\n\t\t\t\t\t\t\t\t\t\tParseDataField {\n\t\t\t\t\t\t\t\t\t\t\tname: tag.clone(),\n\t\t\t\t\t\t\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\t\t\t\t\t\t\tty: TypeOrInline::Inline(ParseData::Enum(vec![name])),\n\t\t\t\t\t\t\t\t\t\t\tflatten: false\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tParseDataField {\n\t\t\t\t\t\t\t\t\t\t\tname: content.clone(),\n\t\t\t\t\t\t\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\t\t\t\t\t\t\tty: TypeOrInline::Inline(data),\n\t\t\t\t\t\t\t\t\t\t\tflatten: false\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t// untagged\n\t\t\t\t\t\t\t(None, None, true) => data,\n\t\t\t\t\t\t\t// unknown\n\t\t\t\t\t\t\t_ => return Err(syn::Error::new(Span::call_site(), \"Unknown enum representation\"))\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t\t.collect::<syn::Result<Vec<_>>>()?\n\t\t\t))\n\t\t};\n\n\tmatch (data_strings, data_types) {\n\t\t// only variants without fields\n\t\t(Some(data), None) => Ok(data),\n\t\t// only one variant with fields\n\t\t(None, Some(ParseData::Alternatives(mut alt))) if alt.len() == 1 => Ok(alt.remove(0)),\n\t\t// only variants with fields\n\t\t(None, Some(data)) => Ok(data),\n\t\t// variants with and without fields\n\t\t(Some(data), Some(ParseData::Alternatives(mut alt))) => {\n\t\t\talt.push(data);\n\t\t\tOk(ParseData::Alternatives(alt))\n\t\t},\n\t\t// no variants\n\t\t(None, None) => Err(syn::Error::new(\n\t\t\tinum.brace_token.span,\n\t\t\t\"#[derive(OpenapiType)] does not support enums with no variants\"\n\t\t)),\n\t\t// data_types always produces Alternatives\n\t\t_ => unreachable!()\n\t}\n}\n\npub(super) fn parse_union(union: &DataUnion) -> syn::Result<ParseData> {\n\tErr(syn::Error::new(\n\t\tunion.union_token.span(),\n\t\t\"#[derive(OpenapiType)] cannot be used on unions\"\n\t))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","util.rs"],"content":"use proc_macro2::{Ident, Span};\nuse syn::{Lit, LitStr};\n\n/// Convert any literal path into a [syn::Path].\nmacro_rules! path {\n\t(:: $($segment:ident)::*) => {\n\t\tpath!(@private Some(Default::default()), $($segment),*)\n\t};\n\t($($segment:ident)::*) => {\n\t\tpath!(@private None, $($segment),*)\n\t};\n\t(@private $leading_colon:expr, $($segment:ident),*) => {\n\t\t{\n\t\t\t#[allow(unused_mut)]\n\t\t\tlet mut segments: ::syn::punctuated::Punctuated<::syn::PathSegment, _> = Default::default();\n\t\t\t$(\n\t\t\t\tsegments.push(::syn::PathSegment {\n\t\t\t\t\tident: ::proc_macro2::Ident::new(stringify!($segment), ::proc_macro2::Span::call_site()),\n\t\t\t\t\targuments: Default::default()\n\t\t\t\t});\n\t\t\t)*\n\t\t\t::syn::Path {\n\t\t\t\tleading_colon: $leading_colon,\n\t\t\t\tsegments\n\t\t\t}\n\t\t}\n\t};\n}\n\n/// Convert [Ident], [String] and [&str] into a [LitStr].\npub(super) trait ToLitStr {\n\tfn to_lit_str(&self) -> LitStr;\n}\n\nimpl ToLitStr for Ident {\n\tfn to_lit_str(&self) -> LitStr {\n\t\tLitStr::new(&self.to_string(), self.span())\n\t}\n}\n\nimpl ToLitStr for String {\n\tfn to_lit_str(&self) -> LitStr {\n\t\tLitStr::new(self, Span::call_site())\n\t}\n}\n\nimpl ToLitStr for &str {\n\tfn to_lit_str(&self) -> LitStr {\n\t\tLitStr::new(self, Span::call_site())\n\t}\n}\n\n/// Convert a [Lit] to one specific literal type.\npub(crate) trait ExpectLit {\n\tfn expect_str(self) -> syn::Result<LitStr>;\n}\n\nimpl ExpectLit for Lit {\n\tfn expect_str(self) -> syn::Result<LitStr> {\n\t\tmatch self {\n\t\t\tSelf::Str(str) => Ok(str),\n\t\t\t_ => Err(syn::Error::new(self.span(), \"Expected string literal\"))\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","src","impls.rs"],"content":"use crate::{OpenapiSchema, OpenapiType};\n#[cfg(feature = \"chrono\")]\nuse chrono::{offset::TimeZone, Date, DateTime, NaiveDate, NaiveDateTime};\nuse indexmap::{IndexMap, IndexSet};\nuse openapiv3::{\n\tAdditionalProperties, ArrayType, IntegerType, NumberFormat, NumberType, ObjectType, ReferenceOr, SchemaKind,\n\tStringFormat, StringType, Type, VariantOrUnknownOrEmpty\n};\nuse serde_json::Value;\nuse std::{\n\tcollections::{BTreeMap, BTreeSet, HashMap, HashSet},\n\thash::BuildHasher,\n\tnum::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize}\n};\n#[cfg(feature = \"uuid\")]\nuse uuid::Uuid;\n\nmacro_rules! impl_openapi_type {\n\t($($ty:ident $(<$($generic:ident : $bound:path),+>)*),* => $schema:expr) => {\n\t\t$(\n\t\t\timpl $(<$($generic : $bound),+>)* OpenapiType for $ty $(<$($generic),+>)* {\n\t\t\t\tfn schema() -> OpenapiSchema {\n\t\t\t\t\t$schema\n\t\t\t\t}\n\t\t\t}\n\t\t)*\n\t};\n}\n\ntype Unit = ();\nimpl_openapi_type!(Unit => {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Object(ObjectType {\n\t\tadditional_properties: Some(AdditionalProperties::Any(false)),\n\t\t..Default::default()\n\t})))\n});\n\nimpl_openapi_type!(Value => {\n\tOpenapiSchema {\n\t\tnullable: true,\n\t\tdescription: None,\n\t\tname: None,\n\t\tschema: SchemaKind::Any(Default::default()),\n\t\tdependencies: Default::default()\n\t}\n});\n\nimpl_openapi_type!(bool => OpenapiSchema::new(SchemaKind::Type(Type::Boolean {})));\n\n#[inline]\nfn int_schema(minimum: Option<i64>, bits: Option<i64>) -> OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Integer(IntegerType {\n\t\tminimum,\n\t\tformat: bits\n\t\t\t.map(|bits| VariantOrUnknownOrEmpty::Unknown(format!(\"int{}\", bits)))\n\t\t\t.unwrap_or(VariantOrUnknownOrEmpty::Empty),\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(isize => int_schema(None, None));\nimpl_openapi_type!(i8 => int_schema(None, Some(8)));\nimpl_openapi_type!(i16 => int_schema(None, Some(16)));\nimpl_openapi_type!(i32 => int_schema(None, Some(32)));\nimpl_openapi_type!(i64 => int_schema(None, Some(64)));\nimpl_openapi_type!(i128 => int_schema(None, Some(128)));\n\nimpl_openapi_type!(usize => int_schema(Some(0), None));\nimpl_openapi_type!(u8 => int_schema(Some(0), Some(8)));\nimpl_openapi_type!(u16 => int_schema(Some(0), Some(16)));\nimpl_openapi_type!(u32 => int_schema(Some(0), Some(32)));\nimpl_openapi_type!(u64 => int_schema(Some(0), Some(64)));\nimpl_openapi_type!(u128 => int_schema(Some(0), Some(128)));\n\nimpl_openapi_type!(NonZeroUsize => int_schema(Some(1), None));\nimpl_openapi_type!(NonZeroU8 => int_schema(Some(1), Some(8)));\nimpl_openapi_type!(NonZeroU16 => int_schema(Some(1), Some(16)));\nimpl_openapi_type!(NonZeroU32 => int_schema(Some(1), Some(32)));\nimpl_openapi_type!(NonZeroU64 => int_schema(Some(1), Some(64)));\nimpl_openapi_type!(NonZeroU128 => int_schema(Some(1), Some(128)));\n\n#[inline]\nfn float_schema(format: NumberFormat) -> OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Number(NumberType {\n\t\tformat: VariantOrUnknownOrEmpty::Item(format),\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(f32 => float_schema(NumberFormat::Float));\nimpl_openapi_type!(f64 => float_schema(NumberFormat::Double));\n\n#[inline]\nfn str_schema(format: VariantOrUnknownOrEmpty<StringFormat>) -> OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::String(StringType {\n\t\tformat,\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(String, str => str_schema(VariantOrUnknownOrEmpty::Empty));\n\n#[cfg(feature = \"chrono\")]\nimpl_openapi_type!(Date<T: TimeZone>, NaiveDate => {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::Date))\n});\n\n#[cfg(feature = \"chrono\")]\nimpl_openapi_type!(DateTime<T: TimeZone>, NaiveDateTime => {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::DateTime))\n});\n\n#[cfg(feature = \"uuid\")]\nimpl_openapi_type!(Uuid => {\n\tstr_schema(VariantOrUnknownOrEmpty::Unknown(\"uuid\".to_owned()))\n});\n\nimpl_openapi_type!(Option<T: OpenapiType> => {\n\tlet schema = T::schema();\n\tlet mut dependencies = schema.dependencies.clone();\n\tlet schema = match schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\tSchemaKind::AllOf { all_of: vec![reference] }\n\t\t},\n\t\tNone => schema.schema\n\t};\n\n\tOpenapiSchema {\n\t\tnullable: true,\n\t\tname: None,\n\t\tdescription: None,\n\t\tschema,\n\t\tdependencies\n\t}\n});\n\n#[inline]\nfn array_schema<T: OpenapiType>(unique_items: bool) -> OpenapiSchema {\n\tlet schema = T::schema();\n\tlet mut dependencies = schema.dependencies.clone();\n\n\tlet items = match schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\treference\n\t\t},\n\t\tNone => ReferenceOr::Item(Box::new(schema.into_schema()))\n\t};\n\n\tOpenapiSchema {\n\t\tnullable: false,\n\t\tname: None,\n\t\tdescription: None,\n\t\tschema: SchemaKind::Type(Type::Array(ArrayType {\n\t\t\titems,\n\t\t\tmin_items: None,\n\t\t\tmax_items: None,\n\t\t\tunique_items\n\t\t})),\n\t\tdependencies\n\t}\n}\n\nimpl_openapi_type!(Vec<T: OpenapiType> => array_schema::<T>(false));\nimpl_openapi_type!(BTreeSet<T: OpenapiType>, IndexSet<T: OpenapiType>, HashSet<T: OpenapiType, S: BuildHasher> => {\n\tarray_schema::<T>(true)\n});\n\n#[inline]\nfn map_schema<K: OpenapiType, T: OpenapiType>() -> OpenapiSchema {\n\tlet key_schema = K::schema();\n\tlet mut dependencies = key_schema.dependencies.clone();\n\n\tlet keys = match key_schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, key_schema);\n\t\t\treference\n\t\t},\n\t\tNone => ReferenceOr::Item(Box::new(key_schema.into_schema()))\n\t};\n\n\tlet schema = T::schema();\n\tdependencies.extend(schema.dependencies.iter().map(|(k, v)| (k.clone(), v.clone())));\n\n\tlet items = Box::new(match schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\treference\n\t\t},\n\t\tNone => ReferenceOr::Item(schema.into_schema())\n\t});\n\n\tlet mut properties = IndexMap::new();\n\tproperties.insert(\"default\".to_owned(), keys);\n\n\tOpenapiSchema {\n\t\tnullable: false,\n\t\tname: None,\n\t\tdescription: None,\n\t\tschema: SchemaKind::Type(Type::Object(ObjectType {\n\t\t\tproperties,\n\t\t\trequired: vec![\"default\".to_owned()],\n\t\t\tadditional_properties: Some(AdditionalProperties::Schema(items)),\n\t\t\t..Default::default()\n\t\t})),\n\t\tdependencies\n\t}\n}\n\nimpl_openapi_type!(\n\tBTreeMap<K: OpenapiType, T: OpenapiType>,\n\tIndexMap<K: OpenapiType, T: OpenapiType>,\n\tHashMap<K: OpenapiType, T: OpenapiType, S: BuildHasher>\n\t=> map_schema::<K, T>()\n);\n","traces":[{"line":22,"address":[363344],"length":1,"stats":{"Line":47},"fn_name":"schema"},{"line":32,"address":[307696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[307649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[307689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[363632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[363505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[363514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[363531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[363582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[308128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[308219],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[308283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[308363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[308443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[308523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[308603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[308683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[308763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[308859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[308955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[309051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[309147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[380891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[380971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[381067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[381163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[381259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[381355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[309244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[309292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":101,"address":[309339],"length":1,"stats":{"Line":5},"fn_name":null},{"line":105,"address":[309707],"length":1,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[384667],"length":1,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[330861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[477345],"length":1,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[477404],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[477431,477496,477557],"length":1,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[477599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[477872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[477647,477813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[477924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[478127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[477559],"length":1,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[478552],"length":1,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[478471],"length":1,"stats":{"Line":3},"fn_name":null},{"line":135,"address":[478483],"length":1,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[478495],"length":1,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[478521],"length":1,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[517256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[350344],"length":1,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[347640],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":78,"coverable":97},{"path":["/","home","runner","work","openapi_type","openapi_type","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms)]\n#![forbid(unsafe_code)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(clippy::tabs_in_doc_comments))]\n#![doc = r##\"\nThis crate gives static type information for primitives and commonly used types from the standard\nlibrary and a few other commonly used libraries like `chrono` and `uuid`. Also, it provides a\nderive macro for structs and enums to gain access to their static type information at runtime.\n\nThe core of this crate is the [`OpenapiType`] trait. It has one static function,\n[`schema`](OpenapiType::schema), which returns an [`OpenapiSchema`]. This assembles the static\ntype information in a way that is convenient to use for a generated OpenAPI specification, but\ncan also be utilized in other use cases as well.\n\n# Custom Types\nTo gain access to the static type information of your custom types at runtime, the easiest way\nis to use the derive macro:\n\n```rust\n# use openapi_type::OpenapiType;\n#[derive(OpenapiType)]\nstruct FooBar {\n\tfoo: String,\n\tbar: u64\n}\n# let schema = FooBar::schema().into_schema();\n# let schema_json = serde_json::to_value(&schema).unwrap();\n# assert_eq!(schema_json, serde_json::json!({\n#   \"type\": \"object\",\n#   \"title\": \"FooBar\",\n#   \"properties\": {\n#     \"foo\": {\n#       \"type\": \"string\"\n#     },\n#     \"bar\": {\n#       \"type\": \"integer\",\n#       \"format\": \"int64\",\n#       \"minimum\": 0\n#     }\n#   },\n#   \"required\": [\"foo\", \"bar\"]\n# }));\n```\n\n# OpenAPI specification\nUsing above type, running `FooBar::schema().into_schema()` yields\n\n```yaml\ntype: object\ntitle: FooBar\nproperties:\n  foo:\n    type: string\n  bar:\n    type: integer\n    format: int64\n    minimum: 0\nrequired:\n  - foo\n  - bar\n```\n\nNote, however, that this is not sufficient for more complex types. If one of your structs fields\nis a type that has a name (that is, `Type::schema().name` is not `None`), above schema will contain\na reference to that schema. Therefore, always remember to put the\n[`dependencies`](OpenapiSchema::dependencies) into the specification alongside the type you are\ninterested in.\n\"##]\n\npub use indexmap;\npub use openapi_type_derive::OpenapiType;\npub use openapiv3 as openapi;\n\nmod impls;\n#[doc(hidden)]\npub mod private;\n\nuse indexmap::IndexMap;\nuse openapi::{Schema, SchemaData, SchemaKind};\n\n/// This struct is used to generate the OpenAPI specification for a particular type. It is already\n/// made available for all primitives and some other types from the rust standard library, and\n/// you can also make your own types provide one through the [OpenapiType] trait and derive macro.\n///\n/// Note that this struct is marked non-exhaustive. This means that new attributes might be added\n/// at any point in time without a breaking change. The only way to obtain a value is through the\n/// [OpenapiSchema::new] method.\n#[derive(Debug, Clone, PartialEq)]\n#[non_exhaustive]\npub struct OpenapiSchema {\n\t/// The name of this schema. If it is None, the schema will be inlined.\n\tpub name: Option<String>,\n\t/// The description of this schema. Optional and only makes sense when a [name] is set as well.\n\tpub description: Option<String>,\n\t/// Whether this particular schema is nullable. Note that there is no guarantee that this will\n\t/// make it into the final specification, it might just be interpreted as a hint to make it\n\t/// an optional parameter.\n\tpub nullable: bool,\n\t/// The actual OpenAPI schema.\n\tpub schema: SchemaKind,\n\t/// Other schemas that this schema depends on. They will be included in the final OpenAPI Spec\n\t/// along with this schema.\n\tpub dependencies: IndexMap<String, OpenapiSchema>\n}\n\nimpl OpenapiSchema {\n\t/// Create a new schema that has no name.\n\tpub fn new(schema: SchemaKind) -> Self {\n\t\tSelf {\n\t\t\tname: None,\n\t\t\tdescription: None,\n\t\t\tnullable: false,\n\t\t\tschema,\n\t\t\tdependencies: IndexMap::new()\n\t\t}\n\t}\n\n\t/// Convert this schema to a [Schema] that can be serialized to the OpenAPI Spec.\n\tpub fn into_schema(self) -> Schema {\n\t\tSchema {\n\t\t\tschema_data: SchemaData {\n\t\t\t\tnullable: self.nullable,\n\t\t\t\ttitle: self.name,\n\t\t\t\tdescription: self.description,\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tschema_kind: self.schema\n\t\t}\n\t}\n}\n\n/**\nThis trait needs to be implemented by every type that is being used in the OpenAPI Spec. It gives\naccess to the [OpenapiSchema] of this type. It is provided for primitive types, String and the\nlike. For use on your own types, there is a derive macro:\n\n```\n# #[macro_use] extern crate openapi_type_derive;\n#\n#[derive(OpenapiType)]\nstruct MyResponse {\n\tmessage: String\n}\n```\n*/\npub trait OpenapiType {\n\tfn schema() -> OpenapiSchema;\n}\n\nimpl<'a, T: ?Sized + OpenapiType> OpenapiType for &'a T {\n\tfn schema() -> OpenapiSchema {\n\t\tT::schema()\n\t}\n}\n","traces":[{"line":107,"address":[375936,376186],"length":1,"stats":{"Line":4},"fn_name":"new"},{"line":113,"address":[375997],"length":1,"stats":{"Line":4},"fn_name":null},{"line":118,"address":[946192,946964],"length":1,"stats":{"Line":4},"fn_name":"into_schema"},{"line":120,"address":[376230,376322],"length":1,"stats":{"Line":8},"fn_name":null},{"line":126,"address":[376662],"length":1,"stats":{"Line":4},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","runner","work","openapi_type","openapi_type","src","private.rs"],"content":"use crate::OpenapiSchema;\nuse indexmap::IndexMap;\nuse openapiv3::{ReferenceOr, Schema, SchemaKind, Type};\nuse std::borrow::Cow;\n\npub type Dependencies = IndexMap<String, OpenapiSchema>;\npub type Properties = IndexMap<String, ReferenceOr<Box<Schema>>>;\npub type Required = Vec<String>;\n\nfn add_dependencies(dependencies: &mut Dependencies, other: &mut Dependencies) {\n\twhile let Some((dep_name, dep_schema)) = other.pop() {\n\t\tif !dependencies.contains_key(&dep_name) {\n\t\t\tdependencies.insert(dep_name, dep_schema);\n\t\t}\n\t}\n}\n\npub fn inline_if_unnamed(\n\tdependencies: &mut Dependencies,\n\tmut schema: OpenapiSchema,\n\tdoc: Option<&'static str>\n) -> ReferenceOr<Schema> {\n\tadd_dependencies(dependencies, &mut schema.dependencies);\n\tmatch schema.name.as_ref() {\n\t\tSome(schema_name) => {\n\t\t\tlet ref_name = schema_name.replace(|c: char| !c.is_alphanumeric(), \"_\");\n\t\t\tlet mut reference = \"#/components/schemas/\".to_string();\n\t\t\treference.push_str(&ref_name);\n\t\t\tdependencies.insert(ref_name, schema);\n\t\t\tReferenceOr::Reference { reference }\n\t\t},\n\n\t\tNone => {\n\t\t\tlet mut schema = schema.into_schema();\n\t\t\tif let Some(doc) = doc {\n\t\t\t\tschema.schema_data.description = Some(doc.to_string());\n\t\t\t}\n\t\t\tReferenceOr::Item(schema)\n\t\t}\n\t}\n}\n\nstruct FlattenError(Cow<'static, str>);\n\nfn flatten_impl(properties: &mut Properties, required: &mut Required, schema: SchemaKind) -> Result<(), FlattenError> {\n\tlet mut obj = match schema {\n\t\tSchemaKind::Type(Type::Object(obj)) => obj,\n\t\tSchemaKind::OneOf { .. } => {\n\t\t\treturn Err(FlattenError(\n\t\t\t\t\"#[serde(flatten)] is currently not supported for enums with non-unit variants\".into()\n\t\t\t))\n\t\t},\n\t\t_ => return Err(FlattenError(\"Expected object\".into()))\n\t};\n\n\twhile let Some((prop_name, prop_schema)) = obj.properties.pop() {\n\t\tif properties.contains_key(&prop_name) {\n\t\t\treturn Err(FlattenError(format!(\"Duplicate property name {}\", prop_name).into()));\n\t\t}\n\t\tproperties.insert(prop_name, prop_schema);\n\t}\n\trequired.extend(obj.required.into_iter());\n\n\tOk(())\n}\n\npub fn flatten(\n\tdependencies: &mut Dependencies,\n\tproperties: &mut Properties,\n\trequired: &mut Required,\n\tmut schema: OpenapiSchema\n) {\n\tadd_dependencies(dependencies, &mut schema.dependencies);\n\tmatch flatten_impl(properties, required, schema.schema) {\n\t\tOk(_) => {},\n\t\tErr(e) => panic!(\"Flattening produced an error: {}\", e.0)\n\t};\n}\n","traces":[{"line":10,"address":[1046544,1047058],"length":1,"stats":{"Line":3},"fn_name":"add_dependencies"},{"line":11,"address":[1047097,1046582],"length":1,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[1046713,1046759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[1046827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[1048230,1047120],"length":1,"stats":{"Line":3},"fn_name":"inline_if_unnamed"},{"line":23,"address":[1047181],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[1047224,1047286],"length":1,"stats":{"Line":6},"fn_name":null},{"line":25,"address":[391228],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[370502,370480],"length":1,"stats":{"Line":9},"fn_name":"{closure#0}"},{"line":27,"address":[391301],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[391333,391409],"length":1,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[1047615],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[1047318],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[1047876,1048150],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[1048102,1047933,1048155,1048010],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[1047940],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[392096,393994],"length":1,"stats":{"Line":1},"fn_name":"flatten_impl"},{"line":46,"address":[392263,392144],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[392496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[392308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[392276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[392228,392568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[392785,392561,393881,392697],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[393162,392873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[393340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[393846,393218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[392902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[392990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[394603,394080],"length":1,"stats":{"Line":1},"fn_name":"flatten"},{"line":73,"address":[394139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[394174,394275],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":25,"coverable":31},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","custom_types.rs"],"content":"#![allow(dead_code)]\nuse openapi_type::OpenapiType;\n\ninclude!(\"util/test_type.rs\");\n\n#[derive(OpenapiType)]\nstruct UnitStruct;\ntest_type!(UnitStruct = {\n\t\"type\": \"object\",\n\t\"title\": \"UnitStruct\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\nstruct SimpleStruct {\n\tfoo: String,\n\tbar: isize\n}\ntest_type!(SimpleStruct = {\n\t\"type\": \"object\",\n\t\"title\": \"SimpleStruct\",\n\t\"properties\": {\n\t\t\"foo\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"bar\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"foo\", \"bar\"]\n});\n\n#[derive(OpenapiType)]\n#[openapi(rename = \"FooBar\")]\nstruct StructRename;\ntest_type!(StructRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FooBar\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\nenum EnumWithoutFields {\n\tSuccess,\n\tError\n}\ntest_type!(EnumWithoutFields = {\n\t\"type\": \"string\",\n\t\"title\": \"EnumWithoutFields\",\n\t\"enum\": [\n\t\t\"Success\",\n\t\t\"Error\"\n\t]\n});\n\n#[derive(OpenapiType)]\nenum EnumWithOneField {\n\tSuccess { value: isize }\n}\ntest_type!(EnumWithOneField = {\n\t\"type\": \"object\",\n\t\"title\": \"EnumWithOneField\",\n\t\"properties\": {\n\t\t\"Success\": {\n\t\t\t\"$ref\": \"#/components/schemas/EnumWithOneField__Success\"\n\t\t}\n\t},\n\t\"required\": [\"Success\"]\n}, {\n\t\"EnumWithOneField__Success\": {\n\t\t\"title\": \"EnumWithOneField::Success\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t}\n});\n\n#[derive(OpenapiType)]\nenum EnumWithFields {\n\tSuccess { value: isize },\n\tError { msg: String }\n}\ntest_type!(EnumWithFields = {\n\t\"title\": \"EnumWithFields\",\n\t\"oneOf\": [{\n\t\t\"$ref\": \"#/components/schemas/EnumWithFields__Success__ExtTagWrapper\"\n\t}, {\n\t\t\"$ref\": \"#/components/schemas/EnumWithFields__Error__ExtTagWrapper\"\n\t}]\n}, {\n\t\"EnumWithFields__Success\": {\n\t\t\"title\": \"EnumWithFields::Success\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t},\n\t\"EnumWithFields__Success__ExtTagWrapper\": {\n\t\t\"title\": \"EnumWithFields::Success::ExtTagWrapper\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Success\": {\n\t\t\t\t\"$ref\": \"#/components/schemas/EnumWithFields__Success\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Success\"]\n\t},\n\t\"EnumWithFields__Error\": {\n\t\t\"title\": \"EnumWithFields::Error\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"msg\": {\n\t\t\t\t\"type\": \"string\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"msg\"]\n\t},\n\t\"EnumWithFields__Error__ExtTagWrapper\": {\n\t\t\"title\": \"EnumWithFields::Error::ExtTagWrapper\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Error\": {\n\t\t\t\t\"$ref\": \"#/components/schemas/EnumWithFields__Error\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Error\"]\n\t}\n});\n\n#[derive(OpenapiType)]\nenum EnumExternallyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumExternallyTagged = {\n\t\"title\": \"EnumExternallyTagged\",\n\t\"oneOf\": [{\n\t\t\"$ref\": \"#/components/schemas/EnumExternallyTagged__Success__ExtTagWrapper\"\n\t}, {\n\t\t\"type\": \"string\",\n\t\t\"enum\": [\"Empty\", \"Error\"]\n\t}]\n}, {\n\t\"EnumExternallyTagged__Success\": {\n\t\t\"title\": \"EnumExternallyTagged::Success\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t},\n\t\"EnumExternallyTagged__Success__ExtTagWrapper\": {\n\t\t\"title\": \"EnumExternallyTagged::Success::ExtTagWrapper\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Success\": {\n\t\t\t\t\"$ref\": \"#/components/schemas/EnumExternallyTagged__Success\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Success\"]\n\t}\n});\n\n#[derive(OpenapiType)]\n#[openapi(tag = \"ty\")]\nenum EnumInternallyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\n// TODO the Success variant should probably be $ref-ed\ntest_type!(EnumInternallyTagged = {\n\t\"title\": \"EnumInternallyTagged\",\n\t\"oneOf\": [{\n\t\t\"$ref\": \"#/components/schemas/EnumInternallyTagged__Success\"\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Empty\", \"Error\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\"]\n\t}]\n}, {\n\t\"EnumInternallyTagged__Success\": {\n\t\t\"title\": \"EnumInternallyTagged::Success\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t},\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Success\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\", \"ty\"]\n\t}\n});\n\n#[derive(OpenapiType)]\n#[openapi(tag = \"ty\", content = \"ct\")]\nenum EnumAdjacentlyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumAdjacentlyTagged = {\n\t\"title\": \"EnumAdjacentlyTagged\",\n\t\"oneOf\": [{\n\t\t\"$ref\": \"#/components/schemas/EnumAdjacentlyTagged__Success__AdjTagWrapper\"\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Empty\", \"Error\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\"]\n\t}]\n}, {\n\t\"EnumAdjacentlyTagged__Success\": {\n\t\t\"title\": \"EnumAdjacentlyTagged::Success\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t},\n\t\"EnumAdjacentlyTagged__Success__AdjTagWrapper\": {\n\t\t\"title\": \"EnumAdjacentlyTagged::Success::AdjTagWrapper\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Success\"]\n\t\t\t},\n\t\t\t\"ct\": {\n\t\t\t\t\"$ref\": \"#/components/schemas/EnumAdjacentlyTagged__Success\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\", \"ct\"]\n\t}\n});\n\n#[derive(OpenapiType)]\n#[openapi(untagged)]\nenum EnumUntagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\n// TODO the Success variant should probably be $ref-ed\ntest_type!(EnumUntagged = {\n\t\"title\": \"EnumUntagged\",\n\t\"oneOf\": [{\n\t\t\"$ref\": \"#/components/schemas/EnumUntagged__Success\"\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"additionalProperties\": false\n\t}]\n}, {\n\t\"EnumUntagged__Success\": {\n\t\t\"title\": \"EnumUntagged::Success\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","custom_types_attrs.rs"],"content":"#![allow(dead_code)]\nuse openapi_type::OpenapiType;\n\ninclude!(\"util/test_type.rs\");\n\n/// Very cool struct!\n#[derive(OpenapiType)]\nstruct StructDoc {\n\t/// Very important!\n\tfoo: String\n}\ntest_type!(StructDoc = {\n\t\"type\": \"object\",\n\t\"title\": \"StructDoc\",\n\t\"description\": \"Very cool struct!\",\n\t\"properties\": {\n\t\t\"foo\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"Very important!\"\n\t\t}\n\t},\n\t\"required\": [\"foo\"]\n});\n\n/// Very cool enum!\n#[derive(OpenapiType)]\nenum EnumDoc {\n\t/// Look, a message!\n\tMessage {\n\t\t/// The text of the message in markdown format.\n\t\ttext: String\n\t},\n\t/// Oops\n\tError\n}\n// TODO the variant doc isn't currently included\ntest_type!(EnumDoc = {\n\t\"title\": \"EnumDoc\",\n\t\"description\": \"Very cool enum!\",\n\t\"oneOf\": [{\n\t\t\"$ref\": \"#/components/schemas/EnumDoc__Message__ExtTagWrapper\"\n\t}, {\n\t\t\"type\": \"string\",\n\t\t\"enum\": [\"Error\"]\n\t}]\n}, {\n\t\"EnumDoc__Message\": {\n\t\t\"title\": \"EnumDoc::Message\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"description\": \"The text of the message in markdown format.\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"text\"]\n\t},\n\t\"EnumDoc__Message__ExtTagWrapper\": {\n\t\t\"title\": \"EnumDoc::Message::ExtTagWrapper\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Message\": {\n\t\t\t\t\"$ref\": \"#/components/schemas/EnumDoc__Message\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Message\"]\n\t}\n});\n\n#[derive(OpenapiType)]\n#[openapi(rename = \"FooBar\")]\nstruct ContainerRename;\ntest_type!(ContainerRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FooBar\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\n#[openapi(rename_all = \"UPPERCASE\")]\nstruct FieldRename {\n\t#[openapi(rename = \"bar\")]\n\tfoo: String\n}\ntest_type!(FieldRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FieldRename\",\n\t\"properties\": {\n\t\t\"bar\": {\n\t\t\t\"type\": \"string\"\n\t\t}\n\t},\n\t\"required\": [\"bar\"]\n});\n\n#[derive(OpenapiType)]\nstruct FieldFlattenInner {\n\tinner: String\n}\n#[derive(OpenapiType)]\nstruct FieldFlatten {\n\touter: String,\n\t#[openapi(flatten)]\n\tflat: FieldFlattenInner\n}\ntest_type!(FieldFlatten = {\n\t\"type\": \"object\",\n\t\"title\": \"FieldFlatten\",\n\t\"properties\": {\n\t\t\"inner\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"outer\": {\n\t\t\t\"type\": \"string\"\n\t\t}\n\t},\n\t\"required\": [\"outer\", \"inner\"]\n});\n\n#[derive(OpenapiType)]\nstruct FieldSkip {\n\t#[openapi(skip_serializing, skip_deserializing)]\n\tfoo: String,\n\t#[openapi(skip)]\n\tbar: String\n}\ntest_type!(FieldSkip = {\n\t\"type\": \"object\",\n\t\"title\": \"FieldSkip\"\n});\n\n#[derive(OpenapiType)]\nstruct FieldNullable {\n\t#[openapi(skip_serializing)]\n\tfoo0: String,\n\t#[openapi(skip_deserializing)]\n\tfoo1: String,\n\t#[openapi(default)]\n\tfoo2: String,\n\t#[openapi(default = \"String::new\")]\n\tfoo3: String,\n\t#[openapi(skip_serializing_if = \"String::is_empty\")]\n\tfoo4: String\n}\ntest_type!(FieldNullable = {\n\t\"type\": \"object\",\n\t\"title\": \"FieldNullable\",\n\t\"properties\": {\n\t\t\"foo0\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"foo1\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"foo2\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"foo3\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"foo4\": {\n\t\t\t\"type\": \"string\"\n\t\t}\n\t}\n});\n\nmacro_rules! test_rename_all {\n\t(rename_all = $rename_all:literal, foo_bar = $foo_bar:literal) => {\n\t\tpaste::paste! {\n\t\t\t#[derive(OpenapiType, serde::Serialize)]\n\t\t\t#[openapi(rename = \"FooBar\")]\n\t\t\t#[serde(rename_all = $rename_all)]\n\t\t\t#[allow(non_camel_case_types, non_snake_case)]\n\t\t\tstruct [< ContainerRenameAll_ $rename_all >] {\n\t\t\t\tfoo_bar: Option<&'static str>,\n\t\t\t}\n\t\t\ttest_type!([< ContainerRenameAll_ $rename_all >] = {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"title\": \"FooBar\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t$foo_bar: {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t});\n\t\t\t#[test]\n\t\t\tfn [< containerrenameall_ $rename_all:lower _serde >]() {\n\t\t\t\tlet value = [< ContainerRenameAll_ $rename_all >] {\n\t\t\t\t\tfoo_bar: Some(\"foo_bar\"),\n\t\t\t\t};\n\t\t\t\tlet json = serde_json::to_value(&value).unwrap();\n\t\t\t\tlet expected = serde_json::json!({\n\t\t\t\t\t$foo_bar: \"foo_bar\",\n\t\t\t\t});\n\t\t\t\tpretty_assertions::assert_eq!(json, expected);\n\t\t\t}\n\t\t}\n\t};\n}\n\ntest_rename_all!(rename_all = \"lowercase\", foo_bar = \"foo_bar\");\ntest_rename_all!(rename_all = \"UPPERCASE\", foo_bar = \"FOO_BAR\");\ntest_rename_all!(rename_all = \"PascalCase\", foo_bar = \"FooBar\");\ntest_rename_all!(rename_all = \"camelCase\", foo_bar = \"fooBar\");\ntest_rename_all!(rename_all = \"snake_case\", foo_bar = \"foo_bar\");\ntest_rename_all!(rename_all = \"SCREAMING_SNAKE_CASE\", foo_bar = \"FOO_BAR\");\ntest_rename_all!(rename_all = \"kebab-case\", foo_bar = \"foo-bar\");\ntest_rename_all!(rename_all = \"SCREAMING-KEBAB-CASE\", foo_bar = \"FOO-BAR\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","enum_with_no_variants.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nenum Foo {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","not_openapitype.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo {\n\tbar: Bar\n}\n\nstruct Bar;\n\nfn main() {\n\tFoo::schema();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","not_openapitype_generics.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo<T> {\n\tbar: T\n}\n\nstruct Bar;\n\nfn main() {\n\t<Foo<Bar>>::schema();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","tuple_struct.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo(i64, i64);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","tuple_variant.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nenum Foo {\n\tPair(i64, i64)\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","union.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nunion Foo {\n\tsigned: i64,\n\tunsigned: u64\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","unknown_attribute.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\n#[openapi(pizza)]\nstruct Foo;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","std_types.rs"],"content":"#[cfg(feature = \"chrono\")]\nuse chrono::{Date, DateTime, FixedOffset, NaiveDate, NaiveDateTime, Utc};\nuse indexmap::{IndexMap, IndexSet};\nuse openapi_type::OpenapiType;\nuse serde_json::Value;\nuse std::{\n\tcollections::{BTreeMap, BTreeSet, HashMap, HashSet},\n\tnum::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize}\n};\n#[cfg(feature = \"uuid\")]\nuse uuid::Uuid;\n\nmacro_rules! test_type {\n\t($($ty:ident $(<$($generic:ident),+>)*),* = $json:tt) => {\n\t\tpaste::paste! { $(\n\t\t\t#[test]\n\t\t\tfn [< $ty:lower $($(_ $generic:lower)+)* >]() {\n\t\t\t\tlet schema = <$ty $(<$($generic),+>)* as OpenapiType>::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(&schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t}\n\t\t)* }\n\t};\n}\n\ntype Unit = ();\ntest_type!(Unit = {\n\t\"type\": \"object\",\n\t\"additionalProperties\": false\n});\n\ntest_type!(Value = {\n\t\"nullable\": true\n});\n\ntest_type!(bool = {\n\t\"type\": \"boolean\"\n});\n\n// ### integer types\n\ntest_type!(isize = {\n\t\"type\": \"integer\"\n});\n\ntest_type!(usize = {\n\t\"type\": \"integer\",\n\t\"minimum\": 0\n});\n\ntest_type!(i8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\"\n});\n\ntest_type!(u8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\",\n\t\"minimum\": 0\n});\n\ntest_type!(i16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\"\n});\n\ntest_type!(u16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\",\n\t\"minimum\": 0\n});\n\ntest_type!(i32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\"\n});\n\ntest_type!(u32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\",\n\t\"minimum\": 0\n});\n\ntest_type!(i64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\"\n});\n\ntest_type!(u64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\",\n\t\"minimum\": 0\n});\n\ntest_type!(i128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\"\n});\n\ntest_type!(u128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\",\n\t\"minimum\": 0\n});\n\n// ### non-zero integer types\n\ntest_type!(NonZeroUsize = {\n\t\"type\": \"integer\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\",\n\t\"minimum\": 1\n});\n\n// ### floats\n\ntest_type!(f32 = {\n\t\"type\": \"number\",\n\t\"format\": \"float\"\n});\n\ntest_type!(f64 = {\n\t\"type\": \"number\",\n\t\"format\": \"double\"\n});\n\n// ### string\n\ntest_type!(String = {\n\t\"type\": \"string\"\n});\n\n#[cfg(feature = \"uuid\")]\ntest_type!(Uuid = {\n\t\"type\": \"string\",\n\t\"format\": \"uuid\"\n});\n\n// ### date/time\n\n#[cfg(feature = \"chrono\")]\ntest_type!(Date<FixedOffset>, Date<Utc>, NaiveDate = {\n\t\"type\": \"string\",\n\t\"format\": \"date\"\n});\n\n#[cfg(feature = \"chrono\")]\ntest_type!(DateTime<FixedOffset>, DateTime<Utc>, NaiveDateTime = {\n\t\"type\": \"string\",\n\t\"format\": \"date-time\"\n});\n\n// ### some std types\n\ntest_type!(Option<String> = {\n\t\"type\": \"string\",\n\t\"nullable\": true\n});\n\ntest_type!(Vec<String> = {\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"string\"\n\t}\n});\n\ntest_type!(BTreeSet<String>, IndexSet<String>, HashSet<String> = {\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"string\"\n\t},\n\t\"uniqueItems\": true\n});\n\ntest_type!(BTreeMap<isize, String>, IndexMap<isize, String>, HashMap<isize, String> = {\n\t\"type\": \"object\",\n\t\"properties\": {\n\t\t\"default\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"default\"],\n\t\"additionalProperties\": {\n\t\t\"type\": \"string\"\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","trybuild.rs"],"content":"use trybuild::TestCases;\n\n#[test]\nfn trybuild() {\n\tlet t = TestCases::new();\n\tt.compile_fail(\"tests/fail/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","util","test_type.rs"],"content":"macro_rules! test_type {\n\t($ty:ty = $json:tt) => {\n\t\tpaste::paste! {\n\t\t\t#[test]\n\t\t\tfn [< $ty:lower >]() {\n\t\t\t\tlet schema = <$ty as OpenapiType>::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(&schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t}\n\t\t}\n\t};\n\t($ty:ty = $json:tt, {$($dep_name:literal: $dep_json:tt),*}) => {\n\t\ttest_type!($ty = $json);\n\t\tpaste::paste! {\n\t\t\t#[test]\n\t\t\tfn [< $ty:lower _dependencies >]() {\n\t\t\t\tlet mut schema = <$ty as OpenapiType>::schema();\n\t\t\t\t$({\n\t\t\t\t\tlet dep_schema = schema.dependencies.remove($dep_name).expect(concat!(\"Schema is missing the following dependency: \", $dep_name));\n\t\t\t\t\tlet dep_schema = openapi_type::OpenapiSchema::into_schema(dep_schema);\n\t\t\t\t\tlet dep_json = serde_json::to_value(&dep_schema).unwrap();\n\t\t\t\t\tlet expected = serde_json::json!($dep_json);\n\t\t\t\t\tpretty_assertions::assert_eq!(dep_json, expected)\n\t\t\t\t})*\n\t\t\t}\n\t\t}\n\t};\n}\n","traces":[],"covered":0,"coverable":0}]}