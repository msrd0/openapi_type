{"files":[{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","attrs.rs"],"content":"use crate::util::ExpectLit;\nuse syn::{punctuated::Punctuated, spanned::Spanned as _, Attribute, LitStr, Meta, Token};\n\n#[derive(Default)]\npub(super) struct ContainerAttributes {\n\tpub(super) rename: Option<LitStr>,\n\tpub(super) rename_all: Option<LitStr>,\n\tpub(super) tag: Option<LitStr>,\n\tpub(super) content: Option<LitStr>,\n\tpub(super) untagged: bool\n}\n\npub(super) fn parse_container_attrs(\n\tinput: &Attribute,\n\tattrs: &mut ContainerAttributes,\n\terror_on_unknown: bool\n) -> syn::Result<()> {\n\tlet tokens: Punctuated<Meta, Token![,]> = input.parse_args_with(Punctuated::parse_terminated)?;\n\tfor token in tokens {\n\t\tmatch token {\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"rename\") => {\n\t\t\t\tattrs.rename = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"rename_all\") => {\n\t\t\t\tattrs.rename_all = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"tag\") => {\n\t\t\t\tattrs.tag = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"content\") => {\n\t\t\t\tattrs.content = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::Path(path) if path.is_ident(\"untagged\") => {\n\t\t\t\tattrs.untagged = true;\n\t\t\t},\n\n\t\t\tMeta::Path(path) if error_on_unknown => return Err(syn::Error::new(path.span(), \"Unexpected token\")),\n\t\t\tMeta::List(list) if error_on_unknown => return Err(syn::Error::new(list.span(), \"Unexpected token\")),\n\t\t\tMeta::NameValue(kv) if error_on_unknown => return Err(syn::Error::new(kv.path.span(), \"Unexpected token\")),\n\t\t\t_ => {}\n\t\t}\n\t}\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","codegen.rs"],"content":"use crate::parser::{ParseData, ParseDataType};\nuse proc_macro2::TokenStream;\nuse quote::quote;\nuse syn::LitStr;\n\nimpl ParseData {\n\tpub(super) fn gen_schema(&self) -> TokenStream {\n\t\tmatch self {\n\t\t\tSelf::Struct(fields) => gen_struct(fields),\n\t\t\tSelf::Enum(variants) => gen_enum(variants),\n\t\t\tSelf::Alternatives(alt) => gen_alt(alt),\n\t\t\tSelf::Unit => gen_unit()\n\t\t}\n\t}\n}\n\nfn gen_struct(fields: &[(LitStr, ParseDataType)]) -> TokenStream {\n\tlet field_name = fields.iter().map(|(name, _)| name);\n\tlet field_schema = fields.iter().map(|(_, ty)| match ty {\n\t\tParseDataType::Type(ty) => {\n\t\t\tquote!(<#ty as ::openapi_type::OpenapiType>::schema())\n\t\t},\n\t\tParseDataType::Inline(data) => {\n\t\t\tlet code = data.gen_schema();\n\t\t\tquote!(::openapi_type::OpenapiSchema::new(#code))\n\t\t}\n\t});\n\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t{\n\t\t\tlet mut properties = <::openapi_type::indexmap::IndexMap<\n\t\t\t\t::std::string::String,\n\t\t\t\t#openapi::ReferenceOr<::std::boxed::Box<#openapi::Schema>>\n\t\t\t>>::new();\n\t\t\tlet mut required = <::std::vec::Vec<::std::string::String>>::new();\n\n\t\t\t#({\n\t\t\t\t\tconst FIELD_NAME: &::core::primitive::str = #field_name;\n\t\t\t\t\tlet mut field_schema = #field_schema;\n\t\t\t\t\t::openapi_type::private::add_dependencies(\n\t\t\t\t\t\t&mut dependencies,\n\t\t\t\t\t\t&mut field_schema.dependencies\n\t\t\t\t\t);\n\n\t\t\t\t\t// fields in OpenAPI are nullable by default\n\t\t\t\t\tmatch field_schema.nullable {\n\t\t\t\t\t\ttrue => field_schema.nullable = false,\n\t\t\t\t\t\tfalse => required.push(::std::string::String::from(FIELD_NAME))\n\t\t\t\t\t};\n\n\t\t\t\t\tmatch field_schema.name.as_ref() {\n\t\t\t\t\t\t// include the field schema as reference\n\t\t\t\t\t\t::std::option::Option::Some(schema_name) => {\n\t\t\t\t\t\t\tlet mut reference = ::std::string::String::from(\"#/components/schemas/\");\n\t\t\t\t\t\t\treference.push_str(schema_name);\n\t\t\t\t\t\t\tproperties.insert(\n\t\t\t\t\t\t\t\t::std::string::String::from(FIELD_NAME),\n\t\t\t\t\t\t\t\t#openapi::ReferenceOr::Reference { reference }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdependencies.insert(\n\t\t\t\t\t\t\t\t::std::string::String::from(schema_name),\n\t\t\t\t\t\t\t\tfield_schema\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t// inline the field schema\n\t\t\t\t\t\t::std::option::Option::None => {\n\t\t\t\t\t\t\tproperties.insert(\n\t\t\t\t\t\t\t\t::std::string::String::from(FIELD_NAME),\n\t\t\t\t\t\t\t\t#openapi::ReferenceOr::Item(\n\t\t\t\t\t\t\t\t\t::std::boxed::Box::new(\n\t\t\t\t\t\t\t\t\t\tfield_schema.into_schema()\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t})*\n\n\t\t\t#openapi::SchemaKind::Type(\n\t\t\t\t#openapi::Type::Object(\n\t\t\t\t\t#openapi::ObjectType {\n\t\t\t\t\t\tproperties,\n\t\t\t\t\t\trequired,\n\t\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}\n}\n\nfn gen_enum(variants: &[LitStr]) -> TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t{\n\t\t\tlet mut enumeration = <::std::vec::Vec<::std::string::String>>::new();\n\t\t\t#(enumeration.push(::std::string::String::from(#variants));)*\n\t\t\t#openapi::SchemaKind::Type(\n\t\t\t\t#openapi::Type::String(\n\t\t\t\t\t#openapi::StringType {\n\t\t\t\t\t\tenumeration,\n\t\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}\n}\n\nfn gen_alt(alt: &[ParseData]) -> TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tlet schema = alt.iter().map(|data| data.gen_schema());\n\tquote! {\n\t\t{\n\t\t\tlet mut alternatives = <::std::vec::Vec<\n\t\t\t\t#openapi::ReferenceOr<#openapi::Schema>\n\t\t\t>>::new();\n\t\t\t#(alternatives.push(#openapi::ReferenceOr::Item(\n\t\t\t\t::openapi_type::OpenapiSchema::new(#schema).into_schema()\n\t\t\t));)*\n\t\t\t#openapi::SchemaKind::OneOf {\n\t\t\t\tone_of: alternatives\n\t\t\t}\n\t\t}\n\t}\n}\n\nfn gen_unit() -> TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t#openapi::SchemaKind::Type(\n\t\t\t#openapi::Type::Object(\n\t\t\t\t#openapi::ObjectType {\n\t\t\t\t\tadditional_properties: ::std::option::Option::Some(\n\t\t\t\t\t\t#openapi::AdditionalProperties::Any(false)\n\t\t\t\t\t),\n\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t}\n\t\t\t)\n\t\t)\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms)]\n#![deny(broken_intra_doc_links)]\n#![forbid(unsafe_code)]\n//! This crate defines the macros for `#[derive(OpenapiType)]`.\n\nuse proc_macro::TokenStream;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::quote;\nuse syn::{parse_macro_input, Data, DeriveInput, LitStr, TraitBound, TraitBoundModifier, TypeParamBound};\n\n#[macro_use]\nmod util;\n\nmod attrs;\nuse attrs::*;\nmod codegen;\nmod parser;\nuse parser::*;\n\n/// The derive macro for [OpenapiType](https://docs.rs/openapi_type/*/openapi_type/trait.OpenapiType.html).\n#[proc_macro_derive(OpenapiType, attributes(openapi))]\npub fn derive_openapi_type(input: TokenStream) -> TokenStream {\n\tlet input = parse_macro_input!(input);\n\texpand_openapi_type(input).unwrap_or_else(|err| err.to_compile_error()).into()\n}\n\nfn expand_openapi_type(mut input: DeriveInput) -> syn::Result<TokenStream2> {\n\t// parse #[serde] and #[openapi] attributes\n\tlet mut attrs = ContainerAttributes::default();\n\tfor attr in &input.attrs {\n\t\tif attr.path.is_ident(\"serde\") {\n\t\t\tparse_container_attrs(attr, &mut attrs, false)?;\n\t\t}\n\t}\n\tfor attr in &input.attrs {\n\t\tif attr.path.is_ident(\"openapi\") {\n\t\t\tparse_container_attrs(attr, &mut attrs, true)?;\n\t\t}\n\t}\n\n\t// prepare impl block for codegen\n\tlet ident = &input.ident;\n\tlet name = ident.to_string();\n\tlet mut name = LitStr::new(&name, ident.span());\n\tif let Some(rename) = &attrs.rename {\n\t\tname = rename.clone();\n\t}\n\n\t// prepare the generics - all impl generics will get `OpenapiType` requirement\n\tlet (impl_generics, ty_generics, where_clause) = {\n\t\tlet generics = &mut input.generics;\n\t\tgenerics.type_params_mut().for_each(|param| {\n\t\t\tparam.colon_token.get_or_insert_with(Default::default);\n\t\t\tparam.bounds.push(TypeParamBound::Trait(TraitBound {\n\t\t\t\tparen_token: None,\n\t\t\t\tmodifier: TraitBoundModifier::None,\n\t\t\t\tlifetimes: None,\n\t\t\t\tpath: path!(::openapi_type::OpenapiType)\n\t\t\t}));\n\t\t});\n\t\tgenerics.split_for_impl()\n\t};\n\n\t// parse the input data\n\tlet parsed = match &input.data {\n\t\tData::Struct(strukt) => parse_struct(strukt)?,\n\t\tData::Enum(inum) => parse_enum(inum, &attrs)?,\n\t\tData::Union(union) => parse_union(union)?\n\t};\n\n\t// run the codegen\n\tlet schema_code = parsed.gen_schema();\n\n\t// put the code together\n\tOk(quote! {\n\t\t#[allow(unused_mut)]\n\t\timpl #impl_generics ::openapi_type::OpenapiType for #ident #ty_generics #where_clause {\n\t\t\tfn schema() -> ::openapi_type::OpenapiSchema {\n\t\t\t\t// prepare the dependencies\n\t\t\t\tlet mut dependencies = ::openapi_type::private::Dependencies::new();\n\n\t\t\t\t// create the schema\n\t\t\t\tlet schema = #schema_code;\n\n\t\t\t\t// return everything\n\t\t\t\tconst NAME: &::core::primitive::str = #name;\n\t\t\t\t::openapi_type::OpenapiSchema {\n\t\t\t\t\tname: ::std::option::Option::Some(::std::string::String::from(NAME)),\n\t\t\t\t\tnullable: false,\n\t\t\t\t\tschema,\n\t\t\t\t\tdependencies\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","parser.rs"],"content":"use crate::{attrs::ContainerAttributes, util::ToLitStr};\nuse proc_macro2::Span;\nuse syn::{spanned::Spanned as _, DataEnum, DataStruct, DataUnion, Fields, FieldsNamed, LitStr, Type};\n\npub(super) enum ParseDataType {\n\tType(Type),\n\tInline(ParseData)\n}\n\n#[allow(dead_code)]\npub(super) enum ParseData {\n\tStruct(Vec<(LitStr, ParseDataType)>),\n\tEnum(Vec<LitStr>),\n\tAlternatives(Vec<ParseData>),\n\tUnit\n}\n\nfn parse_named_fields(named_fields: &FieldsNamed) -> syn::Result<ParseData> {\n\tlet mut fields: Vec<(LitStr, ParseDataType)> = Vec::new();\n\tfor f in &named_fields.named {\n\t\tlet ident = f\n\t\t\t.ident\n\t\t\t.as_ref()\n\t\t\t.ok_or_else(|| syn::Error::new(f.span(), \"#[derive(OpenapiType)] does not support fields without an ident\"))?;\n\t\tlet name = ident.to_lit_str();\n\t\tlet ty = f.ty.to_owned();\n\t\tfields.push((name, ParseDataType::Type(ty)));\n\t}\n\tOk(ParseData::Struct(fields))\n}\n\npub(super) fn parse_struct(strukt: &DataStruct) -> syn::Result<ParseData> {\n\tmatch &strukt.fields {\n\t\tFields::Named(named_fields) => parse_named_fields(named_fields),\n\t\tFields::Unnamed(unnamed_fields) => Err(syn::Error::new(\n\t\t\tunnamed_fields.span(),\n\t\t\t\"#[derive(OpenapiType)] does not support tuple structs\"\n\t\t)),\n\t\tFields::Unit => Ok(ParseData::Unit)\n\t}\n}\n\npub(super) fn parse_enum(inum: &DataEnum, attrs: &ContainerAttributes) -> syn::Result<ParseData> {\n\tlet mut strings: Vec<LitStr> = Vec::new();\n\tlet mut types: Vec<(LitStr, ParseData)> = Vec::new();\n\n\tfor v in &inum.variants {\n\t\tlet name = v.ident.to_lit_str();\n\t\tmatch &v.fields {\n\t\t\tFields::Named(named_fields) => {\n\t\t\t\ttypes.push((name, parse_named_fields(named_fields)?));\n\t\t\t},\n\t\t\tFields::Unnamed(unnamed_fields) => {\n\t\t\t\treturn Err(syn::Error::new(\n\t\t\t\t\tunnamed_fields.span(),\n\t\t\t\t\t\"#[derive(OpenapiType)] does not support tuple variants\"\n\t\t\t\t))\n\t\t\t},\n\t\t\tFields::Unit => strings.push(name)\n\t\t}\n\t}\n\n\tlet data_strings = if strings.is_empty() {\n\t\tNone\n\t} else {\n\t\tmatch (&attrs.tag, &attrs.content, attrs.untagged) {\n\t\t\t// externally tagged (default)\n\t\t\t(None, None, false) => Some(ParseData::Enum(strings)),\n\t\t\t// internally tagged or adjacently tagged\n\t\t\t(Some(tag), _, false) => Some(ParseData::Struct(vec![(\n\t\t\t\ttag.clone(),\n\t\t\t\tParseDataType::Inline(ParseData::Enum(strings))\n\t\t\t)])),\n\t\t\t// untagged\n\t\t\t(None, None, true) => Some(ParseData::Unit),\n\t\t\t// unknown\n\t\t\t_ => return Err(syn::Error::new(Span::call_site(), \"Unknown enum representation\"))\n\t\t}\n\t};\n\n\tlet data_types =\n\t\tif types.is_empty() {\n\t\t\tNone\n\t\t} else {\n\t\t\tSome(ParseData::Alternatives(\n\t\t\t\ttypes\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|(name, mut data)| {\n\t\t\t\t\t\tOk(match (&attrs.tag, &attrs.content, attrs.untagged) {\n\t\t\t\t\t\t\t// externally tagged (default)\n\t\t\t\t\t\t\t(None, None, false) => ParseData::Struct(vec![(name, ParseDataType::Inline(data))]),\n\t\t\t\t\t\t\t// internally tagged\n\t\t\t\t\t\t\t(Some(tag), None, false) => {\n\t\t\t\t\t\t\t\tmatch &mut data {\n\t\t\t\t\t\t\t\t\tParseData::Struct(fields) => {\n\t\t\t\t\t\t\t\t\t\tfields.push((tag.clone(), ParseDataType::Inline(ParseData::Enum(vec![name]))))\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t_ => return Err(syn::Error::new(\n\t\t\t\t\t\t\t\t\t\ttag.span(),\n\t\t\t\t\t\t\t\t\t\t\"#[derive(OpenapiType)] does not support tuple variants on internally tagged enums\"\n\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t// adjacently tagged\n\t\t\t\t\t\t\t(Some(tag), Some(content), false) => ParseData::Struct(vec![\n\t\t\t\t\t\t\t\t(tag.clone(), ParseDataType::Inline(ParseData::Enum(vec![name]))),\n\t\t\t\t\t\t\t\t(content.clone(), ParseDataType::Inline(data)),\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t// untagged\n\t\t\t\t\t\t\t(None, None, true) => data,\n\t\t\t\t\t\t\t// unknown\n\t\t\t\t\t\t\t_ => return Err(syn::Error::new(Span::call_site(), \"Unknown enum representation\"))\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t\t.collect::<syn::Result<Vec<_>>>()?\n\t\t\t))\n\t\t};\n\n\tmatch (data_strings, data_types) {\n\t\t// only variants without fields\n\t\t(Some(data), None) => Ok(data),\n\t\t// only one variant with fields\n\t\t(None, Some(ParseData::Alternatives(mut alt))) if alt.len() == 1 => Ok(alt.remove(0)),\n\t\t// only variants with fields\n\t\t(None, Some(data)) => Ok(data),\n\t\t// variants with and without fields\n\t\t(Some(data), Some(ParseData::Alternatives(mut alt))) => {\n\t\t\talt.push(data);\n\t\t\tOk(ParseData::Alternatives(alt))\n\t\t},\n\t\t// no variants\n\t\t(None, None) => Err(syn::Error::new(\n\t\t\tinum.brace_token.span,\n\t\t\t\"#[derive(OpenapiType)] does not support enums with no variants\"\n\t\t)),\n\t\t// data_types always produces Alternatives\n\t\t_ => unreachable!()\n\t}\n}\n\npub(super) fn parse_union(union: &DataUnion) -> syn::Result<ParseData> {\n\tErr(syn::Error::new(\n\t\tunion.union_token.span(),\n\t\t\"#[derive(OpenapiType)] cannot be used on unions\"\n\t))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","util.rs"],"content":"use proc_macro2::Ident;\nuse syn::{Lit, LitStr};\n\n/// Convert any literal path into a [syn::Path].\nmacro_rules! path {\n\t(:: $($segment:ident)::*) => {\n\t\tpath!(@private Some(Default::default()), $($segment),*)\n\t};\n\t($($segment:ident)::*) => {\n\t\tpath!(@private None, $($segment),*)\n\t};\n\t(@private $leading_colon:expr, $($segment:ident),*) => {\n\t\t{\n\t\t\t#[allow(unused_mut)]\n\t\t\tlet mut segments: ::syn::punctuated::Punctuated<::syn::PathSegment, _> = Default::default();\n\t\t\t$(\n\t\t\t\tsegments.push(::syn::PathSegment {\n\t\t\t\t\tident: ::proc_macro2::Ident::new(stringify!($segment), ::proc_macro2::Span::call_site()),\n\t\t\t\t\targuments: Default::default()\n\t\t\t\t});\n\t\t\t)*\n\t\t\t::syn::Path {\n\t\t\t\tleading_colon: $leading_colon,\n\t\t\t\tsegments\n\t\t\t}\n\t\t}\n\t};\n}\n\n/// Convert any [Ident] into a [LitStr]. Basically `stringify!`.\npub(super) trait ToLitStr {\n\tfn to_lit_str(&self) -> LitStr;\n}\nimpl ToLitStr for Ident {\n\tfn to_lit_str(&self) -> LitStr {\n\t\tLitStr::new(&self.to_string(), self.span())\n\t}\n}\n\n/// Convert a [Lit] to one specific literal type.\npub(crate) trait ExpectLit {\n\tfn expect_str(self) -> syn::Result<LitStr>;\n}\n\nimpl ExpectLit for Lit {\n\tfn expect_str(self) -> syn::Result<LitStr> {\n\t\tmatch self {\n\t\t\tSelf::Str(str) => Ok(str),\n\t\t\t_ => Err(syn::Error::new(self.span(), \"Expected string literal\"))\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","src","impls.rs"],"content":"use crate::{OpenapiSchema, OpenapiType};\n#[cfg(feature = \"chrono\")]\nuse chrono::{offset::TimeZone, Date, DateTime, NaiveDate, NaiveDateTime};\nuse indexmap::{IndexMap, IndexSet};\nuse openapiv3::{\n\tAdditionalProperties, ArrayType, IntegerType, NumberFormat, NumberType, ObjectType, ReferenceOr, SchemaKind,\n\tStringFormat, StringType, Type, VariantOrUnknownOrEmpty\n};\nuse serde_json::Value;\nuse std::{\n\tcollections::{BTreeMap, BTreeSet, HashMap, HashSet},\n\thash::BuildHasher,\n\tnum::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize}\n};\n#[cfg(feature = \"uuid\")]\nuse uuid::Uuid;\n\nmacro_rules! impl_openapi_type {\n\t($($ty:ident $(<$($generic:ident : $bound:path),+>)*),* => $schema:expr) => {\n\t\t$(\n\t\t\timpl $(<$($generic : $bound),+>)* OpenapiType for $ty $(<$($generic),+>)* {\n\t\t\t\tfn schema() -> OpenapiSchema {\n\t\t\t\t\t$schema\n\t\t\t\t}\n\t\t\t}\n\t\t)*\n\t};\n}\n\ntype Unit = ();\nimpl_openapi_type!(Unit => {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Object(ObjectType {\n\t\tadditional_properties: Some(AdditionalProperties::Any(false)),\n\t\t..Default::default()\n\t})))\n});\n\nimpl_openapi_type!(Value => {\n\tOpenapiSchema {\n\t\tnullable: true,\n\t\tname: None,\n\t\tschema: SchemaKind::Any(Default::default()),\n\t\tdependencies: Default::default()\n\t}\n});\n\nimpl_openapi_type!(bool => OpenapiSchema::new(SchemaKind::Type(Type::Boolean {})));\n\n#[inline]\nfn int_schema(minimum: Option<i64>, bits: Option<i64>) -> OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Integer(IntegerType {\n\t\tminimum,\n\t\tformat: bits\n\t\t\t.map(|bits| VariantOrUnknownOrEmpty::Unknown(format!(\"int{}\", bits)))\n\t\t\t.unwrap_or(VariantOrUnknownOrEmpty::Empty),\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(isize => int_schema(None, None));\nimpl_openapi_type!(i8 => int_schema(None, Some(8)));\nimpl_openapi_type!(i16 => int_schema(None, Some(16)));\nimpl_openapi_type!(i32 => int_schema(None, Some(32)));\nimpl_openapi_type!(i64 => int_schema(None, Some(64)));\nimpl_openapi_type!(i128 => int_schema(None, Some(128)));\n\nimpl_openapi_type!(usize => int_schema(Some(0), None));\nimpl_openapi_type!(u8 => int_schema(Some(0), Some(8)));\nimpl_openapi_type!(u16 => int_schema(Some(0), Some(16)));\nimpl_openapi_type!(u32 => int_schema(Some(0), Some(32)));\nimpl_openapi_type!(u64 => int_schema(Some(0), Some(64)));\nimpl_openapi_type!(u128 => int_schema(Some(0), Some(128)));\n\nimpl_openapi_type!(NonZeroUsize => int_schema(Some(1), None));\nimpl_openapi_type!(NonZeroU8 => int_schema(Some(1), Some(8)));\nimpl_openapi_type!(NonZeroU16 => int_schema(Some(1), Some(16)));\nimpl_openapi_type!(NonZeroU32 => int_schema(Some(1), Some(32)));\nimpl_openapi_type!(NonZeroU64 => int_schema(Some(1), Some(64)));\nimpl_openapi_type!(NonZeroU128 => int_schema(Some(1), Some(128)));\n\n#[inline]\nfn float_schema(format: NumberFormat) -> OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Number(NumberType {\n\t\tformat: VariantOrUnknownOrEmpty::Item(format),\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(f32 => float_schema(NumberFormat::Float));\nimpl_openapi_type!(f64 => float_schema(NumberFormat::Double));\n\n#[inline]\nfn str_schema(format: VariantOrUnknownOrEmpty<StringFormat>) -> OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::String(StringType {\n\t\tformat,\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(String, str => str_schema(VariantOrUnknownOrEmpty::Empty));\n\n#[cfg(feature = \"chrono\")]\nimpl_openapi_type!(Date<T: TimeZone>, NaiveDate => {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::Date))\n});\n\n#[cfg(feature = \"chrono\")]\nimpl_openapi_type!(DateTime<T: TimeZone>, NaiveDateTime => {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::DateTime))\n});\n\n#[cfg(feature = \"uuid\")]\nimpl_openapi_type!(Uuid => {\n\tstr_schema(VariantOrUnknownOrEmpty::Unknown(\"uuid\".to_owned()))\n});\n\nimpl_openapi_type!(Option<T: OpenapiType> => {\n\tlet schema = T::schema();\n\tlet mut dependencies = schema.dependencies.clone();\n\tlet schema = match schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\tSchemaKind::AllOf { all_of: vec![reference] }\n\t\t},\n\t\tNone => schema.schema\n\t};\n\n\tOpenapiSchema {\n\t\tnullable: true,\n\t\tname: None,\n\t\tschema,\n\t\tdependencies\n\t}\n});\n\n#[inline]\nfn array_schema<T: OpenapiType>(unique_items: bool) -> OpenapiSchema {\n\tlet schema = T::schema();\n\tlet mut dependencies = schema.dependencies.clone();\n\n\tlet items = match schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\treference\n\t\t},\n\t\tNone => ReferenceOr::Item(Box::new(schema.into_schema()))\n\t};\n\n\tOpenapiSchema {\n\t\tnullable: false,\n\t\tname: None,\n\t\tschema: SchemaKind::Type(Type::Array(ArrayType {\n\t\t\titems,\n\t\t\tmin_items: None,\n\t\t\tmax_items: None,\n\t\t\tunique_items\n\t\t})),\n\t\tdependencies\n\t}\n}\n\nimpl_openapi_type!(Vec<T: OpenapiType> => array_schema::<T>(false));\nimpl_openapi_type!(BTreeSet<T: OpenapiType>, IndexSet<T: OpenapiType>, HashSet<T: OpenapiType, S: BuildHasher> => {\n\tarray_schema::<T>(true)\n});\n\n#[inline]\nfn map_schema<K: OpenapiType, T: OpenapiType>() -> OpenapiSchema {\n\tlet key_schema = K::schema();\n\tlet mut dependencies = key_schema.dependencies.clone();\n\n\tlet keys = match key_schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, key_schema);\n\t\t\treference\n\t\t},\n\t\tNone => ReferenceOr::Item(Box::new(key_schema.into_schema()))\n\t};\n\n\tlet schema = T::schema();\n\tdependencies.extend(schema.dependencies.iter().map(|(k, v)| (k.clone(), v.clone())));\n\n\tlet items = Box::new(match schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\treference\n\t\t},\n\t\tNone => ReferenceOr::Item(schema.into_schema())\n\t});\n\n\tlet mut properties = IndexMap::new();\n\tproperties.insert(\"default\".to_owned(), keys);\n\n\tOpenapiSchema {\n\t\tnullable: false,\n\t\tname: None,\n\t\tschema: SchemaKind::Type(Type::Object(ObjectType {\n\t\t\tproperties,\n\t\t\trequired: vec![\"default\".to_owned()],\n\t\t\tadditional_properties: Some(AdditionalProperties::Schema(items)),\n\t\t\t..Default::default()\n\t\t})),\n\t\tdependencies\n\t}\n}\n\nimpl_openapi_type!(\n\tBTreeMap<K: OpenapiType, T: OpenapiType>,\n\tIndexMap<K: OpenapiType, T: OpenapiType>,\n\tHashMap<K: OpenapiType, T: OpenapiType, S: BuildHasher>\n\t=> map_schema::<K, T>()\n);\n","traces":[{"line":22,"address":[861280,860992,861184,860896,861088,860816],"length":1,"stats":{"Line":43},"fn_name":"schema"},{"line":32,"address":[818630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[818570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[818615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[818043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[817946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[817968],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[818019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[819082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[819191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[819255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[819335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[819415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[819495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[819575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[819655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[819735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[819831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[819927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[820023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[820119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[860823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[860903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[860999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[861095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[861191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[861287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[820215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[820263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[820311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[322023,322071,322119],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[445239,445287,445191],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[788446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[317242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[317323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[317350,317448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[317455,317377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[317694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[317503],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[317746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[317928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[317402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[318285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[318177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[318189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[318237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[442442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[323844],"length":1,"stats":{"Line":3},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[309048],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":80,"coverable":95},{"path":["/","home","runner","work","openapi_type","openapi_type","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms)]\n#![forbid(unsafe_code)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(clippy::tabs_in_doc_comments))]\n#![doc = r##\"\nThis crate gives static type information for primitives and commonly used types from the standard\nlibrary and a few other commonly used libraries like `chrono` and `uuid`. Also, it provides a\nderive macro for structs and enums to gain access to their static type information at runtime.\n\nThe core of this crate is the [`OpenapiType`] trait. It has one static function,\n[`schema`](OpenapiType::schema), which returns an [`OpenapiSchema`]. This assembles the static\ntype information in a way that is convenient to use for a generated OpenAPI specification, but\ncan also be utilized in other use cases as well.\n\n# Custom Types\nTo gain access to the static type information of your custom types at runtime, the easiest way\nis to use the derive macro:\n\n```rust\n# use openapi_type::OpenapiType;\n#[derive(OpenapiType)]\nstruct FooBar {\n\tfoo: String,\n\tbar: u64\n}\n# let schema = FooBar::schema().into_schema();\n# let schema_json = serde_json::to_value(&schema).unwrap();\n# assert_eq!(schema_json, serde_json::json!({\n#   \"type\": \"object\",\n#   \"title\": \"FooBar\",\n#   \"properties\": {\n#     \"foo\": {\n#       \"type\": \"string\"\n#     },\n#     \"bar\": {\n#       \"type\": \"integer\",\n#       \"format\": \"int64\",\n#       \"minimum\": 0\n#     }\n#   },\n#   \"required\": [\"foo\", \"bar\"]\n# }));\n```\n\n# OpenAPI specification\nUsing above type, running `FooBar::schema().into_schema()` yields\n\n```yaml\ntype: object\ntitle: FooBar\nproperties:\n  foo:\n    type: string\n  bar:\n    type: integer\n    format: int64\n    minimum: 0\nrequired:\n  - foo\n  - bar\n```\n\nNote, however, that this is not sufficient for more complex types. If one of your structs fields\nis a type that has a name (that is, `Type::schema().name` is not `None`), above schema will contain\na reference to that schema. Therefore, always remember to put the\n[`dependencies`](OpenapiSchema::dependencies) into the specification alongside the type you are\ninterested in.\n\"##]\n\npub use indexmap;\npub use openapi_type_derive::OpenapiType;\npub use openapiv3 as openapi;\n\nmod impls;\n#[doc(hidden)]\npub mod private;\n\nuse indexmap::IndexMap;\nuse openapi::{Schema, SchemaData, SchemaKind};\n\n// TODO update the documentation\n/**\nThis struct needs to be available for every type that can be part of an OpenAPI Spec. It is\nalready implemented for primitive types, String, Vec, Option and the like. To have it available\nfor your type, simply derive from [OpenapiType].\n*/\n#[derive(Debug, Clone, PartialEq)]\npub struct OpenapiSchema {\n\t/// The name of this schema. If it is None, the schema will be inlined.\n\tpub name: Option<String>,\n\t/// Whether this particular schema is nullable. Note that there is no guarantee that this will\n\t/// make it into the final specification, it might just be interpreted as a hint to make it\n\t/// an optional parameter.\n\tpub nullable: bool,\n\t/// The actual OpenAPI schema.\n\tpub schema: SchemaKind,\n\t/// Other schemas that this schema depends on. They will be included in the final OpenAPI Spec\n\t/// along with this schema.\n\tpub dependencies: IndexMap<String, OpenapiSchema>\n}\n\nimpl OpenapiSchema {\n\t/// Create a new schema that has no name.\n\tpub fn new(schema: SchemaKind) -> Self {\n\t\tSelf {\n\t\t\tname: None,\n\t\t\tnullable: false,\n\t\t\tschema,\n\t\t\tdependencies: IndexMap::new()\n\t\t}\n\t}\n\n\t/// Convert this schema to a [Schema] that can be serialized to the OpenAPI Spec.\n\tpub fn into_schema(self) -> Schema {\n\t\tSchema {\n\t\t\tschema_data: SchemaData {\n\t\t\t\tnullable: self.nullable,\n\t\t\t\ttitle: self.name,\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tschema_kind: self.schema\n\t\t}\n\t}\n}\n\n/**\nThis trait needs to be implemented by every type that is being used in the OpenAPI Spec. It gives\naccess to the [OpenapiSchema] of this type. It is provided for primitive types, String and the\nlike. For use on your own types, there is a derive macro:\n\n```\n# #[macro_use] extern crate openapi_type_derive;\n#\n#[derive(OpenapiType)]\nstruct MyResponse {\n\tmessage: String\n}\n```\n*/\npub trait OpenapiType {\n\tfn schema() -> OpenapiSchema;\n}\n\nimpl<'a, T: ?Sized + OpenapiType> OpenapiType for &'a T {\n\tfn schema() -> OpenapiSchema {\n\t\tT::schema()\n\t}\n}\n","traces":[{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":7},{"path":["/","home","runner","work","openapi_type","openapi_type","src","private.rs"],"content":"use crate::OpenapiSchema;\nuse indexmap::IndexMap;\n\npub type Dependencies = IndexMap<String, OpenapiSchema>;\n\npub fn add_dependencies(dependencies: &mut Dependencies, other: &mut Dependencies) {\n\twhile let Some((dep_name, dep_schema)) = other.pop() {\n\t\tif !dependencies.contains_key(&dep_name) {\n\t\t\tdependencies.insert(dep_name, dep_schema);\n\t\t}\n\t}\n}\n","traces":[{"line":6,"address":[794400,794855],"length":1,"stats":{"Line":1},"fn_name":"add_dependencies"},{"line":7,"address":[794433,794516,794832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[794585,794794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[794633],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":4},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","custom_types.rs"],"content":"#![allow(dead_code)]\nuse openapi_type::OpenapiType;\n\nmacro_rules! test_type {\n\t($ty:ty = $json:tt) => {\n\t\tpaste::paste! {\n\t\t\t#[test]\n\t\t\tfn [< $ty:lower >]() {\n\t\t\t\tlet schema = <$ty as OpenapiType>::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(&schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tassert_eq!(schema_json, expected);\n\t\t\t}\n\t\t}\n\t};\n}\n\n#[derive(OpenapiType)]\nstruct UnitStruct;\ntest_type!(UnitStruct = {\n\t\"type\": \"object\",\n\t\"title\": \"UnitStruct\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\nstruct SimpleStruct {\n\tfoo: String,\n\tbar: isize\n}\ntest_type!(SimpleStruct = {\n\t\"type\": \"object\",\n\t\"title\": \"SimpleStruct\",\n\t\"properties\": {\n\t\t\"foo\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"bar\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"foo\", \"bar\"]\n});\n\n#[derive(OpenapiType)]\n#[openapi(rename = \"FooBar\")]\nstruct StructRename;\ntest_type!(StructRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FooBar\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\nenum EnumWithoutFields {\n\tSuccess,\n\tError\n}\ntest_type!(EnumWithoutFields = {\n\t\"type\": \"string\",\n\t\"title\": \"EnumWithoutFields\",\n\t\"enum\": [\n\t\t\"Success\",\n\t\t\"Error\"\n\t]\n});\n\n#[derive(OpenapiType)]\nenum EnumWithOneField {\n\tSuccess { value: isize }\n}\ntest_type!(EnumWithOneField = {\n\t\"type\": \"object\",\n\t\"title\": \"EnumWithOneField\",\n\t\"properties\": {\n\t\t\"Success\": {\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"value\": {\n\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"value\"]\n\t\t}\n\t},\n\t\"required\": [\"Success\"]\n});\n\n#[derive(OpenapiType)]\nenum EnumWithFields {\n\tSuccess { value: isize },\n\tError { msg: String }\n}\ntest_type!(EnumWithFields = {\n\t\"title\": \"EnumWithFields\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Success\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Success\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Error\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"msg\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"msg\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Error\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\nenum EnumExternallyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumExternallyTagged = {\n\t\"title\": \"EnumExternallyTagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Success\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Success\"]\n\t}, {\n\t\t\"type\": \"string\",\n\t\t\"enum\": [\"Empty\", \"Error\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\n#[openapi(tag = \"ty\")]\nenum EnumInternallyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumInternallyTagged = {\n\t\"title\": \"EnumInternallyTagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t},\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Success\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\", \"ty\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Empty\", \"Error\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\n#[openapi(tag = \"ty\", content = \"ct\")]\nenum EnumAdjacentlyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumAdjacentlyTagged = {\n\t\"title\": \"EnumAdjacentlyTagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Success\"]\n\t\t\t},\n\t\t\t\"ct\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\", \"ct\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Empty\", \"Error\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\n#[openapi(untagged)]\nenum EnumUntagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumUntagged = {\n\t\"title\": \"EnumUntagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"additionalProperties\": false\n\t}]\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","enum_with_no_variants.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nenum Foo {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","not_openapitype.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo {\n\tbar: Bar\n}\n\nstruct Bar;\n\nfn main() {\n\tFoo::schema();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","not_openapitype_generics.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo<T> {\n\tbar: T\n}\n\nstruct Bar;\n\nfn main() {\n\t<Foo<Bar>>::schema();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","tuple_struct.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo(i64, i64);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","tuple_variant.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nenum Foo {\n\tPair(i64, i64)\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","union.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nunion Foo {\n\tsigned: i64,\n\tunsigned: u64\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","unknown_attribute.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\n#[openapi(pizza)]\nstruct Foo;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","std_types.rs"],"content":"#[cfg(feature = \"chrono\")]\nuse chrono::{Date, DateTime, FixedOffset, Local, NaiveDate, NaiveDateTime, Utc};\nuse indexmap::{IndexMap, IndexSet};\nuse openapi_type::OpenapiType;\nuse serde_json::Value;\nuse std::{\n\tcollections::{BTreeMap, BTreeSet, HashMap, HashSet},\n\tnum::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize}\n};\n#[cfg(feature = \"uuid\")]\nuse uuid::Uuid;\n\nmacro_rules! test_type {\n\t($($ty:ident $(<$($generic:ident),+>)*),* = $json:tt) => {\n\t\tpaste::paste! { $(\n\t\t\t#[test]\n\t\t\tfn [< $ty:lower $($(_ $generic:lower)+)* >]() {\n\t\t\t\tlet schema = <$ty $(<$($generic),+>)* as OpenapiType>::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(&schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tassert_eq!(schema_json, expected);\n\t\t\t}\n\t\t)* }\n\t};\n}\n\ntype Unit = ();\ntest_type!(Unit = {\n\t\"type\": \"object\",\n\t\"additionalProperties\": false\n});\n\ntest_type!(Value = {\n\t\"nullable\": true\n});\n\ntest_type!(bool = {\n\t\"type\": \"boolean\"\n});\n\n// ### integer types\n\ntest_type!(isize = {\n\t\"type\": \"integer\"\n});\n\ntest_type!(usize = {\n\t\"type\": \"integer\",\n\t\"minimum\": 0\n});\n\ntest_type!(i8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\"\n});\n\ntest_type!(u8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\",\n\t\"minimum\": 0\n});\n\ntest_type!(i16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\"\n});\n\ntest_type!(u16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\",\n\t\"minimum\": 0\n});\n\ntest_type!(i32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\"\n});\n\ntest_type!(u32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\",\n\t\"minimum\": 0\n});\n\ntest_type!(i64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\"\n});\n\ntest_type!(u64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\",\n\t\"minimum\": 0\n});\n\ntest_type!(i128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\"\n});\n\ntest_type!(u128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\",\n\t\"minimum\": 0\n});\n\n// ### non-zero integer types\n\ntest_type!(NonZeroUsize = {\n\t\"type\": \"integer\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\",\n\t\"minimum\": 1\n});\n\n// ### floats\n\ntest_type!(f32 = {\n\t\"type\": \"number\",\n\t\"format\": \"float\"\n});\n\ntest_type!(f64 = {\n\t\"type\": \"number\",\n\t\"format\": \"double\"\n});\n\n// ### string\n\ntest_type!(String = {\n\t\"type\": \"string\"\n});\n\n#[cfg(feature = \"uuid\")]\ntest_type!(Uuid = {\n\t\"type\": \"string\",\n\t\"format\": \"uuid\"\n});\n\n// ### date/time\n\n#[cfg(feature = \"chrono\")]\ntest_type!(Date<FixedOffset>, Date<Local>, Date<Utc>, NaiveDate = {\n\t\"type\": \"string\",\n\t\"format\": \"date\"\n});\n\n#[cfg(feature = \"chrono\")]\ntest_type!(DateTime<FixedOffset>, DateTime<Local>, DateTime<Utc>, NaiveDateTime = {\n\t\"type\": \"string\",\n\t\"format\": \"date-time\"\n});\n\n// ### some std types\n\ntest_type!(Option<String> = {\n\t\"type\": \"string\",\n\t\"nullable\": true\n});\n\ntest_type!(Vec<String> = {\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"string\"\n\t}\n});\n\ntest_type!(BTreeSet<String>, IndexSet<String>, HashSet<String> = {\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"string\"\n\t},\n\t\"uniqueItems\": true\n});\n\ntest_type!(BTreeMap<isize, String>, IndexMap<isize, String>, HashMap<isize, String> = {\n\t\"type\": \"object\",\n\t\"properties\": {\n\t\t\"default\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"default\"],\n\t\"additionalProperties\": {\n\t\t\"type\": \"string\"\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","trybuild.rs"],"content":"use trybuild::TestCases;\n\n#[test]\nfn trybuild() {\n\tlet t = TestCases::new();\n\tt.compile_fail(\"tests/fail/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0}]}