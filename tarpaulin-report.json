{"files":[{"path":["/","home","runner","work","openapi_type","openapi_type","src","impls.rs"],"content":"use crate::{OpenapiSchema, OpenapiType};\nuse indexmap::{IndexMap, IndexSet};\nuse openapiv3::{\n\tAdditionalProperties, ArrayType, IntegerType, NumberFormat, NumberType, ObjectType, ReferenceOr, SchemaKind,\n\tStringFormat, StringType, Type, VariantOrUnknownOrEmpty\n};\nuse serde_json::Value;\nuse std::{\n\tcollections::{BTreeMap, BTreeSet, HashMap, HashSet},\n\thash::BuildHasher,\n\tnum::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize}\n};\n\nmacro_rules! impl_openapi_type {\n\t($($($ty:ident)::+ $(<$($generic:ident : $bound:path),+>)?),* => $schema:expr) => {\n\t\t$(\n\t\t\timpl $(<$($generic : $bound),+>)? OpenapiType for $($ty)::+ $(<$($generic),+>)? {\n\t\t\t\tfn schema() -> OpenapiSchema {\n\t\t\t\t\t$schema\n\t\t\t\t}\n\t\t\t}\n\t\t)*\n\t};\n}\n\ntype Unit = ();\nimpl_openapi_type!(Unit => {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Object(ObjectType {\n\t\tadditional_properties: Some(AdditionalProperties::Any(false)),\n\t\t..Default::default()\n\t})))\n});\n\nimpl_openapi_type!(Value => {\n\tOpenapiSchema {\n\t\tnullable: true,\n\t\tdescription: None,\n\t\tname: None,\n\t\tschema: SchemaKind::Any(Default::default()),\n\t\tdependencies: Default::default()\n\t}\n});\n\nimpl_openapi_type!(bool => OpenapiSchema::new(SchemaKind::Type(Type::Boolean {})));\n\n#[inline]\nfn int_schema(minimum: Option<i64>, bits: Option<i64>) -> OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Integer(IntegerType {\n\t\tminimum,\n\t\tformat: bits\n\t\t\t.map(|bits| VariantOrUnknownOrEmpty::Unknown(format!(\"int{}\", bits)))\n\t\t\t.unwrap_or(VariantOrUnknownOrEmpty::Empty),\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(isize => int_schema(None, None));\nimpl_openapi_type!(i8 => int_schema(None, Some(8)));\nimpl_openapi_type!(i16 => int_schema(None, Some(16)));\nimpl_openapi_type!(i32 => int_schema(None, Some(32)));\nimpl_openapi_type!(i64 => int_schema(None, Some(64)));\nimpl_openapi_type!(i128 => int_schema(None, Some(128)));\n\nimpl_openapi_type!(usize => int_schema(Some(0), None));\nimpl_openapi_type!(u8 => int_schema(Some(0), Some(8)));\nimpl_openapi_type!(u16 => int_schema(Some(0), Some(16)));\nimpl_openapi_type!(u32 => int_schema(Some(0), Some(32)));\nimpl_openapi_type!(u64 => int_schema(Some(0), Some(64)));\nimpl_openapi_type!(u128 => int_schema(Some(0), Some(128)));\n\nimpl_openapi_type!(NonZeroUsize => int_schema(Some(1), None));\nimpl_openapi_type!(NonZeroU8 => int_schema(Some(1), Some(8)));\nimpl_openapi_type!(NonZeroU16 => int_schema(Some(1), Some(16)));\nimpl_openapi_type!(NonZeroU32 => int_schema(Some(1), Some(32)));\nimpl_openapi_type!(NonZeroU64 => int_schema(Some(1), Some(64)));\nimpl_openapi_type!(NonZeroU128 => int_schema(Some(1), Some(128)));\n\n#[inline]\nfn float_schema(format: NumberFormat) -> OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Number(NumberType {\n\t\tformat: VariantOrUnknownOrEmpty::Item(format),\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(f32 => float_schema(NumberFormat::Float));\nimpl_openapi_type!(f64 => float_schema(NumberFormat::Double));\n\n#[inline]\nfn str_schema(format: VariantOrUnknownOrEmpty<StringFormat>) -> OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::String(StringType {\n\t\tformat,\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(String, str => str_schema(VariantOrUnknownOrEmpty::Empty));\n\n#[cfg(feature = \"chrono\")]\nimpl_openapi_type!(chrono::Date<T: chrono::TimeZone>, chrono::NaiveDate => {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::Date))\n});\n\n#[cfg(feature = \"time\")]\nimpl_openapi_type!(time::Date => {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::Date))\n});\n\n#[cfg(feature = \"chrono\")]\nimpl_openapi_type!(chrono::DateTime<T: chrono::TimeZone>, chrono::NaiveDateTime => {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::DateTime))\n});\n\n#[cfg(feature = \"time\")]\nimpl_openapi_type!(time::OffsetDateTime, time::PrimitiveDateTime => {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::DateTime))\n});\n\n#[cfg(feature = \"uuid\")]\nimpl_openapi_type!(uuid::Uuid => {\n\tstr_schema(VariantOrUnknownOrEmpty::Unknown(\"uuid\".to_owned()))\n});\n\nimpl_openapi_type!(Option<T: OpenapiType> => {\n\tlet schema = T::schema();\n\tlet mut dependencies = schema.dependencies.clone();\n\tlet schema = match schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\tSchemaKind::AllOf { all_of: vec![reference] }\n\t\t},\n\t\tNone => schema.schema\n\t};\n\n\tOpenapiSchema {\n\t\tnullable: true,\n\t\tname: None,\n\t\tdescription: None,\n\t\tschema,\n\t\tdependencies\n\t}\n});\n\n#[inline]\nfn array_schema<T: OpenapiType>(unique_items: bool) -> OpenapiSchema {\n\tlet schema = T::schema();\n\tlet mut dependencies = schema.dependencies.clone();\n\n\tlet items = match schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\treference\n\t\t},\n\t\tNone => ReferenceOr::Item(Box::new(schema.into_schema()))\n\t};\n\n\tOpenapiSchema {\n\t\tnullable: false,\n\t\tname: None,\n\t\tdescription: None,\n\t\tschema: SchemaKind::Type(Type::Array(ArrayType {\n\t\t\titems: Some(items),\n\t\t\tmin_items: None,\n\t\t\tmax_items: None,\n\t\t\tunique_items\n\t\t})),\n\t\tdependencies\n\t}\n}\n\nimpl_openapi_type!(Vec<T: OpenapiType> => array_schema::<T>(false));\nimpl_openapi_type!(BTreeSet<T: OpenapiType>, IndexSet<T: OpenapiType>, HashSet<T: OpenapiType, S: BuildHasher> => {\n\tarray_schema::<T>(true)\n});\n\n#[inline]\nfn map_schema<K: OpenapiType, T: OpenapiType>() -> OpenapiSchema {\n\tlet key_schema = K::schema();\n\tlet mut dependencies = key_schema.dependencies.clone();\n\n\tlet keys = match key_schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, key_schema);\n\t\t\treference\n\t\t},\n\t\tNone => ReferenceOr::Item(Box::new(key_schema.into_schema()))\n\t};\n\n\tlet schema = T::schema();\n\tdependencies.extend(schema.dependencies.iter().map(|(k, v)| (k.clone(), v.clone())));\n\n\tlet items = Box::new(match schema.name.clone() {\n\t\tSome(name) => {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\treference\n\t\t},\n\t\tNone => ReferenceOr::Item(schema.into_schema())\n\t});\n\n\tlet mut properties = IndexMap::new();\n\tproperties.insert(\"default\".to_owned(), keys);\n\n\tOpenapiSchema {\n\t\tnullable: false,\n\t\tname: None,\n\t\tdescription: None,\n\t\tschema: SchemaKind::Type(Type::Object(ObjectType {\n\t\t\tproperties,\n\t\t\trequired: vec![\"default\".to_owned()],\n\t\t\tadditional_properties: Some(AdditionalProperties::Schema(items)),\n\t\t\t..Default::default()\n\t\t})),\n\t\tdependencies\n\t}\n}\n\nimpl_openapi_type!(\n\tBTreeMap<K: OpenapiType, T: OpenapiType>,\n\tHashMap<K: OpenapiType, T: OpenapiType, S: BuildHasher>,\n\tIndexMap<K: OpenapiType, T: OpenapiType>\n\t=> map_schema::<K, T>()\n);\n\n#[cfg(feature = \"linked-hash-map\")]\nimpl_openapi_type!(\n\tlinked_hash_map::LinkedHashMap<K: OpenapiType, T: OpenapiType, S: BuildHasher>\n\t=> map_schema::<K, T>()\n);\n","traces":[{"line":18,"address":[395600,395648],"length":1,"stats":{"Line":49},"fn_name":"schema<chrono::offset::fixed::FixedOffset>"},{"line":28,"address":[1051216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[1051169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[1051209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[1029124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[1028993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[1029002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[1029019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[1029062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[1051664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[1051755],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[1051819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[1051899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[1051979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[1052059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[1052139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1052219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[1052299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[1052395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1052491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[1052587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[1052683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[1004939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[1005019],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[1005115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[1005211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[1005307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[1005403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[1052780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[1052828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[1004731],"length":1,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[496043,495995],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[1026683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[395659,395611],"length":1,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[1011147],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[1020989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[490503],"length":1,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[490562],"length":1,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[490715,490589,490654],"length":1,"stats":{"Line":6},"fn_name":null},{"line":128,"address":[490757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[491022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[490805,490963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[491074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[491272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[490717],"length":1,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[491704],"length":1,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[491623],"length":1,"stats":{"Line":3},"fn_name":null},{"line":141,"address":[491635],"length":1,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[491647],"length":1,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[491673],"length":1,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[528056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[409640],"length":1,"stats":{"Line":3},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[396408],"length":1,"stats":{"Line":3},"fn_name":null},{"line":239,"address":[415352],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":81,"coverable":100},{"path":["/","home","runner","work","openapi_type","openapi_type","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms)]\n#![deny(rustdoc::broken_intra_doc_links)]\n#![forbid(unsafe_code)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(clippy::tabs_in_doc_comments))]\n#![doc = r##\"\nThis crate gives static type information for primitives and commonly used types from the standard\nlibrary and other commonly used libraries `chrono`, `indexmap`, `linked-hash-map`, `time` and\n`uuid` when the according feature is enabled. Also, it provides a derive macro for structs and\nenums to gain access to their static type information at runtime.\n\nThe core of this crate is the [`OpenapiType`] trait. It has one static function,\n[`schema`](OpenapiType::schema), which returns an [`OpenapiSchema`]. This assembles the static\ntype information in a way that is convenient to use for a generated OpenAPI specification, but\ncan also be utilized in other use cases as well.\n\n# Custom Types\nTo gain access to the static type information of your custom types at runtime, the easiest way\nis to use the derive macro:\n\n```rust\n# use openapi_type::OpenapiType;\n#[derive(OpenapiType)]\nstruct FooBar {\n\tfoo: String,\n\tbar: u64\n}\n# let schema = FooBar::schema().into_schema();\n# let schema_json = serde_json::to_value(&schema).unwrap();\n# assert_eq!(schema_json, serde_json::json!({\n#   \"type\": \"object\",\n#   \"title\": \"FooBar\",\n#   \"properties\": {\n#     \"foo\": {\n#       \"type\": \"string\"\n#     },\n#     \"bar\": {\n#       \"type\": \"integer\",\n#       \"format\": \"int64\",\n#       \"minimum\": 0\n#     }\n#   },\n#   \"required\": [\"foo\", \"bar\"]\n# }));\n```\n\n# OpenAPI specification\nUsing above type, running `FooBar::schema().into_schema()` yields\n\n```yaml\ntype: object\ntitle: FooBar\nproperties:\n  foo:\n    type: string\n  bar:\n    type: integer\n    format: int64\n    minimum: 0\nrequired:\n  - foo\n  - bar\n```\n\nNote, however, that this is not sufficient for more complex types. If one of your structs fields\nis a type that has a name (that is, `Type::schema().name` is not `None`), above schema will contain\na reference to that schema. Therefore, always remember to put the\n[`dependencies`](OpenapiSchema::dependencies) into the specification alongside the type you are\ninterested in.\n\"##]\n\npub use indexmap;\npub use openapi_type_derive::OpenapiType;\npub use openapiv3 as openapi;\n\nmod impls;\n#[doc(hidden)]\npub mod private;\n\nuse indexmap::IndexMap;\nuse openapi::{Schema, SchemaData, SchemaKind};\n\n/// This struct is used to generate the OpenAPI specification for a particular type. It is already\n/// made available for all primitives and some other types from the rust standard library, and\n/// you can also make your own types provide one through the [OpenapiType] trait and derive macro.\n///\n/// Note that this struct is marked non-exhaustive. This means that new attributes might be added\n/// at any point in time without a breaking change. The only way to obtain a value is through the\n/// [OpenapiSchema::new] method.\n#[derive(Debug, Clone, PartialEq)]\n#[non_exhaustive]\npub struct OpenapiSchema {\n\t/// The name of this schema. If it is None, the schema will be inlined.\n\tpub name: Option<String>,\n\t/// The description of this schema. Optional and only makes sense when a [`name`](Self::name)\n\t/// is set as well.\n\tpub description: Option<String>,\n\t/// Whether this particular schema is nullable. Note that there is no guarantee that this will\n\t/// make it into the final specification, it might just be interpreted as a hint to make it\n\t/// an optional parameter.\n\tpub nullable: bool,\n\t/// The actual OpenAPI schema.\n\tpub schema: SchemaKind,\n\t/// Other schemas that this schema depends on. They will be included in the final OpenAPI Spec\n\t/// along with this schema.\n\tpub dependencies: IndexMap<String, OpenapiSchema>\n}\n\nimpl OpenapiSchema {\n\t/// Create a new schema that has no name.\n\tpub fn new(schema: SchemaKind) -> Self {\n\t\tSelf {\n\t\t\tname: None,\n\t\t\tdescription: None,\n\t\t\tnullable: false,\n\t\t\tschema,\n\t\t\tdependencies: IndexMap::new()\n\t\t}\n\t}\n\n\t/// Convert this schema to a [Schema] that can be serialized to the OpenAPI Spec.\n\tpub fn into_schema(self) -> Schema {\n\t\tSchema {\n\t\t\tschema_data: SchemaData {\n\t\t\t\tnullable: self.nullable,\n\t\t\t\ttitle: self.name,\n\t\t\t\tdescription: self.description,\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tschema_kind: self.schema\n\t\t}\n\t}\n}\n\n/// This trait needs to be implemented by every type that is being used in the OpenAPI Spec. It gives\n/// access to the [OpenapiSchema] of this type. It is provided for primitive types, String and the\n/// like. For use on your own types, there is a derive macro:\n/// \n/// ```\n/// # #[macro_use] extern crate openapi_type_derive;\n/// #\n/// #[derive(OpenapiType)]\n/// struct MyResponse {\n/// \tmessage: String\n/// }\n/// ```\npub trait OpenapiType {\n\tfn schema() -> OpenapiSchema;\n}\n\nimpl<'a, T: ?Sized + OpenapiType> OpenapiType for &'a T {\n\tfn schema() -> OpenapiSchema {\n\t\tT::schema()\n\t}\n}\n","traces":[{"line":110,"address":[1072606,1072352],"length":1,"stats":{"Line":3},"fn_name":"new"},{"line":116,"address":[423997],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[1046784,1047636],"length":1,"stats":{"Line":3},"fn_name":"into_schema"},{"line":123,"address":[1046806,1046898],"length":1,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[1047318],"length":1,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","runner","work","openapi_type","openapi_type","src","private.rs"],"content":"use crate::OpenapiSchema;\nuse indexmap::IndexMap;\nuse openapiv3::{ReferenceOr, Schema, SchemaKind, Type};\nuse std::borrow::Cow;\n\npub type Dependencies = IndexMap<String, OpenapiSchema>;\npub type Properties = IndexMap<String, ReferenceOr<Box<Schema>>>;\npub type Required = Vec<String>;\n\nfn add_dependencies(dependencies: &mut Dependencies, other: &mut Dependencies) {\n\twhile let Some((dep_name, dep_schema)) = other.pop() {\n\t\tif !dependencies.contains_key(&dep_name) {\n\t\t\tdependencies.insert(dep_name, dep_schema);\n\t\t}\n\t}\n}\n\npub fn inline_if_unnamed(\n\tdependencies: &mut Dependencies,\n\tmut schema: OpenapiSchema,\n\tdoc: Option<&'static str>\n) -> ReferenceOr<Schema> {\n\tadd_dependencies(dependencies, &mut schema.dependencies);\n\tmatch schema.name.as_ref() {\n\t\tSome(schema_name) => {\n\t\t\tlet ref_name = schema_name.replace(|c: char| !c.is_alphanumeric(), \"_\");\n\t\t\tlet mut reference = \"#/components/schemas/\".to_string();\n\t\t\treference.push_str(&ref_name);\n\t\t\tdependencies.insert(ref_name, schema);\n\t\t\tReferenceOr::Reference { reference }\n\t\t},\n\n\t\tNone => {\n\t\t\tlet mut schema = schema.into_schema();\n\t\t\tif let Some(doc) = doc {\n\t\t\t\tschema.schema_data.description = Some(doc.to_string());\n\t\t\t}\n\t\t\tReferenceOr::Item(schema)\n\t\t}\n\t}\n}\n\nstruct FlattenError(Cow<'static, str>);\n\nfn flatten_impl(properties: &mut Properties, required: &mut Required, schema: SchemaKind) -> Result<(), FlattenError> {\n\tlet mut obj = match schema {\n\t\tSchemaKind::Type(Type::Object(obj)) => obj,\n\t\tSchemaKind::OneOf { .. } => {\n\t\t\treturn Err(FlattenError(\n\t\t\t\t\"#[serde(flatten)] is currently not supported for enums with non-unit variants\".into()\n\t\t\t))\n\t\t},\n\t\t_ => return Err(FlattenError(\"Expected object\".into()))\n\t};\n\n\twhile let Some((prop_name, prop_schema)) = obj.properties.pop() {\n\t\tif properties.contains_key(&prop_name) {\n\t\t\treturn Err(FlattenError(format!(\"Duplicate property name {}\", prop_name).into()));\n\t\t}\n\t\tproperties.insert(prop_name, prop_schema);\n\t}\n\trequired.extend(obj.required.into_iter());\n\n\tOk(())\n}\n\npub fn flatten(\n\tdependencies: &mut Dependencies,\n\tproperties: &mut Properties,\n\trequired: &mut Required,\n\tmut schema: OpenapiSchema\n) {\n\tadd_dependencies(dependencies, &mut schema.dependencies);\n\tmatch flatten_impl(properties, required, schema.schema) {\n\t\tOk(_) => {},\n\t\tErr(e) => panic!(\"Flattening produced an error: {}\", e.0)\n\t};\n}\n","traces":[{"line":10,"address":[1042128,1042642],"length":1,"stats":{"Line":2},"fn_name":"add_dependencies"},{"line":11,"address":[1036089,1035569,1035728],"length":1,"stats":{"Line":4},"fn_name":null},{"line":12,"address":[1035751,1035705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[1035819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[1037222,1036112],"length":1,"stats":{"Line":2},"fn_name":"inline_if_unnamed"},{"line":23,"address":[1036173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[1042870,1042808],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[1042964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[1091958,1091936],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":27,"address":[1036449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[1036481,1036557],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[1036607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[1036310],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[1036868,1037142],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[1037147,1037094,1036925,1037002],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[1043524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[1043856,1045782],"length":1,"stats":{"Line":1},"fn_name":"flatten_impl"},{"line":46,"address":[1044027,1043904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[1044264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[1044076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[1044040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[1043988,1044336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[1045504,1045669,1044329,1044557,1044663,1044452],"length":1,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[1044950,1044637],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[1045132],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[1045006,1045634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[1044682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[1044778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[1045872,1046393],"length":1,"stats":{"Line":1},"fn_name":"flatten"},{"line":73,"address":[1045931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[1045966,1046067],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":25,"coverable":31},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","custom_types.rs"],"content":"#![allow(dead_code)]\nuse openapi_type::OpenapiType;\n\ninclude!(\"util/test_type.rs\");\n\n#[derive(OpenapiType)]\nstruct UnitStruct;\ntest_type!(UnitStruct = {\n\t\"type\": \"object\",\n\t\"title\": \"UnitStruct\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\nstruct SimpleStruct {\n\tfoo: String,\n\tbar: isize\n}\ntest_type!(SimpleStruct = {\n\t\"type\": \"object\",\n\t\"title\": \"SimpleStruct\",\n\t\"properties\": {\n\t\t\"foo\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"bar\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"foo\", \"bar\"]\n});\n\n#[derive(OpenapiType)]\n#[openapi(rename = \"FooBar\")]\nstruct StructRename;\ntest_type!(StructRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FooBar\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\nenum EnumWithoutFields {\n\tSuccess,\n\tError\n}\ntest_type!(EnumWithoutFields = {\n\t\"type\": \"string\",\n\t\"title\": \"EnumWithoutFields\",\n\t\"enum\": [\n\t\t\"Success\",\n\t\t\"Error\"\n\t]\n});\n\n#[derive(OpenapiType)]\nenum EnumWithOneField {\n\tSuccess { value: isize }\n}\ntest_type!(EnumWithOneField = {\n\t\"type\": \"object\",\n\t\"title\": \"EnumWithOneField\",\n\t\"properties\": {\n\t\t\"Success\": {\n\t\t\t\"$ref\": \"#/components/schemas/EnumWithOneField__Success\"\n\t\t}\n\t},\n\t\"required\": [\"Success\"]\n}, {\n\t\"EnumWithOneField__Success\": {\n\t\t\"title\": \"EnumWithOneField::Success\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t}\n});\n\n#[derive(OpenapiType)]\nenum EnumWithFields {\n\tSuccess { value: isize },\n\tError { msg: String }\n}\ntest_type!(EnumWithFields = {\n\t\"title\": \"EnumWithFields\",\n\t\"oneOf\": [{\n\t\t\"$ref\": \"#/components/schemas/EnumWithFields__Success__ExtTagWrapper\"\n\t}, {\n\t\t\"$ref\": \"#/components/schemas/EnumWithFields__Error__ExtTagWrapper\"\n\t}]\n}, {\n\t\"EnumWithFields__Success\": {\n\t\t\"title\": \"EnumWithFields::Success\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t},\n\t\"EnumWithFields__Success__ExtTagWrapper\": {\n\t\t\"title\": \"EnumWithFields::Success::ExtTagWrapper\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Success\": {\n\t\t\t\t\"$ref\": \"#/components/schemas/EnumWithFields__Success\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Success\"]\n\t},\n\t\"EnumWithFields__Error\": {\n\t\t\"title\": \"EnumWithFields::Error\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"msg\": {\n\t\t\t\t\"type\": \"string\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"msg\"]\n\t},\n\t\"EnumWithFields__Error__ExtTagWrapper\": {\n\t\t\"title\": \"EnumWithFields::Error::ExtTagWrapper\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Error\": {\n\t\t\t\t\"$ref\": \"#/components/schemas/EnumWithFields__Error\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Error\"]\n\t}\n});\n\n#[derive(OpenapiType)]\nenum EnumExternallyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumExternallyTagged = {\n\t\"title\": \"EnumExternallyTagged\",\n\t\"oneOf\": [{\n\t\t\"$ref\": \"#/components/schemas/EnumExternallyTagged__Success__ExtTagWrapper\"\n\t}, {\n\t\t\"type\": \"string\",\n\t\t\"enum\": [\"Empty\", \"Error\"]\n\t}]\n}, {\n\t\"EnumExternallyTagged__Success\": {\n\t\t\"title\": \"EnumExternallyTagged::Success\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t},\n\t\"EnumExternallyTagged__Success__ExtTagWrapper\": {\n\t\t\"title\": \"EnumExternallyTagged::Success::ExtTagWrapper\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Success\": {\n\t\t\t\t\"$ref\": \"#/components/schemas/EnumExternallyTagged__Success\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Success\"]\n\t}\n});\n\n#[derive(OpenapiType)]\n#[openapi(tag = \"ty\")]\nenum EnumInternallyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\n// TODO the Success variant should probably be $ref-ed\ntest_type!(EnumInternallyTagged = {\n\t\"title\": \"EnumInternallyTagged\",\n\t\"oneOf\": [{\n\t\t\"$ref\": \"#/components/schemas/EnumInternallyTagged__Success\"\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Empty\", \"Error\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\"]\n\t}]\n}, {\n\t\"EnumInternallyTagged__Success\": {\n\t\t\"title\": \"EnumInternallyTagged::Success\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t},\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Success\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\", \"ty\"]\n\t}\n});\n\n#[derive(OpenapiType)]\n#[openapi(tag = \"ty\", content = \"ct\")]\nenum EnumAdjacentlyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumAdjacentlyTagged = {\n\t\"title\": \"EnumAdjacentlyTagged\",\n\t\"oneOf\": [{\n\t\t\"$ref\": \"#/components/schemas/EnumAdjacentlyTagged__Success__AdjTagWrapper\"\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Empty\", \"Error\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\"]\n\t}]\n}, {\n\t\"EnumAdjacentlyTagged__Success\": {\n\t\t\"title\": \"EnumAdjacentlyTagged::Success\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t},\n\t\"EnumAdjacentlyTagged__Success__AdjTagWrapper\": {\n\t\t\"title\": \"EnumAdjacentlyTagged::Success::AdjTagWrapper\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Success\"]\n\t\t\t},\n\t\t\t\"ct\": {\n\t\t\t\t\"$ref\": \"#/components/schemas/EnumAdjacentlyTagged__Success\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\", \"ct\"]\n\t}\n});\n\n#[derive(OpenapiType)]\n#[openapi(untagged)]\nenum EnumUntagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\n// TODO the Success variant should probably be $ref-ed\ntest_type!(EnumUntagged = {\n\t\"title\": \"EnumUntagged\",\n\t\"oneOf\": [{\n\t\t\"$ref\": \"#/components/schemas/EnumUntagged__Success\"\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"additionalProperties\": false\n\t}]\n}, {\n\t\"EnumUntagged__Success\": {\n\t\t\"title\": \"EnumUntagged::Success\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","custom_types_attrs.rs"],"content":"#![allow(dead_code)]\nuse openapi_type::OpenapiType;\n\ninclude!(\"util/test_type.rs\");\n\n/// Very cool struct!\n#[derive(OpenapiType)]\nstruct StructDoc {\n\t/// Very important!\n\tfoo: String\n}\ntest_type!(StructDoc = {\n\t\"type\": \"object\",\n\t\"title\": \"StructDoc\",\n\t\"description\": \"Very cool struct!\",\n\t\"properties\": {\n\t\t\"foo\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"Very important!\"\n\t\t}\n\t},\n\t\"required\": [\"foo\"]\n});\n\n/// Very cool enum!\n#[derive(OpenapiType)]\nenum EnumDoc {\n\t/// Look, a message!\n\tMessage {\n\t\t/// The text of the message in markdown format.\n\t\ttext: String\n\t},\n\t/// Oops\n\tError\n}\n// TODO the variant doc isn't currently included\ntest_type!(EnumDoc = {\n\t\"title\": \"EnumDoc\",\n\t\"description\": \"Very cool enum!\",\n\t\"oneOf\": [{\n\t\t\"$ref\": \"#/components/schemas/EnumDoc__Message__ExtTagWrapper\"\n\t}, {\n\t\t\"type\": \"string\",\n\t\t\"enum\": [\"Error\"]\n\t}]\n}, {\n\t\"EnumDoc__Message\": {\n\t\t\"title\": \"EnumDoc::Message\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"text\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"description\": \"The text of the message in markdown format.\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"text\"]\n\t},\n\t\"EnumDoc__Message__ExtTagWrapper\": {\n\t\t\"title\": \"EnumDoc::Message::ExtTagWrapper\",\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Message\": {\n\t\t\t\t\"$ref\": \"#/components/schemas/EnumDoc__Message\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Message\"]\n\t}\n});\n\n#[derive(OpenapiType)]\n#[openapi(rename = \"FooBar\")]\nstruct ContainerRename;\ntest_type!(ContainerRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FooBar\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\n#[openapi(rename_all = \"UPPERCASE\")]\nstruct FieldRename {\n\t#[openapi(rename = \"bar\")]\n\tfoo: String\n}\ntest_type!(FieldRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FieldRename\",\n\t\"properties\": {\n\t\t\"bar\": {\n\t\t\t\"type\": \"string\"\n\t\t}\n\t},\n\t\"required\": [\"bar\"]\n});\n\n#[derive(OpenapiType)]\nstruct FieldFlattenInner {\n\tinner: String\n}\n#[derive(OpenapiType)]\nstruct FieldFlatten {\n\touter: String,\n\t#[openapi(flatten)]\n\tflat: FieldFlattenInner\n}\ntest_type!(FieldFlatten = {\n\t\"type\": \"object\",\n\t\"title\": \"FieldFlatten\",\n\t\"properties\": {\n\t\t\"inner\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"outer\": {\n\t\t\t\"type\": \"string\"\n\t\t}\n\t},\n\t\"required\": [\"outer\", \"inner\"]\n});\n\n#[derive(OpenapiType)]\nstruct FieldSkip {\n\t#[openapi(skip_serializing, skip_deserializing)]\n\tfoo: String,\n\t#[openapi(skip)]\n\tbar: String\n}\ntest_type!(FieldSkip = {\n\t\"type\": \"object\",\n\t\"title\": \"FieldSkip\"\n});\n\n#[derive(OpenapiType)]\nstruct FieldNullable {\n\t#[openapi(skip_serializing)]\n\tfoo0: String,\n\t#[openapi(skip_deserializing)]\n\tfoo1: String,\n\t#[openapi(default)]\n\tfoo2: String,\n\t#[openapi(default = \"String::new\")]\n\tfoo3: String,\n\t#[openapi(skip_serializing_if = \"String::is_empty\")]\n\tfoo4: String\n}\ntest_type!(FieldNullable = {\n\t\"type\": \"object\",\n\t\"title\": \"FieldNullable\",\n\t\"properties\": {\n\t\t\"foo0\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"foo1\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"foo2\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"foo3\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"foo4\": {\n\t\t\t\"type\": \"string\"\n\t\t}\n\t}\n});\n\nmacro_rules! test_rename_all {\n\t(rename_all = $rename_all:literal, foo_bar = $foo_bar:literal) => {\n\t\tpaste::paste! {\n\t\t\t#[derive(OpenapiType, serde::Serialize)]\n\t\t\t#[openapi(rename = \"FooBar\")]\n\t\t\t#[serde(rename_all = $rename_all)]\n\t\t\t#[allow(non_camel_case_types, non_snake_case)]\n\t\t\tstruct [< ContainerRenameAll_ $rename_all >] {\n\t\t\t\tfoo_bar: Option<&'static str>,\n\t\t\t}\n\t\t\ttest_type!([< ContainerRenameAll_ $rename_all >] = {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"title\": \"FooBar\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t$foo_bar: {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t});\n\t\t\t#[test]\n\t\t\tfn [< containerrenameall_ $rename_all:lower _serde >]() {\n\t\t\t\tlet value = [< ContainerRenameAll_ $rename_all >] {\n\t\t\t\t\tfoo_bar: Some(\"foo_bar\"),\n\t\t\t\t};\n\t\t\t\tlet json = serde_json::to_value(&value).unwrap();\n\t\t\t\tlet expected = serde_json::json!({\n\t\t\t\t\t$foo_bar: \"foo_bar\",\n\t\t\t\t});\n\t\t\t\tpretty_assertions::assert_eq!(json, expected);\n\t\t\t}\n\t\t}\n\t};\n}\n\ntest_rename_all!(rename_all = \"lowercase\", foo_bar = \"foo_bar\");\ntest_rename_all!(rename_all = \"UPPERCASE\", foo_bar = \"FOO_BAR\");\ntest_rename_all!(rename_all = \"PascalCase\", foo_bar = \"FooBar\");\ntest_rename_all!(rename_all = \"camelCase\", foo_bar = \"fooBar\");\ntest_rename_all!(rename_all = \"snake_case\", foo_bar = \"foo_bar\");\ntest_rename_all!(rename_all = \"SCREAMING_SNAKE_CASE\", foo_bar = \"FOO_BAR\");\ntest_rename_all!(rename_all = \"kebab-case\", foo_bar = \"foo-bar\");\ntest_rename_all!(rename_all = \"SCREAMING-KEBAB-CASE\", foo_bar = \"FOO-BAR\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","enum_with_no_variants.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nenum Foo {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","not_openapitype.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo {\n\tbar: Bar\n}\n\nstruct Bar;\n\nfn main() {\n\tFoo::schema();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","not_openapitype_generics.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo<T> {\n\tbar: T\n}\n\nstruct Bar;\n\nfn main() {\n\t<Foo<Bar>>::schema();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","tuple_struct.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo(i64, i64);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","tuple_variant.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nenum Foo {\n\tPair(i64, i64)\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","union.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nunion Foo {\n\tsigned: i64,\n\tunsigned: u64\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","unknown_attribute.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\n#[openapi(pizza)]\nstruct Foo;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","std_types.rs"],"content":"use indexmap::{IndexMap, IndexSet};\nuse openapi_type::OpenapiType;\nuse serde_json::Value;\nuse std::{\n\tcollections::{BTreeMap, BTreeSet, HashMap, HashSet},\n\tnum::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize}\n};\n\nmacro_rules! test_type {\n\t($($($ty:ident)::+ $(<$($($generic:ident)::+),+>)?),* = $json:tt) => {\n\t\tpaste::paste! {\n\t\t\t$(\n\t\t\t\t#[test]\n\t\t\t\tfn [<$($ty:lower)_+ $($($(_$generic:lower)+)+)? >]() {\n\t\t\t\t\tlet schema = <$($ty)::+ $(<$($($generic)::+),+>)? as OpenapiType>::schema();\n\t\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\t\tlet schema_json = serde_json::to_value(&schema).unwrap();\n\t\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t\t}\n\t\t\t)*\n\t\t}\n\t};\n}\n\ntype Unit = ();\ntest_type!(Unit = {\n\t\"type\": \"object\",\n\t\"additionalProperties\": false\n});\n\ntest_type!(Value = {\n\t\"nullable\": true\n});\n\ntest_type!(bool = {\n\t\"type\": \"boolean\"\n});\n\n// ### integer types\n\ntest_type!(isize = {\n\t\"type\": \"integer\"\n});\n\ntest_type!(usize = {\n\t\"type\": \"integer\",\n\t\"minimum\": 0\n});\n\ntest_type!(i8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\"\n});\n\ntest_type!(u8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\",\n\t\"minimum\": 0\n});\n\ntest_type!(i16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\"\n});\n\ntest_type!(u16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\",\n\t\"minimum\": 0\n});\n\ntest_type!(i32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\"\n});\n\ntest_type!(u32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\",\n\t\"minimum\": 0\n});\n\ntest_type!(i64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\"\n});\n\ntest_type!(u64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\",\n\t\"minimum\": 0\n});\n\ntest_type!(i128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\"\n});\n\ntest_type!(u128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\",\n\t\"minimum\": 0\n});\n\n// ### non-zero integer types\n\ntest_type!(NonZeroUsize = {\n\t\"type\": \"integer\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\",\n\t\"minimum\": 1\n});\n\n// ### floats\n\ntest_type!(f32 = {\n\t\"type\": \"number\",\n\t\"format\": \"float\"\n});\n\ntest_type!(f64 = {\n\t\"type\": \"number\",\n\t\"format\": \"double\"\n});\n\n// ### string\n\ntest_type!(String = {\n\t\"type\": \"string\"\n});\n\n#[cfg(feature = \"uuid\")]\ntest_type!(uuid::Uuid = {\n\t\"type\": \"string\",\n\t\"format\": \"uuid\"\n});\n\n// ### date/time\n\n#[cfg(feature = \"chrono\")]\ntest_type!(chrono::Date<chrono::FixedOffset>, chrono::Date<chrono::Utc>, chrono::NaiveDate = {\n\t\"type\": \"string\",\n\t\"format\": \"date\"\n});\n\n#[cfg(feature = \"time\")]\ntest_type!(time::Date = {\n\t\"type\": \"string\",\n\t\"format\": \"date\"\n});\n\n#[cfg(feature = \"chrono\")]\ntest_type!(chrono::DateTime<chrono::FixedOffset>, chrono::DateTime<chrono::Utc>, chrono::NaiveDateTime = {\n\t\"type\": \"string\",\n\t\"format\": \"date-time\"\n});\n\n#[cfg(feature = \"time\")]\ntest_type!(time::OffsetDateTime, time::PrimitiveDateTime = {\n\t\"type\": \"string\",\n\t\"format\": \"date-time\"\n});\n\n// ### some std types\n\ntest_type!(Option<String> = {\n\t\"type\": \"string\",\n\t\"nullable\": true\n});\n\ntest_type!(Vec<String> = {\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"string\"\n\t}\n});\n\ntest_type!(BTreeSet<String>, IndexSet<String>, HashSet<String> = {\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"string\"\n\t},\n\t\"uniqueItems\": true\n});\n\ntest_type!(BTreeMap<isize, String>, HashMap<isize, String>, IndexMap<isize, String> = {\n\t\"type\": \"object\",\n\t\"properties\": {\n\t\t\"default\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"default\"],\n\t\"additionalProperties\": {\n\t\t\"type\": \"string\"\n\t}\n});\n\n#[cfg(feature = \"linked-hash-map\")]\ntest_type!(linked_hash_map::LinkedHashMap<isize, String> = {\n\t\"type\": \"object\",\n\t\"properties\": {\n\t\t\"default\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"default\"],\n\t\"additionalProperties\": {\n\t\t\"type\": \"string\"\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","trybuild.rs"],"content":"use trybuild::TestCases;\n\n#[test]\nfn trybuild() {\n\tlet t = TestCases::new();\n\tt.compile_fail(\"tests/fail/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","util","test_type.rs"],"content":"macro_rules! test_type {\n\t($ty:ty = $json:tt) => {\n\t\tpaste::paste! {\n\t\t\t#[test]\n\t\t\tfn [< $ty:lower >]() {\n\t\t\t\tlet schema = <$ty as OpenapiType>::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(&schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t}\n\t\t}\n\t};\n\t($ty:ty = $json:tt, {$($dep_name:literal: $dep_json:tt),*}) => {\n\t\ttest_type!($ty = $json);\n\t\tpaste::paste! {\n\t\t\t#[test]\n\t\t\tfn [< $ty:lower _dependencies >]() {\n\t\t\t\tlet mut schema = <$ty as OpenapiType>::schema();\n\t\t\t\t$({\n\t\t\t\t\tlet dep_schema = schema.dependencies.remove($dep_name).expect(concat!(\"Schema is missing the following dependency: \", $dep_name));\n\t\t\t\t\tlet dep_schema = openapi_type::OpenapiSchema::into_schema(dep_schema);\n\t\t\t\t\tlet dep_json = serde_json::to_value(&dep_schema).unwrap();\n\t\t\t\t\tlet expected = serde_json::json!($dep_json);\n\t\t\t\t\tpretty_assertions::assert_eq!(dep_json, expected)\n\t\t\t\t})*\n\t\t\t}\n\t\t}\n\t};\n}\n","traces":[],"covered":0,"coverable":0}]}