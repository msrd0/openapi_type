<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","attrs.rs"],"content":"use crate::util::ExpectLit;\nuse syn::{punctuated::Punctuated, spanned::Spanned as _, Attribute, LitStr, Meta, Token};\n\npub(super) fn parse_doc_attr(input: \u0026Attribute) -\u003e syn::Result\u003cOption\u003cLitStr\u003e\u003e {\n\tinput.parse_meta().and_then(|meta| {\n\t\tOk(match meta {\n\t\t\tMeta::NameValue(kv) =\u003e Some(kv.lit.expect_str()?),\n\t\t\t_ =\u003e None\n\t\t})\n\t})\n}\n\n#[derive(Default)]\npub(super) struct ContainerAttributes {\n\tpub(super) rename: Option\u003cLitStr\u003e,\n\tpub(super) rename_all: Option\u003cLitStr\u003e,\n\tpub(super) tag: Option\u003cLitStr\u003e,\n\tpub(super) content: Option\u003cLitStr\u003e,\n\tpub(super) untagged: bool\n}\n\npub(super) fn parse_container_attrs(\n\tinput: \u0026Attribute,\n\tattrs: \u0026mut ContainerAttributes,\n\terror_on_unknown: bool\n) -\u003e syn::Result\u003c()\u003e {\n\tlet tokens: Punctuated\u003cMeta, Token![,]\u003e = input.parse_args_with(Punctuated::parse_terminated)?;\n\tfor token in tokens {\n\t\tmatch token {\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"rename\") =\u003e {\n\t\t\t\tattrs.rename = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"rename_all\") =\u003e {\n\t\t\t\tattrs.rename_all = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"tag\") =\u003e {\n\t\t\t\tattrs.tag = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"content\") =\u003e {\n\t\t\t\tattrs.content = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::Path(path) if path.is_ident(\"untagged\") =\u003e {\n\t\t\t\tattrs.untagged = true;\n\t\t\t},\n\n\t\t\tMeta::Path(path) if error_on_unknown =\u003e return Err(syn::Error::new(path.span(), \"Unexpected token\")),\n\t\t\tMeta::List(list) if error_on_unknown =\u003e return Err(syn::Error::new(list.span(), \"Unexpected token\")),\n\t\t\tMeta::NameValue(kv) if error_on_unknown =\u003e return Err(syn::Error::new(kv.path.span(), \"Unexpected token\")),\n\t\t\t_ =\u003e {}\n\t\t}\n\t}\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","codegen.rs"],"content":"use crate::parser::{ParseData, ParseDataField, TypeOrInline};\nuse proc_macro2::TokenStream;\nuse quote::quote;\nuse syn::LitStr;\n\npub(super) fn gen_doc_option(doc: \u0026[String]) -\u003e TokenStream {\n\tlet doc = doc.join(\"\\n\");\n\tlet doc = doc.trim();\n\tif doc.is_empty() {\n\t\tquote!(::core::option::Option::None)\n\t} else {\n\t\tquote!(::core::option::Option::Some(#doc))\n\t}\n}\n\nimpl ParseData {\n\tpub(super) fn gen_schema(\u0026self) -\u003e TokenStream {\n\t\tmatch self {\n\t\t\tSelf::Struct(fields) =\u003e gen_struct(fields),\n\t\t\tSelf::Enum(variants) =\u003e gen_enum(variants),\n\t\t\tSelf::Alternatives(alt) =\u003e gen_alt(alt),\n\t\t\tSelf::Unit =\u003e gen_unit()\n\t\t}\n\t}\n}\n\nfn gen_struct(fields: \u0026[ParseDataField]) -\u003e TokenStream {\n\tlet field_name = fields.iter().map(|f| \u0026f.name);\n\tlet field_doc = fields.iter().map(|f| gen_doc_option(\u0026f.doc));\n\tlet field_schema = fields.iter().map(|f| match \u0026f.ty {\n\t\tTypeOrInline::Type(ty) =\u003e {\n\t\t\tquote!(\u003c#ty as ::openapi_type::OpenapiType\u003e::schema())\n\t\t},\n\t\tTypeOrInline::Inline(data) =\u003e {\n\t\t\tlet code = data.gen_schema();\n\t\t\tquote!(::openapi_type::OpenapiSchema::new(#code))\n\t\t}\n\t});\n\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t{\n\t\t\tlet mut properties = \u003c::openapi_type::indexmap::IndexMap\u003c\n\t\t\t\t::std::string::String,\n\t\t\t\t#openapi::ReferenceOr\u003c::std::boxed::Box\u003c#openapi::Schema\u003e\u003e\n\t\t\t\u003e\u003e::new();\n\t\t\tlet mut required = \u003c::std::vec::Vec\u003c::std::string::String\u003e\u003e::new();\n\n\t\t\t#({\n\t\t\t\t\tconst FIELD_NAME: \u0026::core::primitive::str = #field_name;\n\t\t\t\t\tconst FIELD_DOC: ::core::option::Option\u003c\u0026'static ::core::primitive::str\u003e = #field_doc;\n\n\t\t\t\t\tlet mut field_schema = #field_schema;\n\t\t\t\t\t::openapi_type::private::add_dependencies(\n\t\t\t\t\t\t\u0026mut dependencies,\n\t\t\t\t\t\t\u0026mut field_schema.dependencies\n\t\t\t\t\t);\n\n\t\t\t\t\t// fields in OpenAPI are nullable by default\n\t\t\t\t\tmatch field_schema.nullable {\n\t\t\t\t\t\ttrue =\u003e field_schema.nullable = false,\n\t\t\t\t\t\tfalse =\u003e required.push(::std::string::String::from(FIELD_NAME))\n\t\t\t\t\t};\n\n\t\t\t\t\tmatch field_schema.name.as_ref() {\n\t\t\t\t\t\t// include the field schema as reference\n\t\t\t\t\t\t::std::option::Option::Some(schema_name) =\u003e {\n\t\t\t\t\t\t\tlet mut reference = ::std::string::String::from(\"#/components/schemas/\");\n\t\t\t\t\t\t\treference.push_str(schema_name);\n\t\t\t\t\t\t\tproperties.insert(\n\t\t\t\t\t\t\t\t::std::string::String::from(FIELD_NAME),\n\t\t\t\t\t\t\t\t#openapi::ReferenceOr::Reference { reference }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdependencies.insert(\n\t\t\t\t\t\t\t\t::std::string::String::from(schema_name),\n\t\t\t\t\t\t\t\tfield_schema\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// inline the field schema\n\t\t\t\t\t\t::std::option::Option::None =\u003e {\n\t\t\t\t\t\t\tlet mut schema = field_schema.into_schema();\n\t\t\t\t\t\t\tschema.schema_data.description = FIELD_DOC.map(|desc| {\n\t\t\t\t\t\t\t\t::std::string::String::from(desc)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tproperties.insert(\n\t\t\t\t\t\t\t\t::std::string::String::from(FIELD_NAME),\n\t\t\t\t\t\t\t\t#openapi::ReferenceOr::Item(\n\t\t\t\t\t\t\t\t\t::std::boxed::Box::new(schema)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t})*\n\n\t\t\t#openapi::SchemaKind::Type(\n\t\t\t\t#openapi::Type::Object(\n\t\t\t\t\t#openapi::ObjectType {\n\t\t\t\t\t\tproperties,\n\t\t\t\t\t\trequired,\n\t\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}\n}\n\nfn gen_enum(variants: \u0026[LitStr]) -\u003e TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t{\n\t\t\tlet mut enumeration = \u003c::std::vec::Vec\u003c::std::string::String\u003e\u003e::new();\n\t\t\t#(enumeration.push(::std::string::String::from(#variants));)*\n\t\t\t#openapi::SchemaKind::Type(\n\t\t\t\t#openapi::Type::String(\n\t\t\t\t\t#openapi::StringType {\n\t\t\t\t\t\tenumeration,\n\t\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}\n}\n\nfn gen_alt(alt: \u0026[ParseData]) -\u003e TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tlet schema = alt.iter().map(|data| data.gen_schema());\n\tquote! {\n\t\t{\n\t\t\tlet mut alternatives = \u003c::std::vec::Vec\u003c\n\t\t\t\t#openapi::ReferenceOr\u003c#openapi::Schema\u003e\n\t\t\t\u003e\u003e::new();\n\t\t\t#(alternatives.push(#openapi::ReferenceOr::Item(\n\t\t\t\t::openapi_type::OpenapiSchema::new(#schema).into_schema()\n\t\t\t));)*\n\t\t\t#openapi::SchemaKind::OneOf {\n\t\t\t\tone_of: alternatives\n\t\t\t}\n\t\t}\n\t}\n}\n\nfn gen_unit() -\u003e TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t#openapi::SchemaKind::Type(\n\t\t\t#openapi::Type::Object(\n\t\t\t\t#openapi::ObjectType {\n\t\t\t\t\tadditional_properties: ::std::option::Option::Some(\n\t\t\t\t\t\t#openapi::AdditionalProperties::Any(false)\n\t\t\t\t\t),\n\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t}\n\t\t\t)\n\t\t)\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms)]\n#![deny(broken_intra_doc_links)]\n#![forbid(unsafe_code)]\n//! This crate defines the macros for `#[derive(OpenapiType)]`.\n\nuse proc_macro::TokenStream;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::quote;\nuse syn::{parse_macro_input, Data, DeriveInput, LitStr, TraitBound, TraitBoundModifier, TypeParamBound};\n\n// unfortunately, the serde_derive_internals crate does not make\n// `case::RenameRule` available\nmod serde_derive_internals;\n\n#[macro_use]\nmod util;\n\nmod attrs;\nuse attrs::*;\nmod codegen;\nuse codegen::*;\nmod parser;\nuse parser::*;\n\n/// The derive macro for [OpenapiType](https://docs.rs/openapi_type/*/openapi_type/trait.OpenapiType.html).\n#[proc_macro_derive(OpenapiType, attributes(openapi))]\npub fn derive_openapi_type(input: TokenStream) -\u003e TokenStream {\n\tlet input = parse_macro_input!(input);\n\texpand_openapi_type(input).unwrap_or_else(|err| err.to_compile_error()).into()\n}\n\nfn expand_openapi_type(mut input: DeriveInput) -\u003e syn::Result\u003cTokenStream2\u003e {\n\t// parse #[serde] and #[openapi] attributes\n\tlet mut attrs = ContainerAttributes::default();\n\tfor attr in \u0026input.attrs {\n\t\tif attr.path.is_ident(\"serde\") {\n\t\t\tparse_container_attrs(attr, \u0026mut attrs, false)?;\n\t\t}\n\t}\n\tfor attr in \u0026input.attrs {\n\t\tif attr.path.is_ident(\"openapi\") {\n\t\t\tparse_container_attrs(attr, \u0026mut attrs, true)?;\n\t\t}\n\t}\n\n\t// parse #[doc] attributes\n\tlet mut doc: Vec\u003cString\u003e = Vec::new();\n\tfor attr in \u0026input.attrs {\n\t\tif attr.path.is_ident(\"doc\") {\n\t\t\tif let Some(lit) = parse_doc_attr(attr)? {\n\t\t\t\tdoc.push(lit.value());\n\t\t\t}\n\t\t}\n\t}\n\tlet doc = gen_doc_option(\u0026doc);\n\n\t// prepare impl block for codegen\n\tlet ident = \u0026input.ident;\n\tlet name = ident.to_string();\n\tlet mut name = LitStr::new(\u0026name, ident.span());\n\tif let Some(rename) = \u0026attrs.rename {\n\t\tname = rename.clone();\n\t}\n\n\t// prepare the generics - all impl generics will get `OpenapiType` requirement\n\tlet (impl_generics, ty_generics, where_clause) = {\n\t\tlet generics = \u0026mut input.generics;\n\t\tgenerics.type_params_mut().for_each(|param| {\n\t\t\tparam.colon_token.get_or_insert_with(Default::default);\n\t\t\tparam.bounds.push(TypeParamBound::Trait(TraitBound {\n\t\t\t\tparen_token: None,\n\t\t\t\tmodifier: TraitBoundModifier::None,\n\t\t\t\tlifetimes: None,\n\t\t\t\tpath: path!(::openapi_type::OpenapiType)\n\t\t\t}));\n\t\t});\n\t\tgenerics.split_for_impl()\n\t};\n\n\t// parse the input data\n\tlet parsed = match \u0026input.data {\n\t\tData::Struct(strukt) =\u003e parse_struct(strukt, \u0026attrs)?,\n\t\tData::Enum(inum) =\u003e parse_enum(inum, \u0026attrs)?,\n\t\tData::Union(union) =\u003e parse_union(union)?\n\t};\n\n\t// run the codegen\n\tlet schema_code = parsed.gen_schema();\n\n\t// put the code together\n\tOk(quote! {\n\t\t#[allow(unused_mut)]\n\t\timpl #impl_generics ::openapi_type::OpenapiType for #ident #ty_generics #where_clause {\n\t\t\tfn schema() -\u003e ::openapi_type::OpenapiSchema {\n\t\t\t\t// this will be used by the schema code\n\t\t\t\tlet mut dependencies = ::openapi_type::private::Dependencies::new();\n\n\t\t\t\tlet mut schema = ::openapi_type::OpenapiSchema::new(#schema_code);\n\t\t\t\tschema.nullable = false;\n\t\t\t\tschema.dependencies = dependencies;\n\n\t\t\t\tconst NAME: \u0026::core::primitive::str = #name;\n\t\t\t\tschema.name = ::std::option::Option::Some(::std::string::String::from(NAME));\n\n\t\t\t\tconst DESCRIPTION: ::core::option::Option\u003c\u0026'static core::primitive::str\u003e = #doc;\n\t\t\t\tschema.description = DESCRIPTION.map(|desc| ::std::string::String::from(desc));\n\n\t\t\t\tschema\n\t\t\t}\n\t\t}\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","parser.rs"],"content":"use crate::{\n\tattrs::{parse_doc_attr, ContainerAttributes},\n\tserde_derive_internals::case::RenameRule,\n\tutil::ToLitStr\n};\nuse proc_macro2::Span;\nuse syn::{spanned::Spanned as _, DataEnum, DataStruct, DataUnion, Fields, FieldsNamed, LitStr, Type};\n\npub(super) enum TypeOrInline {\n\tType(Type),\n\tInline(ParseData)\n}\n\npub(super) struct ParseDataField {\n\tpub(super) name: LitStr,\n\tpub(super) doc: Vec\u003cString\u003e,\n\tpub(super) ty: TypeOrInline\n}\n\n#[allow(dead_code)]\npub(super) enum ParseData {\n\tStruct(Vec\u003cParseDataField\u003e),\n\tEnum(Vec\u003cLitStr\u003e),\n\tAlternatives(Vec\u003cParseData\u003e),\n\tUnit\n}\n\nfn parse_named_fields(named_fields: \u0026FieldsNamed, rename_all: Option\u003c\u0026LitStr\u003e) -\u003e syn::Result\u003cParseData\u003e {\n\tlet mut fields: Vec\u003cParseDataField\u003e = Vec::new();\n\tfor f in \u0026named_fields.named {\n\t\tlet mut doc = Vec::new();\n\t\tfor attr in \u0026f.attrs {\n\t\t\tif attr.path.is_ident(\"doc\") {\n\t\t\t\tif let Some(lit) = parse_doc_attr(attr)? {\n\t\t\t\t\tdoc.push(lit.value());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet ident = f\n\t\t\t.ident\n\t\t\t.as_ref()\n\t\t\t.ok_or_else(|| syn::Error::new(f.span(), \"#[derive(OpenapiType)] does not support fields without an ident\"))?;\n\t\tlet mut name = ident.to_lit_str();\n\t\tif let Some(rename_all) = rename_all {\n\t\t\tlet rule: RenameRule = rename_all\n\t\t\t\t.value()\n\t\t\t\t.parse()\n\t\t\t\t.map_err(|_| syn::Error::new(rename_all.span(), \"Unknown rename_all rule\"))?;\n\t\t\tlet rename = rule.apply_to_field(\u0026name.value());\n\t\t\tname = LitStr::new(\u0026rename, name.span());\n\t\t}\n\t\tlet ty = f.ty.to_owned();\n\t\tfields.push(ParseDataField {\n\t\t\tname,\n\t\t\tdoc,\n\t\t\tty: TypeOrInline::Type(ty)\n\t\t});\n\t}\n\tOk(ParseData::Struct(fields))\n}\n\npub(super) fn parse_struct(strukt: \u0026DataStruct, attrs: \u0026ContainerAttributes) -\u003e syn::Result\u003cParseData\u003e {\n\tmatch \u0026strukt.fields {\n\t\tFields::Named(named_fields) =\u003e parse_named_fields(named_fields, attrs.rename_all.as_ref()),\n\t\tFields::Unnamed(unnamed_fields) =\u003e Err(syn::Error::new(\n\t\t\tunnamed_fields.span(),\n\t\t\t\"#[derive(OpenapiType)] does not support tuple structs\"\n\t\t)),\n\t\tFields::Unit =\u003e Ok(ParseData::Unit)\n\t}\n}\n\npub(super) fn parse_enum(inum: \u0026DataEnum, attrs: \u0026ContainerAttributes) -\u003e syn::Result\u003cParseData\u003e {\n\tlet mut strings: Vec\u003cLitStr\u003e = Vec::new();\n\tlet mut types: Vec\u003c(LitStr, ParseData)\u003e = Vec::new();\n\n\tfor v in \u0026inum.variants {\n\t\tlet name = v.ident.to_lit_str();\n\t\tmatch \u0026v.fields {\n\t\t\tFields::Named(named_fields) =\u003e {\n\t\t\t\ttypes.push((name, parse_named_fields(named_fields, attrs.rename_all.as_ref())?));\n\t\t\t},\n\t\t\tFields::Unnamed(unnamed_fields) =\u003e {\n\t\t\t\treturn Err(syn::Error::new(\n\t\t\t\t\tunnamed_fields.span(),\n\t\t\t\t\t\"#[derive(OpenapiType)] does not support tuple variants\"\n\t\t\t\t))\n\t\t\t},\n\t\t\tFields::Unit =\u003e strings.push(name)\n\t\t}\n\t}\n\n\tlet data_strings = if strings.is_empty() {\n\t\tNone\n\t} else {\n\t\tmatch (\u0026attrs.tag, \u0026attrs.content, attrs.untagged) {\n\t\t\t// externally tagged (default)\n\t\t\t(None, None, false) =\u003e Some(ParseData::Enum(strings)),\n\t\t\t// internally tagged or adjacently tagged\n\t\t\t(Some(tag), _, false) =\u003e Some(ParseData::Struct(vec![ParseDataField {\n\t\t\t\tname: tag.clone(),\n\t\t\t\tdoc: Vec::new(),\n\t\t\t\tty: TypeOrInline::Inline(ParseData::Enum(strings))\n\t\t\t}])),\n\t\t\t// untagged\n\t\t\t(None, None, true) =\u003e Some(ParseData::Unit),\n\t\t\t// unknown\n\t\t\t_ =\u003e return Err(syn::Error::new(Span::call_site(), \"Unknown enum representation\"))\n\t\t}\n\t};\n\n\tlet data_types =\n\t\tif types.is_empty() {\n\t\t\tNone\n\t\t} else {\n\t\t\tSome(ParseData::Alternatives(\n\t\t\t\ttypes\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|(name, mut data)| {\n\t\t\t\t\t\tOk(match (\u0026attrs.tag, \u0026attrs.content, attrs.untagged) {\n\t\t\t\t\t\t\t// externally tagged (default)\n\t\t\t\t\t\t\t(None, None, false) =\u003e ParseData::Struct(vec![ParseDataField {\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\t\t\t\tty: TypeOrInline::Inline(data)\n\t\t\t\t\t\t\t}]),\n\t\t\t\t\t\t\t// internally tagged\n\t\t\t\t\t\t\t(Some(tag), None, false) =\u003e {\n\t\t\t\t\t\t\t\tmatch \u0026mut data {\n\t\t\t\t\t\t\t\t\tParseData::Struct(fields) =\u003e fields.push(ParseDataField {\n\t\t\t\t\t\t\t\t\t\tname: tag.clone(),\n\t\t\t\t\t\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\t\t\t\t\t\tty: TypeOrInline::Inline(ParseData::Enum(vec![name]))\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t_ =\u003e return Err(syn::Error::new(\n\t\t\t\t\t\t\t\t\t\ttag.span(),\n\t\t\t\t\t\t\t\t\t\t\"#[derive(OpenapiType)] does not support tuple variants on internally tagged enums\"\n\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t// adjacently tagged\n\t\t\t\t\t\t\t(Some(tag), Some(content), false) =\u003e ParseData::Struct(vec![\n\t\t\t\t\t\t\t\tParseDataField {\n\t\t\t\t\t\t\t\t\tname: tag.clone(),\n\t\t\t\t\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\t\t\t\t\tty: TypeOrInline::Inline(ParseData::Enum(vec![name]))\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tParseDataField {\n\t\t\t\t\t\t\t\t\tname: content.clone(),\n\t\t\t\t\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\t\t\t\t\tty: TypeOrInline::Inline(data)\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t// untagged\n\t\t\t\t\t\t\t(None, None, true) =\u003e data,\n\t\t\t\t\t\t\t// unknown\n\t\t\t\t\t\t\t_ =\u003e return Err(syn::Error::new(Span::call_site(), \"Unknown enum representation\"))\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t\t.collect::\u003csyn::Result\u003cVec\u003c_\u003e\u003e\u003e()?\n\t\t\t))\n\t\t};\n\n\tmatch (data_strings, data_types) {\n\t\t// only variants without fields\n\t\t(Some(data), None) =\u003e Ok(data),\n\t\t// only one variant with fields\n\t\t(None, Some(ParseData::Alternatives(mut alt))) if alt.len() == 1 =\u003e Ok(alt.remove(0)),\n\t\t// only variants with fields\n\t\t(None, Some(data)) =\u003e Ok(data),\n\t\t// variants with and without fields\n\t\t(Some(data), Some(ParseData::Alternatives(mut alt))) =\u003e {\n\t\t\talt.push(data);\n\t\t\tOk(ParseData::Alternatives(alt))\n\t\t},\n\t\t// no variants\n\t\t(None, None) =\u003e Err(syn::Error::new(\n\t\t\tinum.brace_token.span,\n\t\t\t\"#[derive(OpenapiType)] does not support enums with no variants\"\n\t\t)),\n\t\t// data_types always produces Alternatives\n\t\t_ =\u003e unreachable!()\n\t}\n}\n\npub(super) fn parse_union(union: \u0026DataUnion) -\u003e syn::Result\u003cParseData\u003e {\n\tErr(syn::Error::new(\n\t\tunion.union_token.span(),\n\t\t\"#[derive(OpenapiType)] cannot be used on unions\"\n\t))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","serde_derive_internals","case.rs"],"content":"//! Code to convert the Rust-styled field/variant (e.g. `my_field`, `MyType`) to the\n//! case of the source (e.g. `my-field`, `MY_FIELD`).\n\n// See https://users.rust-lang.org/t/psa-dealing-with-warning-unused-import-std-ascii-asciiext-in-today-s-nightly/13726\n#[allow(deprecated, unused_imports)]\nuse std::ascii::AsciiExt;\n\nuse std::str::FromStr;\n\nuse self::RenameRule::*;\n\n/// The different possible ways to change case of fields in a struct, or variants in an enum.\n#[derive(Copy, Clone, PartialEq)]\npub enum RenameRule {\n    /// Don't apply a default rename rule.\n    None,\n    /// Rename direct children to \"lowercase\" style.\n    LowerCase,\n    /// Rename direct children to \"UPPERCASE\" style.\n    UPPERCASE,\n    /// Rename direct children to \"PascalCase\" style, as typically used for\n    /// enum variants.\n    PascalCase,\n    /// Rename direct children to \"camelCase\" style.\n    CamelCase,\n    /// Rename direct children to \"snake_case\" style, as commonly used for\n    /// fields.\n    SnakeCase,\n    /// Rename direct children to \"SCREAMING_SNAKE_CASE\" style, as commonly\n    /// used for constants.\n    ScreamingSnakeCase,\n    /// Rename direct children to \"kebab-case\" style.\n    KebabCase,\n    /// Rename direct children to \"SCREAMING-KEBAB-CASE\" style.\n    ScreamingKebabCase,\n}\n\nimpl RenameRule {\n    /// Apply a renaming rule to an enum variant, returning the version expected in the source.\n    pub fn apply_to_variant(\u0026self, variant: \u0026str) -\u003e String {\n        match *self {\n            None | PascalCase =\u003e variant.to_owned(),\n            LowerCase =\u003e variant.to_ascii_lowercase(),\n            UPPERCASE =\u003e variant.to_ascii_uppercase(),\n            CamelCase =\u003e variant[..1].to_ascii_lowercase() + \u0026variant[1..],\n            SnakeCase =\u003e {\n                let mut snake = String::new();\n                for (i, ch) in variant.char_indices() {\n                    if i \u003e 0 \u0026\u0026 ch.is_uppercase() {\n                        snake.push('_');\n                    }\n                    snake.push(ch.to_ascii_lowercase());\n                }\n                snake\n            }\n            ScreamingSnakeCase =\u003e SnakeCase.apply_to_variant(variant).to_ascii_uppercase(),\n            KebabCase =\u003e SnakeCase.apply_to_variant(variant).replace('_', \"-\"),\n            ScreamingKebabCase =\u003e ScreamingSnakeCase\n                .apply_to_variant(variant)\n                .replace('_', \"-\"),\n        }\n    }\n\n    /// Apply a renaming rule to a struct field, returning the version expected in the source.\n    pub fn apply_to_field(\u0026self, field: \u0026str) -\u003e String {\n        match *self {\n            None | LowerCase | SnakeCase =\u003e field.to_owned(),\n            UPPERCASE =\u003e field.to_ascii_uppercase(),\n            PascalCase =\u003e {\n                let mut pascal = String::new();\n                let mut capitalize = true;\n                for ch in field.chars() {\n                    if ch == '_' {\n                        capitalize = true;\n                    } else if capitalize {\n                        pascal.push(ch.to_ascii_uppercase());\n                        capitalize = false;\n                    } else {\n                        pascal.push(ch);\n                    }\n                }\n                pascal\n            }\n            CamelCase =\u003e {\n                let pascal = PascalCase.apply_to_field(field);\n                pascal[..1].to_ascii_lowercase() + \u0026pascal[1..]\n            }\n            ScreamingSnakeCase =\u003e field.to_ascii_uppercase(),\n            KebabCase =\u003e field.replace('_', \"-\"),\n            ScreamingKebabCase =\u003e ScreamingSnakeCase.apply_to_field(field).replace('_', \"-\"),\n        }\n    }\n}\n\nimpl FromStr for RenameRule {\n    type Err = ();\n\n    fn from_str(rename_all_str: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match rename_all_str {\n            \"lowercase\" =\u003e Ok(LowerCase),\n            \"UPPERCASE\" =\u003e Ok(UPPERCASE),\n            \"PascalCase\" =\u003e Ok(PascalCase),\n            \"camelCase\" =\u003e Ok(CamelCase),\n            \"snake_case\" =\u003e Ok(SnakeCase),\n            \"SCREAMING_SNAKE_CASE\" =\u003e Ok(ScreamingSnakeCase),\n            \"kebab-case\" =\u003e Ok(KebabCase),\n            \"SCREAMING-KEBAB-CASE\" =\u003e Ok(ScreamingKebabCase),\n            _ =\u003e Err(()),\n        }\n    }\n}\n\n#[test]\nfn rename_variants() {\n    for \u0026(original, lower, upper, camel, snake, screaming, kebab, screaming_kebab) in \u0026[\n        (\n            \"Outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"OUTCOME\",\n        ),\n        (\n            \"VeryTasty\",\n            \"verytasty\",\n            \"VERYTASTY\",\n            \"veryTasty\",\n            \"very_tasty\",\n            \"VERY_TASTY\",\n            \"very-tasty\",\n            \"VERY-TASTY\",\n        ),\n        (\"A\", \"a\", \"A\", \"a\", \"a\", \"A\", \"a\", \"A\"),\n        (\"Z42\", \"z42\", \"Z42\", \"z42\", \"z42\", \"Z42\", \"z42\", \"Z42\"),\n    ] {\n        assert_eq!(None.apply_to_variant(original), original);\n        assert_eq!(LowerCase.apply_to_variant(original), lower);\n        assert_eq!(UPPERCASE.apply_to_variant(original), upper);\n        assert_eq!(PascalCase.apply_to_variant(original), original);\n        assert_eq!(CamelCase.apply_to_variant(original), camel);\n        assert_eq!(SnakeCase.apply_to_variant(original), snake);\n        assert_eq!(ScreamingSnakeCase.apply_to_variant(original), screaming);\n        assert_eq!(KebabCase.apply_to_variant(original), kebab);\n        assert_eq!(\n            ScreamingKebabCase.apply_to_variant(original),\n            screaming_kebab\n        );\n    }\n}\n\n#[test]\nfn rename_fields() {\n    for \u0026(original, upper, pascal, camel, screaming, kebab, screaming_kebab) in \u0026[\n        (\n            \"outcome\", \"OUTCOME\", \"Outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"OUTCOME\",\n        ),\n        (\n            \"very_tasty\",\n            \"VERY_TASTY\",\n            \"VeryTasty\",\n            \"veryTasty\",\n            \"VERY_TASTY\",\n            \"very-tasty\",\n            \"VERY-TASTY\",\n        ),\n        (\"a\", \"A\", \"A\", \"a\", \"A\", \"a\", \"A\"),\n        (\"z42\", \"Z42\", \"Z42\", \"z42\", \"Z42\", \"z42\", \"Z42\"),\n    ] {\n        assert_eq!(None.apply_to_field(original), original);\n        assert_eq!(UPPERCASE.apply_to_field(original), upper);\n        assert_eq!(PascalCase.apply_to_field(original), pascal);\n        assert_eq!(CamelCase.apply_to_field(original), camel);\n        assert_eq!(SnakeCase.apply_to_field(original), original);\n        assert_eq!(ScreamingSnakeCase.apply_to_field(original), screaming);\n        assert_eq!(KebabCase.apply_to_field(original), kebab);\n        assert_eq!(ScreamingKebabCase.apply_to_field(original), screaming_kebab);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","serde_derive_internals","mod.rs"],"content":"#[allow(clippy::upper_case_acronyms, dead_code)]\npub(super) mod case;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","util.rs"],"content":"use proc_macro2::Ident;\nuse syn::{Lit, LitStr};\n\n/// Convert any literal path into a [syn::Path].\nmacro_rules! path {\n\t(:: $($segment:ident)::*) =\u003e {\n\t\tpath!(@private Some(Default::default()), $($segment),*)\n\t};\n\t($($segment:ident)::*) =\u003e {\n\t\tpath!(@private None, $($segment),*)\n\t};\n\t(@private $leading_colon:expr, $($segment:ident),*) =\u003e {\n\t\t{\n\t\t\t#[allow(unused_mut)]\n\t\t\tlet mut segments: ::syn::punctuated::Punctuated\u003c::syn::PathSegment, _\u003e = Default::default();\n\t\t\t$(\n\t\t\t\tsegments.push(::syn::PathSegment {\n\t\t\t\t\tident: ::proc_macro2::Ident::new(stringify!($segment), ::proc_macro2::Span::call_site()),\n\t\t\t\t\targuments: Default::default()\n\t\t\t\t});\n\t\t\t)*\n\t\t\t::syn::Path {\n\t\t\t\tleading_colon: $leading_colon,\n\t\t\t\tsegments\n\t\t\t}\n\t\t}\n\t};\n}\n\n/// Convert any [Ident] into a [LitStr]. Basically `stringify!`.\npub(super) trait ToLitStr {\n\tfn to_lit_str(\u0026self) -\u003e LitStr;\n}\nimpl ToLitStr for Ident {\n\tfn to_lit_str(\u0026self) -\u003e LitStr {\n\t\tLitStr::new(\u0026self.to_string(), self.span())\n\t}\n}\n\n/// Convert a [Lit] to one specific literal type.\npub(crate) trait ExpectLit {\n\tfn expect_str(self) -\u003e syn::Result\u003cLitStr\u003e;\n}\n\nimpl ExpectLit for Lit {\n\tfn expect_str(self) -\u003e syn::Result\u003cLitStr\u003e {\n\t\tmatch self {\n\t\t\tSelf::Str(str) =\u003e Ok(str),\n\t\t\t_ =\u003e Err(syn::Error::new(self.span(), \"Expected string literal\"))\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","build.rs"],"content":"use std::env;\nuse std::process::Command;\nuse std::str::{self, FromStr};\n\n// The rustc-cfg strings below are *not* public API. Please let us know by\n// opening a GitHub issue if your build environment requires some way to enable\n// these cfgs other than by executing our build script.\nfn main() {\n    let minor = match rustc_minor_version() {\n        Some(minor) =\u003e minor,\n        None =\u003e return,\n    };\n\n    let target = env::var(\"TARGET\").unwrap();\n    let emscripten = target == \"asmjs-unknown-emscripten\" || target == \"wasm32-unknown-emscripten\";\n\n    // std::collections::Bound was stabilized in Rust 1.17\n    // but it was moved to core::ops later in Rust 1.26:\n    // https://doc.rust-lang.org/core/ops/enum.Bound.html\n    if minor \u003e= 26 {\n        println!(\"cargo:rustc-cfg=ops_bound\");\n    } else if minor \u003e= 17 \u0026\u0026 cfg!(feature = \"std\") {\n        println!(\"cargo:rustc-cfg=collections_bound\");\n    }\n\n    // core::cmp::Reverse stabilized in Rust 1.19:\n    // https://doc.rust-lang.org/stable/core/cmp/struct.Reverse.html\n    if minor \u003e= 19 {\n        println!(\"cargo:rustc-cfg=core_reverse\");\n    }\n\n    // CString::into_boxed_c_str stabilized in Rust 1.20:\n    // https://doc.rust-lang.org/std/ffi/struct.CString.html#method.into_boxed_c_str\n    if minor \u003e= 20 {\n        println!(\"cargo:rustc-cfg=de_boxed_c_str\");\n    }\n\n    // From\u003cBox\u003cT\u003e\u003e for Rc\u003cT\u003e / Arc\u003cT\u003e stabilized in Rust 1.21:\n    // https://doc.rust-lang.org/std/rc/struct.Rc.html#impl-From\u003cBox\u003cT\u003e\u003e\n    // https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-From\u003cBox\u003cT\u003e\u003e\n    if minor \u003e= 21 {\n        println!(\"cargo:rustc-cfg=de_rc_dst\");\n    }\n\n    // Duration available in core since Rust 1.25:\n    // https://blog.rust-lang.org/2018/03/29/Rust-1.25.html#library-stabilizations\n    if minor \u003e= 25 {\n        println!(\"cargo:rustc-cfg=core_duration\");\n    }\n\n    // 128-bit integers stabilized in Rust 1.26:\n    // https://blog.rust-lang.org/2018/05/10/Rust-1.26.html\n    //\n    // Disabled on Emscripten targets as Emscripten doesn't\n    // currently support integers larger than 64 bits.\n    if minor \u003e= 26 \u0026\u0026 !emscripten {\n        println!(\"cargo:rustc-cfg=integer128\");\n    }\n\n    // Inclusive ranges methods stabilized in Rust 1.27:\n    // https://github.com/rust-lang/rust/pull/50758\n    if minor \u003e= 27 {\n        println!(\"cargo:rustc-cfg=range_inclusive\");\n    }\n\n    // Non-zero integers stabilized in Rust 1.28:\n    // https://github.com/rust-lang/rust/pull/50808\n    if minor \u003e= 28 {\n        println!(\"cargo:rustc-cfg=num_nonzero\");\n    }\n\n    // TryFrom, Atomic types, and non-zero signed integers stabilized in Rust 1.34:\n    // https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#tryfrom-and-tryinto\n    // https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#library-stabilizations\n    if minor \u003e= 34 {\n        println!(\"cargo:rustc-cfg=core_try_from\");\n        println!(\"cargo:rustc-cfg=num_nonzero_signed\");\n\n        // Whitelist of archs that support std::sync::atomic module. Ideally we\n        // would use #[cfg(target_has_atomic = \"...\")] but it is not stable yet.\n        // Instead this is based on rustc's src/librustc_target/spec/*.rs.\n        let has_atomic64 = target.starts_with(\"x86_64\")\n            || target.starts_with(\"i686\")\n            || target.starts_with(\"aarch64\")\n            || target.starts_with(\"powerpc64\")\n            || target.starts_with(\"sparc64\")\n            || target.starts_with(\"mips64el\");\n        let has_atomic32 = has_atomic64 || emscripten;\n        if has_atomic64 {\n            println!(\"cargo:rustc-cfg=std_atomic64\");\n        }\n        if has_atomic32 {\n            println!(\"cargo:rustc-cfg=std_atomic\");\n        }\n    }\n}\n\nfn rustc_minor_version() -\u003e Option\u003cu32\u003e {\n    let rustc = match env::var_os(\"RUSTC\") {\n        Some(rustc) =\u003e rustc,\n        None =\u003e return None,\n    };\n\n    let output = match Command::new(rustc).arg(\"--version\").output() {\n        Ok(output) =\u003e output,\n        Err(_) =\u003e return None,\n    };\n\n    let version = match str::from_utf8(\u0026output.stdout) {\n        Ok(version) =\u003e version,\n        Err(_) =\u003e return None,\n    };\n\n    let mut pieces = version.split('.');\n    if pieces.next() != Some(\"rustc 1\") {\n        return None;\n    }\n\n    let next = match pieces.next() {\n        Some(next) =\u003e next,\n        None =\u003e return None,\n    };\n\n    u32::from_str(next).ok()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","from_primitive.rs"],"content":"use lib::*;\n\nmacro_rules! int_to_int {\n    ($dst:ident, $n:ident) =\u003e {\n        if $dst::min_value() as i64 \u003c= $n as i64 \u0026\u0026 $n as i64 \u003c= $dst::max_value() as i64 {\n            Some($n as $dst)\n        } else {\n            None\n        }\n    };\n}\n\nmacro_rules! int_to_uint {\n    ($dst:ident, $n:ident) =\u003e {\n        if 0 \u003c= $n \u0026\u0026 $n as u64 \u003c= $dst::max_value() as u64 {\n            Some($n as $dst)\n        } else {\n            None\n        }\n    };\n}\n\nmacro_rules! uint_to {\n    ($dst:ident, $n:ident) =\u003e {\n        if $n as u64 \u003c= $dst::max_value() as u64 {\n            Some($n as $dst)\n        } else {\n            None\n        }\n    };\n}\n\npub trait FromPrimitive: Sized {\n    fn from_i8(n: i8) -\u003e Option\u003cSelf\u003e;\n    fn from_i16(n: i16) -\u003e Option\u003cSelf\u003e;\n    fn from_i32(n: i32) -\u003e Option\u003cSelf\u003e;\n    fn from_i64(n: i64) -\u003e Option\u003cSelf\u003e;\n    fn from_u8(n: u8) -\u003e Option\u003cSelf\u003e;\n    fn from_u16(n: u16) -\u003e Option\u003cSelf\u003e;\n    fn from_u32(n: u32) -\u003e Option\u003cSelf\u003e;\n    fn from_u64(n: u64) -\u003e Option\u003cSelf\u003e;\n}\n\nmacro_rules! impl_from_primitive_for_int {\n    ($t:ident) =\u003e {\n        impl FromPrimitive for $t {\n            #[inline]\n            fn from_i8(n: i8) -\u003e Option\u003cSelf\u003e {\n                int_to_int!($t, n)\n            }\n            #[inline]\n            fn from_i16(n: i16) -\u003e Option\u003cSelf\u003e {\n                int_to_int!($t, n)\n            }\n            #[inline]\n            fn from_i32(n: i32) -\u003e Option\u003cSelf\u003e {\n                int_to_int!($t, n)\n            }\n            #[inline]\n            fn from_i64(n: i64) -\u003e Option\u003cSelf\u003e {\n                int_to_int!($t, n)\n            }\n            #[inline]\n            fn from_u8(n: u8) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u16(n: u16) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u32(n: u32) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u64(n: u64) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n        }\n    };\n}\n\nmacro_rules! impl_from_primitive_for_uint {\n    ($t:ident) =\u003e {\n        impl FromPrimitive for $t {\n            #[inline]\n            fn from_i8(n: i8) -\u003e Option\u003cSelf\u003e {\n                int_to_uint!($t, n)\n            }\n            #[inline]\n            fn from_i16(n: i16) -\u003e Option\u003cSelf\u003e {\n                int_to_uint!($t, n)\n            }\n            #[inline]\n            fn from_i32(n: i32) -\u003e Option\u003cSelf\u003e {\n                int_to_uint!($t, n)\n            }\n            #[inline]\n            fn from_i64(n: i64) -\u003e Option\u003cSelf\u003e {\n                int_to_uint!($t, n)\n            }\n            #[inline]\n            fn from_u8(n: u8) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u16(n: u16) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u32(n: u32) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u64(n: u64) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n        }\n    };\n}\n\nmacro_rules! impl_from_primitive_for_float {\n    ($t:ident) =\u003e {\n        impl FromPrimitive for $t {\n            #[inline]\n            fn from_i8(n: i8) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_i16(n: i16) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_i32(n: i32) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_i64(n: i64) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_u8(n: u8) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_u16(n: u16) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_u32(n: u32) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_u64(n: u64) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n        }\n    };\n}\n\nimpl_from_primitive_for_int!(isize);\nimpl_from_primitive_for_int!(i8);\nimpl_from_primitive_for_int!(i16);\nimpl_from_primitive_for_int!(i32);\nimpl_from_primitive_for_int!(i64);\nimpl_from_primitive_for_uint!(usize);\nimpl_from_primitive_for_uint!(u8);\nimpl_from_primitive_for_uint!(u16);\nimpl_from_primitive_for_uint!(u32);\nimpl_from_primitive_for_uint!(u64);\nimpl_from_primitive_for_float!(f32);\nimpl_from_primitive_for_float!(f64);\n\nserde_if_integer128! {\n    impl FromPrimitive for i128 {\n        #[inline]\n        fn from_i8(n: i8) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_i16(n: i16) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_i32(n: i32) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_i64(n: i64) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_u8(n: u8) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_u16(n: u16) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_u32(n: u32) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_u64(n: u64) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n    }\n\n    impl FromPrimitive for u128 {\n        #[inline]\n        fn from_i8(n: i8) -\u003e Option\u003cSelf\u003e {\n            if n \u003e= 0 {\n                Some(n as u128)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn from_i16(n: i16) -\u003e Option\u003cSelf\u003e {\n            if n \u003e= 0 {\n                Some(n as u128)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn from_i32(n: i32) -\u003e Option\u003cSelf\u003e {\n            if n \u003e= 0 {\n                Some(n as u128)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn from_i64(n: i64) -\u003e Option\u003cSelf\u003e {\n            if n \u003e= 0 {\n                Some(n as u128)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn from_u8(n: u8) -\u003e Option\u003cSelf\u003e {\n            Some(n as u128)\n        }\n        #[inline]\n        fn from_u16(n: u16) -\u003e Option\u003cSelf\u003e {\n            Some(n as u128)\n        }\n        #[inline]\n        fn from_u32(n: u32) -\u003e Option\u003cSelf\u003e {\n            Some(n as u128)\n        }\n        #[inline]\n        fn from_u64(n: u64) -\u003e Option\u003cSelf\u003e {\n            Some(n as u128)\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","ignored_any.rs"],"content":"use lib::*;\n\nuse de::{\n    Deserialize, Deserializer, EnumAccess, Error, MapAccess, SeqAccess, VariantAccess, Visitor,\n};\n\n/// An efficient way of discarding data from a deserializer.\n///\n/// Think of this like `serde_json::Value` in that it can be deserialized from\n/// any type, except that it does not store any information about the data that\n/// gets deserialized.\n///\n/// ```edition2018\n/// use std::fmt;\n/// use std::marker::PhantomData;\n///\n/// use serde::de::{\n///     self, Deserialize, DeserializeSeed, Deserializer, IgnoredAny, SeqAccess, Visitor,\n/// };\n///\n/// /// A seed that can be used to deserialize only the `n`th element of a sequence\n/// /// while efficiently discarding elements of any type before or after index `n`.\n/// ///\n/// /// For example to deserialize only the element at index 3:\n/// ///\n/// /// ```\n/// /// NthElement::new(3).deserialize(deserializer)\n/// /// ```\n/// pub struct NthElement\u003cT\u003e {\n///     n: usize,\n///     marker: PhantomData\u003cT\u003e,\n/// }\n///\n/// impl\u003cT\u003e NthElement\u003cT\u003e {\n///     pub fn new(n: usize) -\u003e Self {\n///         NthElement {\n///             n: n,\n///             marker: PhantomData,\n///         }\n///     }\n/// }\n///\n/// impl\u003c'de, T\u003e Visitor\u003c'de\u003e for NthElement\u003cT\u003e\n/// where\n///     T: Deserialize\u003c'de\u003e,\n/// {\n///     type Value = T;\n///\n///     fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n///         write!(\n///             formatter,\n///             \"a sequence in which we care about element {}\",\n///             self.n\n///         )\n///     }\n///\n///     fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n///     where\n///         A: SeqAccess\u003c'de\u003e,\n///     {\n///         // Skip over the first `n` elements.\n///         for i in 0..self.n {\n///             // It is an error if the sequence ends before we get to element `n`.\n///             if seq.next_element::\u003cIgnoredAny\u003e()?.is_none() {\n///                 return Err(de::Error::invalid_length(i, \u0026self));\n///             }\n///         }\n///\n///         // Deserialize the one we care about.\n///         let nth = match seq.next_element()? {\n///             Some(nth) =\u003e nth,\n///             None =\u003e {\n///                 return Err(de::Error::invalid_length(self.n, \u0026self));\n///             }\n///         };\n///\n///         // Skip over any remaining elements in the sequence after `n`.\n///         while let Some(IgnoredAny) = seq.next_element()? {\n///             // ignore\n///         }\n///\n///         Ok(nth)\n///     }\n/// }\n///\n/// impl\u003c'de, T\u003e DeserializeSeed\u003c'de\u003e for NthElement\u003cT\u003e\n/// where\n///     T: Deserialize\u003c'de\u003e,\n/// {\n///     type Value = T;\n///\n///     fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n///     where\n///         D: Deserializer\u003c'de\u003e,\n///     {\n///         deserializer.deserialize_seq(self)\n///     }\n/// }\n///\n/// # fn example\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003c(), D::Error\u003e\n/// # where\n/// #     D: Deserializer\u003c'de\u003e,\n/// # {\n/// // Deserialize only the sequence element at index 3 from this deserializer.\n/// // The element at index 3 is required to be a string. Elements before and\n/// // after index 3 are allowed to be of any type.\n/// let s: String = NthElement::new(3).deserialize(deserializer)?;\n/// #     Ok(())\n/// # }\n/// ```\n#[derive(Copy, Clone, Debug, Default)]\npub struct IgnoredAny;\n\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for IgnoredAny {\n    type Value = IgnoredAny;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"anything at all\")\n    }\n\n    #[inline]\n    fn visit_bool\u003cE\u003e(self, x: bool) -\u003e Result\u003cSelf::Value, E\u003e {\n        let _ = x;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_i64\u003cE\u003e(self, x: i64) -\u003e Result\u003cSelf::Value, E\u003e {\n        let _ = x;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_u64\u003cE\u003e(self, x: u64) -\u003e Result\u003cSelf::Value, E\u003e {\n        let _ = x;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_f64\u003cE\u003e(self, x: f64) -\u003e Result\u003cSelf::Value, E\u003e {\n        let _ = x;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_str\u003cE\u003e(self, s: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        let _ = s;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_none\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e {\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        IgnoredAny::deserialize(deserializer)\n    }\n\n    #[inline]\n    fn visit_newtype_struct\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        IgnoredAny::deserialize(deserializer)\n    }\n\n    #[inline]\n    fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e {\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: SeqAccess\u003c'de\u003e,\n    {\n        while let Some(IgnoredAny) = try!(seq.next_element()) {\n            // Gobble\n        }\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_map\u003cA\u003e(self, mut map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: MapAccess\u003c'de\u003e,\n    {\n        while let Some((IgnoredAny, IgnoredAny)) = try!(map.next_entry()) {\n            // Gobble\n        }\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_bytes\u003cE\u003e(self, bytes: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        let _ = bytes;\n        Ok(IgnoredAny)\n    }\n\n    fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: EnumAccess\u003c'de\u003e,\n    {\n        data.variant::\u003cIgnoredAny\u003e()?.1.newtype_variant()\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for IgnoredAny {\n    #[inline]\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cIgnoredAny, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_ignored_any(IgnoredAny)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","impls.rs"],"content":"use lib::*;\n\nuse de::{\n    Deserialize, Deserializer, EnumAccess, Error, SeqAccess, Unexpected, VariantAccess, Visitor,\n};\n\n#[cfg(any(core_duration, feature = \"std\", feature = \"alloc\"))]\nuse de::MapAccess;\n\nuse de::from_primitive::FromPrimitive;\nuse private::de::InPlaceSeed;\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse private::de::size_hint;\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct UnitVisitor;\n\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for UnitVisitor {\n    type Value = ();\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"unit\")\n    }\n\n    fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(())\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for () {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_unit(UnitVisitor)\n    }\n}\n\n#[cfg(feature = \"unstable\")]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for ! {\n    fn deserialize\u003cD\u003e(_deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Err(Error::custom(\"cannot deserialize `!`\"))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct BoolVisitor;\n\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for BoolVisitor {\n    type Value = bool;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a boolean\")\n    }\n\n    fn visit_bool\u003cE\u003e(self, v: bool) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for bool {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_bool(BoolVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! visit_integer_method {\n    ($src_ty:ident, $method:ident, $from_method:ident, $group:ident, $group_ty:ident) =\u003e {\n        #[inline]\n        fn $method\u003cE\u003e(self, v: $src_ty) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            match FromPrimitive::$from_method(v) {\n                Some(v) =\u003e Ok(v),\n                None =\u003e Err(Error::invalid_value(Unexpected::$group(v as $group_ty), \u0026self)),\n            }\n        }\n    }\n}\n\nmacro_rules! visit_float_method {\n    ($src_ty:ident, $method:ident) =\u003e {\n        #[inline]\n        fn $method\u003cE\u003e(self, v: $src_ty) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(v as Self::Value)\n        }\n    }\n}\n\nmacro_rules! impl_deserialize_num {\n    ($ty:ident, $method:ident, $($visit:ident),*) =\u003e {\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for $ty {\n            #[inline]\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct PrimitiveVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for PrimitiveVisitor {\n                    type Value = $ty;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(stringify!($ty))\n                    }\n\n                    $(\n                        impl_deserialize_num!($visit $ty);\n                    )*\n                }\n\n                deserializer.$method(PrimitiveVisitor)\n            }\n        }\n    };\n\n    (integer $ty:ident) =\u003e {\n        visit_integer_method!(i8, visit_i8, from_i8, Signed, i64);\n        visit_integer_method!(i16, visit_i16, from_i16, Signed, i64);\n        visit_integer_method!(i32, visit_i32, from_i32, Signed, i64);\n        visit_integer_method!(i64, visit_i64, from_i64, Signed, i64);\n\n        visit_integer_method!(u8, visit_u8, from_u8, Unsigned, u64);\n        visit_integer_method!(u16, visit_u16, from_u16, Unsigned, u64);\n        visit_integer_method!(u32, visit_u32, from_u32, Unsigned, u64);\n        visit_integer_method!(u64, visit_u64, from_u64, Unsigned, u64);\n    };\n\n    (float $ty:ident) =\u003e {\n        visit_float_method!(f32, visit_f32);\n        visit_float_method!(f64, visit_f64);\n    };\n}\n\nimpl_deserialize_num!(i8, deserialize_i8, integer);\nimpl_deserialize_num!(i16, deserialize_i16, integer);\nimpl_deserialize_num!(i32, deserialize_i32, integer);\nimpl_deserialize_num!(i64, deserialize_i64, integer);\nimpl_deserialize_num!(isize, deserialize_i64, integer);\n\nimpl_deserialize_num!(u8, deserialize_u8, integer);\nimpl_deserialize_num!(u16, deserialize_u16, integer);\nimpl_deserialize_num!(u32, deserialize_u32, integer);\nimpl_deserialize_num!(u64, deserialize_u64, integer);\nimpl_deserialize_num!(usize, deserialize_u64, integer);\n\nimpl_deserialize_num!(f32, deserialize_f32, integer, float);\nimpl_deserialize_num!(f64, deserialize_f64, integer, float);\n\nserde_if_integer128! {\n    impl\u003c'de\u003e Deserialize\u003c'de\u003e for i128 {\n        #[inline]\n        fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            struct PrimitiveVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for PrimitiveVisitor {\n                type Value = i128;\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(\"i128\")\n                }\n\n                impl_deserialize_num!(integer i128);\n\n                #[inline]\n                fn visit_i128\u003cE\u003e(self, v: i128) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    Ok(v)\n                }\n\n                #[inline]\n                fn visit_u128\u003cE\u003e(self, v: u128) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    if v \u003c= i128::max_value() as u128 {\n                        Ok(v as i128)\n                    } else {\n                        Err(Error::invalid_value(Unexpected::Other(\"u128\"), \u0026self))\n                    }\n                }\n            }\n\n            deserializer.deserialize_i128(PrimitiveVisitor)\n        }\n    }\n\n    impl\u003c'de\u003e Deserialize\u003c'de\u003e for u128 {\n        #[inline]\n        fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            struct PrimitiveVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for PrimitiveVisitor {\n                type Value = u128;\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(\"u128\")\n                }\n\n                impl_deserialize_num!(integer u128);\n\n                #[inline]\n                fn visit_i128\u003cE\u003e(self, v: i128) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    if v \u003e= 0 {\n                        Ok(v as u128)\n                    } else {\n                        Err(Error::invalid_value(Unexpected::Other(\"i128\"), \u0026self))\n                    }\n                }\n\n                #[inline]\n                fn visit_u128\u003cE\u003e(self, v: u128) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    Ok(v)\n                }\n            }\n\n            deserializer.deserialize_u128(PrimitiveVisitor)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct CharVisitor;\n\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for CharVisitor {\n    type Value = char;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a character\")\n    }\n\n    #[inline]\n    fn visit_char\u003cE\u003e(self, v: char) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    #[inline]\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        let mut iter = v.chars();\n        match (iter.next(), iter.next()) {\n            (Some(c), None) =\u003e Ok(c),\n            _ =\u003e Err(Error::invalid_value(Unexpected::Str(v), \u0026self)),\n        }\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for char {\n    #[inline]\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_char(CharVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nstruct StringVisitor;\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nstruct StringInPlaceVisitor\u003c'a\u003e(\u0026'a mut String);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for StringVisitor {\n    type Value = String;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a string\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v.to_owned())\n    }\n\n    fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        match str::from_utf8(v) {\n            Ok(s) =\u003e Ok(s.to_owned()),\n            Err(_) =\u003e Err(Error::invalid_value(Unexpected::Bytes(v), \u0026self)),\n        }\n    }\n\n    fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        match String::from_utf8(v) {\n            Ok(s) =\u003e Ok(s),\n            Err(e) =\u003e Err(Error::invalid_value(\n                Unexpected::Bytes(\u0026e.into_bytes()),\n                \u0026self,\n            )),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de\u003e Visitor\u003c'de\u003e for StringInPlaceVisitor\u003c'a\u003e {\n    type Value = ();\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a string\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.0.clear();\n        self.0.push_str(v);\n        Ok(())\n    }\n\n    fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        *self.0 = v;\n        Ok(())\n    }\n\n    fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        match str::from_utf8(v) {\n            Ok(s) =\u003e {\n                self.0.clear();\n                self.0.push_str(s);\n                Ok(())\n            }\n            Err(_) =\u003e Err(Error::invalid_value(Unexpected::Bytes(v), \u0026self)),\n        }\n    }\n\n    fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        match String::from_utf8(v) {\n            Ok(s) =\u003e {\n                *self.0 = s;\n                Ok(())\n            }\n            Err(e) =\u003e Err(Error::invalid_value(\n                Unexpected::Bytes(\u0026e.into_bytes()),\n                \u0026self,\n            )),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for String {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_string(StringVisitor)\n    }\n\n    fn deserialize_in_place\u003cD\u003e(deserializer: D, place: \u0026mut Self) -\u003e Result\u003c(), D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_string(StringInPlaceVisitor(place))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct StrVisitor;\n\nimpl\u003c'a\u003e Visitor\u003c'a\u003e for StrVisitor {\n    type Value = \u0026'a str;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a borrowed string\")\n    }\n\n    fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'a str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v) // so easy\n    }\n\n    fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'a [u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        str::from_utf8(v).map_err(|_| Error::invalid_value(Unexpected::Bytes(v), \u0026self))\n    }\n}\n\nimpl\u003c'de: 'a, 'a\u003e Deserialize\u003c'de\u003e for \u0026'a str {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(StrVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct BytesVisitor;\n\nimpl\u003c'a\u003e Visitor\u003c'a\u003e for BytesVisitor {\n    type Value = \u0026'a [u8];\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a borrowed byte array\")\n    }\n\n    fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'a [u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'a str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v.as_bytes())\n    }\n}\n\nimpl\u003c'de: 'a, 'a\u003e Deserialize\u003c'de\u003e for \u0026'a [u8] {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_bytes(BytesVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nstruct CStringVisitor;\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for CStringVisitor {\n    type Value = CString;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"byte array\")\n    }\n\n    fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: SeqAccess\u003c'de\u003e,\n    {\n        let len = size_hint::cautious(seq.size_hint());\n        let mut values = Vec::with_capacity(len);\n\n        while let Some(value) = try!(seq.next_element()) {\n            values.push(value);\n        }\n\n        CString::new(values).map_err(Error::custom)\n    }\n\n    fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n\n    fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n\n    fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for CString {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_byte_buf(CStringVisitor)\n    }\n}\n\nmacro_rules! forwarded_impl {\n    (\n        $(#[doc = $doc:tt])*\n        ( $($id: ident),* ), $ty: ty, $func: expr\n    ) =\u003e {\n        $(#[doc = $doc])*\n        impl\u003c'de $(, $id : Deserialize\u003c'de\u003e,)*\u003e Deserialize\u003c'de\u003e for $ty {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                Deserialize::deserialize(deserializer).map($func)\n            }\n        }\n    }\n}\n\n#[cfg(all(feature = \"std\", de_boxed_c_str))]\nforwarded_impl!((), Box\u003cCStr\u003e, CString::into_boxed_c_str);\n\n#[cfg(core_reverse)]\nforwarded_impl!((T), Reverse\u003cT\u003e, Reverse);\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct OptionVisitor\u003cT\u003e {\n    marker: PhantomData\u003cT\u003e,\n}\n\nimpl\u003c'de, T\u003e Visitor\u003c'de\u003e for OptionVisitor\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    type Value = Option\u003cT\u003e;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"option\")\n    }\n\n    #[inline]\n    fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(None)\n    }\n\n    #[inline]\n    fn visit_none\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(None)\n    }\n\n    #[inline]\n    fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(deserializer).map(Some)\n    }\n\n    #[doc(hidden)]\n    fn __private_visit_untagged_option\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, ()\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Ok(T::deserialize(deserializer).ok())\n    }\n}\n\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Option\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_option(OptionVisitor {\n            marker: PhantomData,\n        })\n    }\n\n    // The Some variant's repr is opaque, so we can't play cute tricks with its\n    // tag to have deserialize_in_place build the content in place unconditionally.\n    //\n    // FIXME: investigate whether branching on the old value being Some to\n    // deserialize_in_place the value is profitable (probably data-dependent?)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct PhantomDataVisitor\u003cT: ?Sized\u003e {\n    marker: PhantomData\u003cT\u003e,\n}\n\nimpl\u003c'de, T: ?Sized\u003e Visitor\u003c'de\u003e for PhantomDataVisitor\u003cT\u003e {\n    type Value = PhantomData\u003cT\u003e;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"unit\")\n    }\n\n    #[inline]\n    fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(PhantomData)\n    }\n}\n\nimpl\u003c'de, T: ?Sized\u003e Deserialize\u003c'de\u003e for PhantomData\u003cT\u003e {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let visitor = PhantomDataVisitor {\n            marker: PhantomData,\n        };\n        deserializer.deserialize_unit_struct(\"PhantomData\", visitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! seq_impl {\n    (\n        $ty:ident \u003c T $(: $tbound1:ident $(+ $tbound2:ident)*)* $(, $typaram:ident : $bound1:ident $(+ $bound2:ident)*)* \u003e,\n        $access:ident,\n        $clear:expr,\n        $with_capacity:expr,\n        $reserve:expr,\n        $insert:expr\n    ) =\u003e {\n        impl\u003c'de, T $(, $typaram)*\u003e Deserialize\u003c'de\u003e for $ty\u003cT $(, $typaram)*\u003e\n        where\n            T: Deserialize\u003c'de\u003e $(+ $tbound1 $(+ $tbound2)*)*,\n            $($typaram: $bound1 $(+ $bound2)*,)*\n        {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct SeqVisitor\u003cT $(, $typaram)*\u003e {\n                    marker: PhantomData\u003c$ty\u003cT $(, $typaram)*\u003e\u003e,\n                }\n\n                impl\u003c'de, T $(, $typaram)*\u003e Visitor\u003c'de\u003e for SeqVisitor\u003cT $(, $typaram)*\u003e\n                where\n                    T: Deserialize\u003c'de\u003e $(+ $tbound1 $(+ $tbound2)*)*,\n                    $($typaram: $bound1 $(+ $bound2)*,)*\n                {\n                    type Value = $ty\u003cT $(, $typaram)*\u003e;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"a sequence\")\n                    }\n\n                    #[inline]\n                    fn visit_seq\u003cA\u003e(self, mut $access: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                    where\n                        A: SeqAccess\u003c'de\u003e,\n                    {\n                        let mut values = $with_capacity;\n\n                        while let Some(value) = try!($access.next_element()) {\n                            $insert(\u0026mut values, value);\n                        }\n\n                        Ok(values)\n                    }\n                }\n\n                let visitor = SeqVisitor { marker: PhantomData };\n                deserializer.deserialize_seq(visitor)\n            }\n\n            fn deserialize_in_place\u003cD\u003e(deserializer: D, place: \u0026mut Self) -\u003e Result\u003c(), D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct SeqInPlaceVisitor\u003c'a, T: 'a $(, $typaram: 'a)*\u003e(\u0026'a mut $ty\u003cT $(, $typaram)*\u003e);\n\n                impl\u003c'a, 'de, T $(, $typaram)*\u003e Visitor\u003c'de\u003e for SeqInPlaceVisitor\u003c'a, T $(, $typaram)*\u003e\n                where\n                    T: Deserialize\u003c'de\u003e $(+ $tbound1 $(+ $tbound2)*)*,\n                    $($typaram: $bound1 $(+ $bound2)*,)*\n                {\n                    type Value = ();\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"a sequence\")\n                    }\n\n                    #[inline]\n                    fn visit_seq\u003cA\u003e(mut self, mut $access: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                    where\n                        A: SeqAccess\u003c'de\u003e,\n                    {\n                        $clear(\u0026mut self.0);\n                        $reserve(\u0026mut self.0, size_hint::cautious($access.size_hint()));\n\n                        // FIXME: try to overwrite old values here? (Vec, VecDeque, LinkedList)\n                        while let Some(value) = try!($access.next_element()) {\n                            $insert(\u0026mut self.0, value);\n                        }\n\n                        Ok(())\n                    }\n                }\n\n                deserializer.deserialize_seq(SeqInPlaceVisitor(place))\n            }\n        }\n    }\n}\n\n// Dummy impl of reserve\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nfn nop_reserve\u003cT\u003e(_seq: T, _n: usize) {}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(\n    BinaryHeap\u003cT: Ord\u003e,\n    seq,\n    BinaryHeap::clear,\n    BinaryHeap::with_capacity(size_hint::cautious(seq.size_hint())),\n    BinaryHeap::reserve,\n    BinaryHeap::push\n);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(\n    BTreeSet\u003cT: Eq + Ord\u003e,\n    seq,\n    BTreeSet::clear,\n    BTreeSet::new(),\n    nop_reserve,\n    BTreeSet::insert\n);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(\n    LinkedList\u003cT\u003e,\n    seq,\n    LinkedList::clear,\n    LinkedList::new(),\n    nop_reserve,\n    LinkedList::push_back\n);\n\n#[cfg(feature = \"std\")]\nseq_impl!(\n    HashSet\u003cT: Eq + Hash, S: BuildHasher + Default\u003e,\n    seq,\n    HashSet::clear,\n    HashSet::with_capacity_and_hasher(size_hint::cautious(seq.size_hint()), S::default()),\n    HashSet::reserve,\n    HashSet::insert);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(\n    VecDeque\u003cT\u003e,\n    seq,\n    VecDeque::clear,\n    VecDeque::with_capacity(size_hint::cautious(seq.size_hint())),\n    VecDeque::reserve,\n    VecDeque::push_back\n);\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Vec\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        struct VecVisitor\u003cT\u003e {\n            marker: PhantomData\u003cT\u003e,\n        }\n\n        impl\u003c'de, T\u003e Visitor\u003c'de\u003e for VecVisitor\u003cT\u003e\n        where\n            T: Deserialize\u003c'de\u003e,\n        {\n            type Value = Vec\u003cT\u003e;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"a sequence\")\n            }\n\n            fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: SeqAccess\u003c'de\u003e,\n            {\n                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));\n\n                while let Some(value) = try!(seq.next_element()) {\n                    values.push(value);\n                }\n\n                Ok(values)\n            }\n        }\n\n        let visitor = VecVisitor {\n            marker: PhantomData,\n        };\n        deserializer.deserialize_seq(visitor)\n    }\n\n    fn deserialize_in_place\u003cD\u003e(deserializer: D, place: \u0026mut Self) -\u003e Result\u003c(), D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        struct VecInPlaceVisitor\u003c'a, T: 'a\u003e(\u0026'a mut Vec\u003cT\u003e);\n\n        impl\u003c'a, 'de, T\u003e Visitor\u003c'de\u003e for VecInPlaceVisitor\u003c'a, T\u003e\n        where\n            T: Deserialize\u003c'de\u003e,\n        {\n            type Value = ();\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"a sequence\")\n            }\n\n            fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: SeqAccess\u003c'de\u003e,\n            {\n                let hint = size_hint::cautious(seq.size_hint());\n                if let Some(additional) = hint.checked_sub(self.0.len()) {\n                    self.0.reserve(additional);\n                }\n\n                for i in 0..self.0.len() {\n                    let next = {\n                        let next_place = InPlaceSeed(\u0026mut self.0[i]);\n                        try!(seq.next_element_seed(next_place))\n                    };\n                    if next.is_none() {\n                        self.0.truncate(i);\n                        return Ok(());\n                    }\n                }\n\n                while let Some(value) = try!(seq.next_element()) {\n                    self.0.push(value);\n                }\n\n                Ok(())\n            }\n        }\n\n        deserializer.deserialize_seq(VecInPlaceVisitor(place))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct ArrayVisitor\u003cA\u003e {\n    marker: PhantomData\u003cA\u003e,\n}\nstruct ArrayInPlaceVisitor\u003c'a, A: 'a\u003e(\u0026'a mut A);\n\nimpl\u003cA\u003e ArrayVisitor\u003cA\u003e {\n    fn new() -\u003e Self {\n        ArrayVisitor {\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, T\u003e Visitor\u003c'de\u003e for ArrayVisitor\u003c[T; 0]\u003e {\n    type Value = [T; 0];\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"an empty array\")\n    }\n\n    #[inline]\n    fn visit_seq\u003cA\u003e(self, _: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: SeqAccess\u003c'de\u003e,\n    {\n        Ok([])\n    }\n}\n\n// Does not require T: Deserialize\u003c'de\u003e.\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for [T; 0] {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_tuple(0, ArrayVisitor::\u003c[T; 0]\u003e::new())\n    }\n}\n\nmacro_rules! array_impls {\n    ($($len:expr =\u003e ($($n:tt)+))+) =\u003e {\n        $(\n            impl\u003c'de, T\u003e Visitor\u003c'de\u003e for ArrayVisitor\u003c[T; $len]\u003e\n            where\n                T: Deserialize\u003c'de\u003e,\n            {\n                type Value = [T; $len];\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(concat!(\"an array of length \", $len))\n                }\n\n                #[inline]\n                fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                where\n                    A: SeqAccess\u003c'de\u003e,\n                {\n                    Ok([$(\n                        match try!(seq.next_element()) {\n                            Some(val) =\u003e val,\n                            None =\u003e return Err(Error::invalid_length($n, \u0026self)),\n                        }\n                    ),+])\n                }\n            }\n\n            impl\u003c'a, 'de, T\u003e Visitor\u003c'de\u003e for ArrayInPlaceVisitor\u003c'a, [T; $len]\u003e\n            where\n                T: Deserialize\u003c'de\u003e,\n            {\n                type Value = ();\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(concat!(\"an array of length \", $len))\n                }\n\n                #[inline]\n                fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                where\n                    A: SeqAccess\u003c'de\u003e,\n                {\n                    let mut fail_idx = None;\n                    for (idx, dest) in self.0[..].iter_mut().enumerate() {\n                        if try!(seq.next_element_seed(InPlaceSeed(dest))).is_none() {\n                            fail_idx = Some(idx);\n                            break;\n                        }\n                    }\n                    if let Some(idx) = fail_idx {\n                        return Err(Error::invalid_length(idx, \u0026self));\n                    }\n                    Ok(())\n                }\n            }\n\n            impl\u003c'de, T\u003e Deserialize\u003c'de\u003e for [T; $len]\n            where\n                T: Deserialize\u003c'de\u003e,\n            {\n                fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n                where\n                    D: Deserializer\u003c'de\u003e,\n                {\n                    deserializer.deserialize_tuple($len, ArrayVisitor::\u003c[T; $len]\u003e::new())\n                }\n\n                fn deserialize_in_place\u003cD\u003e(deserializer: D, place: \u0026mut Self) -\u003e Result\u003c(), D::Error\u003e\n                where\n                    D: Deserializer\u003c'de\u003e,\n                {\n                    deserializer.deserialize_tuple($len, ArrayInPlaceVisitor(place))\n                }\n            }\n        )+\n    }\n}\n\narray_impls! {\n    1 =\u003e (0)\n    2 =\u003e (0 1)\n    3 =\u003e (0 1 2)\n    4 =\u003e (0 1 2 3)\n    5 =\u003e (0 1 2 3 4)\n    6 =\u003e (0 1 2 3 4 5)\n    7 =\u003e (0 1 2 3 4 5 6)\n    8 =\u003e (0 1 2 3 4 5 6 7)\n    9 =\u003e (0 1 2 3 4 5 6 7 8)\n    10 =\u003e (0 1 2 3 4 5 6 7 8 9)\n    11 =\u003e (0 1 2 3 4 5 6 7 8 9 10)\n    12 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11)\n    13 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12)\n    14 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13)\n    15 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14)\n    16 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)\n    17 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16)\n    18 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17)\n    19 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18)\n    20 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19)\n    21 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)\n    22 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21)\n    23 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22)\n    24 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23)\n    25 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24)\n    26 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25)\n    27 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26)\n    28 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27)\n    29 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28)\n    30 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29)\n    31 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)\n    32 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! tuple_impls {\n    ($($len:tt =\u003e ($($n:tt $name:ident)+))+) =\u003e {\n        $(\n            impl\u003c'de, $($name: Deserialize\u003c'de\u003e),+\u003e Deserialize\u003c'de\u003e for ($($name,)+) {\n                #[inline]\n                fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n                where\n                    D: Deserializer\u003c'de\u003e,\n                {\n                    struct TupleVisitor\u003c$($name,)+\u003e {\n                        marker: PhantomData\u003c($($name,)+)\u003e,\n                    }\n\n                    impl\u003c'de, $($name: Deserialize\u003c'de\u003e),+\u003e Visitor\u003c'de\u003e for TupleVisitor\u003c$($name,)+\u003e {\n                        type Value = ($($name,)+);\n\n                        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                            formatter.write_str(concat!(\"a tuple of size \", $len))\n                        }\n\n                        #[inline]\n                        #[allow(non_snake_case)]\n                        fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                        where\n                            A: SeqAccess\u003c'de\u003e,\n                        {\n                            $(\n                                let $name = match try!(seq.next_element()) {\n                                    Some(value) =\u003e value,\n                                    None =\u003e return Err(Error::invalid_length($n, \u0026self)),\n                                };\n                            )+\n\n                            Ok(($($name,)+))\n                        }\n                    }\n\n                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })\n                }\n\n                #[inline]\n                fn deserialize_in_place\u003cD\u003e(deserializer: D, place: \u0026mut Self) -\u003e Result\u003c(), D::Error\u003e\n                where\n                    D: Deserializer\u003c'de\u003e,\n                {\n                    struct TupleInPlaceVisitor\u003c'a, $($name: 'a,)+\u003e(\u0026'a mut ($($name,)+));\n\n                    impl\u003c'a, 'de, $($name: Deserialize\u003c'de\u003e),+\u003e Visitor\u003c'de\u003e for TupleInPlaceVisitor\u003c'a, $($name,)+\u003e {\n                        type Value = ();\n\n                        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                            formatter.write_str(concat!(\"a tuple of size \", $len))\n                        }\n\n                        #[inline]\n                        #[allow(non_snake_case)]\n                        fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                        where\n                            A: SeqAccess\u003c'de\u003e,\n                        {\n                            $(\n                                if try!(seq.next_element_seed(InPlaceSeed(\u0026mut (self.0).$n))).is_none() {\n                                    return Err(Error::invalid_length($n, \u0026self));\n                                }\n                            )+\n\n                            Ok(())\n                        }\n                    }\n\n                    deserializer.deserialize_tuple($len, TupleInPlaceVisitor(place))\n                }\n            }\n        )+\n    }\n}\n\ntuple_impls! {\n    1  =\u003e (0 T0)\n    2  =\u003e (0 T0 1 T1)\n    3  =\u003e (0 T0 1 T1 2 T2)\n    4  =\u003e (0 T0 1 T1 2 T2 3 T3)\n    5  =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4)\n    6  =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5)\n    7  =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6)\n    8  =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7)\n    9  =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8)\n    10 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9)\n    11 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10)\n    12 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11)\n    13 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12)\n    14 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13)\n    15 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14)\n    16 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! map_impl {\n    (\n        $ty:ident \u003c K $(: $kbound1:ident $(+ $kbound2:ident)*)*, V $(, $typaram:ident : $bound1:ident $(+ $bound2:ident)*)* \u003e,\n        $access:ident,\n        $with_capacity:expr\n    ) =\u003e {\n        impl\u003c'de, K, V $(, $typaram)*\u003e Deserialize\u003c'de\u003e for $ty\u003cK, V $(, $typaram)*\u003e\n        where\n            K: Deserialize\u003c'de\u003e $(+ $kbound1 $(+ $kbound2)*)*,\n            V: Deserialize\u003c'de\u003e,\n            $($typaram: $bound1 $(+ $bound2)*),*\n        {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct MapVisitor\u003cK, V $(, $typaram)*\u003e {\n                    marker: PhantomData\u003c$ty\u003cK, V $(, $typaram)*\u003e\u003e,\n                }\n\n                impl\u003c'de, K, V $(, $typaram)*\u003e Visitor\u003c'de\u003e for MapVisitor\u003cK, V $(, $typaram)*\u003e\n                where\n                    K: Deserialize\u003c'de\u003e $(+ $kbound1 $(+ $kbound2)*)*,\n                    V: Deserialize\u003c'de\u003e,\n                    $($typaram: $bound1 $(+ $bound2)*),*\n                {\n                    type Value = $ty\u003cK, V $(, $typaram)*\u003e;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"a map\")\n                    }\n\n                    #[inline]\n                    fn visit_map\u003cA\u003e(self, mut $access: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                    where\n                        A: MapAccess\u003c'de\u003e,\n                    {\n                        let mut values = $with_capacity;\n\n                        while let Some((key, value)) = try!($access.next_entry()) {\n                            values.insert(key, value);\n                        }\n\n                        Ok(values)\n                    }\n                }\n\n                let visitor = MapVisitor { marker: PhantomData };\n                deserializer.deserialize_map(visitor)\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmap_impl!(\n    BTreeMap\u003cK: Ord, V\u003e,\n    map,\n    BTreeMap::new());\n\n#[cfg(feature = \"std\")]\nmap_impl!(\n    HashMap\u003cK: Eq + Hash, V, S: BuildHasher + Default\u003e,\n    map,\n    HashMap::with_capacity_and_hasher(size_hint::cautious(map.size_hint()), S::default()));\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nmacro_rules! parse_ip_impl {\n    ($expecting:tt $ty:ty; $size:tt) =\u003e {\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for $ty {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                if deserializer.is_human_readable() {\n                    struct IpAddrVisitor;\n\n                    impl\u003c'de\u003e Visitor\u003c'de\u003e for IpAddrVisitor {\n                        type Value = $ty;\n\n                        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                            formatter.write_str($expecting)\n                        }\n\n                        fn visit_str\u003cE\u003e(self, s: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                        where\n                            E: Error,\n                        {\n                            s.parse().map_err(Error::custom)\n                        }\n                    }\n\n                    deserializer.deserialize_str(IpAddrVisitor)\n                } else {\n                    \u003c[u8; $size]\u003e::deserialize(deserializer).map(\u003c$ty\u003e::from)\n                }\n            }\n        }\n    };\n}\n\n#[cfg(feature = \"std\")]\nmacro_rules! variant_identifier {\n    (\n        $name_kind: ident ( $($variant: ident; $bytes: expr; $index: expr),* )\n        $expecting_message: expr,\n        $variants_name: ident\n    ) =\u003e {\n        enum $name_kind {\n            $( $variant ),*\n        }\n\n        static $variants_name: \u0026'static [\u0026'static str] = \u0026[ $( stringify!($variant) ),*];\n\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for $name_kind {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct KindVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for KindVisitor {\n                    type Value = $name_kind;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str($expecting_message)\n                    }\n\n                    fn visit_u32\u003cE\u003e(self, value: u32) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            $(\n                                $index =\u003e Ok($name_kind :: $variant),\n                            )*\n                            _ =\u003e Err(Error::invalid_value(Unexpected::Unsigned(value as u64), \u0026self),),\n                        }\n                    }\n\n                    fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            $(\n                                stringify!($variant) =\u003e Ok($name_kind :: $variant),\n                            )*\n                            _ =\u003e Err(Error::unknown_variant(value, $variants_name)),\n                        }\n                    }\n\n                    fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            $(\n                                $bytes =\u003e Ok($name_kind :: $variant),\n                            )*\n                            _ =\u003e {\n                                match str::from_utf8(value) {\n                                    Ok(value) =\u003e Err(Error::unknown_variant(value, $variants_name)),\n                                    Err(_) =\u003e Err(Error::invalid_value(Unexpected::Bytes(value), \u0026self)),\n                                }\n                            }\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(KindVisitor)\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nmacro_rules! deserialize_enum {\n    (\n        $name: ident $name_kind: ident ( $($variant: ident; $bytes: expr; $index: expr),* )\n        $expecting_message: expr,\n        $deserializer: expr\n    ) =\u003e {\n        variant_identifier!{\n            $name_kind ( $($variant; $bytes; $index),* )\n            $expecting_message,\n            VARIANTS\n        }\n\n        struct EnumVisitor;\n        impl\u003c'de\u003e Visitor\u003c'de\u003e for EnumVisitor {\n            type Value = $name;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(concat!(\"a \", stringify!($name)))\n            }\n\n\n            fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: EnumAccess\u003c'de\u003e,\n            {\n                match try!(data.variant()) {\n                    $(\n                        ($name_kind :: $variant, v) =\u003e v.newtype_variant().map($name :: $variant),\n                    )*\n                }\n            }\n        }\n        $deserializer.deserialize_enum(stringify!($name), VARIANTS, EnumVisitor)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for net::IpAddr {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        if deserializer.is_human_readable() {\n            struct IpAddrVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for IpAddrVisitor {\n                type Value = net::IpAddr;\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(\"IP address\")\n                }\n\n                fn visit_str\u003cE\u003e(self, s: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    s.parse().map_err(Error::custom)\n                }\n            }\n\n            deserializer.deserialize_str(IpAddrVisitor)\n        } else {\n            use lib::net::IpAddr;\n            deserialize_enum! {\n                IpAddr IpAddrKind (V4; b\"V4\"; 0, V6; b\"V6\"; 1)\n                \"`V4` or `V6`\",\n                deserializer\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nparse_ip_impl!(\"IPv4 address\" net::Ipv4Addr; 4);\n\n#[cfg(feature = \"std\")]\nparse_ip_impl!(\"IPv6 address\" net::Ipv6Addr; 16);\n\n#[cfg(feature = \"std\")]\nmacro_rules! parse_socket_impl {\n    ($expecting:tt $ty:ty, $new:expr) =\u003e {\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for $ty {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                if deserializer.is_human_readable() {\n                    struct SocketAddrVisitor;\n\n                    impl\u003c'de\u003e Visitor\u003c'de\u003e for SocketAddrVisitor {\n                        type Value = $ty;\n\n                        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                            formatter.write_str($expecting)\n                        }\n\n                        fn visit_str\u003cE\u003e(self, s: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                        where\n                            E: Error,\n                        {\n                            s.parse().map_err(Error::custom)\n                        }\n                    }\n\n                    deserializer.deserialize_str(SocketAddrVisitor)\n                } else {\n                    \u003c(_, u16)\u003e::deserialize(deserializer).map(|(ip, port)| $new(ip, port))\n                }\n            }\n        }\n    };\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for net::SocketAddr {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        if deserializer.is_human_readable() {\n            struct SocketAddrVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for SocketAddrVisitor {\n                type Value = net::SocketAddr;\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(\"socket address\")\n                }\n\n                fn visit_str\u003cE\u003e(self, s: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    s.parse().map_err(Error::custom)\n                }\n            }\n\n            deserializer.deserialize_str(SocketAddrVisitor)\n        } else {\n            use lib::net::SocketAddr;\n            deserialize_enum! {\n                SocketAddr SocketAddrKind (V4; b\"V4\"; 0, V6; b\"V6\"; 1)\n                \"`V4` or `V6`\",\n                deserializer\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nparse_socket_impl!(\"IPv4 socket address\" net::SocketAddrV4, net::SocketAddrV4::new);\n\n#[cfg(feature = \"std\")]\nparse_socket_impl!(\"IPv6 socket address\" net::SocketAddrV6, |ip, port| net::SocketAddrV6::new(\n    ip, port, 0, 0\n));\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nstruct PathVisitor;\n\n#[cfg(feature = \"std\")]\nimpl\u003c'a\u003e Visitor\u003c'a\u003e for PathVisitor {\n    type Value = \u0026'a Path;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a borrowed path\")\n    }\n\n    fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'a str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v.as_ref())\n    }\n\n    fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'a [u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        str::from_utf8(v)\n            .map(AsRef::as_ref)\n            .map_err(|_| Error::invalid_value(Unexpected::Bytes(v), \u0026self))\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de: 'a, 'a\u003e Deserialize\u003c'de\u003e for \u0026'a Path {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(PathVisitor)\n    }\n}\n\n#[cfg(feature = \"std\")]\nstruct PathBufVisitor;\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for PathBufVisitor {\n    type Value = PathBuf;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"path string\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(From::from(v))\n    }\n\n    fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(From::from(v))\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for PathBuf {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_string(PathBufVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// If this were outside of the serde crate, it would just use:\n//\n//    #[derive(Deserialize)]\n//    #[serde(variant_identifier)]\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nvariant_identifier! {\n    OsStringKind (Unix; b\"Unix\"; 0, Windows; b\"Windows\"; 1)\n    \"`Unix` or `Windows`\",\n    OSSTR_VARIANTS\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nstruct OsStringVisitor;\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for OsStringVisitor {\n    type Value = OsString;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"os string\")\n    }\n\n    #[cfg(unix)]\n    fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: EnumAccess\u003c'de\u003e,\n    {\n        use std::os::unix::ffi::OsStringExt;\n\n        match try!(data.variant()) {\n            (OsStringKind::Unix, v) =\u003e v.newtype_variant().map(OsString::from_vec),\n            (OsStringKind::Windows, _) =\u003e Err(Error::custom(\n                \"cannot deserialize Windows OS string on Unix\",\n            )),\n        }\n    }\n\n    #[cfg(windows)]\n    fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: EnumAccess\u003c'de\u003e,\n    {\n        use std::os::windows::ffi::OsStringExt;\n\n        match try!(data.variant()) {\n            (OsStringKind::Windows, v) =\u003e v\n                .newtype_variant::\u003cVec\u003cu16\u003e\u003e()\n                .map(|vec| OsString::from_wide(\u0026vec)),\n            (OsStringKind::Unix, _) =\u003e Err(Error::custom(\n                \"cannot deserialize Unix OS string on Windows\",\n            )),\n        }\n    }\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for OsString {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_enum(\"OsString\", OSSTR_VARIANTS, OsStringVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nforwarded_impl!((T), Box\u003cT\u003e, Box::new);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nforwarded_impl!((T), Box\u003c[T]\u003e, Vec::into_boxed_slice);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nforwarded_impl!((), Box\u003cstr\u003e, String::into_boxed_str);\n\n#[cfg(all(\n    not(de_rc_dst),\n    feature = \"rc\",\n    any(feature = \"std\", feature = \"alloc\")\n))]\nforwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Arc` will not attempt to\n    /// deduplicate `Arc` references to the same data. Every deserialized `Arc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    (T), Arc\u003cT\u003e, Arc::new\n}\n\n#[cfg(all(\n    not(de_rc_dst),\n    feature = \"rc\",\n    any(feature = \"std\", feature = \"alloc\")\n))]\nforwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Rc` will not attempt to\n    /// deduplicate `Rc` references to the same data. Every deserialized `Rc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    (T), Rc\u003cT\u003e, Rc::new\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, 'a, T: ?Sized\u003e Deserialize\u003c'de\u003e for Cow\u003c'a, T\u003e\nwhere\n    T: ToOwned,\n    T::Owned: Deserialize\u003c'de\u003e,\n{\n    #[inline]\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::Owned::deserialize(deserializer).map(Cow::Owned)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde. The resulting\n/// `Weak\u003cT\u003e` has a reference count of 0 and cannot be upgraded.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nimpl\u003c'de, T: ?Sized\u003e Deserialize\u003c'de\u003e for RcWeak\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        try!(Option::\u003cT\u003e::deserialize(deserializer));\n        Ok(RcWeak::new())\n    }\n}\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde. The resulting\n/// `Weak\u003cT\u003e` has a reference count of 0 and cannot be upgraded.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nimpl\u003c'de, T: ?Sized\u003e Deserialize\u003c'de\u003e for ArcWeak\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        try!(Option::\u003cT\u003e::deserialize(deserializer));\n        Ok(ArcWeak::new())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(all(de_rc_dst, feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nmacro_rules! box_forwarded_impl {\n    (\n        $(#[doc = $doc:tt])*\n        $t:ident\n    ) =\u003e {\n        $(#[doc = $doc])*\n        impl\u003c'de, T: ?Sized\u003e Deserialize\u003c'de\u003e for $t\u003cT\u003e\n        where\n            Box\u003cT\u003e: Deserialize\u003c'de\u003e,\n        {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                Box::deserialize(deserializer).map(Into::into)\n            }\n        }\n    };\n}\n\n#[cfg(all(de_rc_dst, feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nbox_forwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Rc` will not attempt to\n    /// deduplicate `Rc` references to the same data. Every deserialized `Rc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    Rc\n}\n\n#[cfg(all(de_rc_dst, feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nbox_forwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Arc` will not attempt to\n    /// deduplicate `Arc` references to the same data. Every deserialized `Arc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    Arc\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Cell\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e + Copy,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(deserializer).map(Cell::new)\n    }\n}\n\nforwarded_impl!((T), RefCell\u003cT\u003e, RefCell::new);\n\n#[cfg(feature = \"std\")]\nforwarded_impl!((T), Mutex\u003cT\u003e, Mutex::new);\n\n#[cfg(feature = \"std\")]\nforwarded_impl!((T), RwLock\u003cT\u003e, RwLock::new);\n\n////////////////////////////////////////////////////////////////////////////////\n\n// This is a cleaned-up version of the impl generated by:\n//\n//     #[derive(Deserialize)]\n//     #[serde(deny_unknown_fields)]\n//     struct Duration {\n//         secs: u64,\n//         nanos: u32,\n//     }\n#[cfg(any(core_duration, feature = \"std\"))]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Duration {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        // If this were outside of the serde crate, it would just use:\n        //\n        //    #[derive(Deserialize)]\n        //    #[serde(field_identifier, rename_all = \"lowercase\")]\n        enum Field {\n            Secs,\n            Nanos,\n        };\n\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for Field {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct FieldVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"`secs` or `nanos`\")\n                    }\n\n                    fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"secs\" =\u003e Ok(Field::Secs),\n                            \"nanos\" =\u003e Ok(Field::Nanos),\n                            _ =\u003e Err(Error::unknown_field(value, FIELDS)),\n                        }\n                    }\n\n                    fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"secs\" =\u003e Ok(Field::Secs),\n                            b\"nanos\" =\u003e Ok(Field::Nanos),\n                            _ =\u003e {\n                                let value = ::export::from_utf8_lossy(value);\n                                Err(Error::unknown_field(\u0026value, FIELDS))\n                            }\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct DurationVisitor;\n\n        impl\u003c'de\u003e Visitor\u003c'de\u003e for DurationVisitor {\n            type Value = Duration;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"struct Duration\")\n            }\n\n            fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: SeqAccess\u003c'de\u003e,\n            {\n                let secs: u64 = match try!(seq.next_element()) {\n                    Some(value) =\u003e value,\n                    None =\u003e {\n                        return Err(Error::invalid_length(0, \u0026self));\n                    }\n                };\n                let nanos: u32 = match try!(seq.next_element()) {\n                    Some(value) =\u003e value,\n                    None =\u003e {\n                        return Err(Error::invalid_length(1, \u0026self));\n                    }\n                };\n                Ok(Duration::new(secs, nanos))\n            }\n\n            fn visit_map\u003cA\u003e(self, mut map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: MapAccess\u003c'de\u003e,\n            {\n                let mut secs: Option\u003cu64\u003e = None;\n                let mut nanos: Option\u003cu32\u003e = None;\n                while let Some(key) = try!(map.next_key()) {\n                    match key {\n                        Field::Secs =\u003e {\n                            if secs.is_some() {\n                                return Err(\u003cA::Error as Error\u003e::duplicate_field(\"secs\"));\n                            }\n                            secs = Some(try!(map.next_value()));\n                        }\n                        Field::Nanos =\u003e {\n                            if nanos.is_some() {\n                                return Err(\u003cA::Error as Error\u003e::duplicate_field(\"nanos\"));\n                            }\n                            nanos = Some(try!(map.next_value()));\n                        }\n                    }\n                }\n                let secs = match secs {\n                    Some(secs) =\u003e secs,\n                    None =\u003e return Err(\u003cA::Error as Error\u003e::missing_field(\"secs\")),\n                };\n                let nanos = match nanos {\n                    Some(nanos) =\u003e nanos,\n                    None =\u003e return Err(\u003cA::Error as Error\u003e::missing_field(\"nanos\")),\n                };\n                Ok(Duration::new(secs, nanos))\n            }\n        }\n\n        const FIELDS: \u0026'static [\u0026'static str] = \u0026[\"secs\", \"nanos\"];\n        deserializer.deserialize_struct(\"Duration\", FIELDS, DurationVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for SystemTime {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        // Reuse duration\n        enum Field {\n            Secs,\n            Nanos,\n        };\n\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for Field {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct FieldVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"`secs_since_epoch` or `nanos_since_epoch`\")\n                    }\n\n                    fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"secs_since_epoch\" =\u003e Ok(Field::Secs),\n                            \"nanos_since_epoch\" =\u003e Ok(Field::Nanos),\n                            _ =\u003e Err(Error::unknown_field(value, FIELDS)),\n                        }\n                    }\n\n                    fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"secs_since_epoch\" =\u003e Ok(Field::Secs),\n                            b\"nanos_since_epoch\" =\u003e Ok(Field::Nanos),\n                            _ =\u003e {\n                                let value = String::from_utf8_lossy(value);\n                                Err(Error::unknown_field(\u0026value, FIELDS))\n                            }\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct DurationVisitor;\n\n        impl\u003c'de\u003e Visitor\u003c'de\u003e for DurationVisitor {\n            type Value = Duration;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"struct SystemTime\")\n            }\n\n            fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: SeqAccess\u003c'de\u003e,\n            {\n                let secs: u64 = match try!(seq.next_element()) {\n                    Some(value) =\u003e value,\n                    None =\u003e {\n                        return Err(Error::invalid_length(0, \u0026self));\n                    }\n                };\n                let nanos: u32 = match try!(seq.next_element()) {\n                    Some(value) =\u003e value,\n                    None =\u003e {\n                        return Err(Error::invalid_length(1, \u0026self));\n                    }\n                };\n                Ok(Duration::new(secs, nanos))\n            }\n\n            fn visit_map\u003cA\u003e(self, mut map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: MapAccess\u003c'de\u003e,\n            {\n                let mut secs: Option\u003cu64\u003e = None;\n                let mut nanos: Option\u003cu32\u003e = None;\n                while let Some(key) = try!(map.next_key()) {\n                    match key {\n                        Field::Secs =\u003e {\n                            if secs.is_some() {\n                                return Err(\u003cA::Error as Error\u003e::duplicate_field(\n                                    \"secs_since_epoch\",\n                                ));\n                            }\n                            secs = Some(try!(map.next_value()));\n                        }\n                        Field::Nanos =\u003e {\n                            if nanos.is_some() {\n                                return Err(\u003cA::Error as Error\u003e::duplicate_field(\n                                    \"nanos_since_epoch\",\n                                ));\n                            }\n                            nanos = Some(try!(map.next_value()));\n                        }\n                    }\n                }\n                let secs = match secs {\n                    Some(secs) =\u003e secs,\n                    None =\u003e return Err(\u003cA::Error as Error\u003e::missing_field(\"secs_since_epoch\")),\n                };\n                let nanos = match nanos {\n                    Some(nanos) =\u003e nanos,\n                    None =\u003e return Err(\u003cA::Error as Error\u003e::missing_field(\"nanos_since_epoch\")),\n                };\n                Ok(Duration::new(secs, nanos))\n            }\n        }\n\n        const FIELDS: \u0026'static [\u0026'static str] = \u0026[\"secs_since_epoch\", \"nanos_since_epoch\"];\n        let duration = try!(deserializer.deserialize_struct(\"SystemTime\", FIELDS, DurationVisitor));\n        Ok(UNIX_EPOCH + duration)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Similar to:\n//\n//     #[derive(Deserialize)]\n//     #[serde(deny_unknown_fields)]\n//     struct Range {\n//         start: u64,\n//         end: u32,\n//     }\nimpl\u003c'de, Idx\u003e Deserialize\u003c'de\u003e for Range\u003cIdx\u003e\nwhere\n    Idx: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let (start, end) = deserializer.deserialize_struct(\n            \"Range\",\n            range::FIELDS,\n            range::RangeVisitor {\n                expecting: \"struct Range\",\n                phantom: PhantomData,\n            },\n        )?;\n        Ok(start..end)\n    }\n}\n\n#[cfg(range_inclusive)]\nimpl\u003c'de, Idx\u003e Deserialize\u003c'de\u003e for RangeInclusive\u003cIdx\u003e\nwhere\n    Idx: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let (start, end) = deserializer.deserialize_struct(\n            \"RangeInclusive\",\n            range::FIELDS,\n            range::RangeVisitor {\n                expecting: \"struct RangeInclusive\",\n                phantom: PhantomData,\n            },\n        )?;\n        Ok(RangeInclusive::new(start, end))\n    }\n}\n\nmod range {\n    use lib::*;\n\n    use de::{Deserialize, Deserializer, Error, MapAccess, SeqAccess, Visitor};\n\n    pub const FIELDS: \u0026'static [\u0026'static str] = \u0026[\"start\", \"end\"];\n\n    // If this were outside of the serde crate, it would just use:\n    //\n    //    #[derive(Deserialize)]\n    //    #[serde(field_identifier, rename_all = \"lowercase\")]\n    enum Field {\n        Start,\n        End,\n    }\n\n    impl\u003c'de\u003e Deserialize\u003c'de\u003e for Field {\n        fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            struct FieldVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for FieldVisitor {\n                type Value = Field;\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(\"`start` or `end`\")\n                }\n\n                fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    match value {\n                        \"start\" =\u003e Ok(Field::Start),\n                        \"end\" =\u003e Ok(Field::End),\n                        _ =\u003e Err(Error::unknown_field(value, FIELDS)),\n                    }\n                }\n\n                fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    match value {\n                        b\"start\" =\u003e Ok(Field::Start),\n                        b\"end\" =\u003e Ok(Field::End),\n                        _ =\u003e {\n                            let value = ::export::from_utf8_lossy(value);\n                            Err(Error::unknown_field(\u0026value, FIELDS))\n                        }\n                    }\n                }\n            }\n\n            deserializer.deserialize_identifier(FieldVisitor)\n        }\n    }\n\n    pub struct RangeVisitor\u003cIdx\u003e {\n        pub expecting: \u0026'static str,\n        pub phantom: PhantomData\u003cIdx\u003e,\n    }\n\n    impl\u003c'de, Idx\u003e Visitor\u003c'de\u003e for RangeVisitor\u003cIdx\u003e\n    where\n        Idx: Deserialize\u003c'de\u003e,\n    {\n        type Value = (Idx, Idx);\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            formatter.write_str(self.expecting)\n        }\n\n        fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n        where\n            A: SeqAccess\u003c'de\u003e,\n        {\n            let start: Idx = match try!(seq.next_element()) {\n                Some(value) =\u003e value,\n                None =\u003e {\n                    return Err(Error::invalid_length(0, \u0026self));\n                }\n            };\n            let end: Idx = match try!(seq.next_element()) {\n                Some(value) =\u003e value,\n                None =\u003e {\n                    return Err(Error::invalid_length(1, \u0026self));\n                }\n            };\n            Ok((start, end))\n        }\n\n        fn visit_map\u003cA\u003e(self, mut map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n        where\n            A: MapAccess\u003c'de\u003e,\n        {\n            let mut start: Option\u003cIdx\u003e = None;\n            let mut end: Option\u003cIdx\u003e = None;\n            while let Some(key) = try!(map.next_key()) {\n                match key {\n                    Field::Start =\u003e {\n                        if start.is_some() {\n                            return Err(\u003cA::Error as Error\u003e::duplicate_field(\"start\"));\n                        }\n                        start = Some(try!(map.next_value()));\n                    }\n                    Field::End =\u003e {\n                        if end.is_some() {\n                            return Err(\u003cA::Error as Error\u003e::duplicate_field(\"end\"));\n                        }\n                        end = Some(try!(map.next_value()));\n                    }\n                }\n            }\n            let start = match start {\n                Some(start) =\u003e start,\n                None =\u003e return Err(\u003cA::Error as Error\u003e::missing_field(\"start\")),\n            };\n            let end = match end {\n                Some(end) =\u003e end,\n                None =\u003e return Err(\u003cA::Error as Error\u003e::missing_field(\"end\")),\n            };\n            Ok((start, end))\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(ops_bound, collections_bound))]\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Bound\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        enum Field {\n            Unbounded,\n            Included,\n            Excluded,\n        }\n\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for Field {\n            #[inline]\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct FieldVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"`Unbounded`, `Included` or `Excluded`\")\n                    }\n\n                    fn visit_u32\u003cE\u003e(self, value: u32) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            0 =\u003e Ok(Field::Unbounded),\n                            1 =\u003e Ok(Field::Included),\n                            2 =\u003e Ok(Field::Excluded),\n                            _ =\u003e Err(Error::invalid_value(\n                                Unexpected::Unsigned(value as u64),\n                                \u0026self,\n                            )),\n                        }\n                    }\n\n                    fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"Unbounded\" =\u003e Ok(Field::Unbounded),\n                            \"Included\" =\u003e Ok(Field::Included),\n                            \"Excluded\" =\u003e Ok(Field::Excluded),\n                            _ =\u003e Err(Error::unknown_variant(value, VARIANTS)),\n                        }\n                    }\n\n                    fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"Unbounded\" =\u003e Ok(Field::Unbounded),\n                            b\"Included\" =\u003e Ok(Field::Included),\n                            b\"Excluded\" =\u003e Ok(Field::Excluded),\n                            _ =\u003e match str::from_utf8(value) {\n                                Ok(value) =\u003e Err(Error::unknown_variant(value, VARIANTS)),\n                                Err(_) =\u003e {\n                                    Err(Error::invalid_value(Unexpected::Bytes(value), \u0026self))\n                                }\n                            },\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct BoundVisitor\u003cT\u003e(PhantomData\u003cBound\u003cT\u003e\u003e);\n\n        impl\u003c'de, T\u003e Visitor\u003c'de\u003e for BoundVisitor\u003cT\u003e\n        where\n            T: Deserialize\u003c'de\u003e,\n        {\n            type Value = Bound\u003cT\u003e;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"enum Bound\")\n            }\n\n            fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: EnumAccess\u003c'de\u003e,\n            {\n                match try!(data.variant()) {\n                    (Field::Unbounded, v) =\u003e v.unit_variant().map(|()| Bound::Unbounded),\n                    (Field::Included, v) =\u003e v.newtype_variant().map(Bound::Included),\n                    (Field::Excluded, v) =\u003e v.newtype_variant().map(Bound::Excluded),\n                }\n            }\n        }\n\n        const VARIANTS: \u0026'static [\u0026'static str] = \u0026[\"Unbounded\", \"Included\", \"Excluded\"];\n\n        deserializer.deserialize_enum(\"Bound\", VARIANTS, BoundVisitor(PhantomData))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! nonzero_integers {\n    ( $( $T: ident, )+ ) =\u003e {\n        $(\n            #[cfg(num_nonzero)]\n            impl\u003c'de\u003e Deserialize\u003c'de\u003e for num::$T {\n                fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n                where\n                    D: Deserializer\u003c'de\u003e,\n                {\n                    let value = try!(Deserialize::deserialize(deserializer));\n                    match \u003cnum::$T\u003e::new(value) {\n                        Some(nonzero) =\u003e Ok(nonzero),\n                        None =\u003e Err(Error::custom(\"expected a non-zero value\")),\n                    }\n                }\n            }\n        )+\n    };\n}\n\nnonzero_integers! {\n    NonZeroU8,\n    NonZeroU16,\n    NonZeroU32,\n    NonZeroU64,\n    NonZeroUsize,\n}\n\n#[cfg(num_nonzero_signed)]\nnonzero_integers! {\n    NonZeroI8,\n    NonZeroI16,\n    NonZeroI32,\n    NonZeroI64,\n    NonZeroIsize,\n}\n\n// Currently 128-bit integers do not work on Emscripten targets so we need an\n// additional `#[cfg]`\nserde_if_integer128! {\n    nonzero_integers! {\n        NonZeroU128,\n    }\n\n    #[cfg(num_nonzero_signed)]\n    nonzero_integers! {\n        NonZeroI128,\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003c'de, T, E\u003e Deserialize\u003c'de\u003e for Result\u003cT, E\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n    E: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        // If this were outside of the serde crate, it would just use:\n        //\n        //    #[derive(Deserialize)]\n        //    #[serde(variant_identifier)]\n        enum Field {\n            Ok,\n            Err,\n        }\n\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for Field {\n            #[inline]\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct FieldVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"`Ok` or `Err`\")\n                    }\n\n                    fn visit_u32\u003cE\u003e(self, value: u32) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            0 =\u003e Ok(Field::Ok),\n                            1 =\u003e Ok(Field::Err),\n                            _ =\u003e Err(Error::invalid_value(\n                                Unexpected::Unsigned(value as u64),\n                                \u0026self,\n                            )),\n                        }\n                    }\n\n                    fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"Ok\" =\u003e Ok(Field::Ok),\n                            \"Err\" =\u003e Ok(Field::Err),\n                            _ =\u003e Err(Error::unknown_variant(value, VARIANTS)),\n                        }\n                    }\n\n                    fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"Ok\" =\u003e Ok(Field::Ok),\n                            b\"Err\" =\u003e Ok(Field::Err),\n                            _ =\u003e match str::from_utf8(value) {\n                                Ok(value) =\u003e Err(Error::unknown_variant(value, VARIANTS)),\n                                Err(_) =\u003e {\n                                    Err(Error::invalid_value(Unexpected::Bytes(value), \u0026self))\n                                }\n                            },\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct ResultVisitor\u003cT, E\u003e(PhantomData\u003cResult\u003cT, E\u003e\u003e);\n\n        impl\u003c'de, T, E\u003e Visitor\u003c'de\u003e for ResultVisitor\u003cT, E\u003e\n        where\n            T: Deserialize\u003c'de\u003e,\n            E: Deserialize\u003c'de\u003e,\n        {\n            type Value = Result\u003cT, E\u003e;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"enum Result\")\n            }\n\n            fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: EnumAccess\u003c'de\u003e,\n            {\n                match try!(data.variant()) {\n                    (Field::Ok, v) =\u003e v.newtype_variant().map(Ok),\n                    (Field::Err, v) =\u003e v.newtype_variant().map(Err),\n                }\n            }\n        }\n\n        const VARIANTS: \u0026'static [\u0026'static str] = \u0026[\"Ok\", \"Err\"];\n\n        deserializer.deserialize_enum(\"Result\", VARIANTS, ResultVisitor(PhantomData))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Wrapping\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Deserialize::deserialize(deserializer).map(Wrapping)\n    }\n}\n\n#[cfg(all(feature = \"std\", std_atomic))]\nmacro_rules! atomic_impl {\n    ($($ty:ident)*) =\u003e {\n        $(\n            impl\u003c'de\u003e Deserialize\u003c'de\u003e for $ty {\n                fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n                where\n                    D: Deserializer\u003c'de\u003e,\n                {\n                    Deserialize::deserialize(deserializer).map(Self::new)\n                }\n            }\n        )*\n    };\n}\n\n#[cfg(all(feature = \"std\", std_atomic))]\natomic_impl! {\n    AtomicBool\n    AtomicI8 AtomicI16 AtomicI32 AtomicIsize\n    AtomicU8 AtomicU16 AtomicU32 AtomicUsize\n}\n\n#[cfg(all(feature = \"std\", std_atomic64))]\natomic_impl! {\n    AtomicI64 AtomicU64\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","mod.rs"],"content":"//! Generic data structure deserialization framework.\n//!\n//! The two most important traits in this module are [`Deserialize`] and\n//! [`Deserializer`].\n//!\n//!  - **A type that implements `Deserialize` is a data structure** that can be\n//!    deserialized from any data format supported by Serde, and conversely\n//!  - **A type that implements `Deserializer` is a data format** that can\n//!    deserialize any data structure supported by Serde.\n//!\n//! # The Deserialize trait\n//!\n//! Serde provides [`Deserialize`] implementations for many Rust primitive and\n//! standard library types. The complete list is below. All of these can be\n//! deserialized using Serde out of the box.\n//!\n//! Additionally, Serde provides a procedural macro called [`serde_derive`] to\n//! automatically generate [`Deserialize`] implementations for structs and enums\n//! in your program. See the [derive section of the manual] for how to use this.\n//!\n//! In rare cases it may be necessary to implement [`Deserialize`] manually for\n//! some type in your program. See the [Implementing `Deserialize`] section of\n//! the manual for more about this.\n//!\n//! Third-party crates may provide [`Deserialize`] implementations for types\n//! that they expose. For example the [`linked-hash-map`] crate provides a\n//! [`LinkedHashMap\u003cK, V\u003e`] type that is deserializable by Serde because the\n//! crate provides an implementation of [`Deserialize`] for it.\n//!\n//! # The Deserializer trait\n//!\n//! [`Deserializer`] implementations are provided by third-party crates, for\n//! example [`serde_json`], [`serde_yaml`] and [`bincode`].\n//!\n//! A partial list of well-maintained formats is given on the [Serde\n//! website][data formats].\n//!\n//! # Implementations of Deserialize provided by Serde\n//!\n//! This is a slightly different set of types than what is supported for\n//! serialization. Some types can be serialized by Serde but not deserialized.\n//! One example is `OsStr`.\n//!\n//!  - **Primitive types**:\n//!    - bool\n//!    - i8, i16, i32, i64, i128, isize\n//!    - u8, u16, u32, u64, u128, usize\n//!    - f32, f64\n//!    - char\n//!  - **Compound types**:\n//!    - \\[T; 0\\] through \\[T; 32\\]\n//!    - tuples up to size 16\n//!  - **Common standard library types**:\n//!    - String\n//!    - Option\\\u003cT\\\u003e\n//!    - Result\\\u003cT, E\\\u003e\n//!    - PhantomData\\\u003cT\\\u003e\n//!  - **Wrapper types**:\n//!    - Box\\\u003cT\\\u003e\n//!    - Box\\\u003c\\[T\\]\\\u003e\n//!    - Box\\\u003cstr\\\u003e\n//!    - Cow\\\u003c'a, T\\\u003e\n//!    - Cell\\\u003cT\\\u003e\n//!    - RefCell\\\u003cT\\\u003e\n//!    - Mutex\\\u003cT\\\u003e\n//!    - RwLock\\\u003cT\\\u003e\n//!    - Rc\\\u003cT\\\u003e\u0026emsp;*(if* features = [\"rc\"] *is enabled)*\n//!    - Arc\\\u003cT\\\u003e\u0026emsp;*(if* features = [\"rc\"] *is enabled)*\n//!  - **Collection types**:\n//!    - BTreeMap\\\u003cK, V\\\u003e\n//!    - BTreeSet\\\u003cT\\\u003e\n//!    - BinaryHeap\\\u003cT\\\u003e\n//!    - HashMap\\\u003cK, V, H\\\u003e\n//!    - HashSet\\\u003cT, H\\\u003e\n//!    - LinkedList\\\u003cT\\\u003e\n//!    - VecDeque\\\u003cT\\\u003e\n//!    - Vec\\\u003cT\\\u003e\n//!  - **Zero-copy types**:\n//!    - \u0026str\n//!    - \u0026\\[u8\\]\n//!  - **FFI types**:\n//!    - CString\n//!    - Box\\\u003cCStr\\\u003e\n//!    - OsString\n//!  - **Miscellaneous standard library types**:\n//!    - Duration\n//!    - SystemTime\n//!    - Path\n//!    - PathBuf\n//!    - Range\\\u003cT\\\u003e\n//!    - RangeInclusive\\\u003cT\\\u003e\n//!    - Bound\\\u003cT\\\u003e\n//!    - num::NonZero*\n//!    - `!` *(unstable)*\n//!  - **Net types**:\n//!    - IpAddr\n//!    - Ipv4Addr\n//!    - Ipv6Addr\n//!    - SocketAddr\n//!    - SocketAddrV4\n//!    - SocketAddrV6\n//!\n//! [Implementing `Deserialize`]: https://serde.rs/impl-deserialize.html\n//! [`Deserialize`]: ../trait.Deserialize.html\n//! [`Deserializer`]: ../trait.Deserializer.html\n//! [`LinkedHashMap\u003cK, V\u003e`]: https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html\n//! [`bincode`]: https://github.com/TyOverby/bincode\n//! [`linked-hash-map`]: https://crates.io/crates/linked-hash-map\n//! [`serde_derive`]: https://crates.io/crates/serde_derive\n//! [`serde_json`]: https://github.com/serde-rs/json\n//! [`serde_yaml`]: https://github.com/dtolnay/serde-yaml\n//! [derive section of the manual]: https://serde.rs/derive.html\n//! [data formats]: https://serde.rs/#data-formats\n\nuse lib::*;\n\n////////////////////////////////////////////////////////////////////////////////\n\npub mod value;\n\nmod from_primitive;\nmod ignored_any;\nmod impls;\nmod utf8;\n\npub use self::ignored_any::IgnoredAny;\n\n#[cfg(feature = \"std\")]\n#[doc(no_inline)]\npub use std::error::Error as StdError;\n#[cfg(not(feature = \"std\"))]\n#[doc(no_inline)]\npub use std_error::Error as StdError;\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! declare_error_trait {\n    (Error: Sized $(+ $($supertrait:ident)::+)*) =\u003e {\n        /// The `Error` trait allows `Deserialize` implementations to create descriptive\n        /// error messages belonging to the `Deserializer` against which they are\n        /// currently running.\n        ///\n        /// Every `Deserializer` declares an `Error` type that encompasses both\n        /// general-purpose deserialization errors as well as errors specific to the\n        /// particular deserialization format. For example the `Error` type of\n        /// `serde_json` can represent errors like an invalid JSON escape sequence or an\n        /// unterminated string literal, in addition to the error cases that are part of\n        /// this trait.\n        ///\n        /// Most deserializers should only need to provide the `Error::custom` method\n        /// and inherit the default behavior for the other methods.\n        ///\n        /// # Example implementation\n        ///\n        /// The [example data format] presented on the website shows an error\n        /// type appropriate for a basic JSON data format.\n        ///\n        /// [example data format]: https://serde.rs/data-format.html\n        pub trait Error: Sized $(+ $($supertrait)::+)* {\n            /// Raised when there is general error when deserializing a type.\n            ///\n            /// The message should not be capitalized and should not end with a period.\n            ///\n            /// ```edition2018\n            /// # use std::str::FromStr;\n            /// #\n            /// # struct IpAddr;\n            /// #\n            /// # impl FromStr for IpAddr {\n            /// #     type Err = String;\n            /// #\n            /// #     fn from_str(_: \u0026str) -\u003e Result\u003cSelf, String\u003e {\n            /// #         unimplemented!()\n            /// #     }\n            /// # }\n            /// #\n            /// use serde::de::{self, Deserialize, Deserializer};\n            ///\n            /// impl\u003c'de\u003e Deserialize\u003c'de\u003e for IpAddr {\n            ///     fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            ///     where\n            ///         D: Deserializer\u003c'de\u003e,\n            ///     {\n            ///         let s = String::deserialize(deserializer)?;\n            ///         s.parse().map_err(de::Error::custom)\n            ///     }\n            /// }\n            /// ```\n            fn custom\u003cT\u003e(msg: T) -\u003e Self\n            where\n                T: Display;\n\n            /// Raised when a `Deserialize` receives a type different from what it was\n            /// expecting.\n            ///\n            /// The `unexp` argument provides information about what type was received.\n            /// This is the type that was present in the input file or other source data\n            /// of the Deserializer.\n            ///\n            /// The `exp` argument provides information about what type was being\n            /// expected. This is the type that is written in the program.\n            ///\n            /// For example if we try to deserialize a String out of a JSON file\n            /// containing an integer, the unexpected type is the integer and the\n            /// expected type is the string.\n            #[cold]\n            fn invalid_type(unexp: Unexpected, exp: \u0026Expected) -\u003e Self {\n                Error::custom(format_args!(\"invalid type: {}, expected {}\", unexp, exp))\n            }\n\n            /// Raised when a `Deserialize` receives a value of the right type but that\n            /// is wrong for some other reason.\n            ///\n            /// The `unexp` argument provides information about what value was received.\n            /// This is the value that was present in the input file or other source\n            /// data of the Deserializer.\n            ///\n            /// The `exp` argument provides information about what value was being\n            /// expected. This is the type that is written in the program.\n            ///\n            /// For example if we try to deserialize a String out of some binary data\n            /// that is not valid UTF-8, the unexpected value is the bytes and the\n            /// expected value is a string.\n            #[cold]\n            fn invalid_value(unexp: Unexpected, exp: \u0026Expected) -\u003e Self {\n                Error::custom(format_args!(\"invalid value: {}, expected {}\", unexp, exp))\n            }\n\n            /// Raised when deserializing a sequence or map and the input data contains\n            /// too many or too few elements.\n            ///\n            /// The `len` argument is the number of elements encountered. The sequence\n            /// or map may have expected more arguments or fewer arguments.\n            ///\n            /// The `exp` argument provides information about what data was being\n            /// expected. For example `exp` might say that a tuple of size 6 was\n            /// expected.\n            #[cold]\n            fn invalid_length(len: usize, exp: \u0026Expected) -\u003e Self {\n                Error::custom(format_args!(\"invalid length {}, expected {}\", len, exp))\n            }\n\n            /// Raised when a `Deserialize` enum type received a variant with an\n            /// unrecognized name.\n            #[cold]\n            fn unknown_variant(variant: \u0026str, expected: \u0026'static [\u0026'static str]) -\u003e Self {\n                if expected.is_empty() {\n                    Error::custom(format_args!(\n                        \"unknown variant `{}`, there are no variants\",\n                        variant\n                    ))\n                } else {\n                    Error::custom(format_args!(\n                        \"unknown variant `{}`, expected {}\",\n                        variant,\n                        OneOf { names: expected }\n                    ))\n                }\n            }\n\n            /// Raised when a `Deserialize` struct type received a field with an\n            /// unrecognized name.\n            #[cold]\n            fn unknown_field(field: \u0026str, expected: \u0026'static [\u0026'static str]) -\u003e Self {\n                if expected.is_empty() {\n                    Error::custom(format_args!(\n                        \"unknown field `{}`, there are no fields\",\n                        field\n                    ))\n                } else {\n                    Error::custom(format_args!(\n                        \"unknown field `{}`, expected {}\",\n                        field,\n                        OneOf { names: expected }\n                    ))\n                }\n            }\n\n            /// Raised when a `Deserialize` struct type expected to receive a required\n            /// field with a particular name but that field was not present in the\n            /// input.\n            #[cold]\n            fn missing_field(field: \u0026'static str) -\u003e Self {\n                Error::custom(format_args!(\"missing field `{}`\", field))\n            }\n\n            /// Raised when a `Deserialize` struct type received more than one of the\n            /// same field.\n            #[cold]\n            fn duplicate_field(field: \u0026'static str) -\u003e Self {\n                Error::custom(format_args!(\"duplicate field `{}`\", field))\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\ndeclare_error_trait!(Error: Sized + StdError);\n\n#[cfg(not(feature = \"std\"))]\ndeclare_error_trait!(Error: Sized + Debug + Display);\n\n/// `Unexpected` represents an unexpected invocation of any one of the `Visitor`\n/// trait methods.\n///\n/// This is used as an argument to the `invalid_type`, `invalid_value`, and\n/// `invalid_length` methods of the `Error` trait to build error messages.\n///\n/// ```edition2018\n/// # use std::fmt;\n/// #\n/// # use serde::de::{self, Unexpected, Visitor};\n/// #\n/// # struct Example;\n/// #\n/// # impl\u003c'de\u003e Visitor\u003c'de\u003e for Example {\n/// #     type Value = ();\n/// #\n/// #     fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n/// #         write!(formatter, \"definitely not a boolean\")\n/// #     }\n/// #\n/// fn visit_bool\u003cE\u003e(self, v: bool) -\u003e Result\u003cSelf::Value, E\u003e\n/// where\n///     E: de::Error,\n/// {\n///     Err(de::Error::invalid_type(Unexpected::Bool(v), \u0026self))\n/// }\n/// # }\n/// ```\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum Unexpected\u003c'a\u003e {\n    /// The input contained a boolean value that was not expected.\n    Bool(bool),\n\n    /// The input contained an unsigned integer `u8`, `u16`, `u32` or `u64` that\n    /// was not expected.\n    Unsigned(u64),\n\n    /// The input contained a signed integer `i8`, `i16`, `i32` or `i64` that\n    /// was not expected.\n    Signed(i64),\n\n    /// The input contained a floating point `f32` or `f64` that was not\n    /// expected.\n    Float(f64),\n\n    /// The input contained a `char` that was not expected.\n    Char(char),\n\n    /// The input contained a `\u0026str` or `String` that was not expected.\n    Str(\u0026'a str),\n\n    /// The input contained a `\u0026[u8]` or `Vec\u003cu8\u003e` that was not expected.\n    Bytes(\u0026'a [u8]),\n\n    /// The input contained a unit `()` that was not expected.\n    Unit,\n\n    /// The input contained an `Option\u003cT\u003e` that was not expected.\n    Option,\n\n    /// The input contained a newtype struct that was not expected.\n    NewtypeStruct,\n\n    /// The input contained a sequence that was not expected.\n    Seq,\n\n    /// The input contained a map that was not expected.\n    Map,\n\n    /// The input contained an enum that was not expected.\n    Enum,\n\n    /// The input contained a unit variant that was not expected.\n    UnitVariant,\n\n    /// The input contained a newtype variant that was not expected.\n    NewtypeVariant,\n\n    /// The input contained a tuple variant that was not expected.\n    TupleVariant,\n\n    /// The input contained a struct variant that was not expected.\n    StructVariant,\n\n    /// A message stating what uncategorized thing the input contained that was\n    /// not expected.\n    ///\n    /// The message should be a noun or noun phrase, not capitalized and without\n    /// a period. An example message is \"unoriginal superhero\".\n    Other(\u0026'a str),\n}\n\nimpl\u003c'a\u003e fmt::Display for Unexpected\u003c'a\u003e {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e Result\u003c(), fmt::Error\u003e {\n        use self::Unexpected::*;\n        match *self {\n            Bool(b) =\u003e write!(formatter, \"boolean `{}`\", b),\n            Unsigned(i) =\u003e write!(formatter, \"integer `{}`\", i),\n            Signed(i) =\u003e write!(formatter, \"integer `{}`\", i),\n            Float(f) =\u003e write!(formatter, \"floating point `{}`\", f),\n            Char(c) =\u003e write!(formatter, \"character `{}`\", c),\n            Str(s) =\u003e write!(formatter, \"string {:?}\", s),\n            Bytes(_) =\u003e write!(formatter, \"byte array\"),\n            Unit =\u003e write!(formatter, \"unit value\"),\n            Option =\u003e write!(formatter, \"Option value\"),\n            NewtypeStruct =\u003e write!(formatter, \"newtype struct\"),\n            Seq =\u003e write!(formatter, \"sequence\"),\n            Map =\u003e write!(formatter, \"map\"),\n            Enum =\u003e write!(formatter, \"enum\"),\n            UnitVariant =\u003e write!(formatter, \"unit variant\"),\n            NewtypeVariant =\u003e write!(formatter, \"newtype variant\"),\n            TupleVariant =\u003e write!(formatter, \"tuple variant\"),\n            StructVariant =\u003e write!(formatter, \"struct variant\"),\n            Other(other) =\u003e formatter.write_str(other),\n        }\n    }\n}\n\n/// `Expected` represents an explanation of what data a `Visitor` was expecting\n/// to receive.\n///\n/// This is used as an argument to the `invalid_type`, `invalid_value`, and\n/// `invalid_length` methods of the `Error` trait to build error messages. The\n/// message should be a noun or noun phrase that completes the sentence \"This\n/// Visitor expects to receive ...\", for example the message could be \"an\n/// integer between 0 and 64\". The message should not be capitalized and should\n/// not end with a period.\n///\n/// Within the context of a `Visitor` implementation, the `Visitor` itself\n/// (`\u0026self`) is an implementation of this trait.\n///\n/// ```edition2018\n/// # use std::fmt;\n/// #\n/// # use serde::de::{self, Unexpected, Visitor};\n/// #\n/// # struct Example;\n/// #\n/// # impl\u003c'de\u003e Visitor\u003c'de\u003e for Example {\n/// #     type Value = ();\n/// #\n/// #     fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n/// #         write!(formatter, \"definitely not a boolean\")\n/// #     }\n/// #\n/// fn visit_bool\u003cE\u003e(self, v: bool) -\u003e Result\u003cSelf::Value, E\u003e\n/// where\n///     E: de::Error,\n/// {\n///     Err(de::Error::invalid_type(Unexpected::Bool(v), \u0026self))\n/// }\n/// # }\n/// ```\n///\n/// Outside of a `Visitor`, `\u0026\"...\"` can be used.\n///\n/// ```edition2018\n/// # use serde::de::{self, Unexpected};\n/// #\n/// # fn example\u003cE\u003e() -\u003e Result\u003c(), E\u003e\n/// # where\n/// #     E: de::Error,\n/// # {\n/// #     let v = true;\n/// return Err(de::Error::invalid_type(Unexpected::Bool(v), \u0026\"a negative integer\"));\n/// # }\n/// ```\npub trait Expected {\n    /// Format an explanation of what data was being expected. Same signature as\n    /// the `Display` and `Debug` traits.\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result;\n}\n\nimpl\u003c'de, T\u003e Expected for T\nwhere\n    T: Visitor\u003c'de\u003e,\n{\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        self.expecting(formatter)\n    }\n}\n\nimpl\u003c'a\u003e Expected for \u0026'a str {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(self)\n    }\n}\n\nimpl\u003c'a\u003e Display for Expected + 'a {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        Expected::fmt(self, formatter)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A **data structure** that can be deserialized from any data format supported\n/// by Serde.\n///\n/// Serde provides `Deserialize` implementations for many Rust primitive and\n/// standard library types. The complete list is [here][de]. All of these can\n/// be deserialized using Serde out of the box.\n///\n/// Additionally, Serde provides a procedural macro called `serde_derive` to\n/// automatically generate `Deserialize` implementations for structs and enums\n/// in your program. See the [derive section of the manual][derive] for how to\n/// use this.\n///\n/// In rare cases it may be necessary to implement `Deserialize` manually for\n/// some type in your program. See the [Implementing\n/// `Deserialize`][impl-deserialize] section of the manual for more about this.\n///\n/// Third-party crates may provide `Deserialize` implementations for types that\n/// they expose. For example the `linked-hash-map` crate provides a\n/// `LinkedHashMap\u003cK, V\u003e` type that is deserializable by Serde because the crate\n/// provides an implementation of `Deserialize` for it.\n///\n/// [de]: https://docs.serde.rs/serde/de/index.html\n/// [derive]: https://serde.rs/derive.html\n/// [impl-deserialize]: https://serde.rs/impl-deserialize.html\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by `Self` when deserialized. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\npub trait Deserialize\u003c'de\u003e: Sized {\n    /// Deserialize this value from the given Serde deserializer.\n    ///\n    /// See the [Implementing `Deserialize`][impl-deserialize] section of the\n    /// manual for more information about how to implement this method.\n    ///\n    /// [impl-deserialize]: https://serde.rs/impl-deserialize.html\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e;\n\n    /// Deserializes a value into `self` from the given Deserializer.\n    ///\n    /// The purpose of this method is to allow the deserializer to reuse\n    /// resources and avoid copies. As such, if this method returns an error,\n    /// `self` will be in an indeterminate state where some parts of the struct\n    /// have been overwritten. Although whatever state that is will be\n    /// memory-safe.\n    ///\n    /// This is generally useful when repeatedly deserializing values that\n    /// are processed one at a time, where the value of `self` doesn't matter\n    /// when the next deserialization occurs.\n    ///\n    /// If you manually implement this, your recursive deserializations should\n    /// use `deserialize_in_place`.\n    ///\n    /// This method is stable and an official public API, but hidden from the\n    /// documentation because it is almost never what newbies are looking for.\n    /// Showing it in rustdoc would cause it to be featured more prominently\n    /// than it deserves.\n    #[doc(hidden)]\n    fn deserialize_in_place\u003cD\u003e(deserializer: D, place: \u0026mut Self) -\u003e Result\u003c(), D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        // Default implementation just delegates to `deserialize` impl.\n        *place = Deserialize::deserialize(deserializer)?;\n        Ok(())\n    }\n}\n\n/// A data structure that can be deserialized without borrowing any data from\n/// the deserializer.\n///\n/// This is primarily useful for trait bounds on functions. For example a\n/// `from_str` function may be able to deserialize a data structure that borrows\n/// from the input string, but a `from_reader` function may only deserialize\n/// owned data.\n///\n/// ```edition2018\n/// # use serde::de::{Deserialize, DeserializeOwned};\n/// # use std::io::{Read, Result};\n/// #\n/// # trait Ignore {\n/// fn from_str\u003c'a, T\u003e(s: \u0026'a str) -\u003e Result\u003cT\u003e\n/// where\n///     T: Deserialize\u003c'a\u003e;\n///\n/// fn from_reader\u003cR, T\u003e(rdr: R) -\u003e Result\u003cT\u003e\n/// where\n///     R: Read,\n///     T: DeserializeOwned;\n/// # }\n/// ```\n///\n/// # Lifetime\n///\n/// The relationship between `Deserialize` and `DeserializeOwned` in trait\n/// bounds is explained in more detail on the page [Understanding deserializer\n/// lifetimes].\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\npub trait DeserializeOwned: for\u003c'de\u003e Deserialize\u003c'de\u003e {}\nimpl\u003cT\u003e DeserializeOwned for T where T: for\u003c'de\u003e Deserialize\u003c'de\u003e {}\n\n/// `DeserializeSeed` is the stateful form of the `Deserialize` trait. If you\n/// ever find yourself looking for a way to pass data into a `Deserialize` impl,\n/// this trait is the way to do it.\n///\n/// As one example of stateful deserialization consider deserializing a JSON\n/// array into an existing buffer. Using the `Deserialize` trait we could\n/// deserialize a JSON array into a `Vec\u003cT\u003e` but it would be a freshly allocated\n/// `Vec\u003cT\u003e`; there is no way for `Deserialize` to reuse a previously allocated\n/// buffer. Using `DeserializeSeed` instead makes this possible as in the\n/// example code below.\n///\n/// The canonical API for stateless deserialization looks like this:\n///\n/// ```edition2018\n/// # use serde::Deserialize;\n/// #\n/// # enum Error {}\n/// #\n/// fn func\u003c'de, T: Deserialize\u003c'de\u003e\u003e() -\u003e Result\u003cT, Error\u003e\n/// # {\n/// #     unimplemented!()\n/// # }\n/// ```\n///\n/// Adjusting an API like this to support stateful deserialization is a matter\n/// of accepting a seed as input:\n///\n/// ```edition2018\n/// # use serde::de::DeserializeSeed;\n/// #\n/// # enum Error {}\n/// #\n/// fn func_seed\u003c'de, T: DeserializeSeed\u003c'de\u003e\u003e(seed: T) -\u003e Result\u003cT::Value, Error\u003e\n/// # {\n/// #     let _ = seed;\n/// #     unimplemented!()\n/// # }\n/// ```\n///\n/// In practice the majority of deserialization is stateless. An API expecting a\n/// seed can be appeased by passing `std::marker::PhantomData` as a seed in the\n/// case of stateless deserialization.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by `Self::Value` when deserialized. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example\n///\n/// Suppose we have JSON that looks like `[[1, 2], [3, 4, 5], [6]]` and we need\n/// to deserialize it into a flat representation like `vec![1, 2, 3, 4, 5, 6]`.\n/// Allocating a brand new `Vec\u003cT\u003e` for each subarray would be slow. Instead we\n/// would like to allocate a single `Vec\u003cT\u003e` and then deserialize each subarray\n/// into it. This requires stateful deserialization using the `DeserializeSeed`\n/// trait.\n///\n/// ```edition2018\n/// use std::fmt;\n/// use std::marker::PhantomData;\n///\n/// use serde::de::{Deserialize, DeserializeSeed, Deserializer, SeqAccess, Visitor};\n///\n/// // A DeserializeSeed implementation that uses stateful deserialization to\n/// // append array elements onto the end of an existing vector. The preexisting\n/// // state (\"seed\") in this case is the Vec\u003cT\u003e. The `deserialize` method of\n/// // `ExtendVec` will be traversing the inner arrays of the JSON input and\n/// // appending each integer into the existing Vec.\n/// struct ExtendVec\u003c'a, T: 'a\u003e(\u0026'a mut Vec\u003cT\u003e);\n///\n/// impl\u003c'de, 'a, T\u003e DeserializeSeed\u003c'de\u003e for ExtendVec\u003c'a, T\u003e\n/// where\n///     T: Deserialize\u003c'de\u003e,\n/// {\n///     // The return type of the `deserialize` method. This implementation\n///     // appends onto an existing vector but does not create any new data\n///     // structure, so the return type is ().\n///     type Value = ();\n///\n///     fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n///     where\n///         D: Deserializer\u003c'de\u003e,\n///     {\n///         // Visitor implementation that will walk an inner array of the JSON\n///         // input.\n///         struct ExtendVecVisitor\u003c'a, T: 'a\u003e(\u0026'a mut Vec\u003cT\u003e);\n///\n///         impl\u003c'de, 'a, T\u003e Visitor\u003c'de\u003e for ExtendVecVisitor\u003c'a, T\u003e\n///         where\n///             T: Deserialize\u003c'de\u003e,\n///         {\n///             type Value = ();\n///\n///             fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n///                 write!(formatter, \"an array of integers\")\n///             }\n///\n///             fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003c(), A::Error\u003e\n///             where\n///                 A: SeqAccess\u003c'de\u003e,\n///             {\n///                 // Visit each element in the inner array and push it onto\n///                 // the existing vector.\n///                 while let Some(elem) = seq.next_element()? {\n///                     self.0.push(elem);\n///                 }\n///                 Ok(())\n///             }\n///         }\n///\n///         deserializer.deserialize_seq(ExtendVecVisitor(self.0))\n///     }\n/// }\n///\n/// // Visitor implementation that will walk the outer array of the JSON input.\n/// struct FlattenedVecVisitor\u003cT\u003e(PhantomData\u003cT\u003e);\n///\n/// impl\u003c'de, T\u003e Visitor\u003c'de\u003e for FlattenedVecVisitor\u003cT\u003e\n/// where\n///     T: Deserialize\u003c'de\u003e,\n/// {\n///     // This Visitor constructs a single Vec\u003cT\u003e to hold the flattened\n///     // contents of the inner arrays.\n///     type Value = Vec\u003cT\u003e;\n///\n///     fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n///         write!(formatter, \"an array of arrays\")\n///     }\n///\n///     fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cVec\u003cT\u003e, A::Error\u003e\n///     where\n///         A: SeqAccess\u003c'de\u003e,\n///     {\n///         // Create a single Vec to hold the flattened contents.\n///         let mut vec = Vec::new();\n///\n///         // Each iteration through this loop is one inner array.\n///         while let Some(()) = seq.next_element_seed(ExtendVec(\u0026mut vec))? {\n///             // Nothing to do; inner array has been appended into `vec`.\n///         }\n///\n///         // Return the finished vec.\n///         Ok(vec)\n///     }\n/// }\n///\n/// # fn example\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003c(), D::Error\u003e\n/// # where\n/// #     D: Deserializer\u003c'de\u003e,\n/// # {\n/// let visitor = FlattenedVecVisitor(PhantomData);\n/// let flattened: Vec\u003cu64\u003e = deserializer.deserialize_seq(visitor)?;\n/// #     Ok(())\n/// # }\n/// ```\npub trait DeserializeSeed\u003c'de\u003e: Sized {\n    /// The type produced by using this seed.\n    type Value;\n\n    /// Equivalent to the more common `Deserialize::deserialize` method, except\n    /// with some initial piece of data (the seed) passed in.\n    fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e;\n}\n\nimpl\u003c'de, T\u003e DeserializeSeed\u003c'de\u003e for PhantomData\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    type Value = T;\n\n    #[inline]\n    fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cT, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(deserializer)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A **data format** that can deserialize any data structure supported by\n/// Serde.\n///\n/// The role of this trait is to define the deserialization half of the [Serde\n/// data model], which is a way to categorize every Rust data type into one of\n/// 29 possible types. Each method of the `Deserializer` trait corresponds to one\n/// of the types of the data model.\n///\n/// Implementations of `Deserialize` map themselves into this data model by\n/// passing to the `Deserializer` a `Visitor` implementation that can receive\n/// these various types.\n///\n/// The types that make up the Serde data model are:\n///\n///  - **14 primitive types**\n///    - bool\n///    - i8, i16, i32, i64, i128\n///    - u8, u16, u32, u64, u128\n///    - f32, f64\n///    - char\n///  - **string**\n///    - UTF-8 bytes with a length and no null terminator.\n///    - When serializing, all strings are handled equally. When deserializing,\n///      there are three flavors of strings: transient, owned, and borrowed.\n///  - **byte array** - \\[u8\\]\n///    - Similar to strings, during deserialization byte arrays can be\n///      transient, owned, or borrowed.\n///  - **option**\n///    - Either none or some value.\n///  - **unit**\n///    - The type of `()` in Rust. It represents an anonymous value containing\n///      no data.\n///  - **unit_struct**\n///    - For example `struct Unit` or `PhantomData\u003cT\u003e`. It represents a named\n///      value containing no data.\n///  - **unit_variant**\n///    - For example the `E::A` and `E::B` in `enum E { A, B }`.\n///  - **newtype_struct**\n///    - For example `struct Millimeters(u8)`.\n///  - **newtype_variant**\n///    - For example the `E::N` in `enum E { N(u8) }`.\n///  - **seq**\n///    - A variably sized heterogeneous sequence of values, for example `Vec\u003cT\u003e`\n///      or `HashSet\u003cT\u003e`. When serializing, the length may or may not be known\n///      before iterating through all the data. When deserializing, the length\n///      is determined by looking at the serialized data.\n///  - **tuple**\n///    - A statically sized heterogeneous sequence of values for which the\n///      length will be known at deserialization time without looking at the\n///      serialized data, for example `(u8,)` or `(String, u64, Vec\u003cT\u003e)` or\n///      `[u64; 10]`.\n///  - **tuple_struct**\n///    - A named tuple, for example `struct Rgb(u8, u8, u8)`.\n///  - **tuple_variant**\n///    - For example the `E::T` in `enum E { T(u8, u8) }`.\n///  - **map**\n///    - A heterogeneous key-value pairing, for example `BTreeMap\u003cK, V\u003e`.\n///  - **struct**\n///    - A heterogeneous key-value pairing in which the keys are strings and\n///      will be known at deserialization time without looking at the serialized\n///      data, for example `struct S { r: u8, g: u8, b: u8 }`.\n///  - **struct_variant**\n///    - For example the `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`.\n///\n/// The `Deserializer` trait supports two entry point styles which enables\n/// different kinds of deserialization.\n///\n/// 1. The `deserialize` method. Self-describing data formats like JSON are able\n///    to look at the serialized data and tell what it represents. For example\n///    the JSON deserializer may see an opening curly brace (`{`) and know that\n///    it is seeing a map. If the data format supports\n///    `Deserializer::deserialize_any`, it will drive the Visitor using whatever\n///    type it sees in the input. JSON uses this approach when deserializing\n///    `serde_json::Value` which is an enum that can represent any JSON\n///    document. Without knowing what is in a JSON document, we can deserialize\n///    it to `serde_json::Value` by going through\n///    `Deserializer::deserialize_any`.\n///\n/// 2. The various `deserialize_*` methods. Non-self-describing formats like\n///    Bincode need to be told what is in the input in order to deserialize it.\n///    The `deserialize_*` methods are hints to the deserializer for how to\n///    interpret the next piece of input. Non-self-describing formats are not\n///    able to deserialize something like `serde_json::Value` which relies on\n///    `Deserializer::deserialize_any`.\n///\n/// When implementing `Deserialize`, you should avoid relying on\n/// `Deserializer::deserialize_any` unless you need to be told by the\n/// Deserializer what type is in the input. Know that relying on\n/// `Deserializer::deserialize_any` means your data type will be able to\n/// deserialize from self-describing formats only, ruling out Bincode and many\n/// others.\n///\n/// [Serde data model]: https://serde.rs/data-model.html\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed from the input when deserializing. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website contains example code for\n/// a basic JSON `Deserializer`.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait Deserializer\u003c'de\u003e: Sized {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization.\n    type Error: Error;\n\n    /// Require the `Deserializer` to figure out how to drive the visitor based\n    /// on what data type is in the input.\n    ///\n    /// When implementing `Deserialize`, you should avoid relying on\n    /// `Deserializer::deserialize_any` unless you need to be told by the\n    /// Deserializer what type is in the input. Know that relying on\n    /// `Deserializer::deserialize_any` means your data type will be able to\n    /// deserialize from self-describing formats only, ruling out Bincode and\n    /// many others.\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a `bool` value.\n    fn deserialize_bool\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting an `i8` value.\n    fn deserialize_i8\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting an `i16` value.\n    fn deserialize_i16\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting an `i32` value.\n    fn deserialize_i32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting an `i64` value.\n    fn deserialize_i64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    serde_if_integer128! {\n        /// Hint that the `Deserialize` type is expecting an `i128` value.\n        ///\n        /// This method is available only on Rust compiler versions \u003e=1.26. The\n        /// default behavior unconditionally returns an error.\n        fn deserialize_i128\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e\n        {\n            let _ = visitor;\n            Err(Error::custom(\"i128 is not supported\"))\n        }\n    }\n\n    /// Hint that the `Deserialize` type is expecting a `u8` value.\n    fn deserialize_u8\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a `u16` value.\n    fn deserialize_u16\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a `u32` value.\n    fn deserialize_u32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a `u64` value.\n    fn deserialize_u64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    serde_if_integer128! {\n        /// Hint that the `Deserialize` type is expecting an `u128` value.\n        ///\n        /// This method is available only on Rust compiler versions \u003e=1.26. The\n        /// default behavior unconditionally returns an error.\n        fn deserialize_u128\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e\n        {\n            let _ = visitor;\n            Err(Error::custom(\"u128 is not supported\"))\n        }\n    }\n\n    /// Hint that the `Deserialize` type is expecting a `f32` value.\n    fn deserialize_f32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a `f64` value.\n    fn deserialize_f64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a `char` value.\n    fn deserialize_char\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a string value and does\n    /// not benefit from taking ownership of buffered data owned by the\n    /// `Deserializer`.\n    ///\n    /// If the `Visitor` would benefit from taking ownership of `String` data,\n    /// indiciate this to the `Deserializer` by using `deserialize_string`\n    /// instead.\n    fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a string value and would\n    /// benefit from taking ownership of buffered data owned by the\n    /// `Deserializer`.\n    ///\n    /// If the `Visitor` would not benefit from taking ownership of `String`\n    /// data, indicate that to the `Deserializer` by using `deserialize_str`\n    /// instead.\n    fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a byte array and does not\n    /// benefit from taking ownership of buffered data owned by the\n    /// `Deserializer`.\n    ///\n    /// If the `Visitor` would benefit from taking ownership of `Vec\u003cu8\u003e` data,\n    /// indicate this to the `Deserializer` by using `deserialize_byte_buf`\n    /// instead.\n    fn deserialize_bytes\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a byte array and would\n    /// benefit from taking ownership of buffered data owned by the\n    /// `Deserializer`.\n    ///\n    /// If the `Visitor` would not benefit from taking ownership of `Vec\u003cu8\u003e`\n    /// data, indicate that to the `Deserializer` by using `deserialize_bytes`\n    /// instead.\n    fn deserialize_byte_buf\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting an optional value.\n    ///\n    /// This allows deserializers that encode an optional value as a nullable\n    /// value to convert the null value into `None` and a regular value into\n    /// `Some(value)`.\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a unit value.\n    fn deserialize_unit\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a unit struct with a\n    /// particular name.\n    fn deserialize_unit_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a newtype struct with a\n    /// particular name.\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a sequence of values.\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a sequence of values and\n    /// knows how many values there are without looking at the serialized data.\n    fn deserialize_tuple\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a tuple struct with a\n    /// particular name and number of fields.\n    fn deserialize_tuple_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        len: usize,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a map of key-value pairs.\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a struct with a particular\n    /// name and fields.\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting an enum value with a\n    /// particular name and possible variants.\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting the name of a struct\n    /// field or the discriminant of an enum variant.\n    fn deserialize_identifier\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type needs to deserialize a value whose type\n    /// doesn't matter because it is ignored.\n    ///\n    /// Deserializers for non-self-describing formats may not support this mode.\n    fn deserialize_ignored_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Determine whether `Deserialize` implementations should expect to\n    /// deserialize their human-readable form.\n    ///\n    /// Some types have a human-readable form that may be somewhat expensive to\n    /// construct, as well as a binary form that is compact and efficient.\n    /// Generally text-based formats like JSON and YAML will prefer to use the\n    /// human-readable one and binary formats like Bincode will prefer the\n    /// compact one.\n    ///\n    /// ```edition2018\n    /// # use std::ops::Add;\n    /// # use std::str::FromStr;\n    /// #\n    /// # struct Timestamp;\n    /// #\n    /// # impl Timestamp {\n    /// #     const EPOCH: Timestamp = Timestamp;\n    /// # }\n    /// #\n    /// # impl FromStr for Timestamp {\n    /// #     type Err = String;\n    /// #     fn from_str(_: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// # struct Duration;\n    /// #\n    /// # impl Duration {\n    /// #     fn seconds(_: u64) -\u003e Self { unimplemented!() }\n    /// # }\n    /// #\n    /// # impl Add\u003cDuration\u003e for Timestamp {\n    /// #     type Output = Timestamp;\n    /// #     fn add(self, _: Duration) -\u003e Self::Output {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// use serde::de::{self, Deserialize, Deserializer};\n    ///\n    /// impl\u003c'de\u003e Deserialize\u003c'de\u003e for Timestamp {\n    ///     fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    ///     where\n    ///         D: Deserializer\u003c'de\u003e,\n    ///     {\n    ///         if deserializer.is_human_readable() {\n    ///             // Deserialize from a human-readable string like \"2015-05-15T17:01:00Z\".\n    ///             let s = String::deserialize(deserializer)?;\n    ///             Timestamp::from_str(\u0026s).map_err(de::Error::custom)\n    ///         } else {\n    ///             // Deserialize from a compact binary representation, seconds since\n    ///             // the Unix epoch.\n    ///             let n = u64::deserialize(deserializer)?;\n    ///             Ok(Timestamp::EPOCH + Duration::seconds(n))\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// The default implementation of this method returns `true`. Data formats\n    /// may override this to `false` to request a compact form for types that\n    /// support one. Note that modifying this method to change a format from\n    /// human-readable to compact or vice versa should be regarded as a breaking\n    /// change, as a value serialized in human-readable mode is not required to\n    /// deserialize from the same data in compact mode.\n    #[inline]\n    fn is_human_readable(\u0026self) -\u003e bool {\n        true\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// This trait represents a visitor that walks through a deserializer.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the requirement for lifetime of data\n/// that may be borrowed by `Self::Value`. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example\n///\n/// ```edition2018\n/// # use std::fmt;\n/// #\n/// # use serde::de::{self, Unexpected, Visitor};\n/// #\n/// /// A visitor that deserializes a long string - a string containing at least\n/// /// some minimum number of bytes.\n/// struct LongString {\n///     min: usize,\n/// }\n///\n/// impl\u003c'de\u003e Visitor\u003c'de\u003e for LongString {\n///     type Value = String;\n///\n///     fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n///         write!(formatter, \"a string containing at least {} bytes\", self.min)\n///     }\n///\n///     fn visit_str\u003cE\u003e(self, s: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n///     where\n///         E: de::Error,\n///     {\n///         if s.len() \u003e= self.min {\n///             Ok(s.to_owned())\n///         } else {\n///             Err(de::Error::invalid_value(Unexpected::Str(s), \u0026self))\n///         }\n///     }\n/// }\n/// ```\npub trait Visitor\u003c'de\u003e: Sized {\n    /// The value produced by this visitor.\n    type Value;\n\n    /// Format a message stating what data this Visitor expects to receive.\n    ///\n    /// This is used in error messages. The message should complete the sentence\n    /// \"This Visitor expects to receive ...\", for example the message could be\n    /// \"an integer between 0 and 64\". The message should not be capitalized and\n    /// should not end with a period.\n    ///\n    /// ```edition2018\n    /// # use std::fmt;\n    /// #\n    /// # struct S {\n    /// #     max: usize,\n    /// # }\n    /// #\n    /// # impl\u003c'de\u003e serde::de::Visitor\u003c'de\u003e for S {\n    /// #     type Value = ();\n    /// #\n    /// fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///     write!(formatter, \"an integer between 0 and {}\", self.max)\n    /// }\n    /// # }\n    /// ```\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result;\n\n    /// The input contains a boolean.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_bool\u003cE\u003e(self, v: bool) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Bool(v), \u0026self))\n    }\n\n    /// The input contains an `i8`.\n    ///\n    /// The default implementation forwards to [`visit_i64`].\n    ///\n    /// [`visit_i64`]: #method.visit_i64\n    fn visit_i8\u003cE\u003e(self, v: i8) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n\n    /// The input contains an `i16`.\n    ///\n    /// The default implementation forwards to [`visit_i64`].\n    ///\n    /// [`visit_i64`]: #method.visit_i64\n    fn visit_i16\u003cE\u003e(self, v: i16) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n\n    /// The input contains an `i32`.\n    ///\n    /// The default implementation forwards to [`visit_i64`].\n    ///\n    /// [`visit_i64`]: #method.visit_i64\n    fn visit_i32\u003cE\u003e(self, v: i32) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n\n    /// The input contains an `i64`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_i64\u003cE\u003e(self, v: i64) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Signed(v), \u0026self))\n    }\n\n    serde_if_integer128! {\n        /// The input contains a `i128`.\n        ///\n        /// This method is available only on Rust compiler versions \u003e=1.26. The\n        /// default implementation fails with a type error.\n        fn visit_i128\u003cE\u003e(self, v: i128) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            let _ = v;\n            Err(Error::invalid_type(Unexpected::Other(\"i128\"), \u0026self))\n        }\n    }\n\n    /// The input contains a `u8`.\n    ///\n    /// The default implementation forwards to [`visit_u64`].\n    ///\n    /// [`visit_u64`]: #method.visit_u64\n    fn visit_u8\u003cE\u003e(self, v: u8) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n\n    /// The input contains a `u16`.\n    ///\n    /// The default implementation forwards to [`visit_u64`].\n    ///\n    /// [`visit_u64`]: #method.visit_u64\n    fn visit_u16\u003cE\u003e(self, v: u16) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n\n    /// The input contains a `u32`.\n    ///\n    /// The default implementation forwards to [`visit_u64`].\n    ///\n    /// [`visit_u64`]: #method.visit_u64\n    fn visit_u32\u003cE\u003e(self, v: u32) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n\n    /// The input contains a `u64`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_u64\u003cE\u003e(self, v: u64) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Unsigned(v), \u0026self))\n    }\n\n    serde_if_integer128! {\n        /// The input contains a `u128`.\n        ///\n        /// This method is available only on Rust compiler versions \u003e=1.26. The\n        /// default implementation fails with a type error.\n        fn visit_u128\u003cE\u003e(self, v: u128) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            let _ = v;\n            Err(Error::invalid_type(Unexpected::Other(\"u128\"), \u0026self))\n        }\n    }\n\n    /// The input contains an `f32`.\n    ///\n    /// The default implementation forwards to [`visit_f64`].\n    ///\n    /// [`visit_f64`]: #method.visit_f64\n    fn visit_f32\u003cE\u003e(self, v: f32) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_f64(v as f64)\n    }\n\n    /// The input contains an `f64`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_f64\u003cE\u003e(self, v: f64) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Float(v), \u0026self))\n    }\n\n    /// The input contains a `char`.\n    ///\n    /// The default implementation forwards to [`visit_str`] as a one-character\n    /// string.\n    ///\n    /// [`visit_str`]: #method.visit_str\n    #[inline]\n    fn visit_char\u003cE\u003e(self, v: char) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_str(utf8::encode(v).as_str())\n    }\n\n    /// The input contains a string. The lifetime of the string is ephemeral and\n    /// it may be destroyed after this method returns.\n    ///\n    /// This method allows the `Deserializer` to avoid a copy by retaining\n    /// ownership of any buffered data. `Deserialize` implementations that do\n    /// not benefit from taking ownership of `String` data should indicate that\n    /// to the deserializer by using `Deserializer::deserialize_str` rather than\n    /// `Deserializer::deserialize_string`.\n    ///\n    /// It is never correct to implement `visit_string` without implementing\n    /// `visit_str`. Implement neither, both, or just `visit_str`.\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Str(v), \u0026self))\n    }\n\n    /// The input contains a string that lives at least as long as the\n    /// `Deserializer`.\n    ///\n    /// This enables zero-copy deserialization of strings in some formats. For\n    /// example JSON input containing the JSON string `\"borrowed\"` can be\n    /// deserialized with zero copying into a `\u0026'a str` as long as the input\n    /// data outlives `'a`.\n    ///\n    /// The default implementation forwards to `visit_str`.\n    #[inline]\n    fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'de str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_str(v)\n    }\n\n    /// The input contains a string and ownership of the string is being given\n    /// to the `Visitor`.\n    ///\n    /// This method allows the `Visitor` to avoid a copy by taking ownership of\n    /// a string created by the `Deserializer`. `Deserialize` implementations\n    /// that benefit from taking ownership of `String` data should indicate that\n    /// to the deserializer by using `Deserializer::deserialize_string` rather\n    /// than `Deserializer::deserialize_str`, although not every deserializer\n    /// will honor such a request.\n    ///\n    /// It is never correct to implement `visit_string` without implementing\n    /// `visit_str`. Implement neither, both, or just `visit_str`.\n    ///\n    /// The default implementation forwards to `visit_str` and then drops the\n    /// `String`.\n    #[inline]\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_str(\u0026v)\n    }\n\n    /// The input contains a byte array. The lifetime of the byte array is\n    /// ephemeral and it may be destroyed after this method returns.\n    ///\n    /// This method allows the `Deserializer` to avoid a copy by retaining\n    /// ownership of any buffered data. `Deserialize` implementations that do\n    /// not benefit from taking ownership of `Vec\u003cu8\u003e` data should indicate that\n    /// to the deserializer by using `Deserializer::deserialize_bytes` rather\n    /// than `Deserializer::deserialize_byte_buf`.\n    ///\n    /// It is never correct to implement `visit_byte_buf` without implementing\n    /// `visit_bytes`. Implement neither, both, or just `visit_bytes`.\n    fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        let _ = v;\n        Err(Error::invalid_type(Unexpected::Bytes(v), \u0026self))\n    }\n\n    /// The input contains a byte array that lives at least as long as the\n    /// `Deserializer`.\n    ///\n    /// This enables zero-copy deserialization of bytes in some formats. For\n    /// example Bincode data containing bytes can be deserialized with zero\n    /// copying into a `\u0026'a [u8]` as long as the input data outlives `'a`.\n    ///\n    /// The default implementation forwards to `visit_bytes`.\n    #[inline]\n    fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'de [u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_bytes(v)\n    }\n\n    /// The input contains a byte array and ownership of the byte array is being\n    /// given to the `Visitor`.\n    ///\n    /// This method allows the `Visitor` to avoid a copy by taking ownership of\n    /// a byte buffer created by the `Deserializer`. `Deserialize`\n    /// implementations that benefit from taking ownership of `Vec\u003cu8\u003e` data\n    /// should indicate that to the deserializer by using\n    /// `Deserializer::deserialize_byte_buf` rather than\n    /// `Deserializer::deserialize_bytes`, although not every deserializer will\n    /// honor such a request.\n    ///\n    /// It is never correct to implement `visit_byte_buf` without implementing\n    /// `visit_bytes`. Implement neither, both, or just `visit_bytes`.\n    ///\n    /// The default implementation forwards to `visit_bytes` and then drops the\n    /// `Vec\u003cu8\u003e`.\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_bytes(\u0026v)\n    }\n\n    /// The input contains an optional that is absent.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_none\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Option, \u0026self))\n    }\n\n    /// The input contains an optional that is present.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let _ = deserializer;\n        Err(Error::invalid_type(Unexpected::Option, \u0026self))\n    }\n\n    /// The input contains a unit `()`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Unit, \u0026self))\n    }\n\n    /// The input contains a newtype struct.\n    ///\n    /// The content of the newtype struct may be read from the given\n    /// `Deserializer`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_newtype_struct\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let _ = deserializer;\n        Err(Error::invalid_type(Unexpected::NewtypeStruct, \u0026self))\n    }\n\n    /// The input contains a sequence of elements.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_seq\u003cA\u003e(self, seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: SeqAccess\u003c'de\u003e,\n    {\n        let _ = seq;\n        Err(Error::invalid_type(Unexpected::Seq, \u0026self))\n    }\n\n    /// The input contains a key-value map.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_map\u003cA\u003e(self, map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: MapAccess\u003c'de\u003e,\n    {\n        let _ = map;\n        Err(Error::invalid_type(Unexpected::Map, \u0026self))\n    }\n\n    /// The input contains an enum.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: EnumAccess\u003c'de\u003e,\n    {\n        let _ = data;\n        Err(Error::invalid_type(Unexpected::Enum, \u0026self))\n    }\n\n    // Used when deserializing a flattened Option field. Not public API.\n    #[doc(hidden)]\n    fn __private_visit_untagged_option\u003cD\u003e(self, _: D) -\u003e Result\u003cSelf::Value, ()\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Err(())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Provides a `Visitor` access to each element of a sequence in the input.\n///\n/// This is a trait that a `Deserializer` passes to a `Visitor` implementation,\n/// which deserializes each item in a sequence.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by deserialized sequence elements. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SeqAccess` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SeqAccess\u003c'de\u003e {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization.\n    type Error: Error;\n\n    /// This returns `Ok(Some(value))` for the next value in the sequence, or\n    /// `Ok(None)` if there are no more remaining items.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `SeqAccess::next_element` instead.\n    fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e;\n\n    /// This returns `Ok(Some(value))` for the next value in the sequence, or\n    /// `Ok(None)` if there are no more remaining items.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `SeqAccess` implementations should not override the default behavior.\n    #[inline]\n    fn next_element\u003cT\u003e(\u0026mut self) -\u003e Result\u003cOption\u003cT\u003e, Self::Error\u003e\n    where\n        T: Deserialize\u003c'de\u003e,\n    {\n        self.next_element_seed(PhantomData)\n    }\n\n    /// Returns the number of elements remaining in the sequence, if known.\n    #[inline]\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        None\n    }\n}\n\nimpl\u003c'de, 'a, A\u003e SeqAccess\u003c'de\u003e for \u0026'a mut A\nwhere\n    A: SeqAccess\u003c'de\u003e,\n{\n    type Error = A::Error;\n\n    #[inline]\n    fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        (**self).next_element_seed(seed)\n    }\n\n    #[inline]\n    fn next_element\u003cT\u003e(\u0026mut self) -\u003e Result\u003cOption\u003cT\u003e, Self::Error\u003e\n    where\n        T: Deserialize\u003c'de\u003e,\n    {\n        (**self).next_element()\n    }\n\n    #[inline]\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        (**self).size_hint()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Provides a `Visitor` access to each entry of a map in the input.\n///\n/// This is a trait that a `Deserializer` passes to a `Visitor` implementation.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by deserialized map entries. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `MapAccess` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait MapAccess\u003c'de\u003e {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization.\n    type Error: Error;\n\n    /// This returns `Ok(Some(key))` for the next key in the map, or `Ok(None)`\n    /// if there are no more remaining entries.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `MapAccess::next_key` or `MapAccess::next_entry` instead.\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e;\n\n    /// This returns a `Ok(value)` for the next value in the map.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `MapAccess::next_value` instead.\n    ///\n    /// # Panics\n    ///\n    /// Calling `next_value_seed` before `next_key_seed` is incorrect and is\n    /// allowed to panic or return bogus results.\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e;\n\n    /// This returns `Ok(Some((key, value)))` for the next (key-value) pair in\n    /// the map, or `Ok(None)` if there are no more remaining items.\n    ///\n    /// `MapAccess` implementations should override the default behavior if a\n    /// more efficient implementation is possible.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `MapAccess::next_entry` instead.\n    #[inline]\n    fn next_entry_seed\u003cK, V\u003e(\n        \u0026mut self,\n        kseed: K,\n        vseed: V,\n    ) -\u003e Result\u003cOption\u003c(K::Value, V::Value)\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        match try!(self.next_key_seed(kseed)) {\n            Some(key) =\u003e {\n                let value = try!(self.next_value_seed(vseed));\n                Ok(Some((key, value)))\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    /// This returns `Ok(Some(key))` for the next key in the map, or `Ok(None)`\n    /// if there are no more remaining entries.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `MapAccess` implementations should not override the default behavior.\n    #[inline]\n    fn next_key\u003cK\u003e(\u0026mut self) -\u003e Result\u003cOption\u003cK\u003e, Self::Error\u003e\n    where\n        K: Deserialize\u003c'de\u003e,\n    {\n        self.next_key_seed(PhantomData)\n    }\n\n    /// This returns a `Ok(value)` for the next value in the map.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `MapAccess` implementations should not override the default behavior.\n    ///\n    /// # Panics\n    ///\n    /// Calling `next_value` before `next_key` is incorrect and is allowed to\n    /// panic or return bogus results.\n    #[inline]\n    fn next_value\u003cV\u003e(\u0026mut self) -\u003e Result\u003cV, Self::Error\u003e\n    where\n        V: Deserialize\u003c'de\u003e,\n    {\n        self.next_value_seed(PhantomData)\n    }\n\n    /// This returns `Ok(Some((key, value)))` for the next (key-value) pair in\n    /// the map, or `Ok(None)` if there are no more remaining items.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `MapAccess` implementations should not override the default behavior.\n    #[inline]\n    fn next_entry\u003cK, V\u003e(\u0026mut self) -\u003e Result\u003cOption\u003c(K, V)\u003e, Self::Error\u003e\n    where\n        K: Deserialize\u003c'de\u003e,\n        V: Deserialize\u003c'de\u003e,\n    {\n        self.next_entry_seed(PhantomData, PhantomData)\n    }\n\n    /// Returns the number of entries remaining in the map, if known.\n    #[inline]\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        None\n    }\n}\n\nimpl\u003c'de, 'a, A\u003e MapAccess\u003c'de\u003e for \u0026'a mut A\nwhere\n    A: MapAccess\u003c'de\u003e,\n{\n    type Error = A::Error;\n\n    #[inline]\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n    {\n        (**self).next_key_seed(seed)\n    }\n\n    #[inline]\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        (**self).next_value_seed(seed)\n    }\n\n    #[inline]\n    fn next_entry_seed\u003cK, V\u003e(\n        \u0026mut self,\n        kseed: K,\n        vseed: V,\n    ) -\u003e Result\u003cOption\u003c(K::Value, V::Value)\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        (**self).next_entry_seed(kseed, vseed)\n    }\n\n    #[inline]\n    fn next_entry\u003cK, V\u003e(\u0026mut self) -\u003e Result\u003cOption\u003c(K, V)\u003e, Self::Error\u003e\n    where\n        K: Deserialize\u003c'de\u003e,\n        V: Deserialize\u003c'de\u003e,\n    {\n        (**self).next_entry()\n    }\n\n    #[inline]\n    fn next_key\u003cK\u003e(\u0026mut self) -\u003e Result\u003cOption\u003cK\u003e, Self::Error\u003e\n    where\n        K: Deserialize\u003c'de\u003e,\n    {\n        (**self).next_key()\n    }\n\n    #[inline]\n    fn next_value\u003cV\u003e(\u0026mut self) -\u003e Result\u003cV, Self::Error\u003e\n    where\n        V: Deserialize\u003c'de\u003e,\n    {\n        (**self).next_value()\n    }\n\n    #[inline]\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        (**self).size_hint()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Provides a `Visitor` access to the data of an enum in the input.\n///\n/// `EnumAccess` is created by the `Deserializer` and passed to the\n/// `Visitor` in order to identify which variant of an enum to deserialize.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by the deserialized enum variant. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `EnumAccess` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait EnumAccess\u003c'de\u003e: Sized {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization.\n    type Error: Error;\n    /// The `Visitor` that will be used to deserialize the content of the enum\n    /// variant.\n    type Variant: VariantAccess\u003c'de, Error = Self::Error\u003e;\n\n    /// `variant` is called to identify which variant to deserialize.\n    ///\n    /// `Deserialize` implementations should typically use `EnumAccess::variant`\n    /// instead.\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e;\n\n    /// `variant` is called to identify which variant to deserialize.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `EnumAccess` implementations should not override the default behavior.\n    #[inline]\n    fn variant\u003cV\u003e(self) -\u003e Result\u003c(V, Self::Variant), Self::Error\u003e\n    where\n        V: Deserialize\u003c'de\u003e,\n    {\n        self.variant_seed(PhantomData)\n    }\n}\n\n/// `VariantAccess` is a visitor that is created by the `Deserializer` and\n/// passed to the `Deserialize` to deserialize the content of a particular enum\n/// variant.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by the deserialized enum variant. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `VariantAccess` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait VariantAccess\u003c'de\u003e: Sized {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization. Must match the error type of our `EnumAccess`.\n    type Error: Error;\n\n    /// Called when deserializing a variant with no values.\n    ///\n    /// If the data contains a different type of variant, the following\n    /// `invalid_type` error should be constructed:\n    ///\n    /// ```edition2018\n    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n    /// #\n    /// # struct X;\n    /// #\n    /// # impl\u003c'de\u003e VariantAccess\u003c'de\u003e for X {\n    /// #     type Error = value::Error;\n    /// #\n    /// fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n    ///     // What the data actually contained; suppose it is a tuple variant.\n    ///     let unexp = Unexpected::TupleVariant;\n    ///     Err(de::Error::invalid_type(unexp, \u0026\"unit variant\"))\n    /// }\n    /// #\n    /// #     fn newtype_variant_seed\u003cT\u003e(self, _: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    /// #     where\n    /// #         T: DeserializeSeed\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// #\n    /// #     fn tuple_variant\u003cV\u003e(self, _: usize, _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// #     where\n    /// #         V: Visitor\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// #\n    /// #     fn struct_variant\u003cV\u003e(self, _: \u0026[\u0026str], _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// #     where\n    /// #         V: Visitor\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// # }\n    /// ```\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Called when deserializing a variant with a single value.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `VariantAccess::newtype_variant` instead.\n    ///\n    /// If the data contains a different type of variant, the following\n    /// `invalid_type` error should be constructed:\n    ///\n    /// ```edition2018\n    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n    /// #\n    /// # struct X;\n    /// #\n    /// # impl\u003c'de\u003e VariantAccess\u003c'de\u003e for X {\n    /// #     type Error = value::Error;\n    /// #\n    /// #     fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n    /// #         unimplemented!()\n    /// #     }\n    /// #\n    /// fn newtype_variant_seed\u003cT\u003e(self, _seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    /// where\n    ///     T: DeserializeSeed\u003c'de\u003e,\n    /// {\n    ///     // What the data actually contained; suppose it is a unit variant.\n    ///     let unexp = Unexpected::UnitVariant;\n    ///     Err(de::Error::invalid_type(unexp, \u0026\"newtype variant\"))\n    /// }\n    /// #\n    /// #     fn tuple_variant\u003cV\u003e(self, _: usize, _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// #     where\n    /// #         V: Visitor\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// #\n    /// #     fn struct_variant\u003cV\u003e(self, _: \u0026[\u0026str], _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// #     where\n    /// #         V: Visitor\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// # }\n    /// ```\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e;\n\n    /// Called when deserializing a variant with a single value.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `VariantAccess` implementations should not override the default\n    /// behavior.\n    #[inline]\n    fn newtype_variant\u003cT\u003e(self) -\u003e Result\u003cT, Self::Error\u003e\n    where\n        T: Deserialize\u003c'de\u003e,\n    {\n        self.newtype_variant_seed(PhantomData)\n    }\n\n    /// Called when deserializing a tuple-like variant.\n    ///\n    /// The `len` is the number of fields expected in the tuple variant.\n    ///\n    /// If the data contains a different type of variant, the following\n    /// `invalid_type` error should be constructed:\n    ///\n    /// ```edition2018\n    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n    /// #\n    /// # struct X;\n    /// #\n    /// # impl\u003c'de\u003e VariantAccess\u003c'de\u003e for X {\n    /// #     type Error = value::Error;\n    /// #\n    /// #     fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n    /// #         unimplemented!()\n    /// #     }\n    /// #\n    /// #     fn newtype_variant_seed\u003cT\u003e(self, _: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    /// #     where\n    /// #         T: DeserializeSeed\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// #\n    /// fn tuple_variant\u003cV\u003e(\n    ///     self,\n    ///     _len: usize,\n    ///     _visitor: V,\n    /// ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// where\n    ///     V: Visitor\u003c'de\u003e,\n    /// {\n    ///     // What the data actually contained; suppose it is a unit variant.\n    ///     let unexp = Unexpected::UnitVariant;\n    ///     Err(de::Error::invalid_type(unexp, \u0026\"tuple variant\"))\n    /// }\n    /// #\n    /// #     fn struct_variant\u003cV\u003e(self, _: \u0026[\u0026str], _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// #     where\n    /// #         V: Visitor\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// # }\n    /// ```\n    fn tuple_variant\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Called when deserializing a struct-like variant.\n    ///\n    /// The `fields` are the names of the fields of the struct variant.\n    ///\n    /// If the data contains a different type of variant, the following\n    /// `invalid_type` error should be constructed:\n    ///\n    /// ```edition2018\n    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n    /// #\n    /// # struct X;\n    /// #\n    /// # impl\u003c'de\u003e VariantAccess\u003c'de\u003e for X {\n    /// #     type Error = value::Error;\n    /// #\n    /// #     fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n    /// #         unimplemented!()\n    /// #     }\n    /// #\n    /// #     fn newtype_variant_seed\u003cT\u003e(self, _: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    /// #     where\n    /// #         T: DeserializeSeed\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// #\n    /// #     fn tuple_variant\u003cV\u003e(self, _: usize, _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// #     where\n    /// #         V: Visitor\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// #\n    /// fn struct_variant\u003cV\u003e(\n    ///     self,\n    ///     _fields: \u0026'static [\u0026'static str],\n    ///     _visitor: V,\n    /// ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// where\n    ///     V: Visitor\u003c'de\u003e,\n    /// {\n    ///     // What the data actually contained; suppose it is a unit variant.\n    ///     let unexp = Unexpected::UnitVariant;\n    ///     Err(de::Error::invalid_type(unexp, \u0026\"struct variant\"))\n    /// }\n    /// # }\n    /// ```\n    fn struct_variant\u003cV\u003e(\n        self,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Converts an existing value into a `Deserializer` from which other values can\n/// be deserialized.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed from the resulting `Deserializer`. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example\n///\n/// ```edition2018\n/// use std::str::FromStr;\n/// use serde::Deserialize;\n/// use serde::de::{value, IntoDeserializer};\n///\n/// #[derive(Deserialize)]\n/// enum Setting {\n///     On,\n///     Off,\n/// }\n///\n/// impl FromStr for Setting {\n///     type Err = value::Error;\n///\n///     fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n///         Self::deserialize(s.into_deserializer())\n///     }\n/// }\n/// ```\npub trait IntoDeserializer\u003c'de, E: Error = value::Error\u003e {\n    /// The type of the deserializer being converted into.\n    type Deserializer: Deserializer\u003c'de, Error = E\u003e;\n\n    /// Convert this value into a deserializer.\n    fn into_deserializer(self) -\u003e Self::Deserializer;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Used in error messages.\n///\n/// - expected `a`\n/// - expected `a` or `b`\n/// - expected one of `a`, `b`, `c`\n///\n/// The slice of names must not be empty.\nstruct OneOf {\n    names: \u0026'static [\u0026'static str],\n}\n\nimpl Display for OneOf {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self.names.len() {\n            0 =\u003e panic!(), // special case elsewhere\n            1 =\u003e write!(formatter, \"`{}`\", self.names[0]),\n            2 =\u003e write!(formatter, \"`{}` or `{}`\", self.names[0], self.names[1]),\n            _ =\u003e {\n                try!(write!(formatter, \"one of \"));\n                for (i, alt) in self.names.iter().enumerate() {\n                    if i \u003e 0 {\n                        try!(write!(formatter, \", \"));\n                    }\n                    try!(write!(formatter, \"`{}`\", alt));\n                }\n                Ok(())\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","utf8.rs"],"content":"use lib::*;\n\nconst TAG_CONT: u8 = 0b1000_0000;\nconst TAG_TWO_B: u8 = 0b1100_0000;\nconst TAG_THREE_B: u8 = 0b1110_0000;\nconst TAG_FOUR_B: u8 = 0b1111_0000;\nconst MAX_ONE_B: u32 = 0x80;\nconst MAX_TWO_B: u32 = 0x800;\nconst MAX_THREE_B: u32 = 0x10000;\n\n#[inline]\npub fn encode(c: char) -\u003e Encode {\n    let code = c as u32;\n    let mut buf = [0; 4];\n    let pos = if code \u003c MAX_ONE_B {\n        buf[3] = code as u8;\n        3\n    } else if code \u003c MAX_TWO_B {\n        buf[2] = (code \u003e\u003e 6 \u0026 0x1F) as u8 | TAG_TWO_B;\n        buf[3] = (code \u0026 0x3F) as u8 | TAG_CONT;\n        2\n    } else if code \u003c MAX_THREE_B {\n        buf[1] = (code \u003e\u003e 12 \u0026 0x0F) as u8 | TAG_THREE_B;\n        buf[2] = (code \u003e\u003e 6 \u0026 0x3F) as u8 | TAG_CONT;\n        buf[3] = (code \u0026 0x3F) as u8 | TAG_CONT;\n        1\n    } else {\n        buf[0] = (code \u003e\u003e 18 \u0026 0x07) as u8 | TAG_FOUR_B;\n        buf[1] = (code \u003e\u003e 12 \u0026 0x3F) as u8 | TAG_CONT;\n        buf[2] = (code \u003e\u003e 6 \u0026 0x3F) as u8 | TAG_CONT;\n        buf[3] = (code \u0026 0x3F) as u8 | TAG_CONT;\n        0\n    };\n    Encode { buf: buf, pos: pos }\n}\n\npub struct Encode {\n    buf: [u8; 4],\n    pos: usize,\n}\n\nimpl Encode {\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        str::from_utf8(\u0026self.buf[self.pos..]).unwrap()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","value.rs"],"content":"//! Building blocks for deserializing basic values using the `IntoDeserializer`\n//! trait.\n//!\n//! ```edition2018\n//! use std::str::FromStr;\n//! use serde::Deserialize;\n//! use serde::de::{value, IntoDeserializer};\n//!\n//! #[derive(Deserialize)]\n//! enum Setting {\n//!     On,\n//!     Off,\n//! }\n//!\n//! impl FromStr for Setting {\n//!     type Err = value::Error;\n//!\n//!     fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n//!         Self::deserialize(s.into_deserializer())\n//!     }\n//! }\n//! ```\n\nuse lib::*;\n\nuse self::private::{First, Second};\nuse de::{self, Expected, IntoDeserializer, SeqAccess};\nuse private::de::size_hint;\nuse ser;\n\n////////////////////////////////////////////////////////////////////////////////\n\n// For structs that contain a PhantomData. We do not want the trait\n// bound `E: Clone` inferred by derive(Clone).\nmacro_rules! impl_copy_clone {\n    ($ty:ident $(\u003c$lifetime:tt\u003e)*) =\u003e {\n        impl\u003c$($lifetime,)* E\u003e Copy for $ty\u003c$($lifetime,)* E\u003e {}\n\n        impl\u003c$($lifetime,)* E\u003e Clone for $ty\u003c$($lifetime,)* E\u003e {\n            fn clone(\u0026self) -\u003e Self {\n                *self\n            }\n        }\n    };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A minimal representation of all possible errors that can occur using the\n/// `IntoDeserializer` trait.\n#[derive(Clone, Debug, PartialEq)]\npub struct Error {\n    err: ErrorImpl,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\ntype ErrorImpl = Box\u003cstr\u003e;\n#[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\ntype ErrorImpl = ();\n\nimpl de::Error for Error {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cold]\n    fn custom\u003cT\u003e(msg: T) -\u003e Self\n    where\n        T: Display,\n    {\n        Error {\n            err: msg.to_string().into_boxed_str(),\n        }\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    #[cold]\n    fn custom\u003cT\u003e(msg: T) -\u003e Self\n    where\n        T: Display,\n    {\n        let _ = msg;\n        Error { err: () }\n    }\n}\n\nimpl ser::Error for Error {\n    #[cold]\n    fn custom\u003cT\u003e(msg: T) -\u003e Self\n    where\n        T: Display,\n    {\n        de::Error::custom(msg)\n    }\n}\n\nimpl Display for Error {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e Result\u003c(), fmt::Error\u003e {\n        formatter.write_str(\u0026self.err)\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e Result\u003c(), fmt::Error\u003e {\n        formatter.write_str(\"Serde deserialization error\")\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl error::Error for Error {\n    fn description(\u0026self) -\u003e \u0026str {\n        \u0026self.err\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003c'de, E\u003e IntoDeserializer\u003c'de, E\u003e for ()\nwhere\n    E: de::Error,\n{\n    type Deserializer = UnitDeserializer\u003cE\u003e;\n\n    fn into_deserializer(self) -\u003e UnitDeserializer\u003cE\u003e {\n        UnitDeserializer {\n            marker: PhantomData,\n        }\n    }\n}\n\n/// A deserializer holding a `()`.\n#[derive(Debug)]\npub struct UnitDeserializer\u003cE\u003e {\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl_copy_clone!(UnitDeserializer);\n\nimpl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for UnitDeserializer\u003cE\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf unit unit_struct newtype_struct seq tuple tuple_struct\n        map struct enum identifier ignored_any\n    }\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_unit()\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_none()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer that cannot be instantiated.\n#[cfg(feature = \"unstable\")]\npub struct NeverDeserializer\u003cE\u003e {\n    never: !,\n    marker: PhantomData\u003cE\u003e,\n}\n\n#[cfg(feature = \"unstable\")]\nimpl\u003c'de, E\u003e IntoDeserializer\u003c'de, E\u003e for !\nwhere\n    E: de::Error,\n{\n    type Deserializer = NeverDeserializer\u003cE\u003e;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        self\n    }\n}\n\n#[cfg(feature = \"unstable\")]\nimpl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for NeverDeserializer\u003cE\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        self.never\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! primitive_deserializer {\n    ($ty:ty, $doc:tt, $name:ident, $method:ident $($cast:tt)*) =\u003e {\n        #[doc = \"A deserializer holding\"]\n        #[doc = $doc]\n        #[derive(Debug)]\n        pub struct $name\u003cE\u003e {\n            value: $ty,\n            marker: PhantomData\u003cE\u003e\n        }\n\n        impl_copy_clone!($name);\n\n        impl\u003c'de, E\u003e IntoDeserializer\u003c'de, E\u003e for $ty\n        where\n            E: de::Error,\n        {\n            type Deserializer = $name\u003cE\u003e;\n\n            fn into_deserializer(self) -\u003e $name\u003cE\u003e {\n                $name {\n                    value: self,\n                    marker: PhantomData,\n                }\n            }\n        }\n\n        impl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for $name\u003cE\u003e\n        where\n            E: de::Error,\n        {\n            type Error = E;\n\n            forward_to_deserialize_any! {\n                bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str\n                string bytes byte_buf option unit unit_struct newtype_struct seq\n                tuple tuple_struct map struct enum identifier ignored_any\n            }\n\n            fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n            where\n                V: de::Visitor\u003c'de\u003e,\n            {\n                visitor.$method(self.value $($cast)*)\n            }\n        }\n    }\n}\n\nprimitive_deserializer!(bool, \"a `bool`.\", BoolDeserializer, visit_bool);\nprimitive_deserializer!(i8, \"an `i8`.\", I8Deserializer, visit_i8);\nprimitive_deserializer!(i16, \"an `i16`.\", I16Deserializer, visit_i16);\nprimitive_deserializer!(i32, \"an `i32`.\", I32Deserializer, visit_i32);\nprimitive_deserializer!(i64, \"an `i64`.\", I64Deserializer, visit_i64);\nprimitive_deserializer!(isize, \"an `isize`.\", IsizeDeserializer, visit_i64 as i64);\nprimitive_deserializer!(u8, \"a `u8`.\", U8Deserializer, visit_u8);\nprimitive_deserializer!(u16, \"a `u16`.\", U16Deserializer, visit_u16);\nprimitive_deserializer!(u64, \"a `u64`.\", U64Deserializer, visit_u64);\nprimitive_deserializer!(usize, \"a `usize`.\", UsizeDeserializer, visit_u64 as u64);\nprimitive_deserializer!(f32, \"an `f32`.\", F32Deserializer, visit_f32);\nprimitive_deserializer!(f64, \"an `f64`.\", F64Deserializer, visit_f64);\nprimitive_deserializer!(char, \"a `char`.\", CharDeserializer, visit_char);\n\nserde_if_integer128! {\n    primitive_deserializer!(i128, \"an `i128`.\", I128Deserializer, visit_i128);\n    primitive_deserializer!(u128, \"a `u128`.\", U128Deserializer, visit_u128);\n}\n\n/// A deserializer holding a `u32`.\n#[derive(Debug)]\npub struct U32Deserializer\u003cE\u003e {\n    value: u32,\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl_copy_clone!(U32Deserializer);\n\nimpl\u003c'de, E\u003e IntoDeserializer\u003c'de, E\u003e for u32\nwhere\n    E: de::Error,\n{\n    type Deserializer = U32Deserializer\u003cE\u003e;\n\n    fn into_deserializer(self) -\u003e U32Deserializer\u003cE\u003e {\n        U32Deserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for U32Deserializer\u003cE\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_u32(self.value)\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n}\n\nimpl\u003c'de, E\u003e de::EnumAccess\u003c'de\u003e for U32Deserializer\u003cE\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly\u003cE\u003e;\n\n    fn variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003c(T::Value, Self::Variant), Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `\u0026str`.\n#[derive(Debug)]\npub struct StrDeserializer\u003c'a, E\u003e {\n    value: \u0026'a str,\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl_copy_clone!(StrDeserializer\u003c'de\u003e);\n\nimpl\u003c'de, 'a, E\u003e IntoDeserializer\u003c'de, E\u003e for \u0026'a str\nwhere\n    E: de::Error,\n{\n    type Deserializer = StrDeserializer\u003c'a, E\u003e;\n\n    fn into_deserializer(self) -\u003e StrDeserializer\u003c'a, E\u003e {\n        StrDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, 'a, E\u003e de::Deserializer\u003c'de\u003e for StrDeserializer\u003c'a, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_str(self.value)\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\nimpl\u003c'de, 'a, E\u003e de::EnumAccess\u003c'de\u003e for StrDeserializer\u003c'a, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly\u003cE\u003e;\n\n    fn variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003c(T::Value, Self::Variant), Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `\u0026str` with a lifetime tied to another\n/// deserializer.\n#[derive(Debug)]\npub struct BorrowedStrDeserializer\u003c'de, E\u003e {\n    value: \u0026'de str,\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl_copy_clone!(BorrowedStrDeserializer\u003c'de\u003e);\n\nimpl\u003c'de, E\u003e BorrowedStrDeserializer\u003c'de, E\u003e {\n    /// Create a new borrowed deserializer from the given string.\n    pub fn new(value: \u0026'de str) -\u003e BorrowedStrDeserializer\u003c'de, E\u003e {\n        BorrowedStrDeserializer {\n            value: value,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for BorrowedStrDeserializer\u003c'de, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_borrowed_str(self.value)\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\nimpl\u003c'de, E\u003e de::EnumAccess\u003c'de\u003e for BorrowedStrDeserializer\u003c'de, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly\u003cE\u003e;\n\n    fn variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003c(T::Value, Self::Variant), Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `String`.\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[derive(Debug)]\npub struct StringDeserializer\u003cE\u003e {\n    value: String,\n    marker: PhantomData\u003cE\u003e,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003cE\u003e Clone for StringDeserializer\u003cE\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        StringDeserializer {\n            value: self.value.clone(),\n            marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, E\u003e IntoDeserializer\u003c'de, E\u003e for String\nwhere\n    E: de::Error,\n{\n    type Deserializer = StringDeserializer\u003cE\u003e;\n\n    fn into_deserializer(self) -\u003e StringDeserializer\u003cE\u003e {\n        StringDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for StringDeserializer\u003cE\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_string(self.value)\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, 'a, E\u003e de::EnumAccess\u003c'de\u003e for StringDeserializer\u003cE\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly\u003cE\u003e;\n\n    fn variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003c(T::Value, Self::Variant), Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `Cow\u003cstr\u003e`.\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[derive(Debug)]\npub struct CowStrDeserializer\u003c'a, E\u003e {\n    value: Cow\u003c'a, str\u003e,\n    marker: PhantomData\u003cE\u003e,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, E\u003e Clone for CowStrDeserializer\u003c'a, E\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        CowStrDeserializer {\n            value: self.value.clone(),\n            marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, 'a, E\u003e IntoDeserializer\u003c'de, E\u003e for Cow\u003c'a, str\u003e\nwhere\n    E: de::Error,\n{\n    type Deserializer = CowStrDeserializer\u003c'a, E\u003e;\n\n    fn into_deserializer(self) -\u003e CowStrDeserializer\u003c'a, E\u003e {\n        CowStrDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, 'a, E\u003e de::Deserializer\u003c'de\u003e for CowStrDeserializer\u003c'a, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        match self.value {\n            Cow::Borrowed(string) =\u003e visitor.visit_str(string),\n            Cow::Owned(string) =\u003e visitor.visit_string(string),\n        }\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, 'a, E\u003e de::EnumAccess\u003c'de\u003e for CowStrDeserializer\u003c'a, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly\u003cE\u003e;\n\n    fn variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003c(T::Value, Self::Variant), Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `\u0026[u8]` with a lifetime tied to another\n/// deserializer.\n#[derive(Debug)]\npub struct BorrowedBytesDeserializer\u003c'de, E\u003e {\n    value: \u0026'de [u8],\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl_copy_clone!(BorrowedBytesDeserializer\u003c'de\u003e);\n\nimpl\u003c'de, E\u003e BorrowedBytesDeserializer\u003c'de, E\u003e {\n    /// Create a new borrowed deserializer from the given byte slice.\n    pub fn new(value: \u0026'de [u8]) -\u003e BorrowedBytesDeserializer\u003c'de, E\u003e {\n        BorrowedBytesDeserializer {\n            value: value,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for BorrowedBytesDeserializer\u003c'de, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_borrowed_bytes(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any enum\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer that iterates over a sequence.\n#[derive(Clone, Debug)]\npub struct SeqDeserializer\u003cI, E\u003e {\n    iter: iter::Fuse\u003cI\u003e,\n    count: usize,\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl\u003cI, E\u003e SeqDeserializer\u003cI, E\u003e\nwhere\n    I: Iterator,\n{\n    /// Construct a new `SeqDeserializer\u003cI, E\u003e`.\n    pub fn new(iter: I) -\u003e Self {\n        SeqDeserializer {\n            iter: iter.fuse(),\n            count: 0,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003cI, E\u003e SeqDeserializer\u003cI, E\u003e\nwhere\n    I: Iterator,\n    E: de::Error,\n{\n    /// Check for remaining elements after passing a `SeqDeserializer` to\n    /// `Visitor::visit_seq`.\n    pub fn end(self) -\u003e Result\u003c(), E\u003e {\n        let remaining = self.iter.count();\n        if remaining == 0 {\n            Ok(())\n        } else {\n            // First argument is the number of elements in the data, second\n            // argument is the number of elements expected by the Deserialize.\n            Err(de::Error::invalid_length(\n                self.count + remaining,\n                \u0026ExpectedInSeq(self.count),\n            ))\n        }\n    }\n}\n\nimpl\u003c'de, I, T, E\u003e de::Deserializer\u003c'de\u003e for SeqDeserializer\u003cI, E\u003e\nwhere\n    I: Iterator\u003cItem = T\u003e,\n    T: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let v = try!(visitor.visit_seq(\u0026mut self));\n        try!(self.end());\n        Ok(v)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\nimpl\u003c'de, I, T, E\u003e de::SeqAccess\u003c'de\u003e for SeqDeserializer\u003cI, E\u003e\nwhere\n    I: Iterator\u003cItem = T\u003e,\n    T: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn next_element_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cOption\u003cV::Value\u003e, Self::Error\u003e\n    where\n        V: de::DeserializeSeed\u003c'de\u003e,\n    {\n        match self.iter.next() {\n            Some(value) =\u003e {\n                self.count += 1;\n                seed.deserialize(value.into_deserializer()).map(Some)\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        size_hint::from_bounds(\u0026self.iter)\n    }\n}\n\nstruct ExpectedInSeq(usize);\n\nimpl Expected for ExpectedInSeq {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        if self.0 == 1 {\n            write!(formatter, \"1 element in sequence\")\n        } else {\n            write!(formatter, \"{} elements in sequence\", self.0)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, T, E\u003e IntoDeserializer\u003c'de, E\u003e for Vec\u003cT\u003e\nwhere\n    T: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Deserializer = SeqDeserializer\u003c\u003cSelf as IntoIterator\u003e::IntoIter, E\u003e;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        SeqDeserializer::new(self.into_iter())\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, T, E\u003e IntoDeserializer\u003c'de, E\u003e for BTreeSet\u003cT\u003e\nwhere\n    T: IntoDeserializer\u003c'de, E\u003e + Eq + Ord,\n    E: de::Error,\n{\n    type Deserializer = SeqDeserializer\u003c\u003cSelf as IntoIterator\u003e::IntoIter, E\u003e;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        SeqDeserializer::new(self.into_iter())\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de, T, S, E\u003e IntoDeserializer\u003c'de, E\u003e for HashSet\u003cT, S\u003e\nwhere\n    T: IntoDeserializer\u003c'de, E\u003e + Eq + Hash,\n    S: BuildHasher,\n    E: de::Error,\n{\n    type Deserializer = SeqDeserializer\u003c\u003cSelf as IntoIterator\u003e::IntoIter, E\u003e;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        SeqDeserializer::new(self.into_iter())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `SeqAccess`.\n#[derive(Clone, Debug)]\npub struct SeqAccessDeserializer\u003cA\u003e {\n    seq: A,\n}\n\nimpl\u003cA\u003e SeqAccessDeserializer\u003cA\u003e {\n    /// Construct a new `SeqAccessDeserializer\u003cA\u003e`.\n    pub fn new(seq: A) -\u003e Self {\n        SeqAccessDeserializer { seq: seq }\n    }\n}\n\nimpl\u003c'de, A\u003e de::Deserializer\u003c'de\u003e for SeqAccessDeserializer\u003cA\u003e\nwhere\n    A: de::SeqAccess\u003c'de\u003e,\n{\n    type Error = A::Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_seq(self.seq)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer that iterates over a map.\npub struct MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n{\n    iter: iter::Fuse\u003cI\u003e,\n    value: Option\u003cSecond\u003cI::Item\u003e\u003e,\n    count: usize,\n    lifetime: PhantomData\u003c\u0026'de ()\u003e,\n    error: PhantomData\u003cE\u003e,\n}\n\nimpl\u003c'de, I, E\u003e MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n{\n    /// Construct a new `MapDeserializer\u003cI, E\u003e`.\n    pub fn new(iter: I) -\u003e Self {\n        MapDeserializer {\n            iter: iter.fuse(),\n            value: None,\n            count: 0,\n            lifetime: PhantomData,\n            error: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, I, E\u003e MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n    E: de::Error,\n{\n    /// Check for remaining elements after passing a `MapDeserializer` to\n    /// `Visitor::visit_map`.\n    pub fn end(self) -\u003e Result\u003c(), E\u003e {\n        let remaining = self.iter.count();\n        if remaining == 0 {\n            Ok(())\n        } else {\n            // First argument is the number of elements in the data, second\n            // argument is the number of elements expected by the Deserialize.\n            Err(de::Error::invalid_length(\n                self.count + remaining,\n                \u0026ExpectedInMap(self.count),\n            ))\n        }\n    }\n}\n\nimpl\u003c'de, I, E\u003e MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n{\n    fn next_pair(\u0026mut self) -\u003e Option\u003c(First\u003cI::Item\u003e, Second\u003cI::Item\u003e)\u003e {\n        match self.iter.next() {\n            Some(kv) =\u003e {\n                self.count += 1;\n                Some(private::Pair::split(kv))\n            }\n            None =\u003e None,\n        }\n    }\n}\n\nimpl\u003c'de, I, E\u003e de::Deserializer\u003c'de\u003e for MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n    First\u003cI::Item\u003e: IntoDeserializer\u003c'de, E\u003e,\n    Second\u003cI::Item\u003e: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let value = try!(visitor.visit_map(\u0026mut self));\n        try!(self.end());\n        Ok(value)\n    }\n\n    fn deserialize_seq\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let value = try!(visitor.visit_seq(\u0026mut self));\n        try!(self.end());\n        Ok(value)\n    }\n\n    fn deserialize_tuple\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let _ = len;\n        self.deserialize_seq(visitor)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct tuple_struct map\n        struct enum identifier ignored_any\n    }\n}\n\nimpl\u003c'de, I, E\u003e de::MapAccess\u003c'de\u003e for MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n    First\u003cI::Item\u003e: IntoDeserializer\u003c'de, E\u003e,\n    Second\u003cI::Item\u003e: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn next_key_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        match self.next_pair() {\n            Some((key, value)) =\u003e {\n                self.value = Some(value);\n                seed.deserialize(key.into_deserializer()).map(Some)\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn next_value_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        let value = self.value.take();\n        // Panic because this indicates a bug in the program rather than an\n        // expected failure.\n        let value = value.expect(\"MapAccess::visit_value called before visit_key\");\n        seed.deserialize(value.into_deserializer())\n    }\n\n    fn next_entry_seed\u003cTK, TV\u003e(\n        \u0026mut self,\n        kseed: TK,\n        vseed: TV,\n    ) -\u003e Result\u003cOption\u003c(TK::Value, TV::Value)\u003e, Self::Error\u003e\n    where\n        TK: de::DeserializeSeed\u003c'de\u003e,\n        TV: de::DeserializeSeed\u003c'de\u003e,\n    {\n        match self.next_pair() {\n            Some((key, value)) =\u003e {\n                let key = try!(kseed.deserialize(key.into_deserializer()));\n                let value = try!(vseed.deserialize(value.into_deserializer()));\n                Ok(Some((key, value)))\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        size_hint::from_bounds(\u0026self.iter)\n    }\n}\n\nimpl\u003c'de, I, E\u003e de::SeqAccess\u003c'de\u003e for MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n    First\u003cI::Item\u003e: IntoDeserializer\u003c'de, E\u003e,\n    Second\u003cI::Item\u003e: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        match self.next_pair() {\n            Some((k, v)) =\u003e {\n                let de = PairDeserializer(k, v, PhantomData);\n                seed.deserialize(de).map(Some)\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        size_hint::from_bounds(\u0026self.iter)\n    }\n}\n\n// Cannot #[derive(Clone)] because of the bound `Second\u003cI::Item\u003e: Clone`.\nimpl\u003c'de, I, E\u003e Clone for MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator + Clone,\n    I::Item: private::Pair,\n    Second\u003cI::Item\u003e: Clone,\n{\n    fn clone(\u0026self) -\u003e Self {\n        MapDeserializer {\n            iter: self.iter.clone(),\n            value: self.value.clone(),\n            count: self.count,\n            lifetime: self.lifetime,\n            error: self.error,\n        }\n    }\n}\n\n// Cannot #[derive(Debug)] because of the bound `Second\u003cI::Item\u003e: Debug`.\nimpl\u003c'de, I, E\u003e Debug for MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator + Debug,\n    I::Item: private::Pair,\n    Second\u003cI::Item\u003e: Debug,\n{\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter\n            .debug_struct(\"MapDeserializer\")\n            .field(\"iter\", \u0026self.iter)\n            .field(\"value\", \u0026self.value)\n            .field(\"count\", \u0026self.count)\n            .field(\"lifetime\", \u0026self.lifetime)\n            .field(\"error\", \u0026self.error)\n            .finish()\n    }\n}\n\n// Used in the `impl SeqAccess for MapDeserializer` to visit the map as a\n// sequence of pairs.\nstruct PairDeserializer\u003cA, B, E\u003e(A, B, PhantomData\u003cE\u003e);\n\nimpl\u003c'de, A, B, E\u003e de::Deserializer\u003c'de\u003e for PairDeserializer\u003cA, B, E\u003e\nwhere\n    A: IntoDeserializer\u003c'de, E\u003e,\n    B: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct tuple_struct map\n        struct enum identifier ignored_any\n    }\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let mut pair_visitor = PairVisitor(Some(self.0), Some(self.1), PhantomData);\n        let pair = try!(visitor.visit_seq(\u0026mut pair_visitor));\n        if pair_visitor.1.is_none() {\n            Ok(pair)\n        } else {\n            let remaining = pair_visitor.size_hint().unwrap();\n            // First argument is the number of elements in the data, second\n            // argument is the number of elements expected by the Deserialize.\n            Err(de::Error::invalid_length(2, \u0026ExpectedInSeq(2 - remaining)))\n        }\n    }\n\n    fn deserialize_tuple\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        if len == 2 {\n            self.deserialize_seq(visitor)\n        } else {\n            // First argument is the number of elements in the data, second\n            // argument is the number of elements expected by the Deserialize.\n            Err(de::Error::invalid_length(2, \u0026ExpectedInSeq(len)))\n        }\n    }\n}\n\nstruct PairVisitor\u003cA, B, E\u003e(Option\u003cA\u003e, Option\u003cB\u003e, PhantomData\u003cE\u003e);\n\nimpl\u003c'de, A, B, E\u003e de::SeqAccess\u003c'de\u003e for PairVisitor\u003cA, B, E\u003e\nwhere\n    A: IntoDeserializer\u003c'de, E\u003e,\n    B: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        if let Some(k) = self.0.take() {\n            seed.deserialize(k.into_deserializer()).map(Some)\n        } else if let Some(v) = self.1.take() {\n            seed.deserialize(v.into_deserializer()).map(Some)\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        if self.0.is_some() {\n            Some(2)\n        } else if self.1.is_some() {\n            Some(1)\n        } else {\n            Some(0)\n        }\n    }\n}\n\nstruct ExpectedInMap(usize);\n\nimpl Expected for ExpectedInMap {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        if self.0 == 1 {\n            write!(formatter, \"1 element in map\")\n        } else {\n            write!(formatter, \"{} elements in map\", self.0)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, K, V, E\u003e IntoDeserializer\u003c'de, E\u003e for BTreeMap\u003cK, V\u003e\nwhere\n    K: IntoDeserializer\u003c'de, E\u003e + Eq + Ord,\n    V: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Deserializer = MapDeserializer\u003c'de, \u003cSelf as IntoIterator\u003e::IntoIter, E\u003e;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        MapDeserializer::new(self.into_iter())\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de, K, V, S, E\u003e IntoDeserializer\u003c'de, E\u003e for HashMap\u003cK, V, S\u003e\nwhere\n    K: IntoDeserializer\u003c'de, E\u003e + Eq + Hash,\n    V: IntoDeserializer\u003c'de, E\u003e,\n    S: BuildHasher,\n    E: de::Error,\n{\n    type Deserializer = MapDeserializer\u003c'de, \u003cSelf as IntoIterator\u003e::IntoIter, E\u003e;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        MapDeserializer::new(self.into_iter())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `MapAccess`.\n#[derive(Clone, Debug)]\npub struct MapAccessDeserializer\u003cA\u003e {\n    map: A,\n}\n\nimpl\u003cA\u003e MapAccessDeserializer\u003cA\u003e {\n    /// Construct a new `MapAccessDeserializer\u003cA\u003e`.\n    pub fn new(map: A) -\u003e Self {\n        MapAccessDeserializer { map: map }\n    }\n}\n\nimpl\u003c'de, A\u003e de::Deserializer\u003c'de\u003e for MapAccessDeserializer\u003cA\u003e\nwhere\n    A: de::MapAccess\u003c'de\u003e,\n{\n    type Error = A::Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_map(self.map)\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        _name: \u0026str,\n        _variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\nimpl\u003c'de, A\u003e de::EnumAccess\u003c'de\u003e for MapAccessDeserializer\u003cA\u003e\nwhere\n    A: de::MapAccess\u003c'de\u003e,\n{\n    type Error = A::Error;\n    type Variant = private::MapAsEnum\u003cA\u003e;\n\n    fn variant_seed\u003cT\u003e(mut self, seed: T) -\u003e Result\u003c(T::Value, Self::Variant), Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        match self.map.next_key_seed(seed)? {\n            Some(key) =\u003e Ok((key, private::map_as_enum(self.map))),\n            None =\u003e Err(de::Error::invalid_type(de::Unexpected::Map, \u0026\"enum\")),\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmod private {\n    use lib::*;\n\n    use de::{self, DeserializeSeed, Deserializer, MapAccess, Unexpected, VariantAccess, Visitor};\n\n    #[derive(Clone, Debug)]\n    pub struct UnitOnly\u003cE\u003e {\n        marker: PhantomData\u003cE\u003e,\n    }\n\n    pub fn unit_only\u003cT, E\u003e(t: T) -\u003e (T, UnitOnly\u003cE\u003e) {\n        (\n            t,\n            UnitOnly {\n                marker: PhantomData,\n            },\n        )\n    }\n\n    impl\u003c'de, E\u003e de::VariantAccess\u003c'de\u003e for UnitOnly\u003cE\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n            Ok(())\n        }\n\n        fn newtype_variant_seed\u003cT\u003e(self, _seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            Err(de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                \u0026\"newtype variant\",\n            ))\n        }\n\n        fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            Err(de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                \u0026\"tuple variant\",\n            ))\n        }\n\n        fn struct_variant\u003cV\u003e(\n            self,\n            _fields: \u0026'static [\u0026'static str],\n            _visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            Err(de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                \u0026\"struct variant\",\n            ))\n        }\n    }\n\n    #[derive(Clone, Debug)]\n    pub struct MapAsEnum\u003cA\u003e {\n        map: A,\n    }\n\n    pub fn map_as_enum\u003cA\u003e(map: A) -\u003e MapAsEnum\u003cA\u003e {\n        MapAsEnum { map: map }\n    }\n\n    impl\u003c'de, A\u003e VariantAccess\u003c'de\u003e for MapAsEnum\u003cA\u003e\n    where\n        A: MapAccess\u003c'de\u003e,\n    {\n        type Error = A::Error;\n\n        fn unit_variant(mut self) -\u003e Result\u003c(), Self::Error\u003e {\n            self.map.next_value()\n        }\n\n        fn newtype_variant_seed\u003cT\u003e(mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n        where\n            T: DeserializeSeed\u003c'de\u003e,\n        {\n            self.map.next_value_seed(seed)\n        }\n\n        fn tuple_variant\u003cV\u003e(mut self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.map.next_value_seed(SeedTupleVariant {\n                len: len,\n                visitor: visitor,\n            })\n        }\n\n        fn struct_variant\u003cV\u003e(\n            mut self,\n            _fields: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.map\n                .next_value_seed(SeedStructVariant { visitor: visitor })\n        }\n    }\n\n    struct SeedTupleVariant\u003cV\u003e {\n        len: usize,\n        visitor: V,\n    }\n\n    impl\u003c'de, V\u003e DeserializeSeed\u003c'de\u003e for SeedTupleVariant\u003cV\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        type Value = V::Value;\n\n        fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            deserializer.deserialize_tuple(self.len, self.visitor)\n        }\n    }\n\n    struct SeedStructVariant\u003cV\u003e {\n        visitor: V,\n    }\n\n    impl\u003c'de, V\u003e DeserializeSeed\u003c'de\u003e for SeedStructVariant\u003cV\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        type Value = V::Value;\n\n        fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            deserializer.deserialize_map(self.visitor)\n        }\n    }\n\n    /// Avoid having to restate the generic types on `MapDeserializer`. The\n    /// `Iterator::Item` contains enough information to figure out K and V.\n    pub trait Pair {\n        type First;\n        type Second;\n        fn split(self) -\u003e (Self::First, Self::Second);\n    }\n\n    impl\u003cA, B\u003e Pair for (A, B) {\n        type First = A;\n        type Second = B;\n        fn split(self) -\u003e (A, B) {\n            self\n        }\n    }\n\n    pub type First\u003cT\u003e = \u003cT as Pair\u003e::First;\n    pub type Second\u003cT\u003e = \u003cT as Pair\u003e::Second;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","export.rs"],"content":"pub use lib::clone::Clone;\npub use lib::convert::{From, Into};\npub use lib::default::Default;\npub use lib::fmt::{self, Formatter};\npub use lib::marker::PhantomData;\npub use lib::option::Option::{self, None, Some};\npub use lib::result::Result::{self, Err, Ok};\n\npub use self::string::from_utf8_lossy;\n\n#[cfg(any(feature = \"alloc\", feature = \"std\"))]\npub use lib::{ToString, Vec};\n\n#[cfg(core_try_from)]\npub use lib::convert::TryFrom;\n\nmod string {\n    use lib::*;\n\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    pub fn from_utf8_lossy(bytes: \u0026[u8]) -\u003e Cow\u003cstr\u003e {\n        String::from_utf8_lossy(bytes)\n    }\n\n    // The generated code calls this like:\n    //\n    //     let value = \u0026_serde::export::from_utf8_lossy(bytes);\n    //     Err(_serde::de::Error::unknown_variant(value, VARIANTS))\n    //\n    // so it is okay for the return type to be different from the std case as long\n    // as the above works.\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    pub fn from_utf8_lossy(bytes: \u0026[u8]) -\u003e \u0026str {\n        // Three unicode replacement characters if it fails. They look like a\n        // white-on-black question mark. The user will recognize it as invalid\n        // UTF-8.\n        str::from_utf8(bytes).unwrap_or(\"\\u{fffd}\\u{fffd}\\u{fffd}\")\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","integer128.rs"],"content":"/// Conditional compilation depending on whether Serde is built with support for\n/// 128-bit integers.\n///\n/// Data formats that wish to support Rust compiler versions older than 1.26\n/// (or targets that lack 128-bit integers) may place the i128 / u128 methods\n/// of their Serializer and Deserializer behind this macro.\n///\n/// Data formats that require a minimum Rust compiler version of at least 1.26,\n/// or do not target platforms that lack 128-bit integers, do not need to\n/// bother with this macro and may assume support for 128-bit integers.\n///\n/// ```edition2018\n/// # use serde::private::ser::Error;\n/// #\n/// # struct MySerializer;\n/// #\n/// use serde::{serde_if_integer128, Serializer};\n///\n/// impl Serializer for MySerializer {\n///     type Ok = ();\n///     type Error = Error;\n///\n///     fn serialize_i64(self, v: i64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n///         /* ... */\n/// #         unimplemented!()\n///     }\n///\n///     /* ... */\n///\n///     serde_if_integer128! {\n///         fn serialize_i128(self, v: i128) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n///             /* ... */\n/// #             unimplemented!()\n///         }\n///\n///         fn serialize_u128(self, v: u128) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n///             /* ... */\n/// #             unimplemented!()\n///         }\n///     }\n/// #\n/// #     serde::__serialize_unimplemented! {\n/// #         bool i8 i16 i32 u8 u16 u32 u64 f32 f64 char str bytes none some\n/// #         unit unit_struct unit_variant newtype_struct newtype_variant seq\n/// #         tuple tuple_struct tuple_variant map struct struct_variant\n/// #     }\n/// }\n/// ```\n///\n/// When Serde is built with support for 128-bit integers, this macro expands\n/// transparently into just the input tokens.\n///\n/// ```edition2018\n/// macro_rules! serde_if_integer128 {\n///     ($($tt:tt)*) =\u003e {\n///         $($tt)*\n///     };\n/// }\n/// ```\n///\n/// When built without support for 128-bit integers, this macro expands to\n/// nothing.\n///\n/// ```edition2018\n/// macro_rules! serde_if_integer128 {\n///     ($($tt:tt)*) =\u003e {};\n/// }\n/// ```\n#[cfg(integer128)]\n#[macro_export]\nmacro_rules! serde_if_integer128 {\n    ($($tt:tt)*) =\u003e {\n        $($tt)*\n    };\n}\n\n#[cfg(not(integer128))]\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! serde_if_integer128 {\n    ($($tt:tt)*) =\u003e {};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","lib.rs"],"content":"//! # Serde\n//!\n//! Serde is a framework for ***ser***ializing and ***de***serializing Rust data\n//! structures efficiently and generically.\n//!\n//! The Serde ecosystem consists of data structures that know how to serialize\n//! and deserialize themselves along with data formats that know how to\n//! serialize and deserialize other things. Serde provides the layer by which\n//! these two groups interact with each other, allowing any supported data\n//! structure to be serialized and deserialized using any supported data format.\n//!\n//! See the Serde website [https://serde.rs/] for additional documentation and\n//! usage examples.\n//!\n//! [https://serde.rs/]: https://serde.rs/\n//!\n//! ## Design\n//!\n//! Where many other languages rely on runtime reflection for serializing data,\n//! Serde is instead built on Rust's powerful trait system. A data structure\n//! that knows how to serialize and deserialize itself is one that implements\n//! Serde's `Serialize` and `Deserialize` traits (or uses Serde's derive\n//! attribute to automatically generate implementations at compile time). This\n//! avoids any overhead of reflection or runtime type information. In fact in\n//! many situations the interaction between data structure and data format can\n//! be completely optimized away by the Rust compiler, leaving Serde\n//! serialization to perform the same speed as a handwritten serializer for the\n//! specific selection of data structure and data format.\n//!\n//! ## Data formats\n//!\n//! The following is a partial list of data formats that have been implemented\n//! for Serde by the community.\n//!\n//! - [JSON], the ubiquitous JavaScript Object Notation used by many HTTP APIs.\n//! - [Bincode], a compact binary format\n//!   used for IPC within the Servo rendering engine.\n//! - [CBOR], a Concise Binary Object Representation designed for small message\n//!   size without the need for version negotiation.\n//! - [YAML], a popular human-friendly configuration language that ain't markup\n//!   language.\n//! - [MessagePack], an efficient binary format that resembles a compact JSON.\n//! - [TOML], a minimal configuration format used by [Cargo].\n//! - [Pickle], a format common in the Python world.\n//! - [RON], a Rusty Object Notation.\n//! - [BSON], the data storage and network transfer format used by MongoDB.\n//! - [Avro], a binary format used within Apache Hadoop, with support for schema\n//!   definition.\n//! - [JSON5], A superset of JSON including some productions from ES5.\n//! - [Postcard], a no\\_std and embedded-systems friendly compact binary format.\n//! - [URL], the x-www-form-urlencoded format.\n//! - [Envy], a way to deserialize environment variables into Rust structs.\n//!   *(deserialization only)*\n//! - [Envy Store], a way to deserialize [AWS Parameter Store] parameters into\n//!   Rust structs. *(deserialization only)*\n//!\n//! [JSON]: https://github.com/serde-rs/json\n//! [Bincode]: https://github.com/TyOverby/bincode\n//! [CBOR]: https://github.com/pyfisch/cbor\n//! [YAML]: https://github.com/dtolnay/serde-yaml\n//! [MessagePack]: https://github.com/3Hren/msgpack-rust\n//! [TOML]: https://github.com/alexcrichton/toml-rs\n//! [Pickle]: https://github.com/birkenfeld/serde-pickle\n//! [RON]: https://github.com/ron-rs/ron\n//! [BSON]: https://github.com/zonyitoo/bson-rs\n//! [Avro]: https://github.com/flavray/avro-rs\n//! [JSON5]: https://github.com/callum-oakley/json5-rs\n//! [Postcard]: https://github.com/jamesmunns/postcard\n//! [URL]: https://github.com/nox/serde_urlencoded\n//! [Envy]: https://github.com/softprops/envy\n//! [Envy Store]: https://github.com/softprops/envy-store\n//! [Cargo]: http://doc.crates.io/manifest.html\n//! [AWS Parameter Store]: https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-paramstore.html\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Serde types in rustdoc of other crates get linked to here.\n#![doc(html_root_url = \"https://docs.rs/serde/1.0.100\")]\n// Support using Serde without the standard library!\n#![cfg_attr(not(feature = \"std\"), no_std)]\n// Unstable functionality only if the user asks for it. For tracking and\n// discussion of these features please refer to this issue:\n//\n//    https://github.com/serde-rs/serde/issues/812\n#![cfg_attr(feature = \"unstable\", feature(specialization, never_type))]\n#![allow(unknown_lints, bare_trait_objects, deprecated)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(renamed_and_removed_lints))]\n#![cfg_attr(feature = \"cargo-clippy\", deny(clippy, clippy_pedantic))]\n// Ignored clippy and clippy_pedantic lints\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        // not available in our oldest supported compiler\n        checked_conversions,\n        empty_enum,\n        redundant_field_names,\n        redundant_static_lifetimes,\n        // integer and float ser/de requires these sorts of casts\n        cast_possible_truncation,\n        cast_possible_wrap,\n        cast_sign_loss,\n        // things are often more readable this way\n        cast_lossless,\n        module_name_repetitions,\n        single_match_else,\n        type_complexity,\n        use_self,\n        zero_prefixed_literal,\n        // not practical\n        needless_pass_by_value,\n        similar_names,\n        // preference\n        doc_markdown,\n    )\n)]\n// Rustc lints.\n#![deny(missing_docs, unused_imports)]\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"alloc\")]\nextern crate alloc;\n\n/// A facade around all the types we need from the `std`, `core`, and `alloc`\n/// crates. This avoids elaborate import wrangling having to happen in every\n/// module.\nmod lib {\n    mod core {\n        #[cfg(not(feature = \"std\"))]\n        pub use core::*;\n        #[cfg(feature = \"std\")]\n        pub use std::*;\n    }\n\n    pub use self::core::{cmp, iter, mem, num, slice, str};\n    pub use self::core::{f32, f64};\n    pub use self::core::{i16, i32, i64, i8, isize};\n    pub use self::core::{u16, u32, u64, u8, usize};\n\n    pub use self::core::cell::{Cell, RefCell};\n    pub use self::core::clone::{self, Clone};\n    pub use self::core::convert::{self, From, Into};\n    pub use self::core::default::{self, Default};\n    pub use self::core::fmt::{self, Debug, Display};\n    pub use self::core::marker::{self, PhantomData};\n    pub use self::core::ops::Range;\n    pub use self::core::option::{self, Option};\n    pub use self::core::result::{self, Result};\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::borrow::{Cow, ToOwned};\n    #[cfg(feature = \"std\")]\n    pub use std::borrow::{Cow, ToOwned};\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::string::{String, ToString};\n    #[cfg(feature = \"std\")]\n    pub use std::string::{String, ToString};\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::vec::Vec;\n    #[cfg(feature = \"std\")]\n    pub use std::vec::Vec;\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::boxed::Box;\n    #[cfg(feature = \"std\")]\n    pub use std::boxed::Box;\n\n    #[cfg(all(feature = \"rc\", feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::rc::{Rc, Weak as RcWeak};\n    #[cfg(all(feature = \"rc\", feature = \"std\"))]\n    pub use std::rc::{Rc, Weak as RcWeak};\n\n    #[cfg(all(feature = \"rc\", feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::sync::{Arc, Weak as ArcWeak};\n    #[cfg(all(feature = \"rc\", feature = \"std\"))]\n    pub use std::sync::{Arc, Weak as ArcWeak};\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::collections::{BTreeMap, BTreeSet, BinaryHeap, LinkedList, VecDeque};\n    #[cfg(feature = \"std\")]\n    pub use std::collections::{BTreeMap, BTreeSet, BinaryHeap, LinkedList, VecDeque};\n\n    #[cfg(feature = \"std\")]\n    pub use std::{error, net};\n\n    #[cfg(feature = \"std\")]\n    pub use std::collections::{HashMap, HashSet};\n    #[cfg(feature = \"std\")]\n    pub use std::ffi::{CStr, CString, OsStr, OsString};\n    #[cfg(feature = \"std\")]\n    pub use std::hash::{BuildHasher, Hash};\n    #[cfg(feature = \"std\")]\n    pub use std::io::Write;\n    #[cfg(feature = \"std\")]\n    pub use std::num::Wrapping;\n    #[cfg(feature = \"std\")]\n    pub use std::path::{Path, PathBuf};\n    #[cfg(feature = \"std\")]\n    pub use std::sync::{Mutex, RwLock};\n    #[cfg(feature = \"std\")]\n    pub use std::time::{SystemTime, UNIX_EPOCH};\n\n    #[cfg(all(feature = \"std\", collections_bound))]\n    pub use std::collections::Bound;\n\n    #[cfg(core_reverse)]\n    pub use self::core::cmp::Reverse;\n\n    #[cfg(ops_bound)]\n    pub use self::core::ops::Bound;\n\n    #[cfg(range_inclusive)]\n    pub use self::core::ops::RangeInclusive;\n\n    #[cfg(all(feature = \"std\", std_atomic))]\n    pub use std::sync::atomic::{\n        AtomicBool, AtomicI16, AtomicI32, AtomicI8, AtomicIsize, AtomicU16, AtomicU32, AtomicU8,\n        AtomicUsize, Ordering,\n    };\n    #[cfg(all(feature = \"std\", std_atomic64))]\n    pub use std::sync::atomic::{AtomicI64, AtomicU64};\n\n    #[cfg(any(core_duration, feature = \"std\"))]\n    pub use self::core::time::Duration;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[macro_use]\nmod macros;\n\n#[macro_use]\nmod integer128;\n\npub mod de;\npub mod ser;\n\n#[doc(inline)]\npub use de::{Deserialize, Deserializer};\n#[doc(inline)]\npub use ser::{Serialize, Serializer};\n\n// Generated code uses these to support no_std. Not public API.\n#[doc(hidden)]\npub mod export;\n\n// Helpers used by generated code and doc tests. Not public API.\n#[doc(hidden)]\npub mod private;\n\n#[cfg(not(feature = \"std\"))]\nmod std_error;\n\n// Re-export #[derive(Serialize, Deserialize)].\n//\n// The reason re-exporting is not enabled by default is that disabling it would\n// be annoying for crates that provide handwritten impls or data formats. They\n// would need to disable default features and then explicitly re-enable std.\n#[cfg(feature = \"serde_derive\")]\n#[allow(unused_imports)]\n#[macro_use]\nextern crate serde_derive;\n#[cfg(feature = \"serde_derive\")]\n#[doc(hidden)]\npub use serde_derive::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","macros.rs"],"content":"// Super explicit first paragraph because this shows up at the top level and\n// trips up people who are just looking for basic Serialize / Deserialize\n// documentation.\n//\n/// Helper macro when implementing the `Deserializer` part of a new data format\n/// for Serde.\n///\n/// Some [`Deserializer`] implementations for self-describing formats do not\n/// care what hint the [`Visitor`] gives them, they just want to blindly call\n/// the [`Visitor`] method corresponding to the data they can tell is in the\n/// input. This requires repetitive implementations of all the [`Deserializer`]\n/// trait methods.\n///\n/// ```edition2018\n/// # use serde::forward_to_deserialize_any;\n/// # use serde::de::{value, Deserializer, Visitor};\n/// #\n/// # struct MyDeserializer;\n/// #\n/// # impl\u003c'de\u003e Deserializer\u003c'de\u003e for MyDeserializer {\n/// #     type Error = value::Error;\n/// #\n/// #     fn deserialize_any\u003cV\u003e(self, _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n/// #     where\n/// #         V: Visitor\u003c'de\u003e,\n/// #     {\n/// #         unimplemented!()\n/// #     }\n/// #\n/// #[inline]\n/// fn deserialize_bool\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n/// where\n///     V: Visitor\u003c'de\u003e,\n/// {\n///     self.deserialize_any(visitor)\n/// }\n/// #\n/// #     forward_to_deserialize_any! {\n/// #         i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n/// #         bytes byte_buf option unit unit_struct newtype_struct seq tuple\n/// #         tuple_struct map struct enum identifier ignored_any\n/// #     }\n/// # }\n/// ```\n///\n/// The `forward_to_deserialize_any!` macro implements these simple forwarding\n/// methods so that they forward directly to [`Deserializer::deserialize_any`].\n/// You can choose which methods to forward.\n///\n/// ```edition2018\n/// # use serde::forward_to_deserialize_any;\n/// # use serde::de::{value, Deserializer, Visitor};\n/// #\n/// # struct MyDeserializer;\n/// #\n/// impl\u003c'de\u003e Deserializer\u003c'de\u003e for MyDeserializer {\n/// #   type Error = value::Error;\n/// #\n///     fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n///     where\n///         V: Visitor\u003c'de\u003e,\n///     {\n///         /* ... */\n/// #       let _ = visitor;\n/// #       unimplemented!()\n///     }\n///\n///     forward_to_deserialize_any! {\n///         bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n///         bytes byte_buf option unit unit_struct newtype_struct seq tuple\n///         tuple_struct map struct enum identifier ignored_any\n///     }\n/// }\n/// ```\n///\n/// The macro assumes the convention that your `Deserializer` lifetime parameter\n/// is called `'de` and that the `Visitor` type parameters on each method are\n/// called `V`. A different type parameter and a different lifetime can be\n/// specified explicitly if necessary.\n///\n/// ```edition2018\n/// # use std::marker::PhantomData;\n/// #\n/// # use serde::forward_to_deserialize_any;\n/// # use serde::de::{value, Deserializer, Visitor};\n/// #\n/// # struct MyDeserializer\u003cV\u003e(PhantomData\u003cV\u003e);\n/// #\n/// # impl\u003c'q, V\u003e Deserializer\u003c'q\u003e for MyDeserializer\u003cV\u003e {\n/// #     type Error = value::Error;\n/// #\n/// #     fn deserialize_any\u003cW\u003e(self, visitor: W) -\u003e Result\u003cW::Value, Self::Error\u003e\n/// #     where\n/// #         W: Visitor\u003c'q\u003e,\n/// #     {\n/// #         unimplemented!()\n/// #     }\n/// #\n/// forward_to_deserialize_any! {\n///     \u003cW: Visitor\u003c'q\u003e\u003e\n///     bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n///     bytes byte_buf option unit unit_struct newtype_struct seq tuple\n///     tuple_struct map struct enum identifier ignored_any\n/// }\n/// # }\n/// ```\n///\n/// [`Deserializer`]: trait.Deserializer.html\n/// [`Visitor`]: de/trait.Visitor.html\n/// [`Deserializer::deserialize_any`]: trait.Deserializer.html#tymethod.deserialize_any\n#[macro_export(local_inner_macros)]\nmacro_rules! forward_to_deserialize_any {\n    (\u003c$visitor:ident: Visitor\u003c$lifetime:tt\u003e\u003e $($func:ident)*) =\u003e {\n        $(forward_to_deserialize_any_helper!{$func\u003c$lifetime, $visitor\u003e})*\n    };\n    // This case must be after the previous one.\n    ($($func:ident)*) =\u003e {\n        $(forward_to_deserialize_any_helper!{$func\u003c'de, V\u003e})*\n    };\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! forward_to_deserialize_any_method {\n    ($func:ident\u003c$l:tt, $v:ident\u003e($($arg:ident : $ty:ty),*)) =\u003e {\n        #[inline]\n        fn $func\u003c$v\u003e(self, $($arg: $ty,)* visitor: $v) -\u003e $crate::export::Result\u003c$v::Value, Self::Error\u003e\n        where\n            $v: $crate::de::Visitor\u003c$l\u003e,\n        {\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }\n    };\n}\n\n#[doc(hidden)]\n#[macro_export(local_inner_macros)]\nmacro_rules! forward_to_deserialize_any_helper {\n    (bool\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_bool\u003c$l, $v\u003e()}\n    };\n    (i8\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_i8\u003c$l, $v\u003e()}\n    };\n    (i16\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_i16\u003c$l, $v\u003e()}\n    };\n    (i32\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_i32\u003c$l, $v\u003e()}\n    };\n    (i64\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_i64\u003c$l, $v\u003e()}\n    };\n    (i128\u003c$l:tt, $v:ident\u003e) =\u003e {\n        serde_if_integer128! {\n            forward_to_deserialize_any_method!{deserialize_i128\u003c$l, $v\u003e()}\n        }\n    };\n    (u8\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_u8\u003c$l, $v\u003e()}\n    };\n    (u16\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_u16\u003c$l, $v\u003e()}\n    };\n    (u32\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_u32\u003c$l, $v\u003e()}\n    };\n    (u64\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_u64\u003c$l, $v\u003e()}\n    };\n    (u128\u003c$l:tt, $v:ident\u003e) =\u003e {\n        serde_if_integer128! {\n            forward_to_deserialize_any_method!{deserialize_u128\u003c$l, $v\u003e()}\n        }\n    };\n    (f32\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_f32\u003c$l, $v\u003e()}\n    };\n    (f64\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_f64\u003c$l, $v\u003e()}\n    };\n    (char\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_char\u003c$l, $v\u003e()}\n    };\n    (str\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_str\u003c$l, $v\u003e()}\n    };\n    (string\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_string\u003c$l, $v\u003e()}\n    };\n    (bytes\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_bytes\u003c$l, $v\u003e()}\n    };\n    (byte_buf\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_byte_buf\u003c$l, $v\u003e()}\n    };\n    (option\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_option\u003c$l, $v\u003e()}\n    };\n    (unit\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_unit\u003c$l, $v\u003e()}\n    };\n    (unit_struct\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_unit_struct\u003c$l, $v\u003e(name: \u0026'static str)}\n    };\n    (newtype_struct\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_newtype_struct\u003c$l, $v\u003e(name: \u0026'static str)}\n    };\n    (seq\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_seq\u003c$l, $v\u003e()}\n    };\n    (tuple\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_tuple\u003c$l, $v\u003e(len: usize)}\n    };\n    (tuple_struct\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_tuple_struct\u003c$l, $v\u003e(name: \u0026'static str, len: usize)}\n    };\n    (map\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_map\u003c$l, $v\u003e()}\n    };\n    (struct\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_struct\u003c$l, $v\u003e(name: \u0026'static str, fields: \u0026'static [\u0026'static str])}\n    };\n    (enum\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_enum\u003c$l, $v\u003e(name: \u0026'static str, variants: \u0026'static [\u0026'static str])}\n    };\n    (identifier\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_identifier\u003c$l, $v\u003e()}\n    };\n    (ignored_any\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_ignored_any\u003c$l, $v\u003e()}\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","private","de.rs"],"content":"use lib::*;\n\nuse de::{Deserialize, DeserializeSeed, Deserializer, Error, IntoDeserializer, Visitor};\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse de::{MapAccess, Unexpected};\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub use self::content::{\n    Content, ContentDeserializer, ContentRefDeserializer, EnumDeserializer,\n    InternallyTaggedUnitVisitor, TagContentOtherField, TagContentOtherFieldVisitor,\n    TagOrContentField, TagOrContentFieldVisitor, TaggedContentVisitor, UntaggedUnitVisitor,\n};\n\n/// If the missing field is of type `Option\u003cT\u003e` then treat is as `None`,\n/// otherwise it is an error.\npub fn missing_field\u003c'de, V, E\u003e(field: \u0026'static str) -\u003e Result\u003cV, E\u003e\nwhere\n    V: Deserialize\u003c'de\u003e,\n    E: Error,\n{\n    struct MissingFieldDeserializer\u003cE\u003e(\u0026'static str, PhantomData\u003cE\u003e);\n\n    impl\u003c'de, E\u003e Deserializer\u003c'de\u003e for MissingFieldDeserializer\u003cE\u003e\n    where\n        E: Error,\n    {\n        type Error = E;\n\n        fn deserialize_any\u003cV\u003e(self, _visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            Err(Error::missing_field(self.0))\n        }\n\n        fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            visitor.visit_none()\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    let deserializer = MissingFieldDeserializer(field, PhantomData);\n    Deserialize::deserialize(deserializer)\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub fn borrow_cow_str\u003c'de: 'a, 'a, D\u003e(deserializer: D) -\u003e Result\u003cCow\u003c'a, str\u003e, D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    struct CowStrVisitor;\n\n    impl\u003c'a\u003e Visitor\u003c'a\u003e for CowStrVisitor {\n        type Value = Cow\u003c'a, str\u003e;\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            formatter.write_str(\"a string\")\n        }\n\n        fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v.to_owned()))\n        }\n\n        fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'a str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Borrowed(v))\n        }\n\n        fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v))\n        }\n\n        fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            match str::from_utf8(v) {\n                Ok(s) =\u003e Ok(Cow::Owned(s.to_owned())),\n                Err(_) =\u003e Err(Error::invalid_value(Unexpected::Bytes(v), \u0026self)),\n            }\n        }\n\n        fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'a [u8]) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            match str::from_utf8(v) {\n                Ok(s) =\u003e Ok(Cow::Borrowed(s)),\n                Err(_) =\u003e Err(Error::invalid_value(Unexpected::Bytes(v), \u0026self)),\n            }\n        }\n\n        fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            match String::from_utf8(v) {\n                Ok(s) =\u003e Ok(Cow::Owned(s)),\n                Err(e) =\u003e Err(Error::invalid_value(\n                    Unexpected::Bytes(\u0026e.into_bytes()),\n                    \u0026self,\n                )),\n            }\n        }\n    }\n\n    deserializer.deserialize_str(CowStrVisitor)\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub fn borrow_cow_bytes\u003c'de: 'a, 'a, D\u003e(deserializer: D) -\u003e Result\u003cCow\u003c'a, [u8]\u003e, D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    struct CowBytesVisitor;\n\n    impl\u003c'a\u003e Visitor\u003c'a\u003e for CowBytesVisitor {\n        type Value = Cow\u003c'a, [u8]\u003e;\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            formatter.write_str(\"a byte array\")\n        }\n\n        fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v.as_bytes().to_vec()))\n        }\n\n        fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'a str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Borrowed(v.as_bytes()))\n        }\n\n        fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v.into_bytes()))\n        }\n\n        fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v.to_vec()))\n        }\n\n        fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'a [u8]) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Borrowed(v))\n        }\n\n        fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v))\n        }\n    }\n\n    deserializer.deserialize_bytes(CowBytesVisitor)\n}\n\npub mod size_hint {\n    use lib::*;\n\n    pub fn from_bounds\u003cI\u003e(iter: \u0026I) -\u003e Option\u003cusize\u003e\n    where\n        I: Iterator,\n    {\n        helper(iter.size_hint())\n    }\n\n    #[inline]\n    pub fn cautious(hint: Option\u003cusize\u003e) -\u003e usize {\n        cmp::min(hint.unwrap_or(0), 4096)\n    }\n\n    fn helper(bounds: (usize, Option\u003cusize\u003e)) -\u003e Option\u003cusize\u003e {\n        match bounds {\n            (lower, Some(upper)) if lower == upper =\u003e Some(upper),\n            _ =\u003e None,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmod content {\n    // This module is private and nothing here should be used outside of\n    // generated code.\n    //\n    // We will iterate on the implementation for a few releases and only have to\n    // worry about backward compatibility for the `untagged` and `tag` attributes\n    // rather than for this entire mechanism.\n    //\n    // This issue is tracking making some of this stuff public:\n    // https://github.com/serde-rs/serde/issues/741\n\n    use lib::*;\n\n    use super::size_hint;\n    use de::{\n        self, Deserialize, DeserializeSeed, Deserializer, EnumAccess, Expected, IgnoredAny,\n        MapAccess, SeqAccess, Unexpected, Visitor,\n    };\n\n    /// Used from generated code to buffer the contents of the Deserializer when\n    /// deserializing untagged enums and internally tagged enums.\n    ///\n    /// Not public API. Use serde-value instead.\n    #[derive(Debug)]\n    pub enum Content\u003c'de\u003e {\n        Bool(bool),\n\n        U8(u8),\n        U16(u16),\n        U32(u32),\n        U64(u64),\n\n        I8(i8),\n        I16(i16),\n        I32(i32),\n        I64(i64),\n\n        F32(f32),\n        F64(f64),\n\n        Char(char),\n        String(String),\n        Str(\u0026'de str),\n        ByteBuf(Vec\u003cu8\u003e),\n        Bytes(\u0026'de [u8]),\n\n        None,\n        Some(Box\u003cContent\u003c'de\u003e\u003e),\n\n        Unit,\n        Newtype(Box\u003cContent\u003c'de\u003e\u003e),\n        Seq(Vec\u003cContent\u003c'de\u003e\u003e),\n        Map(Vec\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e),\n    }\n\n    impl\u003c'de\u003e Content\u003c'de\u003e {\n        pub fn as_str(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n            match *self {\n                Content::Str(x) =\u003e Some(x),\n                Content::String(ref x) =\u003e Some(x),\n                Content::Bytes(x) =\u003e str::from_utf8(x).ok(),\n                Content::ByteBuf(ref x) =\u003e str::from_utf8(x).ok(),\n                _ =\u003e None,\n            }\n        }\n\n        #[cold]\n        fn unexpected(\u0026self) -\u003e Unexpected {\n            match *self {\n                Content::Bool(b) =\u003e Unexpected::Bool(b),\n                Content::U8(n) =\u003e Unexpected::Unsigned(n as u64),\n                Content::U16(n) =\u003e Unexpected::Unsigned(n as u64),\n                Content::U32(n) =\u003e Unexpected::Unsigned(n as u64),\n                Content::U64(n) =\u003e Unexpected::Unsigned(n),\n                Content::I8(n) =\u003e Unexpected::Signed(n as i64),\n                Content::I16(n) =\u003e Unexpected::Signed(n as i64),\n                Content::I32(n) =\u003e Unexpected::Signed(n as i64),\n                Content::I64(n) =\u003e Unexpected::Signed(n),\n                Content::F32(f) =\u003e Unexpected::Float(f as f64),\n                Content::F64(f) =\u003e Unexpected::Float(f),\n                Content::Char(c) =\u003e Unexpected::Char(c),\n                Content::String(ref s) =\u003e Unexpected::Str(s),\n                Content::Str(s) =\u003e Unexpected::Str(s),\n                Content::ByteBuf(ref b) =\u003e Unexpected::Bytes(b),\n                Content::Bytes(b) =\u003e Unexpected::Bytes(b),\n                Content::None | Content::Some(_) =\u003e Unexpected::Option,\n                Content::Unit =\u003e Unexpected::Unit,\n                Content::Newtype(_) =\u003e Unexpected::NewtypeStruct,\n                Content::Seq(_) =\u003e Unexpected::Seq,\n                Content::Map(_) =\u003e Unexpected::Map,\n            }\n        }\n    }\n\n    impl\u003c'de\u003e Deserialize\u003c'de\u003e for Content\u003c'de\u003e {\n        fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            // Untagged and internally tagged enums are only supported in\n            // self-describing formats.\n            let visitor = ContentVisitor { value: PhantomData };\n            deserializer.deserialize_any(visitor)\n        }\n    }\n\n    struct ContentVisitor\u003c'de\u003e {\n        value: PhantomData\u003cContent\u003c'de\u003e\u003e,\n    }\n\n    impl\u003c'de\u003e ContentVisitor\u003c'de\u003e {\n        fn new() -\u003e Self {\n            ContentVisitor { value: PhantomData }\n        }\n    }\n\n    impl\u003c'de\u003e Visitor\u003c'de\u003e for ContentVisitor\u003c'de\u003e {\n        type Value = Content\u003c'de\u003e;\n\n        fn expecting(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            fmt.write_str(\"any value\")\n        }\n\n        fn visit_bool\u003cF\u003e(self, value: bool) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::Bool(value))\n        }\n\n        fn visit_i8\u003cF\u003e(self, value: i8) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::I8(value))\n        }\n\n        fn visit_i16\u003cF\u003e(self, value: i16) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::I16(value))\n        }\n\n        fn visit_i32\u003cF\u003e(self, value: i32) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::I32(value))\n        }\n\n        fn visit_i64\u003cF\u003e(self, value: i64) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::I64(value))\n        }\n\n        fn visit_u8\u003cF\u003e(self, value: u8) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::U8(value))\n        }\n\n        fn visit_u16\u003cF\u003e(self, value: u16) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::U16(value))\n        }\n\n        fn visit_u32\u003cF\u003e(self, value: u32) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::U32(value))\n        }\n\n        fn visit_u64\u003cF\u003e(self, value: u64) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::U64(value))\n        }\n\n        fn visit_f32\u003cF\u003e(self, value: f32) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::F32(value))\n        }\n\n        fn visit_f64\u003cF\u003e(self, value: f64) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::F64(value))\n        }\n\n        fn visit_char\u003cF\u003e(self, value: char) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::Char(value))\n        }\n\n        fn visit_str\u003cF\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::String(value.into()))\n        }\n\n        fn visit_borrowed_str\u003cF\u003e(self, value: \u0026'de str) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::Str(value))\n        }\n\n        fn visit_string\u003cF\u003e(self, value: String) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::String(value))\n        }\n\n        fn visit_bytes\u003cF\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::ByteBuf(value.into()))\n        }\n\n        fn visit_borrowed_bytes\u003cF\u003e(self, value: \u0026'de [u8]) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::Bytes(value))\n        }\n\n        fn visit_byte_buf\u003cF\u003e(self, value: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::ByteBuf(value))\n        }\n\n        fn visit_unit\u003cF\u003e(self) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::Unit)\n        }\n\n        fn visit_none\u003cF\u003e(self) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::None)\n        }\n\n        fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            Deserialize::deserialize(deserializer).map(|v| Content::Some(Box::new(v)))\n        }\n\n        fn visit_newtype_struct\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            Deserialize::deserialize(deserializer).map(|v| Content::Newtype(Box::new(v)))\n        }\n\n        fn visit_seq\u003cV\u003e(self, mut visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n        where\n            V: SeqAccess\u003c'de\u003e,\n        {\n            let mut vec = Vec::with_capacity(size_hint::cautious(visitor.size_hint()));\n            while let Some(e) = try!(visitor.next_element()) {\n                vec.push(e);\n            }\n            Ok(Content::Seq(vec))\n        }\n\n        fn visit_map\u003cV\u003e(self, mut visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n        where\n            V: MapAccess\u003c'de\u003e,\n        {\n            let mut vec = Vec::with_capacity(size_hint::cautious(visitor.size_hint()));\n            while let Some(kv) = try!(visitor.next_entry()) {\n                vec.push(kv);\n            }\n            Ok(Content::Map(vec))\n        }\n\n        fn visit_enum\u003cV\u003e(self, _visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n        where\n            V: EnumAccess\u003c'de\u003e,\n        {\n            Err(de::Error::custom(\n                \"untagged and internally tagged enums do not support enum input\",\n            ))\n        }\n    }\n\n    /// This is the type of the map keys in an internally tagged enum.\n    ///\n    /// Not public API.\n    pub enum TagOrContent\u003c'de\u003e {\n        Tag,\n        Content(Content\u003c'de\u003e),\n    }\n\n    struct TagOrContentVisitor\u003c'de\u003e {\n        name: \u0026'static str,\n        value: PhantomData\u003cTagOrContent\u003c'de\u003e\u003e,\n    }\n\n    impl\u003c'de\u003e TagOrContentVisitor\u003c'de\u003e {\n        fn new(name: \u0026'static str) -\u003e Self {\n            TagOrContentVisitor {\n                name: name,\n                value: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de\u003e DeserializeSeed\u003c'de\u003e for TagOrContentVisitor\u003c'de\u003e {\n        type Value = TagOrContent\u003c'de\u003e;\n\n        fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            // Internally tagged enums are only supported in self-describing\n            // formats.\n            deserializer.deserialize_any(self)\n        }\n    }\n\n    impl\u003c'de\u003e Visitor\u003c'de\u003e for TagOrContentVisitor\u003c'de\u003e {\n        type Value = TagOrContent\u003c'de\u003e;\n\n        fn expecting(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(fmt, \"a type tag `{}` or any other value\", self.name)\n        }\n\n        fn visit_bool\u003cF\u003e(self, value: bool) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_bool(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_i8\u003cF\u003e(self, value: i8) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_i8(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_i16\u003cF\u003e(self, value: i16) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_i16(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_i32\u003cF\u003e(self, value: i32) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_i32(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_i64\u003cF\u003e(self, value: i64) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_i64(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_u8\u003cF\u003e(self, value: u8) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_u8(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_u16\u003cF\u003e(self, value: u16) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_u16(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_u32\u003cF\u003e(self, value: u32) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_u32(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_u64\u003cF\u003e(self, value: u64) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_u64(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_f32\u003cF\u003e(self, value: f32) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_f32(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_f64\u003cF\u003e(self, value: f64) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_f64(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_char\u003cF\u003e(self, value: char) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_char(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_str\u003cF\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            if value == self.name {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_str(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_borrowed_str\u003cF\u003e(self, value: \u0026'de str) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            if value == self.name {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_borrowed_str(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_string\u003cF\u003e(self, value: String) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            if value == self.name {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_string(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_bytes\u003cF\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            if value == self.name.as_bytes() {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_bytes(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_borrowed_bytes\u003cF\u003e(self, value: \u0026'de [u8]) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            if value == self.name.as_bytes() {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_borrowed_bytes(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_byte_buf\u003cF\u003e(self, value: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            if value == self.name.as_bytes() {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_byte_buf(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_unit\u003cF\u003e(self) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_unit()\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_none\u003cF\u003e(self) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_none()\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            ContentVisitor::new()\n                .visit_some(deserializer)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_newtype_struct\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            ContentVisitor::new()\n                .visit_newtype_struct(deserializer)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n        where\n            V: SeqAccess\u003c'de\u003e,\n        {\n            ContentVisitor::new()\n                .visit_seq(visitor)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n        where\n            V: MapAccess\u003c'de\u003e,\n        {\n            ContentVisitor::new()\n                .visit_map(visitor)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_enum\u003cV\u003e(self, visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n        where\n            V: EnumAccess\u003c'de\u003e,\n        {\n            ContentVisitor::new()\n                .visit_enum(visitor)\n                .map(TagOrContent::Content)\n        }\n    }\n\n    /// Used by generated code to deserialize an internally tagged enum.\n    ///\n    /// Not public API.\n    pub struct TaggedContent\u003c'de, T\u003e {\n        pub tag: T,\n        pub content: Content\u003c'de\u003e,\n    }\n\n    /// Not public API.\n    pub struct TaggedContentVisitor\u003c'de, T\u003e {\n        tag_name: \u0026'static str,\n        value: PhantomData\u003cTaggedContent\u003c'de, T\u003e\u003e,\n    }\n\n    impl\u003c'de, T\u003e TaggedContentVisitor\u003c'de, T\u003e {\n        /// Visitor for the content of an internally tagged enum with the given\n        /// tag name.\n        pub fn new(name: \u0026'static str) -\u003e Self {\n            TaggedContentVisitor {\n                tag_name: name,\n                value: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de, T\u003e DeserializeSeed\u003c'de\u003e for TaggedContentVisitor\u003c'de, T\u003e\n    where\n        T: Deserialize\u003c'de\u003e,\n    {\n        type Value = TaggedContent\u003c'de, T\u003e;\n\n        fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            // Internally tagged enums are only supported in self-describing\n            // formats.\n            deserializer.deserialize_any(self)\n        }\n    }\n\n    impl\u003c'de, T\u003e Visitor\u003c'de\u003e for TaggedContentVisitor\u003c'de, T\u003e\n    where\n        T: Deserialize\u003c'de\u003e,\n    {\n        type Value = TaggedContent\u003c'de, T\u003e;\n\n        fn expecting(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            fmt.write_str(\"internally tagged enum\")\n        }\n\n        fn visit_seq\u003cS\u003e(self, mut seq: S) -\u003e Result\u003cSelf::Value, S::Error\u003e\n        where\n            S: SeqAccess\u003c'de\u003e,\n        {\n            let tag = match try!(seq.next_element()) {\n                Some(tag) =\u003e tag,\n                None =\u003e {\n                    return Err(de::Error::missing_field(self.tag_name));\n                }\n            };\n            let rest = de::value::SeqAccessDeserializer::new(seq);\n            Ok(TaggedContent {\n                tag: tag,\n                content: try!(Content::deserialize(rest)),\n            })\n        }\n\n        fn visit_map\u003cM\u003e(self, mut map: M) -\u003e Result\u003cSelf::Value, M::Error\u003e\n        where\n            M: MapAccess\u003c'de\u003e,\n        {\n            let mut tag = None;\n            let mut vec = Vec::with_capacity(size_hint::cautious(map.size_hint()));\n            while let Some(k) = try!(map.next_key_seed(TagOrContentVisitor::new(self.tag_name))) {\n                match k {\n                    TagOrContent::Tag =\u003e {\n                        if tag.is_some() {\n                            return Err(de::Error::duplicate_field(self.tag_name));\n                        }\n                        tag = Some(try!(map.next_value()));\n                    }\n                    TagOrContent::Content(k) =\u003e {\n                        let v = try!(map.next_value());\n                        vec.push((k, v));\n                    }\n                }\n            }\n            match tag {\n                None =\u003e Err(de::Error::missing_field(self.tag_name)),\n                Some(tag) =\u003e Ok(TaggedContent {\n                    tag: tag,\n                    content: Content::Map(vec),\n                }),\n            }\n        }\n    }\n\n    /// Used by generated code to deserialize an adjacently tagged enum.\n    ///\n    /// Not public API.\n    pub enum TagOrContentField {\n        Tag,\n        Content,\n    }\n\n    /// Not public API.\n    pub struct TagOrContentFieldVisitor {\n        pub tag: \u0026'static str,\n        pub content: \u0026'static str,\n    }\n\n    impl\u003c'de\u003e DeserializeSeed\u003c'de\u003e for TagOrContentFieldVisitor {\n        type Value = TagOrContentField;\n\n        fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            deserializer.deserialize_str(self)\n        }\n    }\n\n    impl\u003c'de\u003e Visitor\u003c'de\u003e for TagOrContentFieldVisitor {\n        type Value = TagOrContentField;\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(formatter, \"{:?} or {:?}\", self.tag, self.content)\n        }\n\n        fn visit_str\u003cE\u003e(self, field: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: de::Error,\n        {\n            if field == self.tag {\n                Ok(TagOrContentField::Tag)\n            } else if field == self.content {\n                Ok(TagOrContentField::Content)\n            } else {\n                Err(de::Error::invalid_value(Unexpected::Str(field), \u0026self))\n            }\n        }\n    }\n\n    /// Used by generated code to deserialize an adjacently tagged enum when\n    /// ignoring unrelated fields is allowed.\n    ///\n    /// Not public API.\n    pub enum TagContentOtherField {\n        Tag,\n        Content,\n        Other,\n    }\n\n    /// Not public API.\n    pub struct TagContentOtherFieldVisitor {\n        pub tag: \u0026'static str,\n        pub content: \u0026'static str,\n    }\n\n    impl\u003c'de\u003e DeserializeSeed\u003c'de\u003e for TagContentOtherFieldVisitor {\n        type Value = TagContentOtherField;\n\n        fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            deserializer.deserialize_str(self)\n        }\n    }\n\n    impl\u003c'de\u003e Visitor\u003c'de\u003e for TagContentOtherFieldVisitor {\n        type Value = TagContentOtherField;\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(\n                formatter,\n                \"{:?}, {:?}, or other ignored fields\",\n                self.tag, self.content\n            )\n        }\n\n        fn visit_str\u003cE\u003e(self, field: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: de::Error,\n        {\n            if field == self.tag {\n                Ok(TagContentOtherField::Tag)\n            } else if field == self.content {\n                Ok(TagContentOtherField::Content)\n            } else {\n                Ok(TagContentOtherField::Other)\n            }\n        }\n    }\n\n    /// Not public API\n    pub struct ContentDeserializer\u003c'de, E\u003e {\n        content: Content\u003c'de\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, E\u003e ContentDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        #[cold]\n        fn invalid_type(self, exp: \u0026Expected) -\u003e E {\n            de::Error::invalid_type(self.content.unexpected(), exp)\n        }\n\n        fn deserialize_integer\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::U8(v) =\u003e visitor.visit_u8(v),\n                Content::U16(v) =\u003e visitor.visit_u16(v),\n                Content::U32(v) =\u003e visitor.visit_u32(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I8(v) =\u003e visitor.visit_i8(v),\n                Content::I16(v) =\u003e visitor.visit_i16(v),\n                Content::I32(v) =\u003e visitor.visit_i32(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n    }\n\n    fn visit_content_seq\u003c'de, V, E\u003e(content: Vec\u003cContent\u003c'de\u003e\u003e, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n        E: de::Error,\n    {\n        let seq = content.into_iter().map(ContentDeserializer::new);\n        let mut seq_visitor = de::value::SeqDeserializer::new(seq);\n        let value = try!(visitor.visit_seq(\u0026mut seq_visitor));\n        try!(seq_visitor.end());\n        Ok(value)\n    }\n\n    fn visit_content_map\u003c'de, V, E\u003e(\n        content: Vec\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, E\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n        E: de::Error,\n    {\n        let map = content\n            .into_iter()\n            .map(|(k, v)| (ContentDeserializer::new(k), ContentDeserializer::new(v)));\n        let mut map_visitor = de::value::MapDeserializer::new(map);\n        let value = try!(visitor.visit_map(\u0026mut map_visitor));\n        try!(map_visitor.end());\n        Ok(value)\n    }\n\n    /// Used when deserializing an internally tagged enum because the content\n    /// will be used exactly once.\n    impl\u003c'de, E\u003e Deserializer\u003c'de\u003e for ContentDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Bool(v) =\u003e visitor.visit_bool(v),\n                Content::U8(v) =\u003e visitor.visit_u8(v),\n                Content::U16(v) =\u003e visitor.visit_u16(v),\n                Content::U32(v) =\u003e visitor.visit_u32(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I8(v) =\u003e visitor.visit_i8(v),\n                Content::I16(v) =\u003e visitor.visit_i16(v),\n                Content::I32(v) =\u003e visitor.visit_i32(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                Content::F32(v) =\u003e visitor.visit_f32(v),\n                Content::F64(v) =\u003e visitor.visit_f64(v),\n                Content::Char(v) =\u003e visitor.visit_char(v),\n                Content::String(v) =\u003e visitor.visit_string(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(v) =\u003e visitor.visit_byte_buf(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                Content::Unit =\u003e visitor.visit_unit(),\n                Content::None =\u003e visitor.visit_none(),\n                Content::Some(v) =\u003e visitor.visit_some(ContentDeserializer::new(*v)),\n                Content::Newtype(v) =\u003e visitor.visit_newtype_struct(ContentDeserializer::new(*v)),\n                Content::Seq(v) =\u003e visit_content_seq(v, visitor),\n                Content::Map(v) =\u003e visit_content_map(v, visitor),\n            }\n        }\n\n        fn deserialize_bool\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Bool(v) =\u003e visitor.visit_bool(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_i8\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i16\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u8\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u16\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_f32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::F32(v) =\u003e visitor.visit_f32(v),\n                Content::F64(v) =\u003e visitor.visit_f64(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_f64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::F64(v) =\u003e visitor.visit_f64(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_char\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Char(v) =\u003e visitor.visit_char(v),\n                Content::String(v) =\u003e visitor.visit_string(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_string(visitor)\n        }\n\n        fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::String(v) =\u003e visitor.visit_string(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(v) =\u003e visitor.visit_byte_buf(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_bytes\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_byte_buf(visitor)\n        }\n\n        fn deserialize_byte_buf\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::String(v) =\u003e visitor.visit_string(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(v) =\u003e visitor.visit_byte_buf(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                Content::Seq(v) =\u003e visit_content_seq(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::None =\u003e visitor.visit_none(),\n                Content::Some(v) =\u003e visitor.visit_some(ContentDeserializer::new(*v)),\n                Content::Unit =\u003e visitor.visit_unit(),\n                _ =\u003e visitor.visit_some(self),\n            }\n        }\n\n        fn deserialize_unit\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Unit =\u003e visitor.visit_unit(),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_unit_struct\u003cV\u003e(\n            self,\n            _name: \u0026'static str,\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                // As a special case, allow deserializing untagged newtype\n                // variant containing unit struct.\n                //\n                //     #[derive(Deserialize)]\n                //     struct Info;\n                //\n                //     #[derive(Deserialize)]\n                //     #[serde(tag = \"topic\")]\n                //     enum Message {\n                //         Info(Info),\n                //     }\n                //\n                // We want {\"topic\":\"Info\"} to deserialize even though\n                // ordinarily unit structs do not deserialize from empty map.\n                Content::Map(ref v) if v.is_empty() =\u003e visitor.visit_unit(),\n                _ =\u003e self.deserialize_any(visitor),\n            }\n        }\n\n        fn deserialize_newtype_struct\u003cV\u003e(\n            self,\n            _name: \u0026str,\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Newtype(v) =\u003e visitor.visit_newtype_struct(ContentDeserializer::new(*v)),\n                _ =\u003e visitor.visit_newtype_struct(self),\n            }\n        }\n\n        fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Seq(v) =\u003e visit_content_seq(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_tuple\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_seq(visitor)\n        }\n\n        fn deserialize_tuple_struct\u003cV\u003e(\n            self,\n            _name: \u0026'static str,\n            _len: usize,\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_seq(visitor)\n        }\n\n        fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Map(v) =\u003e visit_content_map(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_struct\u003cV\u003e(\n            self,\n            _name: \u0026'static str,\n            _fields: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Seq(v) =\u003e visit_content_seq(v, visitor),\n                Content::Map(v) =\u003e visit_content_map(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_enum\u003cV\u003e(\n            self,\n            _name: \u0026str,\n            _variants: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            let (variant, value) = match self.content {\n                Content::Map(value) =\u003e {\n                    let mut iter = value.into_iter();\n                    let (variant, value) = match iter.next() {\n                        Some(v) =\u003e v,\n                        None =\u003e {\n                            return Err(de::Error::invalid_value(\n                                de::Unexpected::Map,\n                                \u0026\"map with a single key\",\n                            ));\n                        }\n                    };\n                    // enums are encoded in json as maps with a single key:value pair\n                    if iter.next().is_some() {\n                        return Err(de::Error::invalid_value(\n                            de::Unexpected::Map,\n                            \u0026\"map with a single key\",\n                        ));\n                    }\n                    (variant, Some(value))\n                }\n                s @ Content::String(_) | s @ Content::Str(_) =\u003e (s, None),\n                other =\u003e {\n                    return Err(de::Error::invalid_type(\n                        other.unexpected(),\n                        \u0026\"string or map\",\n                    ));\n                }\n            };\n\n            visitor.visit_enum(EnumDeserializer::new(variant, value))\n        }\n\n        fn deserialize_identifier\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::String(v) =\u003e visitor.visit_string(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(v) =\u003e visitor.visit_byte_buf(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                Content::U8(v) =\u003e visitor.visit_u8(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_ignored_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            drop(self);\n            visitor.visit_unit()\n        }\n    }\n\n    impl\u003c'de, E\u003e ContentDeserializer\u003c'de, E\u003e {\n        /// private API, don't use\n        pub fn new(content: Content\u003c'de\u003e) -\u003e Self {\n            ContentDeserializer {\n                content: content,\n                err: PhantomData,\n            }\n        }\n    }\n\n    pub struct EnumDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        variant: Content\u003c'de\u003e,\n        value: Option\u003cContent\u003c'de\u003e\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, E\u003e EnumDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        pub fn new(variant: Content\u003c'de\u003e, value: Option\u003cContent\u003c'de\u003e\u003e) -\u003e EnumDeserializer\u003c'de, E\u003e {\n            EnumDeserializer {\n                variant: variant,\n                value: value,\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de, E\u003e de::EnumAccess\u003c'de\u003e for EnumDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n        type Variant = VariantDeserializer\u003c'de, Self::Error\u003e;\n\n        fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), E\u003e\n        where\n            V: de::DeserializeSeed\u003c'de\u003e,\n        {\n            let visitor = VariantDeserializer {\n                value: self.value,\n                err: PhantomData,\n            };\n            seed.deserialize(ContentDeserializer::new(self.variant))\n                .map(|v| (v, visitor))\n        }\n    }\n\n    pub struct VariantDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        value: Option\u003cContent\u003c'de\u003e\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, E\u003e de::VariantAccess\u003c'de\u003e for VariantDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn unit_variant(self) -\u003e Result\u003c(), E\u003e {\n            match self.value {\n                Some(value) =\u003e de::Deserialize::deserialize(ContentDeserializer::new(value)),\n                None =\u003e Ok(()),\n            }\n        }\n\n        fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, E\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.value {\n                Some(value) =\u003e seed.deserialize(ContentDeserializer::new(value)),\n                None =\u003e Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    \u0026\"newtype variant\",\n                )),\n            }\n        }\n\n        fn tuple_variant\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            match self.value {\n                Some(Content::Seq(v)) =\u003e {\n                    de::Deserializer::deserialize_any(SeqDeserializer::new(v), visitor)\n                }\n                Some(other) =\u003e Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    \u0026\"tuple variant\",\n                )),\n                None =\u003e Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    \u0026\"tuple variant\",\n                )),\n            }\n        }\n\n        fn struct_variant\u003cV\u003e(\n            self,\n            _fields: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            match self.value {\n                Some(Content::Map(v)) =\u003e {\n                    de::Deserializer::deserialize_any(MapDeserializer::new(v), visitor)\n                }\n                Some(Content::Seq(v)) =\u003e {\n                    de::Deserializer::deserialize_any(SeqDeserializer::new(v), visitor)\n                }\n                Some(other) =\u003e Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    \u0026\"struct variant\",\n                )),\n                _ =\u003e Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    \u0026\"struct variant\",\n                )),\n            }\n        }\n    }\n\n    struct SeqDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        iter: \u003cVec\u003cContent\u003c'de\u003e\u003e as IntoIterator\u003e::IntoIter,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, E\u003e SeqDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        fn new(vec: Vec\u003cContent\u003c'de\u003e\u003e) -\u003e Self {\n            SeqDeserializer {\n                iter: vec.into_iter(),\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for SeqDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        #[inline]\n        fn deserialize_any\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            let len = self.iter.len();\n            if len == 0 {\n                visitor.visit_unit()\n            } else {\n                let ret = try!(visitor.visit_seq(\u0026mut self));\n                let remaining = self.iter.len();\n                if remaining == 0 {\n                    Ok(ret)\n                } else {\n                    Err(de::Error::invalid_length(len, \u0026\"fewer elements in array\"))\n                }\n            }\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf option unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    impl\u003c'de, E\u003e de::SeqAccess\u003c'de\u003e for SeqDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.iter.next() {\n                Some(value) =\u003e seed.deserialize(ContentDeserializer::new(value)).map(Some),\n                None =\u003e Ok(None),\n            }\n        }\n\n        fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n            size_hint::from_bounds(\u0026self.iter)\n        }\n    }\n\n    struct MapDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        iter: \u003cVec\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e as IntoIterator\u003e::IntoIter,\n        value: Option\u003cContent\u003c'de\u003e\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, E\u003e MapDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        fn new(map: Vec\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e) -\u003e Self {\n            MapDeserializer {\n                iter: map.into_iter(),\n                value: None,\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de, E\u003e de::MapAccess\u003c'de\u003e for MapDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn next_key_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.iter.next() {\n                Some((key, value)) =\u003e {\n                    self.value = Some(value);\n                    seed.deserialize(ContentDeserializer::new(key)).map(Some)\n                }\n                None =\u003e Ok(None),\n            }\n        }\n\n        fn next_value_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.value.take() {\n                Some(value) =\u003e seed.deserialize(ContentDeserializer::new(value)),\n                None =\u003e Err(de::Error::custom(\"value is missing\")),\n            }\n        }\n\n        fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n            size_hint::from_bounds(\u0026self.iter)\n        }\n    }\n\n    impl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for MapDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        #[inline]\n        fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            visitor.visit_map(self)\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf option unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    /// Not public API.\n    pub struct ContentRefDeserializer\u003c'a, 'de: 'a, E\u003e {\n        content: \u0026'a Content\u003c'de\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'a, 'de, E\u003e ContentRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        #[cold]\n        fn invalid_type(self, exp: \u0026Expected) -\u003e E {\n            de::Error::invalid_type(self.content.unexpected(), exp)\n        }\n\n        fn deserialize_integer\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::U8(v) =\u003e visitor.visit_u8(v),\n                Content::U16(v) =\u003e visitor.visit_u16(v),\n                Content::U32(v) =\u003e visitor.visit_u32(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I8(v) =\u003e visitor.visit_i8(v),\n                Content::I16(v) =\u003e visitor.visit_i16(v),\n                Content::I32(v) =\u003e visitor.visit_i32(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n    }\n\n    fn visit_content_seq_ref\u003c'a, 'de, V, E\u003e(\n        content: \u0026'a [Content\u003c'de\u003e],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, E\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n        E: de::Error,\n    {\n        let seq = content.iter().map(ContentRefDeserializer::new);\n        let mut seq_visitor = de::value::SeqDeserializer::new(seq);\n        let value = try!(visitor.visit_seq(\u0026mut seq_visitor));\n        try!(seq_visitor.end());\n        Ok(value)\n    }\n\n    fn visit_content_map_ref\u003c'a, 'de, V, E\u003e(\n        content: \u0026'a [(Content\u003c'de\u003e, Content\u003c'de\u003e)],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, E\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n        E: de::Error,\n    {\n        let map = content.iter().map(|\u0026(ref k, ref v)| {\n            (\n                ContentRefDeserializer::new(k),\n                ContentRefDeserializer::new(v),\n            )\n        });\n        let mut map_visitor = de::value::MapDeserializer::new(map);\n        let value = try!(visitor.visit_map(\u0026mut map_visitor));\n        try!(map_visitor.end());\n        Ok(value)\n    }\n\n    /// Used when deserializing an untagged enum because the content may need\n    /// to be used more than once.\n    impl\u003c'de, 'a, E\u003e Deserializer\u003c'de\u003e for ContentRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Bool(v) =\u003e visitor.visit_bool(v),\n                Content::U8(v) =\u003e visitor.visit_u8(v),\n                Content::U16(v) =\u003e visitor.visit_u16(v),\n                Content::U32(v) =\u003e visitor.visit_u32(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I8(v) =\u003e visitor.visit_i8(v),\n                Content::I16(v) =\u003e visitor.visit_i16(v),\n                Content::I32(v) =\u003e visitor.visit_i32(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                Content::F32(v) =\u003e visitor.visit_f32(v),\n                Content::F64(v) =\u003e visitor.visit_f64(v),\n                Content::Char(v) =\u003e visitor.visit_char(v),\n                Content::String(ref v) =\u003e visitor.visit_str(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(ref v) =\u003e visitor.visit_bytes(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                Content::Unit =\u003e visitor.visit_unit(),\n                Content::None =\u003e visitor.visit_none(),\n                Content::Some(ref v) =\u003e visitor.visit_some(ContentRefDeserializer::new(v)),\n                Content::Newtype(ref v) =\u003e {\n                    visitor.visit_newtype_struct(ContentRefDeserializer::new(v))\n                }\n                Content::Seq(ref v) =\u003e visit_content_seq_ref(v, visitor),\n                Content::Map(ref v) =\u003e visit_content_map_ref(v, visitor),\n            }\n        }\n\n        fn deserialize_bool\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Bool(v) =\u003e visitor.visit_bool(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_i8\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i16\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u8\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u16\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_f32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::F32(v) =\u003e visitor.visit_f32(v),\n                Content::F64(v) =\u003e visitor.visit_f64(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_f64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::F64(v) =\u003e visitor.visit_f64(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_char\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Char(v) =\u003e visitor.visit_char(v),\n                Content::String(ref v) =\u003e visitor.visit_str(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::String(ref v) =\u003e visitor.visit_str(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(ref v) =\u003e visitor.visit_bytes(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_str(visitor)\n        }\n\n        fn deserialize_bytes\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::String(ref v) =\u003e visitor.visit_str(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(ref v) =\u003e visitor.visit_bytes(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                Content::Seq(ref v) =\u003e visit_content_seq_ref(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_byte_buf\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_bytes(visitor)\n        }\n\n        fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::None =\u003e visitor.visit_none(),\n                Content::Some(ref v) =\u003e visitor.visit_some(ContentRefDeserializer::new(v)),\n                Content::Unit =\u003e visitor.visit_unit(),\n                _ =\u003e visitor.visit_some(self),\n            }\n        }\n\n        fn deserialize_unit\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Unit =\u003e visitor.visit_unit(),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_unit_struct\u003cV\u003e(\n            self,\n            _name: \u0026'static str,\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_unit(visitor)\n        }\n\n        fn deserialize_newtype_struct\u003cV\u003e(self, _name: \u0026str, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Newtype(ref v) =\u003e {\n                    visitor.visit_newtype_struct(ContentRefDeserializer::new(v))\n                }\n                _ =\u003e visitor.visit_newtype_struct(self),\n            }\n        }\n\n        fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Seq(ref v) =\u003e visit_content_seq_ref(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_tuple\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_seq(visitor)\n        }\n\n        fn deserialize_tuple_struct\u003cV\u003e(\n            self,\n            _name: \u0026'static str,\n            _len: usize,\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_seq(visitor)\n        }\n\n        fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Map(ref v) =\u003e visit_content_map_ref(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_struct\u003cV\u003e(\n            self,\n            _name: \u0026'static str,\n            _fields: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Seq(ref v) =\u003e visit_content_seq_ref(v, visitor),\n                Content::Map(ref v) =\u003e visit_content_map_ref(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_enum\u003cV\u003e(\n            self,\n            _name: \u0026str,\n            _variants: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            let (variant, value) = match *self.content {\n                Content::Map(ref value) =\u003e {\n                    let mut iter = value.iter();\n                    let \u0026(ref variant, ref value) = match iter.next() {\n                        Some(v) =\u003e v,\n                        None =\u003e {\n                            return Err(de::Error::invalid_value(\n                                de::Unexpected::Map,\n                                \u0026\"map with a single key\",\n                            ));\n                        }\n                    };\n                    // enums are encoded in json as maps with a single key:value pair\n                    if iter.next().is_some() {\n                        return Err(de::Error::invalid_value(\n                            de::Unexpected::Map,\n                            \u0026\"map with a single key\",\n                        ));\n                    }\n                    (variant, Some(value))\n                }\n                ref s @ Content::String(_) | ref s @ Content::Str(_) =\u003e (s, None),\n                ref other =\u003e {\n                    return Err(de::Error::invalid_type(\n                        other.unexpected(),\n                        \u0026\"string or map\",\n                    ));\n                }\n            };\n\n            visitor.visit_enum(EnumRefDeserializer {\n                variant: variant,\n                value: value,\n                err: PhantomData,\n            })\n        }\n\n        fn deserialize_identifier\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::String(ref v) =\u003e visitor.visit_str(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(ref v) =\u003e visitor.visit_bytes(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                Content::U8(v) =\u003e visitor.visit_u8(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_ignored_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            visitor.visit_unit()\n        }\n    }\n\n    impl\u003c'a, 'de, E\u003e ContentRefDeserializer\u003c'a, 'de, E\u003e {\n        /// private API, don't use\n        pub fn new(content: \u0026'a Content\u003c'de\u003e) -\u003e Self {\n            ContentRefDeserializer {\n                content: content,\n                err: PhantomData,\n            }\n        }\n    }\n\n    struct EnumRefDeserializer\u003c'a, 'de: 'a, E\u003e\n    where\n        E: de::Error,\n    {\n        variant: \u0026'a Content\u003c'de\u003e,\n        value: Option\u003c\u0026'a Content\u003c'de\u003e\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, 'a, E\u003e de::EnumAccess\u003c'de\u003e for EnumRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n        type Variant = VariantRefDeserializer\u003c'a, 'de, Self::Error\u003e;\n\n        fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n        where\n            V: de::DeserializeSeed\u003c'de\u003e,\n        {\n            let visitor = VariantRefDeserializer {\n                value: self.value,\n                err: PhantomData,\n            };\n            seed.deserialize(ContentRefDeserializer::new(self.variant))\n                .map(|v| (v, visitor))\n        }\n    }\n\n    struct VariantRefDeserializer\u003c'a, 'de: 'a, E\u003e\n    where\n        E: de::Error,\n    {\n        value: Option\u003c\u0026'a Content\u003c'de\u003e\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, 'a, E\u003e de::VariantAccess\u003c'de\u003e for VariantRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn unit_variant(self) -\u003e Result\u003c(), E\u003e {\n            match self.value {\n                Some(value) =\u003e de::Deserialize::deserialize(ContentRefDeserializer::new(value)),\n                None =\u003e Ok(()),\n            }\n        }\n\n        fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, E\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.value {\n                Some(value) =\u003e seed.deserialize(ContentRefDeserializer::new(value)),\n                None =\u003e Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    \u0026\"newtype variant\",\n                )),\n            }\n        }\n\n        fn tuple_variant\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            match self.value {\n                Some(\u0026Content::Seq(ref v)) =\u003e {\n                    de::Deserializer::deserialize_any(SeqRefDeserializer::new(v), visitor)\n                }\n                Some(other) =\u003e Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    \u0026\"tuple variant\",\n                )),\n                None =\u003e Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    \u0026\"tuple variant\",\n                )),\n            }\n        }\n\n        fn struct_variant\u003cV\u003e(\n            self,\n            _fields: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            match self.value {\n                Some(\u0026Content::Map(ref v)) =\u003e {\n                    de::Deserializer::deserialize_any(MapRefDeserializer::new(v), visitor)\n                }\n                Some(\u0026Content::Seq(ref v)) =\u003e {\n                    de::Deserializer::deserialize_any(SeqRefDeserializer::new(v), visitor)\n                }\n                Some(other) =\u003e Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    \u0026\"struct variant\",\n                )),\n                _ =\u003e Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    \u0026\"struct variant\",\n                )),\n            }\n        }\n    }\n\n    struct SeqRefDeserializer\u003c'a, 'de: 'a, E\u003e\n    where\n        E: de::Error,\n    {\n        iter: \u003c\u0026'a [Content\u003c'de\u003e] as IntoIterator\u003e::IntoIter,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'a, 'de, E\u003e SeqRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        fn new(slice: \u0026'a [Content\u003c'de\u003e]) -\u003e Self {\n            SeqRefDeserializer {\n                iter: slice.iter(),\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de, 'a, E\u003e de::Deserializer\u003c'de\u003e for SeqRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        #[inline]\n        fn deserialize_any\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            let len = self.iter.len();\n            if len == 0 {\n                visitor.visit_unit()\n            } else {\n                let ret = try!(visitor.visit_seq(\u0026mut self));\n                let remaining = self.iter.len();\n                if remaining == 0 {\n                    Ok(ret)\n                } else {\n                    Err(de::Error::invalid_length(len, \u0026\"fewer elements in array\"))\n                }\n            }\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf option unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    impl\u003c'de, 'a, E\u003e de::SeqAccess\u003c'de\u003e for SeqRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.iter.next() {\n                Some(value) =\u003e seed\n                    .deserialize(ContentRefDeserializer::new(value))\n                    .map(Some),\n                None =\u003e Ok(None),\n            }\n        }\n\n        fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n            size_hint::from_bounds(\u0026self.iter)\n        }\n    }\n\n    struct MapRefDeserializer\u003c'a, 'de: 'a, E\u003e\n    where\n        E: de::Error,\n    {\n        iter: \u003c\u0026'a [(Content\u003c'de\u003e, Content\u003c'de\u003e)] as IntoIterator\u003e::IntoIter,\n        value: Option\u003c\u0026'a Content\u003c'de\u003e\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'a, 'de, E\u003e MapRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        fn new(map: \u0026'a [(Content\u003c'de\u003e, Content\u003c'de\u003e)]) -\u003e Self {\n            MapRefDeserializer {\n                iter: map.iter(),\n                value: None,\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de, 'a, E\u003e de::MapAccess\u003c'de\u003e for MapRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn next_key_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.iter.next() {\n                Some(\u0026(ref key, ref value)) =\u003e {\n                    self.value = Some(value);\n                    seed.deserialize(ContentRefDeserializer::new(key)).map(Some)\n                }\n                None =\u003e Ok(None),\n            }\n        }\n\n        fn next_value_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.value.take() {\n                Some(value) =\u003e seed.deserialize(ContentRefDeserializer::new(value)),\n                None =\u003e Err(de::Error::custom(\"value is missing\")),\n            }\n        }\n\n        fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n            size_hint::from_bounds(\u0026self.iter)\n        }\n    }\n\n    impl\u003c'de, 'a, E\u003e de::Deserializer\u003c'de\u003e for MapRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        #[inline]\n        fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            visitor.visit_map(self)\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf option unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    impl\u003c'de, E\u003e de::IntoDeserializer\u003c'de, E\u003e for ContentDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Deserializer = Self;\n\n        fn into_deserializer(self) -\u003e Self {\n            self\n        }\n    }\n\n    impl\u003c'de, 'a, E\u003e de::IntoDeserializer\u003c'de, E\u003e for ContentRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Deserializer = Self;\n\n        fn into_deserializer(self) -\u003e Self {\n            self\n        }\n    }\n\n    /// Visitor for deserializing an internally tagged unit variant.\n    ///\n    /// Not public API.\n    pub struct InternallyTaggedUnitVisitor\u003c'a\u003e {\n        type_name: \u0026'a str,\n        variant_name: \u0026'a str,\n    }\n\n    impl\u003c'a\u003e InternallyTaggedUnitVisitor\u003c'a\u003e {\n        /// Not public API.\n        pub fn new(type_name: \u0026'a str, variant_name: \u0026'a str) -\u003e Self {\n            InternallyTaggedUnitVisitor {\n                type_name: type_name,\n                variant_name: variant_name,\n            }\n        }\n    }\n\n    impl\u003c'de, 'a\u003e Visitor\u003c'de\u003e for InternallyTaggedUnitVisitor\u003c'a\u003e {\n        type Value = ();\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(\n                formatter,\n                \"unit variant {}::{}\",\n                self.type_name, self.variant_name\n            )\n        }\n\n        fn visit_seq\u003cS\u003e(self, _: S) -\u003e Result\u003c(), S::Error\u003e\n        where\n            S: SeqAccess\u003c'de\u003e,\n        {\n            Ok(())\n        }\n\n        fn visit_map\u003cM\u003e(self, mut access: M) -\u003e Result\u003c(), M::Error\u003e\n        where\n            M: MapAccess\u003c'de\u003e,\n        {\n            while let Some(_) = try!(access.next_entry::\u003cIgnoredAny, IgnoredAny\u003e()) {}\n            Ok(())\n        }\n    }\n\n    /// Visitor for deserializing an untagged unit variant.\n    ///\n    /// Not public API.\n    pub struct UntaggedUnitVisitor\u003c'a\u003e {\n        type_name: \u0026'a str,\n        variant_name: \u0026'a str,\n    }\n\n    impl\u003c'a\u003e UntaggedUnitVisitor\u003c'a\u003e {\n        /// Not public API.\n        pub fn new(type_name: \u0026'a str, variant_name: \u0026'a str) -\u003e Self {\n            UntaggedUnitVisitor {\n                type_name: type_name,\n                variant_name: variant_name,\n            }\n        }\n    }\n\n    impl\u003c'de, 'a\u003e Visitor\u003c'de\u003e for UntaggedUnitVisitor\u003c'a\u003e {\n        type Value = ();\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(\n                formatter,\n                \"unit variant {}::{}\",\n                self.type_name, self.variant_name\n            )\n        }\n\n        fn visit_unit\u003cE\u003e(self) -\u003e Result\u003c(), E\u003e\n        where\n            E: de::Error,\n        {\n            Ok(())\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Like `IntoDeserializer` but also implemented for `\u0026[u8]`. This is used for\n// the newtype fallthrough case of `field_identifier`.\n//\n//    #[derive(Deserialize)]\n//    #[serde(field_identifier)]\n//    enum F {\n//        A,\n//        B,\n//        Other(String), // deserialized using IdentifierDeserializer\n//    }\npub trait IdentifierDeserializer\u003c'de, E: Error\u003e {\n    type Deserializer: Deserializer\u003c'de, Error = E\u003e;\n\n    fn from(self) -\u003e Self::Deserializer;\n}\n\nimpl\u003c'de, E\u003e IdentifierDeserializer\u003c'de, E\u003e for u32\nwhere\n    E: Error,\n{\n    type Deserializer = \u003cu32 as IntoDeserializer\u003c'de, E\u003e\u003e::Deserializer;\n\n    fn from(self) -\u003e Self::Deserializer {\n        self.into_deserializer()\n    }\n}\n\npub struct StrDeserializer\u003c'a, E\u003e {\n    value: \u0026'a str,\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl\u003c'a, E\u003e IdentifierDeserializer\u003c'a, E\u003e for \u0026'a str\nwhere\n    E: Error,\n{\n    type Deserializer = StrDeserializer\u003c'a, E\u003e;\n\n    fn from(self) -\u003e Self::Deserializer {\n        StrDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, 'a, E\u003e Deserializer\u003c'de\u003e for StrDeserializer\u003c'a, E\u003e\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_str(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\npub struct BytesDeserializer\u003c'a, E\u003e {\n    value: \u0026'a [u8],\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl\u003c'a, E\u003e IdentifierDeserializer\u003c'a, E\u003e for \u0026'a [u8]\nwhere\n    E: Error,\n{\n    type Deserializer = BytesDeserializer\u003c'a, E\u003e;\n\n    fn from(self) -\u003e Self::Deserializer {\n        BytesDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, 'a, E\u003e Deserializer\u003c'de\u003e for BytesDeserializer\u003c'a, E\u003e\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_bytes(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\n/// A DeserializeSeed helper for implementing deserialize_in_place Visitors.\n///\n/// Wraps a mutable reference and calls deserialize_in_place on it.\npub struct InPlaceSeed\u003c'a, T: 'a\u003e(pub \u0026'a mut T);\n\nimpl\u003c'a, 'de, T\u003e DeserializeSeed\u003c'de\u003e for InPlaceSeed\u003c'a, T\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    type Value = ();\n    fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize_in_place(deserializer, self.0)\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapDeserializer\u003c'a, 'de: 'a, E\u003e(\n    pub \u0026'a mut Vec\u003cOption\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e\u003e,\n    pub PhantomData\u003cE\u003e,\n);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e FlatMapDeserializer\u003c'a, 'de, E\u003e\nwhere\n    E: Error,\n{\n    fn deserialize_other\u003cV\u003e() -\u003e Result\u003cV, E\u003e {\n        Err(Error::custom(\"can only flatten structs and maps\"))\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! forward_to_deserialize_other {\n    ($($func:ident ( $($arg:ty),* ))*) =\u003e {\n        $(\n            fn $func\u003cV\u003e(self, $(_: $arg,)* _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                Self::deserialize_other()\n            }\n        )*\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e Deserializer\u003c'de\u003e for FlatMapDeserializer\u003c'a, 'de, E\u003e\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_map(FlatInternallyTaggedAccess {\n            iter: self.0.iter_mut(),\n            pending: None,\n            _marker: PhantomData,\n        })\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        for item in self.0.iter_mut() {\n            // items in the vector are nulled out when used.  So we can only use\n            // an item if it's still filled in and if the field is one we care\n            // about.\n            let use_item = match *item {\n                None =\u003e false,\n                Some((ref c, _)) =\u003e c.as_str().map_or(false, |x| variants.contains(\u0026x)),\n            };\n\n            if use_item {\n                let (key, value) = item.take().unwrap();\n                return visitor.visit_enum(EnumDeserializer::new(key, Some(value)));\n            }\n        }\n\n        Err(Error::custom(format_args!(\n            \"no variant of enum {} found in flattened data\",\n            name\n        )))\n    }\n\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_map(FlatMapAccess::new(self.0.iter()))\n    }\n\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        _: \u0026'static str,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_map(FlatStructAccess::new(self.0.iter_mut(), fields))\n    }\n\n    fn deserialize_newtype_struct\u003cV\u003e(self, _name: \u0026str, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_newtype_struct(self)\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match visitor.__private_visit_untagged_option(self) {\n            Ok(value) =\u003e Ok(value),\n            Err(()) =\u003e Self::deserialize_other(),\n        }\n    }\n\n    forward_to_deserialize_other! {\n        deserialize_bool()\n        deserialize_i8()\n        deserialize_i16()\n        deserialize_i32()\n        deserialize_i64()\n        deserialize_u8()\n        deserialize_u16()\n        deserialize_u32()\n        deserialize_u64()\n        deserialize_f32()\n        deserialize_f64()\n        deserialize_char()\n        deserialize_str()\n        deserialize_string()\n        deserialize_bytes()\n        deserialize_byte_buf()\n        deserialize_unit()\n        deserialize_unit_struct(\u0026'static str)\n        deserialize_seq()\n        deserialize_tuple(usize)\n        deserialize_tuple_struct(\u0026'static str, usize)\n        deserialize_identifier()\n        deserialize_ignored_any()\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapAccess\u003c'a, 'de: 'a, E\u003e {\n    iter: slice::Iter\u003c'a, Option\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e\u003e,\n    pending_content: Option\u003c\u0026'a Content\u003c'de\u003e\u003e,\n    _marker: PhantomData\u003cE\u003e,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e FlatMapAccess\u003c'a, 'de, E\u003e {\n    fn new(\n        iter: slice::Iter\u003c'a, Option\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e\u003e,\n    ) -\u003e FlatMapAccess\u003c'a, 'de, E\u003e {\n        FlatMapAccess {\n            iter: iter,\n            pending_content: None,\n            _marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e MapAccess\u003c'de\u003e for FlatMapAccess\u003c'a, 'de, E\u003e\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn next_key_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        while let Some(item) = self.iter.next() {\n            // Items in the vector are nulled out when used by a struct.\n            if let Some((ref key, ref content)) = *item {\n                self.pending_content = Some(content);\n                return seed.deserialize(ContentRefDeserializer::new(key)).map(Some);\n            }\n        }\n        Ok(None)\n    }\n\n    fn next_value_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.pending_content.take() {\n            Some(value) =\u003e seed.deserialize(ContentRefDeserializer::new(value)),\n            None =\u003e Err(Error::custom(\"value is missing\")),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatStructAccess\u003c'a, 'de: 'a, E\u003e {\n    iter: slice::IterMut\u003c'a, Option\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e\u003e,\n    pending_content: Option\u003cContent\u003c'de\u003e\u003e,\n    fields: \u0026'static [\u0026'static str],\n    _marker: PhantomData\u003cE\u003e,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e FlatStructAccess\u003c'a, 'de, E\u003e {\n    fn new(\n        iter: slice::IterMut\u003c'a, Option\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e\u003e,\n        fields: \u0026'static [\u0026'static str],\n    ) -\u003e FlatStructAccess\u003c'a, 'de, E\u003e {\n        FlatStructAccess {\n            iter: iter,\n            pending_content: None,\n            fields: fields,\n            _marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e MapAccess\u003c'de\u003e for FlatStructAccess\u003c'a, 'de, E\u003e\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn next_key_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        while let Some(item) = self.iter.next() {\n            // items in the vector are nulled out when used.  So we can only use\n            // an item if it's still filled in and if the field is one we care\n            // about.  In case we do not know which fields we want, we take them all.\n            let use_item = match *item {\n                None =\u003e false,\n                Some((ref c, _)) =\u003e c.as_str().map_or(false, |key| self.fields.contains(\u0026key)),\n            };\n\n            if use_item {\n                let (key, content) = item.take().unwrap();\n                self.pending_content = Some(content);\n                return seed.deserialize(ContentDeserializer::new(key)).map(Some);\n            }\n        }\n        Ok(None)\n    }\n\n    fn next_value_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.pending_content.take() {\n            Some(value) =\u003e seed.deserialize(ContentDeserializer::new(value)),\n            None =\u003e Err(Error::custom(\"value is missing\")),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatInternallyTaggedAccess\u003c'a, 'de: 'a, E\u003e {\n    iter: slice::IterMut\u003c'a, Option\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e\u003e,\n    pending: Option\u003c\u0026'a Content\u003c'de\u003e\u003e,\n    _marker: PhantomData\u003cE\u003e,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e MapAccess\u003c'de\u003e for FlatInternallyTaggedAccess\u003c'a, 'de, E\u003e\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn next_key_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        while let Some(item) = self.iter.next() {\n            if let Some((ref key, ref content)) = *item {\n                // Do not take(), instead borrow this entry. The internally tagged\n                // enum does its own buffering so we can't tell whether this entry\n                // is going to be consumed. Borrowing here leaves the entry\n                // available for later flattened fields.\n                self.pending = Some(content);\n                return seed.deserialize(ContentRefDeserializer::new(key)).map(Some);\n            }\n        }\n        Ok(None)\n    }\n\n    fn next_value_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.pending.take() {\n            Some(value) =\u003e seed.deserialize(ContentRefDeserializer::new(value)),\n            None =\u003e panic!(\"value is missing\"),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","private","macros.rs"],"content":"#[doc(hidden)]\n#[macro_export]\nmacro_rules! __private_serialize {\n    () =\u003e {\n        trait Serialize {\n            fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                S: $crate::Serializer;\n        }\n    };\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! __private_deserialize {\n    () =\u003e {\n        trait Deserialize\u003c'de\u003e: Sized {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: $crate::Deserializer\u003c'de\u003e;\n        }\n    };\n}\n\n/// Used only by Serde doc tests. Not public API.\n#[doc(hidden)]\n#[macro_export(local_inner_macros)]\nmacro_rules! __serialize_unimplemented {\n    ($($func:ident)*) =\u003e {\n        $(\n            __serialize_unimplemented_helper!($func);\n        )*\n    };\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! __serialize_unimplemented_method {\n    ($func:ident $(\u003c$t:ident\u003e)* ($($arg:ty),*) -\u003e $ret:ident) =\u003e {\n        fn $func $(\u003c$t: ?Sized + $crate::Serialize\u003e)* (self $(, _: $arg)*) -\u003e $crate::export::Result\u003cSelf::$ret, Self::Error\u003e {\n            unimplemented!()\n        }\n    };\n}\n\n#[doc(hidden)]\n#[macro_export(local_inner_macros)]\nmacro_rules! __serialize_unimplemented_helper {\n    (bool) =\u003e {\n        __serialize_unimplemented_method!(serialize_bool(bool) -\u003e Ok);\n    };\n    (i8) =\u003e {\n        __serialize_unimplemented_method!(serialize_i8(i8) -\u003e Ok);\n    };\n    (i16) =\u003e {\n        __serialize_unimplemented_method!(serialize_i16(i16) -\u003e Ok);\n    };\n    (i32) =\u003e {\n        __serialize_unimplemented_method!(serialize_i32(i32) -\u003e Ok);\n    };\n    (i64) =\u003e {\n        __serialize_unimplemented_method!(serialize_i64(i64) -\u003e Ok);\n    };\n    (u8) =\u003e {\n        __serialize_unimplemented_method!(serialize_u8(u8) -\u003e Ok);\n    };\n    (u16) =\u003e {\n        __serialize_unimplemented_method!(serialize_u16(u16) -\u003e Ok);\n    };\n    (u32) =\u003e {\n        __serialize_unimplemented_method!(serialize_u32(u32) -\u003e Ok);\n    };\n    (u64) =\u003e {\n        __serialize_unimplemented_method!(serialize_u64(u64) -\u003e Ok);\n    };\n    (f32) =\u003e {\n        __serialize_unimplemented_method!(serialize_f32(f32) -\u003e Ok);\n    };\n    (f64) =\u003e {\n        __serialize_unimplemented_method!(serialize_f64(f64) -\u003e Ok);\n    };\n    (char) =\u003e {\n        __serialize_unimplemented_method!(serialize_char(char) -\u003e Ok);\n    };\n    (str) =\u003e {\n        __serialize_unimplemented_method!(serialize_str(\u0026str) -\u003e Ok);\n    };\n    (bytes) =\u003e {\n        __serialize_unimplemented_method!(serialize_bytes(\u0026[u8]) -\u003e Ok);\n    };\n    (none) =\u003e {\n        __serialize_unimplemented_method!(serialize_none() -\u003e Ok);\n    };\n    (some) =\u003e {\n        __serialize_unimplemented_method!(serialize_some\u003cT\u003e(\u0026T) -\u003e Ok);\n    };\n    (unit) =\u003e {\n        __serialize_unimplemented_method!(serialize_unit() -\u003e Ok);\n    };\n    (unit_struct) =\u003e {\n        __serialize_unimplemented_method!(serialize_unit_struct(\u0026str) -\u003e Ok);\n    };\n    (unit_variant) =\u003e {\n        __serialize_unimplemented_method!(serialize_unit_variant(\u0026str, u32, \u0026str) -\u003e Ok);\n    };\n    (newtype_struct) =\u003e {\n        __serialize_unimplemented_method!(serialize_newtype_struct\u003cT\u003e(\u0026str, \u0026T) -\u003e Ok);\n    };\n    (newtype_variant) =\u003e {\n        __serialize_unimplemented_method!(serialize_newtype_variant\u003cT\u003e(\u0026str, u32, \u0026str, \u0026T) -\u003e Ok);\n    };\n    (seq) =\u003e {\n        type SerializeSeq = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_seq(Option\u003cusize\u003e) -\u003e SerializeSeq);\n    };\n    (tuple) =\u003e {\n        type SerializeTuple = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_tuple(usize) -\u003e SerializeTuple);\n    };\n    (tuple_struct) =\u003e {\n        type SerializeTupleStruct = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_tuple_struct(\u0026str, usize) -\u003e SerializeTupleStruct);\n    };\n    (tuple_variant) =\u003e {\n        type SerializeTupleVariant = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_tuple_variant(\u0026str, u32, \u0026str, usize) -\u003e SerializeTupleVariant);\n    };\n    (map) =\u003e {\n        type SerializeMap = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_map(Option\u003cusize\u003e) -\u003e SerializeMap);\n    };\n    (struct) =\u003e {\n        type SerializeStruct = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_struct(\u0026str, usize) -\u003e SerializeStruct);\n    };\n    (struct_variant) =\u003e {\n        type SerializeStructVariant = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_struct_variant(\u0026str, u32, \u0026str, usize) -\u003e SerializeStructVariant);\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","private","mod.rs"],"content":"mod macros;\n\npub mod de;\npub mod ser;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","private","ser.rs"],"content":"use lib::*;\n\nuse ser::{self, Impossible, Serialize, SerializeMap, SerializeStruct, Serializer};\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse self::content::{\n    Content, ContentSerializer, SerializeStructVariantAsMapValue, SerializeTupleVariantAsMapValue,\n};\n\n/// Used to check that serde(getter) attributes return the expected type.\n/// Not public API.\npub fn constrain\u003cT: ?Sized\u003e(t: \u0026T) -\u003e \u0026T {\n    t\n}\n\n/// Not public API.\npub fn serialize_tagged_newtype\u003cS, T\u003e(\n    serializer: S,\n    type_ident: \u0026'static str,\n    variant_ident: \u0026'static str,\n    tag: \u0026'static str,\n    variant_name: \u0026'static str,\n    value: \u0026T,\n) -\u003e Result\u003cS::Ok, S::Error\u003e\nwhere\n    S: Serializer,\n    T: Serialize,\n{\n    value.serialize(TaggedSerializer {\n        type_ident: type_ident,\n        variant_ident: variant_ident,\n        tag: tag,\n        variant_name: variant_name,\n        delegate: serializer,\n    })\n}\n\nstruct TaggedSerializer\u003cS\u003e {\n    type_ident: \u0026'static str,\n    variant_ident: \u0026'static str,\n    tag: \u0026'static str,\n    variant_name: \u0026'static str,\n    delegate: S,\n}\n\nenum Unsupported {\n    Boolean,\n    Integer,\n    Float,\n    Char,\n    String,\n    ByteArray,\n    Optional,\n    Unit,\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    UnitStruct,\n    Sequence,\n    Tuple,\n    TupleStruct,\n    Enum,\n}\n\nimpl Display for Unsupported {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match *self {\n            Unsupported::Boolean =\u003e formatter.write_str(\"a boolean\"),\n            Unsupported::Integer =\u003e formatter.write_str(\"an integer\"),\n            Unsupported::Float =\u003e formatter.write_str(\"a float\"),\n            Unsupported::Char =\u003e formatter.write_str(\"a char\"),\n            Unsupported::String =\u003e formatter.write_str(\"a string\"),\n            Unsupported::ByteArray =\u003e formatter.write_str(\"a byte array\"),\n            Unsupported::Optional =\u003e formatter.write_str(\"an optional\"),\n            Unsupported::Unit =\u003e formatter.write_str(\"unit\"),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Unsupported::UnitStruct =\u003e formatter.write_str(\"unit struct\"),\n            Unsupported::Sequence =\u003e formatter.write_str(\"a sequence\"),\n            Unsupported::Tuple =\u003e formatter.write_str(\"a tuple\"),\n            Unsupported::TupleStruct =\u003e formatter.write_str(\"a tuple struct\"),\n            Unsupported::Enum =\u003e formatter.write_str(\"an enum\"),\n        }\n    }\n}\n\nimpl\u003cS\u003e TaggedSerializer\u003cS\u003e\nwhere\n    S: Serializer,\n{\n    fn bad_type(self, what: Unsupported) -\u003e S::Error {\n        ser::Error::custom(format_args!(\n            \"cannot serialize tagged newtype variant {}::{} containing {}\",\n            self.type_ident, self.variant_ident, what\n        ))\n    }\n}\n\nimpl\u003cS\u003e Serializer for TaggedSerializer\u003cS\u003e\nwhere\n    S: Serializer,\n{\n    type Ok = S::Ok;\n    type Error = S::Error;\n\n    type SerializeSeq = Impossible\u003cS::Ok, S::Error\u003e;\n    type SerializeTuple = Impossible\u003cS::Ok, S::Error\u003e;\n    type SerializeTupleStruct = Impossible\u003cS::Ok, S::Error\u003e;\n    type SerializeMap = S::SerializeMap;\n    type SerializeStruct = S::SerializeStruct;\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    type SerializeTupleVariant = Impossible\u003cS::Ok, S::Error\u003e;\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    type SerializeTupleVariant = SerializeTupleVariantAsMapValue\u003cS::SerializeMap\u003e;\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    type SerializeStructVariant = Impossible\u003cS::Ok, S::Error\u003e;\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    type SerializeStructVariant = SerializeStructVariantAsMapValue\u003cS::SerializeMap\u003e;\n\n    fn serialize_bool(self, _: bool) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Boolean))\n    }\n\n    fn serialize_i8(self, _: i8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i16(self, _: i16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i32(self, _: i32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i64(self, _: i64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u8(self, _: u8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u16(self, _: u16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u32(self, _: u32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u64(self, _: u64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_f32(self, _: f32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Float))\n    }\n\n    fn serialize_f64(self, _: f64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Float))\n    }\n\n    fn serialize_char(self, _: char) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Char))\n    }\n\n    fn serialize_str(self, _: \u0026str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::String))\n    }\n\n    fn serialize_bytes(self, _: \u0026[u8]) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::ByteArray))\n    }\n\n    fn serialize_none(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Optional))\n    }\n\n    fn serialize_some\u003cT: ?Sized\u003e(self, _: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        Err(self.bad_type(Unsupported::Optional))\n    }\n\n    fn serialize_unit(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Unit))\n    }\n\n    fn serialize_unit_struct(self, _: \u0026'static str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        let mut map = try!(self.delegate.serialize_map(Some(1)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        map.end()\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        inner_variant: \u0026'static str,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        let mut map = try!(self.delegate.serialize_map(Some(2)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        try!(map.serialize_entry(inner_variant, \u0026()));\n        map.end()\n    }\n\n    fn serialize_newtype_struct\u003cT: ?Sized\u003e(\n        self,\n        _: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        inner_variant: \u0026'static str,\n        inner_value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        let mut map = try!(self.delegate.serialize_map(Some(2)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        try!(map.serialize_entry(inner_variant, inner_value));\n        map.end()\n    }\n\n    fn serialize_seq(self, _: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeSeq, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Sequence))\n    }\n\n    fn serialize_tuple(self, _: usize) -\u003e Result\u003cSelf::SerializeTuple, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Tuple))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleStruct, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::TupleStruct))\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn serialize_tuple_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        _: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleVariant, Self::Error\u003e {\n        // Lack of push-based serialization means we need to buffer the content\n        // of the tuple variant, so it requires std.\n        Err(self.bad_type(Unsupported::Enum))\n    }\n\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn serialize_tuple_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        inner_variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleVariant, Self::Error\u003e {\n        let mut map = try!(self.delegate.serialize_map(Some(2)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        try!(map.serialize_key(inner_variant));\n        Ok(SerializeTupleVariantAsMapValue::new(\n            map,\n            inner_variant,\n            len,\n        ))\n    }\n\n    fn serialize_map(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeMap, Self::Error\u003e {\n        let mut map = try!(self.delegate.serialize_map(len.map(|len| len + 1)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        Ok(map)\n    }\n\n    fn serialize_struct(\n        self,\n        name: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStruct, Self::Error\u003e {\n        let mut state = try!(self.delegate.serialize_struct(name, len + 1));\n        try!(state.serialize_field(self.tag, self.variant_name));\n        Ok(state)\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn serialize_struct_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        _: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeStructVariant, Self::Error\u003e {\n        // Lack of push-based serialization means we need to buffer the content\n        // of the struct variant, so it requires std.\n        Err(self.bad_type(Unsupported::Enum))\n    }\n\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn serialize_struct_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        inner_variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStructVariant, Self::Error\u003e {\n        let mut map = try!(self.delegate.serialize_map(Some(2)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        try!(map.serialize_key(inner_variant));\n        Ok(SerializeStructVariantAsMapValue::new(\n            map,\n            inner_variant,\n            len,\n        ))\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn collect_str\u003cT: ?Sized\u003e(self, _: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Display,\n    {\n        Err(self.bad_type(Unsupported::String))\n    }\n}\n\n/// Used only by Serde doc tests. Not public API.\n#[doc(hidden)]\n#[derive(Debug)]\npub struct Error;\n\nimpl ser::Error for Error {\n    fn custom\u003cT\u003e(_: T) -\u003e Self\n    where\n        T: Display,\n    {\n        unimplemented!()\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl error::Error for Error {\n    fn description(\u0026self) -\u003e \u0026str {\n        unimplemented!()\n    }\n}\n\nimpl Display for Error {\n    fn fmt(\u0026self, _: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        unimplemented!()\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmod content {\n    use lib::*;\n\n    use ser::{self, Serialize, Serializer};\n\n    pub struct SerializeTupleVariantAsMapValue\u003cM\u003e {\n        map: M,\n        name: \u0026'static str,\n        fields: Vec\u003cContent\u003e,\n    }\n\n    impl\u003cM\u003e SerializeTupleVariantAsMapValue\u003cM\u003e {\n        pub fn new(map: M, name: \u0026'static str, len: usize) -\u003e Self {\n            SerializeTupleVariantAsMapValue {\n                map: map,\n                name: name,\n                fields: Vec::with_capacity(len),\n            }\n        }\n    }\n\n    impl\u003cM\u003e ser::SerializeTupleVariant for SerializeTupleVariantAsMapValue\u003cM\u003e\n    where\n        M: ser::SerializeMap,\n    {\n        type Ok = M::Ok;\n        type Error = M::Error;\n\n        fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), M::Error\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cM::Error\u003e::new()));\n            self.fields.push(value);\n            Ok(())\n        }\n\n        fn end(mut self) -\u003e Result\u003cM::Ok, M::Error\u003e {\n            try!(self\n                .map\n                .serialize_value(\u0026Content::TupleStruct(self.name, self.fields)));\n            self.map.end()\n        }\n    }\n\n    pub struct SerializeStructVariantAsMapValue\u003cM\u003e {\n        map: M,\n        name: \u0026'static str,\n        fields: Vec\u003c(\u0026'static str, Content)\u003e,\n    }\n\n    impl\u003cM\u003e SerializeStructVariantAsMapValue\u003cM\u003e {\n        pub fn new(map: M, name: \u0026'static str, len: usize) -\u003e Self {\n            SerializeStructVariantAsMapValue {\n                map: map,\n                name: name,\n                fields: Vec::with_capacity(len),\n            }\n        }\n    }\n\n    impl\u003cM\u003e ser::SerializeStructVariant for SerializeStructVariantAsMapValue\u003cM\u003e\n    where\n        M: ser::SerializeMap,\n    {\n        type Ok = M::Ok;\n        type Error = M::Error;\n\n        fn serialize_field\u003cT: ?Sized\u003e(\n            \u0026mut self,\n            key: \u0026'static str,\n            value: \u0026T,\n        ) -\u003e Result\u003c(), M::Error\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cM::Error\u003e::new()));\n            self.fields.push((key, value));\n            Ok(())\n        }\n\n        fn end(mut self) -\u003e Result\u003cM::Ok, M::Error\u003e {\n            try!(self\n                .map\n                .serialize_value(\u0026Content::Struct(self.name, self.fields)));\n            self.map.end()\n        }\n    }\n\n    #[derive(Debug)]\n    pub enum Content {\n        Bool(bool),\n\n        U8(u8),\n        U16(u16),\n        U32(u32),\n        U64(u64),\n\n        I8(i8),\n        I16(i16),\n        I32(i32),\n        I64(i64),\n\n        F32(f32),\n        F64(f64),\n\n        Char(char),\n        String(String),\n        Bytes(Vec\u003cu8\u003e),\n\n        None,\n        Some(Box\u003cContent\u003e),\n\n        Unit,\n        UnitStruct(\u0026'static str),\n        UnitVariant(\u0026'static str, u32, \u0026'static str),\n        NewtypeStruct(\u0026'static str, Box\u003cContent\u003e),\n        NewtypeVariant(\u0026'static str, u32, \u0026'static str, Box\u003cContent\u003e),\n\n        Seq(Vec\u003cContent\u003e),\n        Tuple(Vec\u003cContent\u003e),\n        TupleStruct(\u0026'static str, Vec\u003cContent\u003e),\n        TupleVariant(\u0026'static str, u32, \u0026'static str, Vec\u003cContent\u003e),\n        Map(Vec\u003c(Content, Content)\u003e),\n        Struct(\u0026'static str, Vec\u003c(\u0026'static str, Content)\u003e),\n        StructVariant(\n            \u0026'static str,\n            u32,\n            \u0026'static str,\n            Vec\u003c(\u0026'static str, Content)\u003e,\n        ),\n    }\n\n    impl Serialize for Content {\n        fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n        where\n            S: Serializer,\n        {\n            match *self {\n                Content::Bool(b) =\u003e serializer.serialize_bool(b),\n                Content::U8(u) =\u003e serializer.serialize_u8(u),\n                Content::U16(u) =\u003e serializer.serialize_u16(u),\n                Content::U32(u) =\u003e serializer.serialize_u32(u),\n                Content::U64(u) =\u003e serializer.serialize_u64(u),\n                Content::I8(i) =\u003e serializer.serialize_i8(i),\n                Content::I16(i) =\u003e serializer.serialize_i16(i),\n                Content::I32(i) =\u003e serializer.serialize_i32(i),\n                Content::I64(i) =\u003e serializer.serialize_i64(i),\n                Content::F32(f) =\u003e serializer.serialize_f32(f),\n                Content::F64(f) =\u003e serializer.serialize_f64(f),\n                Content::Char(c) =\u003e serializer.serialize_char(c),\n                Content::String(ref s) =\u003e serializer.serialize_str(s),\n                Content::Bytes(ref b) =\u003e serializer.serialize_bytes(b),\n                Content::None =\u003e serializer.serialize_none(),\n                Content::Some(ref c) =\u003e serializer.serialize_some(\u0026**c),\n                Content::Unit =\u003e serializer.serialize_unit(),\n                Content::UnitStruct(n) =\u003e serializer.serialize_unit_struct(n),\n                Content::UnitVariant(n, i, v) =\u003e serializer.serialize_unit_variant(n, i, v),\n                Content::NewtypeStruct(n, ref c) =\u003e serializer.serialize_newtype_struct(n, \u0026**c),\n                Content::NewtypeVariant(n, i, v, ref c) =\u003e {\n                    serializer.serialize_newtype_variant(n, i, v, \u0026**c)\n                }\n                Content::Seq(ref elements) =\u003e elements.serialize(serializer),\n                Content::Tuple(ref elements) =\u003e {\n                    use ser::SerializeTuple;\n                    let mut tuple = try!(serializer.serialize_tuple(elements.len()));\n                    for e in elements {\n                        try!(tuple.serialize_element(e));\n                    }\n                    tuple.end()\n                }\n                Content::TupleStruct(n, ref fields) =\u003e {\n                    use ser::SerializeTupleStruct;\n                    let mut ts = try!(serializer.serialize_tuple_struct(n, fields.len()));\n                    for f in fields {\n                        try!(ts.serialize_field(f));\n                    }\n                    ts.end()\n                }\n                Content::TupleVariant(n, i, v, ref fields) =\u003e {\n                    use ser::SerializeTupleVariant;\n                    let mut tv = try!(serializer.serialize_tuple_variant(n, i, v, fields.len()));\n                    for f in fields {\n                        try!(tv.serialize_field(f));\n                    }\n                    tv.end()\n                }\n                Content::Map(ref entries) =\u003e {\n                    use ser::SerializeMap;\n                    let mut map = try!(serializer.serialize_map(Some(entries.len())));\n                    for \u0026(ref k, ref v) in entries {\n                        try!(map.serialize_entry(k, v));\n                    }\n                    map.end()\n                }\n                Content::Struct(n, ref fields) =\u003e {\n                    use ser::SerializeStruct;\n                    let mut s = try!(serializer.serialize_struct(n, fields.len()));\n                    for \u0026(k, ref v) in fields {\n                        try!(s.serialize_field(k, v));\n                    }\n                    s.end()\n                }\n                Content::StructVariant(n, i, v, ref fields) =\u003e {\n                    use ser::SerializeStructVariant;\n                    let mut sv = try!(serializer.serialize_struct_variant(n, i, v, fields.len()));\n                    for \u0026(k, ref v) in fields {\n                        try!(sv.serialize_field(k, v));\n                    }\n                    sv.end()\n                }\n            }\n        }\n    }\n\n    pub struct ContentSerializer\u003cE\u003e {\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ContentSerializer\u003cE\u003e {\n        pub fn new() -\u003e Self {\n            ContentSerializer { error: PhantomData }\n        }\n    }\n\n    impl\u003cE\u003e Serializer for ContentSerializer\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        type SerializeSeq = SerializeSeq\u003cE\u003e;\n        type SerializeTuple = SerializeTuple\u003cE\u003e;\n        type SerializeTupleStruct = SerializeTupleStruct\u003cE\u003e;\n        type SerializeTupleVariant = SerializeTupleVariant\u003cE\u003e;\n        type SerializeMap = SerializeMap\u003cE\u003e;\n        type SerializeStruct = SerializeStruct\u003cE\u003e;\n        type SerializeStructVariant = SerializeStructVariant\u003cE\u003e;\n\n        fn serialize_bool(self, v: bool) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Bool(v))\n        }\n\n        fn serialize_i8(self, v: i8) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::I8(v))\n        }\n\n        fn serialize_i16(self, v: i16) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::I16(v))\n        }\n\n        fn serialize_i32(self, v: i32) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::I32(v))\n        }\n\n        fn serialize_i64(self, v: i64) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::I64(v))\n        }\n\n        fn serialize_u8(self, v: u8) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::U8(v))\n        }\n\n        fn serialize_u16(self, v: u16) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::U16(v))\n        }\n\n        fn serialize_u32(self, v: u32) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::U32(v))\n        }\n\n        fn serialize_u64(self, v: u64) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::U64(v))\n        }\n\n        fn serialize_f32(self, v: f32) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::F32(v))\n        }\n\n        fn serialize_f64(self, v: f64) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::F64(v))\n        }\n\n        fn serialize_char(self, v: char) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Char(v))\n        }\n\n        fn serialize_str(self, value: \u0026str) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::String(value.to_owned()))\n        }\n\n        fn serialize_bytes(self, value: \u0026[u8]) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Bytes(value.to_owned()))\n        }\n\n        fn serialize_none(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::None)\n        }\n\n        fn serialize_some\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cContent, E\u003e\n        where\n            T: Serialize,\n        {\n            Ok(Content::Some(Box::new(try!(value.serialize(self)))))\n        }\n\n        fn serialize_unit(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Unit)\n        }\n\n        fn serialize_unit_struct(self, name: \u0026'static str) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::UnitStruct(name))\n        }\n\n        fn serialize_unit_variant(\n            self,\n            name: \u0026'static str,\n            variant_index: u32,\n            variant: \u0026'static str,\n        ) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::UnitVariant(name, variant_index, variant))\n        }\n\n        fn serialize_newtype_struct\u003cT: ?Sized\u003e(\n            self,\n            name: \u0026'static str,\n            value: \u0026T,\n        ) -\u003e Result\u003cContent, E\u003e\n        where\n            T: Serialize,\n        {\n            Ok(Content::NewtypeStruct(\n                name,\n                Box::new(try!(value.serialize(self))),\n            ))\n        }\n\n        fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n            self,\n            name: \u0026'static str,\n            variant_index: u32,\n            variant: \u0026'static str,\n            value: \u0026T,\n        ) -\u003e Result\u003cContent, E\u003e\n        where\n            T: Serialize,\n        {\n            Ok(Content::NewtypeVariant(\n                name,\n                variant_index,\n                variant,\n                Box::new(try!(value.serialize(self))),\n            ))\n        }\n\n        fn serialize_seq(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeSeq, E\u003e {\n            Ok(SerializeSeq {\n                elements: Vec::with_capacity(len.unwrap_or(0)),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_tuple(self, len: usize) -\u003e Result\u003cSelf::SerializeTuple, E\u003e {\n            Ok(SerializeTuple {\n                elements: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_tuple_struct(\n            self,\n            name: \u0026'static str,\n            len: usize,\n        ) -\u003e Result\u003cSelf::SerializeTupleStruct, E\u003e {\n            Ok(SerializeTupleStruct {\n                name: name,\n                fields: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_tuple_variant(\n            self,\n            name: \u0026'static str,\n            variant_index: u32,\n            variant: \u0026'static str,\n            len: usize,\n        ) -\u003e Result\u003cSelf::SerializeTupleVariant, E\u003e {\n            Ok(SerializeTupleVariant {\n                name: name,\n                variant_index: variant_index,\n                variant: variant,\n                fields: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_map(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeMap, E\u003e {\n            Ok(SerializeMap {\n                entries: Vec::with_capacity(len.unwrap_or(0)),\n                key: None,\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_struct(\n            self,\n            name: \u0026'static str,\n            len: usize,\n        ) -\u003e Result\u003cSelf::SerializeStruct, E\u003e {\n            Ok(SerializeStruct {\n                name: name,\n                fields: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_struct_variant(\n            self,\n            name: \u0026'static str,\n            variant_index: u32,\n            variant: \u0026'static str,\n            len: usize,\n        ) -\u003e Result\u003cSelf::SerializeStructVariant, E\u003e {\n            Ok(SerializeStructVariant {\n                name: name,\n                variant_index: variant_index,\n                variant: variant,\n                fields: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n    }\n\n    pub struct SerializeSeq\u003cE\u003e {\n        elements: Vec\u003cContent\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeSeq for SerializeSeq\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.elements.push(value);\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Seq(self.elements))\n        }\n    }\n\n    pub struct SerializeTuple\u003cE\u003e {\n        elements: Vec\u003cContent\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeTuple for SerializeTuple\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.elements.push(value);\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Tuple(self.elements))\n        }\n    }\n\n    pub struct SerializeTupleStruct\u003cE\u003e {\n        name: \u0026'static str,\n        fields: Vec\u003cContent\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeTupleStruct for SerializeTupleStruct\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.fields.push(value);\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::TupleStruct(self.name, self.fields))\n        }\n    }\n\n    pub struct SerializeTupleVariant\u003cE\u003e {\n        name: \u0026'static str,\n        variant_index: u32,\n        variant: \u0026'static str,\n        fields: Vec\u003cContent\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeTupleVariant for SerializeTupleVariant\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.fields.push(value);\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::TupleVariant(\n                self.name,\n                self.variant_index,\n                self.variant,\n                self.fields,\n            ))\n        }\n    }\n\n    pub struct SerializeMap\u003cE\u003e {\n        entries: Vec\u003c(Content, Content)\u003e,\n        key: Option\u003cContent\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeMap for SerializeMap\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let key = try!(key.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.key = Some(key);\n            Ok(())\n        }\n\n        fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let key = self\n                .key\n                .take()\n                .expect(\"serialize_value called before serialize_key\");\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.entries.push((key, value));\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Map(self.entries))\n        }\n\n        fn serialize_entry\u003cK: ?Sized, V: ?Sized\u003e(\u0026mut self, key: \u0026K, value: \u0026V) -\u003e Result\u003c(), E\u003e\n        where\n            K: Serialize,\n            V: Serialize,\n        {\n            let key = try!(key.serialize(ContentSerializer::\u003cE\u003e::new()));\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.entries.push((key, value));\n            Ok(())\n        }\n    }\n\n    pub struct SerializeStruct\u003cE\u003e {\n        name: \u0026'static str,\n        fields: Vec\u003c(\u0026'static str, Content)\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeStruct for SerializeStruct\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026'static str, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.fields.push((key, value));\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Struct(self.name, self.fields))\n        }\n    }\n\n    pub struct SerializeStructVariant\u003cE\u003e {\n        name: \u0026'static str,\n        variant_index: u32,\n        variant: \u0026'static str,\n        fields: Vec\u003c(\u0026'static str, Content)\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeStructVariant for SerializeStructVariant\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026'static str, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.fields.push((key, value));\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::StructVariant(\n                self.name,\n                self.variant_index,\n                self.variant,\n                self.fields,\n            ))\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapSerializer\u003c'a, M: 'a\u003e(pub \u0026'a mut M);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, M\u003e FlatMapSerializer\u003c'a, M\u003e\nwhere\n    M: SerializeMap + 'a,\n{\n    fn bad_type(self, what: Unsupported) -\u003e M::Error {\n        ser::Error::custom(format_args!(\n            \"can only flatten structs and maps (got {})\",\n            what\n        ))\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, M\u003e Serializer for FlatMapSerializer\u003c'a, M\u003e\nwhere\n    M: SerializeMap + 'a,\n{\n    type Ok = ();\n    type Error = M::Error;\n\n    type SerializeSeq = Impossible\u003cSelf::Ok, M::Error\u003e;\n    type SerializeTuple = Impossible\u003cSelf::Ok, M::Error\u003e;\n    type SerializeTupleStruct = Impossible\u003cSelf::Ok, M::Error\u003e;\n    type SerializeMap = FlatMapSerializeMap\u003c'a, M\u003e;\n    type SerializeStruct = FlatMapSerializeStruct\u003c'a, M\u003e;\n    type SerializeTupleVariant = Impossible\u003cSelf::Ok, M::Error\u003e;\n    type SerializeStructVariant = FlatMapSerializeStructVariantAsMapValue\u003c'a, M\u003e;\n\n    fn serialize_bool(self, _: bool) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Boolean))\n    }\n\n    fn serialize_i8(self, _: i8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i16(self, _: i16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i32(self, _: i32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i64(self, _: i64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u8(self, _: u8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u16(self, _: u16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u32(self, _: u32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u64(self, _: u64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_f32(self, _: f32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Float))\n    }\n\n    fn serialize_f64(self, _: f64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Float))\n    }\n\n    fn serialize_char(self, _: char) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Char))\n    }\n\n    fn serialize_str(self, _: \u0026str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::String))\n    }\n\n    fn serialize_bytes(self, _: \u0026[u8]) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::ByteArray))\n    }\n\n    fn serialize_none(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(())\n    }\n\n    fn serialize_some\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_unit(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Unit))\n    }\n\n    fn serialize_unit_struct(self, _: \u0026'static str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::UnitStruct))\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        _: \u0026'static str,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Enum))\n    }\n\n    fn serialize_newtype_struct\u003cT: ?Sized\u003e(\n        self,\n        _: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        variant: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        try!(self.0.serialize_key(variant));\n        self.0.serialize_value(value)\n    }\n\n    fn serialize_seq(self, _: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeSeq, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Sequence))\n    }\n\n    fn serialize_tuple(self, _: usize) -\u003e Result\u003cSelf::SerializeTuple, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Tuple))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleStruct, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::TupleStruct))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        _: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleVariant, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Enum))\n    }\n\n    fn serialize_map(self, _: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeMap, Self::Error\u003e {\n        Ok(FlatMapSerializeMap(self.0))\n    }\n\n    fn serialize_struct(\n        self,\n        _: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeStruct, Self::Error\u003e {\n        Ok(FlatMapSerializeStruct(self.0))\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        inner_variant: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeStructVariant, Self::Error\u003e {\n        try!(self.0.serialize_key(inner_variant));\n        Ok(FlatMapSerializeStructVariantAsMapValue::new(\n            self.0,\n            inner_variant,\n        ))\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapSerializeMap\u003c'a, M: 'a\u003e(\u0026'a mut M);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, M\u003e ser::SerializeMap for FlatMapSerializeMap\u003c'a, M\u003e\nwhere\n    M: SerializeMap + 'a,\n{\n    type Ok = ();\n    type Error = M::Error;\n\n    fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.0.serialize_key(key)\n    }\n\n    fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.0.serialize_value(value)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapSerializeStruct\u003c'a, M: 'a\u003e(\u0026'a mut M);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, M\u003e ser::SerializeStruct for FlatMapSerializeStruct\u003c'a, M\u003e\nwhere\n    M: SerializeMap + 'a,\n{\n    type Ok = ();\n    type Error = M::Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.0.serialize_entry(key, value)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapSerializeStructVariantAsMapValue\u003c'a, M: 'a\u003e {\n    map: \u0026'a mut M,\n    name: \u0026'static str,\n    fields: Vec\u003c(\u0026'static str, Content)\u003e,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, M\u003e FlatMapSerializeStructVariantAsMapValue\u003c'a, M\u003e\nwhere\n    M: SerializeMap + 'a,\n{\n    fn new(map: \u0026'a mut M, name: \u0026'static str) -\u003e FlatMapSerializeStructVariantAsMapValue\u003c'a, M\u003e {\n        FlatMapSerializeStructVariantAsMapValue {\n            map: map,\n            name: name,\n            fields: Vec::new(),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, M\u003e ser::SerializeStructVariant for FlatMapSerializeStructVariantAsMapValue\u003c'a, M\u003e\nwhere\n    M: SerializeMap + 'a,\n{\n    type Ok = ();\n    type Error = M::Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        let value = try!(value.serialize(ContentSerializer::\u003cM::Error\u003e::new()));\n        self.fields.push((key, value));\n        Ok(())\n    }\n\n    fn end(self) -\u003e Result\u003c(), Self::Error\u003e {\n        try!(self\n            .map\n            .serialize_value(\u0026Content::Struct(self.name, self.fields)));\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","ser","impls.rs"],"content":"use lib::*;\n\nuse ser::{Error, Serialize, SerializeTuple, Serializer};\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! primitive_impl {\n    ($ty:ident, $method:ident $($cast:tt)*) =\u003e {\n        impl Serialize for $ty {\n            #[inline]\n            fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                S: Serializer,\n            {\n                serializer.$method(*self $($cast)*)\n            }\n        }\n    }\n}\n\nprimitive_impl!(bool, serialize_bool);\nprimitive_impl!(isize, serialize_i64 as i64);\nprimitive_impl!(i8, serialize_i8);\nprimitive_impl!(i16, serialize_i16);\nprimitive_impl!(i32, serialize_i32);\nprimitive_impl!(i64, serialize_i64);\nprimitive_impl!(usize, serialize_u64 as u64);\nprimitive_impl!(u8, serialize_u8);\nprimitive_impl!(u16, serialize_u16);\nprimitive_impl!(u32, serialize_u32);\nprimitive_impl!(u64, serialize_u64);\nprimitive_impl!(f32, serialize_f32);\nprimitive_impl!(f64, serialize_f64);\nprimitive_impl!(char, serialize_char);\n\nserde_if_integer128! {\n    primitive_impl!(i128, serialize_i128);\n    primitive_impl!(u128, serialize_u128);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Serialize for str {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.serialize_str(self)\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl Serialize for String {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.serialize_str(self)\n    }\n}\n\nimpl\u003c'a\u003e Serialize for fmt::Arguments\u003c'a\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.collect_str(self)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl Serialize for CStr {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.serialize_bytes(self.to_bytes())\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for CString {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.serialize_bytes(self.to_bytes())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003cT\u003e Serialize for Option\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match *self {\n            Some(ref value) =\u003e serializer.serialize_some(value),\n            None =\u003e serializer.serialize_none(),\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003cT: ?Sized\u003e Serialize for PhantomData\u003cT\u003e {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.serialize_unit_struct(\"PhantomData\")\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Does not require T: Serialize.\nimpl\u003cT\u003e Serialize for [T; 0] {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        try!(serializer.serialize_tuple(0)).end()\n    }\n}\n\nmacro_rules! array_impls {\n    ($($len:tt)+) =\u003e {\n        $(\n            impl\u003cT\u003e Serialize for [T; $len]\n            where\n                T: Serialize,\n            {\n                #[inline]\n                fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n                where\n                    S: Serializer,\n                {\n                    let mut seq = try!(serializer.serialize_tuple($len));\n                    for e in self {\n                        try!(seq.serialize_element(e));\n                    }\n                    seq.end()\n                }\n            }\n        )+\n    }\n}\n\narray_impls! {\n    01 02 03 04 05 06 07 08 09 10\n    11 12 13 14 15 16 17 18 19 20\n    21 22 23 24 25 26 27 28 29 30\n    31 32\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003cT\u003e Serialize for [T]\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.collect_seq(self)\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! seq_impl {\n    ($ty:ident \u003c T $(: $tbound1:ident $(+ $tbound2:ident)*)* $(, $typaram:ident : $bound:ident)* \u003e) =\u003e {\n        impl\u003cT $(, $typaram)*\u003e Serialize for $ty\u003cT $(, $typaram)*\u003e\n        where\n            T: Serialize $(+ $tbound1 $(+ $tbound2)*)*,\n            $($typaram: $bound,)*\n        {\n            #[inline]\n            fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                S: Serializer,\n            {\n                serializer.collect_seq(self)\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(BinaryHeap\u003cT: Ord\u003e);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(BTreeSet\u003cT: Ord\u003e);\n\n#[cfg(feature = \"std\")]\nseq_impl!(HashSet\u003cT: Eq + Hash, H: BuildHasher\u003e);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(LinkedList\u003cT\u003e);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(Vec\u003cT\u003e);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(VecDeque\u003cT\u003e);\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003cIdx\u003e Serialize for Range\u003cIdx\u003e\nwhere\n    Idx: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use super::SerializeStruct;\n        let mut state = try!(serializer.serialize_struct(\"Range\", 2));\n        try!(state.serialize_field(\"start\", \u0026self.start));\n        try!(state.serialize_field(\"end\", \u0026self.end));\n        state.end()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(range_inclusive)]\nimpl\u003cIdx\u003e Serialize for RangeInclusive\u003cIdx\u003e\nwhere\n    Idx: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use super::SerializeStruct;\n        let mut state = try!(serializer.serialize_struct(\"RangeInclusive\", 2));\n        try!(state.serialize_field(\"start\", \u0026self.start()));\n        try!(state.serialize_field(\"end\", \u0026self.end()));\n        state.end()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(ops_bound, collections_bound))]\nimpl\u003cT\u003e Serialize for Bound\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match *self {\n            Bound::Unbounded =\u003e serializer.serialize_unit_variant(\"Bound\", 0, \"Unbounded\"),\n            Bound::Included(ref value) =\u003e {\n                serializer.serialize_newtype_variant(\"Bound\", 1, \"Included\", value)\n            }\n            Bound::Excluded(ref value) =\u003e {\n                serializer.serialize_newtype_variant(\"Bound\", 2, \"Excluded\", value)\n            }\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Serialize for () {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.serialize_unit()\n    }\n}\n\n#[cfg(feature = \"unstable\")]\nimpl Serialize for ! {\n    fn serialize\u003cS\u003e(\u0026self, _serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        *self\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! tuple_impls {\n    ($($len:expr =\u003e ($($n:tt $name:ident)+))+) =\u003e {\n        $(\n            impl\u003c$($name),+\u003e Serialize for ($($name,)+)\n            where\n                $($name: Serialize,)+\n            {\n                #[inline]\n                fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n                where\n                    S: Serializer,\n                {\n                    let mut tuple = try!(serializer.serialize_tuple($len));\n                    $(\n                        try!(tuple.serialize_element(\u0026self.$n));\n                    )+\n                    tuple.end()\n                }\n            }\n        )+\n    }\n}\n\ntuple_impls! {\n    1 =\u003e (0 T0)\n    2 =\u003e (0 T0 1 T1)\n    3 =\u003e (0 T0 1 T1 2 T2)\n    4 =\u003e (0 T0 1 T1 2 T2 3 T3)\n    5 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4)\n    6 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5)\n    7 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6)\n    8 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7)\n    9 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8)\n    10 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9)\n    11 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10)\n    12 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11)\n    13 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12)\n    14 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13)\n    15 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14)\n    16 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! map_impl {\n    ($ty:ident \u003c K $(: $kbound1:ident $(+ $kbound2:ident)*)*, V $(, $typaram:ident : $bound:ident)* \u003e) =\u003e {\n        impl\u003cK, V $(, $typaram)*\u003e Serialize for $ty\u003cK, V $(, $typaram)*\u003e\n        where\n            K: Serialize $(+ $kbound1 $(+ $kbound2)*)*,\n            V: Serialize,\n            $($typaram: $bound,)*\n        {\n            #[inline]\n            fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                S: Serializer,\n            {\n                serializer.collect_map(self)\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmap_impl!(BTreeMap\u003cK: Ord, V\u003e);\n\n#[cfg(feature = \"std\")]\nmap_impl!(HashMap\u003cK: Eq + Hash, V, H: BuildHasher\u003e);\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! deref_impl {\n    (\n        $(#[doc = $doc:tt])*\n        \u003c$($desc:tt)+\n    ) =\u003e {\n        $(#[doc = $doc])*\n        impl \u003c$($desc)+ {\n            #[inline]\n            fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                S: Serializer,\n            {\n                (**self).serialize(serializer)\n            }\n        }\n    };\n}\n\nderef_impl!(\u003c'a, T: ?Sized\u003e Serialize for \u0026'a T where T: Serialize);\nderef_impl!(\u003c'a, T: ?Sized\u003e Serialize for \u0026'a mut T where T: Serialize);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nderef_impl!(\u003cT: ?Sized\u003e Serialize for Box\u003cT\u003e where T: Serialize);\n\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nderef_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Serializing a data structure containing `Rc` will serialize a copy of\n    /// the contents of the `Rc` each time the `Rc` is referenced within the\n    /// data structure. Serialization will not attempt to deduplicate these\n    /// repeated data.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    \u003cT: ?Sized\u003e Serialize for Rc\u003cT\u003e where T: Serialize\n}\n\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nderef_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Serializing a data structure containing `Arc` will serialize a copy of\n    /// the contents of the `Arc` each time the `Arc` is referenced within the\n    /// data structure. Serialization will not attempt to deduplicate these\n    /// repeated data.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    \u003cT: ?Sized\u003e Serialize for Arc\u003cT\u003e where T: Serialize\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nderef_impl!(\u003c'a, T: ?Sized\u003e Serialize for Cow\u003c'a, T\u003e where T: Serialize + ToOwned);\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nimpl\u003cT: ?Sized\u003e Serialize for RcWeak\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.upgrade().serialize(serializer)\n    }\n}\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nimpl\u003cT: ?Sized\u003e Serialize for ArcWeak\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.upgrade().serialize(serializer)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! nonzero_integers {\n    ( $( $T: ident, )+ ) =\u003e {\n        $(\n            #[cfg(num_nonzero)]\n            impl Serialize for num::$T {\n                fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n                where\n                    S: Serializer,\n                {\n                    self.get().serialize(serializer)\n                }\n            }\n        )+\n    }\n}\n\nnonzero_integers! {\n    NonZeroU8,\n    NonZeroU16,\n    NonZeroU32,\n    NonZeroU64,\n    NonZeroUsize,\n}\n\n#[cfg(num_nonzero_signed)]\nnonzero_integers! {\n    NonZeroI8,\n    NonZeroI16,\n    NonZeroI32,\n    NonZeroI64,\n    NonZeroIsize,\n}\n\n// Currently 128-bit integers do not work on Emscripten targets so we need an\n// additional `#[cfg]`\nserde_if_integer128! {\n    nonzero_integers! {\n        NonZeroU128,\n    }\n\n    #[cfg(num_nonzero_signed)]\n    nonzero_integers! {\n        NonZeroI128,\n    }\n}\n\nimpl\u003cT\u003e Serialize for Cell\u003cT\u003e\nwhere\n    T: Serialize + Copy,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.get().serialize(serializer)\n    }\n}\n\nimpl\u003cT\u003e Serialize for RefCell\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match self.try_borrow() {\n            Ok(value) =\u003e value.serialize(serializer),\n            Err(_) =\u003e Err(S::Error::custom(\"already mutably borrowed\")),\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT\u003e Serialize for Mutex\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match self.lock() {\n            Ok(locked) =\u003e locked.serialize(serializer),\n            Err(_) =\u003e Err(S::Error::custom(\"lock poison error while serializing\")),\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT\u003e Serialize for RwLock\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match self.read() {\n            Ok(locked) =\u003e locked.serialize(serializer),\n            Err(_) =\u003e Err(S::Error::custom(\"lock poison error while serializing\")),\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003cT, E\u003e Serialize for Result\u003cT, E\u003e\nwhere\n    T: Serialize,\n    E: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match *self {\n            Result::Ok(ref value) =\u003e serializer.serialize_newtype_variant(\"Result\", 0, \"Ok\", value),\n            Result::Err(ref value) =\u003e {\n                serializer.serialize_newtype_variant(\"Result\", 1, \"Err\", value)\n            }\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(core_duration, feature = \"std\"))]\nimpl Serialize for Duration {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use super::SerializeStruct;\n        let mut state = try!(serializer.serialize_struct(\"Duration\", 2));\n        try!(state.serialize_field(\"secs\", \u0026self.as_secs()));\n        try!(state.serialize_field(\"nanos\", \u0026self.subsec_nanos()));\n        state.end()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl Serialize for SystemTime {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use super::SerializeStruct;\n        let duration_since_epoch = self\n            .duration_since(UNIX_EPOCH)\n            .expect(\"SystemTime must be later than UNIX_EPOCH\");\n        let mut state = try!(serializer.serialize_struct(\"SystemTime\", 2));\n        try!(state.serialize_field(\"secs_since_epoch\", \u0026duration_since_epoch.as_secs()));\n        try!(state.serialize_field(\"nanos_since_epoch\", \u0026duration_since_epoch.subsec_nanos()));\n        state.end()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Serialize a value that implements `Display` as a string, when that string is\n/// statically known to never have more than a constant `MAX_LEN` bytes.\n///\n/// Panics if the `Display` impl tries to write more than `MAX_LEN` bytes.\n#[cfg(feature = \"std\")]\nmacro_rules! serialize_display_bounded_length {\n    ($value:expr, $max:expr, $serializer:expr) =\u003e {{\n        #[allow(deprecated)]\n        let mut buffer: [u8; $max] = unsafe { mem::uninitialized() };\n        let remaining_len = {\n            let mut remaining = \u0026mut buffer[..];\n            write!(remaining, \"{}\", $value).unwrap();\n            remaining.len()\n        };\n        let written_len = buffer.len() - remaining_len;\n        let written = \u0026buffer[..written_len];\n\n        // write! only provides fmt::Formatter to Display implementations, which\n        // has methods write_str and write_char but no method to write arbitrary\n        // bytes. Therefore `written` must be valid UTF-8.\n        let written_str = unsafe { str::from_utf8_unchecked(written) };\n        $serializer.serialize_str(written_str)\n    }};\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::IpAddr {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            match *self {\n                net::IpAddr::V4(ref a) =\u003e a.serialize(serializer),\n                net::IpAddr::V6(ref a) =\u003e a.serialize(serializer),\n            }\n        } else {\n            match *self {\n                net::IpAddr::V4(ref a) =\u003e {\n                    serializer.serialize_newtype_variant(\"IpAddr\", 0, \"V4\", a)\n                }\n                net::IpAddr::V6(ref a) =\u003e {\n                    serializer.serialize_newtype_variant(\"IpAddr\", 1, \"V6\", a)\n                }\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::Ipv4Addr {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            const MAX_LEN: usize = 15;\n            debug_assert_eq!(MAX_LEN, \"101.102.103.104\".len());\n            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n        } else {\n            self.octets().serialize(serializer)\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::Ipv6Addr {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            const MAX_LEN: usize = 39;\n            debug_assert_eq!(MAX_LEN, \"1001:1002:1003:1004:1005:1006:1007:1008\".len());\n            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n        } else {\n            self.octets().serialize(serializer)\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::SocketAddr {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            match *self {\n                net::SocketAddr::V4(ref addr) =\u003e addr.serialize(serializer),\n                net::SocketAddr::V6(ref addr) =\u003e addr.serialize(serializer),\n            }\n        } else {\n            match *self {\n                net::SocketAddr::V4(ref addr) =\u003e {\n                    serializer.serialize_newtype_variant(\"SocketAddr\", 0, \"V4\", addr)\n                }\n                net::SocketAddr::V6(ref addr) =\u003e {\n                    serializer.serialize_newtype_variant(\"SocketAddr\", 1, \"V6\", addr)\n                }\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::SocketAddrV4 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            const MAX_LEN: usize = 21;\n            debug_assert_eq!(MAX_LEN, \"101.102.103.104:65000\".len());\n            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n        } else {\n            (self.ip(), self.port()).serialize(serializer)\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::SocketAddrV6 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            const MAX_LEN: usize = 47;\n            debug_assert_eq!(\n                MAX_LEN,\n                \"[1001:1002:1003:1004:1005:1006:1007:1008]:65000\".len()\n            );\n            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n        } else {\n            (self.ip(), self.port()).serialize(serializer)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl Serialize for Path {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match self.to_str() {\n            Some(s) =\u003e s.serialize(serializer),\n            None =\u003e Err(Error::custom(\"path contains invalid UTF-8 characters\")),\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for PathBuf {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.as_path().serialize(serializer)\n    }\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl Serialize for OsStr {\n    #[cfg(unix)]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use std::os::unix::ffi::OsStrExt;\n        serializer.serialize_newtype_variant(\"OsString\", 0, \"Unix\", self.as_bytes())\n    }\n\n    #[cfg(windows)]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use std::os::windows::ffi::OsStrExt;\n        let val = self.encode_wide().collect::\u003cVec\u003c_\u003e\u003e();\n        serializer.serialize_newtype_variant(\"OsString\", 1, \"Windows\", \u0026val)\n    }\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl Serialize for OsString {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.as_os_str().serialize(serializer)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl\u003cT\u003e Serialize for Wrapping\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.0.serialize(serializer)\n    }\n}\n\n#[cfg(core_reverse)]\nimpl\u003cT\u003e Serialize for Reverse\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.0.serialize(serializer)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(all(feature = \"std\", std_atomic))]\nmacro_rules! atomic_impl {\n    ($($ty:ident)*) =\u003e {\n        $(\n            impl Serialize for $ty {\n                fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n                where\n                    S: Serializer,\n                {\n                    self.load(Ordering::SeqCst).serialize(serializer)\n                }\n            }\n        )*\n    }\n}\n\n#[cfg(all(feature = \"std\", std_atomic))]\natomic_impl! {\n    AtomicBool\n    AtomicI8 AtomicI16 AtomicI32 AtomicIsize\n    AtomicU8 AtomicU16 AtomicU32 AtomicUsize\n}\n\n#[cfg(all(feature = \"std\", std_atomic64))]\natomic_impl! {\n    AtomicI64 AtomicU64\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","ser","impossible.rs"],"content":"//! This module contains `Impossible` serializer and its implementations.\n\nuse lib::*;\n\nuse ser::{\n    self, Serialize, SerializeMap, SerializeSeq, SerializeStruct, SerializeStructVariant,\n    SerializeTuple, SerializeTupleStruct, SerializeTupleVariant,\n};\n\n/// Helper type for implementing a `Serializer` that does not support\n/// serializing one of the compound types.\n///\n/// This type cannot be instantiated, but implements every one of the traits\n/// corresponding to the [`Serializer`] compound types: [`SerializeSeq`],\n/// [`SerializeTuple`], [`SerializeTupleStruct`], [`SerializeTupleVariant`],\n/// [`SerializeMap`], [`SerializeStruct`], and [`SerializeStructVariant`].\n///\n/// ```edition2018\n/// # use serde::ser::{Serializer, Impossible};\n/// # use serde::private::ser::Error;\n/// #\n/// # struct MySerializer;\n/// #\n/// impl Serializer for MySerializer {\n///     type Ok = ();\n///     type Error = Error;\n///\n///     type SerializeSeq = Impossible\u003c(), Error\u003e;\n///     /* other associated types */\n///\n///     /// This data format does not support serializing sequences.\n///     fn serialize_seq(self,\n///                      len: Option\u003cusize\u003e)\n///                      -\u003e Result\u003cSelf::SerializeSeq, Error\u003e {\n///         // Given Impossible cannot be instantiated, the only\n///         // thing we can do here is to return an error.\n/// #         stringify! {\n///         Err(...)\n/// #         };\n/// #         unimplemented!()\n///     }\n///\n///     /* other Serializer methods */\n/// #     serde::__serialize_unimplemented! {\n/// #         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str bytes none some\n/// #         unit unit_struct unit_variant newtype_struct newtype_variant\n/// #         tuple tuple_struct tuple_variant map struct struct_variant\n/// #     }\n/// }\n/// ```\n///\n/// [`Serializer`]: trait.Serializer.html\n/// [`SerializeSeq`]: trait.SerializeSeq.html\n/// [`SerializeTuple`]: trait.SerializeTuple.html\n/// [`SerializeTupleStruct`]: trait.SerializeTupleStruct.html\n/// [`SerializeTupleVariant`]: trait.SerializeTupleVariant.html\n/// [`SerializeMap`]: trait.SerializeMap.html\n/// [`SerializeStruct`]: trait.SerializeStruct.html\n/// [`SerializeStructVariant`]: trait.SerializeStructVariant.html\npub struct Impossible\u003cOk, Error\u003e {\n    void: Void,\n    ok: PhantomData\u003cOk\u003e,\n    error: PhantomData\u003cError\u003e,\n}\n\nenum Void {}\n\nimpl\u003cOk, Error\u003e SerializeSeq for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n\nimpl\u003cOk, Error\u003e SerializeTuple for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n\nimpl\u003cOk, Error\u003e SerializeTupleStruct for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n\nimpl\u003cOk, Error\u003e SerializeTupleVariant for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n\nimpl\u003cOk, Error\u003e SerializeMap for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = key;\n        match self.void {}\n    }\n\n    fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n\nimpl\u003cOk, Error\u003e SerializeStruct for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026'static str, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = key;\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n\nimpl\u003cOk, Error\u003e SerializeStructVariant for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026'static str, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = key;\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","ser","mod.rs"],"content":"//! Generic data structure serialization framework.\n//!\n//! The two most important traits in this module are [`Serialize`] and\n//! [`Serializer`].\n//!\n//!  - **A type that implements `Serialize` is a data structure** that can be\n//!    serialized to any data format supported by Serde, and conversely\n//!  - **A type that implements `Serializer` is a data format** that can\n//!    serialize any data structure supported by Serde.\n//!\n//! # The Serialize trait\n//!\n//! Serde provides [`Serialize`] implementations for many Rust primitive and\n//! standard library types. The complete list is below. All of these can be\n//! serialized using Serde out of the box.\n//!\n//! Additionally, Serde provides a procedural macro called [`serde_derive`] to\n//! automatically generate [`Serialize`] implementations for structs and enums\n//! in your program. See the [derive section of the manual] for how to use this.\n//!\n//! In rare cases it may be necessary to implement [`Serialize`] manually for\n//! some type in your program. See the [Implementing `Serialize`] section of the\n//! manual for more about this.\n//!\n//! Third-party crates may provide [`Serialize`] implementations for types that\n//! they expose. For example the [`linked-hash-map`] crate provides a\n//! [`LinkedHashMap\u003cK, V\u003e`] type that is serializable by Serde because the crate\n//! provides an implementation of [`Serialize`] for it.\n//!\n//! # The Serializer trait\n//!\n//! [`Serializer`] implementations are provided by third-party crates, for\n//! example [`serde_json`], [`serde_yaml`] and [`bincode`].\n//!\n//! A partial list of well-maintained formats is given on the [Serde\n//! website][data formats].\n//!\n//! # Implementations of Serialize provided by Serde\n//!\n//!  - **Primitive types**:\n//!    - bool\n//!    - i8, i16, i32, i64, i128, isize\n//!    - u8, u16, u32, u64, u128, usize\n//!    - f32, f64\n//!    - char\n//!    - str\n//!    - \u0026T and \u0026mut T\n//!  - **Compound types**:\n//!    - \\[T\\]\n//!    - \\[T; 0\\] through \\[T; 32\\]\n//!    - tuples up to size 16\n//!  - **Common standard library types**:\n//!    - String\n//!    - Option\\\u003cT\\\u003e\n//!    - Result\\\u003cT, E\\\u003e\n//!    - PhantomData\\\u003cT\\\u003e\n//!  - **Wrapper types**:\n//!    - Box\\\u003cT\\\u003e\n//!    - Cow\\\u003c'a, T\\\u003e\n//!    - Cell\\\u003cT\\\u003e\n//!    - RefCell\\\u003cT\\\u003e\n//!    - Mutex\\\u003cT\\\u003e\n//!    - RwLock\\\u003cT\\\u003e\n//!    - Rc\\\u003cT\\\u003e\u0026emsp;*(if* features = [\"rc\"] *is enabled)*\n//!    - Arc\\\u003cT\\\u003e\u0026emsp;*(if* features = [\"rc\"] *is enabled)*\n//!  - **Collection types**:\n//!    - BTreeMap\\\u003cK, V\\\u003e\n//!    - BTreeSet\\\u003cT\\\u003e\n//!    - BinaryHeap\\\u003cT\\\u003e\n//!    - HashMap\\\u003cK, V, H\\\u003e\n//!    - HashSet\\\u003cT, H\\\u003e\n//!    - LinkedList\\\u003cT\\\u003e\n//!    - VecDeque\\\u003cT\\\u003e\n//!    - Vec\\\u003cT\\\u003e\n//!  - **FFI types**:\n//!    - CStr\n//!    - CString\n//!    - OsStr\n//!    - OsString\n//!  - **Miscellaneous standard library types**:\n//!    - Duration\n//!    - SystemTime\n//!    - Path\n//!    - PathBuf\n//!    - Range\\\u003cT\\\u003e\n//!    - RangeInclusive\\\u003cT\\\u003e\n//!    - Bound\\\u003cT\\\u003e\n//!    - num::NonZero*\n//!    - `!` *(unstable)*\n//!  - **Net types**:\n//!    - IpAddr\n//!    - Ipv4Addr\n//!    - Ipv6Addr\n//!    - SocketAddr\n//!    - SocketAddrV4\n//!    - SocketAddrV6\n//!\n//! [Implementing `Serialize`]: https://serde.rs/impl-serialize.html\n//! [`LinkedHashMap\u003cK, V\u003e`]: https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html\n//! [`Serialize`]: ../trait.Serialize.html\n//! [`Serializer`]: ../trait.Serializer.html\n//! [`bincode`]: https://github.com/TyOverby/bincode\n//! [`linked-hash-map`]: https://crates.io/crates/linked-hash-map\n//! [`serde_derive`]: https://crates.io/crates/serde_derive\n//! [`serde_json`]: https://github.com/serde-rs/json\n//! [`serde_yaml`]: https://github.com/dtolnay/serde-yaml\n//! [derive section of the manual]: https://serde.rs/derive.html\n//! [data formats]: https://serde.rs/#data-formats\n\nuse lib::*;\n\nmod impls;\nmod impossible;\n\npub use self::impossible::Impossible;\n\n#[cfg(feature = \"std\")]\n#[doc(no_inline)]\npub use std::error::Error as StdError;\n#[cfg(not(feature = \"std\"))]\n#[doc(no_inline)]\npub use std_error::Error as StdError;\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! declare_error_trait {\n    (Error: Sized $(+ $($supertrait:ident)::+)*) =\u003e {\n        /// Trait used by `Serialize` implementations to generically construct\n        /// errors belonging to the `Serializer` against which they are\n        /// currently running.\n        ///\n        /// # Example implementation\n        ///\n        /// The [example data format] presented on the website shows an error\n        /// type appropriate for a basic JSON data format.\n        ///\n        /// [example data format]: https://serde.rs/data-format.html\n        pub trait Error: Sized $(+ $($supertrait)::+)* {\n            /// Used when a [`Serialize`] implementation encounters any error\n            /// while serializing a type.\n            ///\n            /// The message should not be capitalized and should not end with a\n            /// period.\n            ///\n            /// For example, a filesystem [`Path`] may refuse to serialize\n            /// itself if it contains invalid UTF-8 data.\n            ///\n            /// ```edition2018\n            /// # struct Path;\n            /// #\n            /// # impl Path {\n            /// #     fn to_str(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n            /// #         unimplemented!()\n            /// #     }\n            /// # }\n            /// #\n            /// use serde::ser::{self, Serialize, Serializer};\n            ///\n            /// impl Serialize for Path {\n            ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n            ///     where\n            ///         S: Serializer,\n            ///     {\n            ///         match self.to_str() {\n            ///             Some(s) =\u003e serializer.serialize_str(s),\n            ///             None =\u003e Err(ser::Error::custom(\"path contains invalid UTF-8 characters\")),\n            ///         }\n            ///     }\n            /// }\n            /// ```\n            ///\n            /// [`Path`]: https://doc.rust-lang.org/std/path/struct.Path.html\n            /// [`Serialize`]: ../trait.Serialize.html\n            fn custom\u003cT\u003e(msg: T) -\u003e Self\n            where\n                T: Display;\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\ndeclare_error_trait!(Error: Sized + StdError);\n\n#[cfg(not(feature = \"std\"))]\ndeclare_error_trait!(Error: Sized + Debug + Display);\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A **data structure** that can be serialized into any data format supported\n/// by Serde.\n///\n/// Serde provides `Serialize` implementations for many Rust primitive and\n/// standard library types. The complete list is [here][ser]. All of these can\n/// be serialized using Serde out of the box.\n///\n/// Additionally, Serde provides a procedural macro called [`serde_derive`] to\n/// automatically generate `Serialize` implementations for structs and enums in\n/// your program. See the [derive section of the manual] for how to use this.\n///\n/// In rare cases it may be necessary to implement `Serialize` manually for some\n/// type in your program. See the [Implementing `Serialize`] section of the\n/// manual for more about this.\n///\n/// Third-party crates may provide `Serialize` implementations for types that\n/// they expose. For example the [`linked-hash-map`] crate provides a\n/// [`LinkedHashMap\u003cK, V\u003e`] type that is serializable by Serde because the crate\n/// provides an implementation of `Serialize` for it.\n///\n/// [Implementing `Serialize`]: https://serde.rs/impl-serialize.html\n/// [`LinkedHashMap\u003cK, V\u003e`]: https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html\n/// [`linked-hash-map`]: https://crates.io/crates/linked-hash-map\n/// [`serde_derive`]: https://crates.io/crates/serde_derive\n/// [derive section of the manual]: https://serde.rs/derive.html\n/// [ser]: https://docs.serde.rs/serde/ser/index.html\npub trait Serialize {\n    /// Serialize this value into the given Serde serializer.\n    ///\n    /// See the [Implementing `Serialize`] section of the manual for more\n    /// information about how to implement this method.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeStruct, Serializer};\n    ///\n    /// struct Person {\n    ///     name: String,\n    ///     age: u8,\n    ///     phones: Vec\u003cString\u003e,\n    /// }\n    ///\n    /// // This is what #[derive(Serialize)] would generate.\n    /// impl Serialize for Person {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut s = serializer.serialize_struct(\"Person\", 3)?;\n    ///         s.serialize_field(\"name\", \u0026self.name)?;\n    ///         s.serialize_field(\"age\", \u0026self.age)?;\n    ///         s.serialize_field(\"phones\", \u0026self.phones)?;\n    ///         s.end()\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [Implementing `Serialize`]: https://serde.rs/impl-serialize.html\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A **data format** that can serialize any data structure supported by Serde.\n///\n/// The role of this trait is to define the serialization half of the [Serde\n/// data model], which is a way to categorize every Rust data structure into one\n/// of 29 possible types. Each method of the `Serializer` trait corresponds to\n/// one of the types of the data model.\n///\n/// Implementations of `Serialize` map themselves into this data model by\n/// invoking exactly one of the `Serializer` methods.\n///\n/// The types that make up the Serde data model are:\n///\n///  - **14 primitive types**\n///    - bool\n///    - i8, i16, i32, i64, i128\n///    - u8, u16, u32, u64, u128\n///    - f32, f64\n///    - char\n///  - **string**\n///    - UTF-8 bytes with a length and no null terminator.\n///    - When serializing, all strings are handled equally. When deserializing,\n///      there are three flavors of strings: transient, owned, and borrowed.\n///  - **byte array** - \\[u8\\]\n///    - Similar to strings, during deserialization byte arrays can be\n///      transient, owned, or borrowed.\n///  - **option**\n///    - Either none or some value.\n///  - **unit**\n///    - The type of `()` in Rust. It represents an anonymous value containing\n///      no data.\n///  - **unit_struct**\n///    - For example `struct Unit` or `PhantomData\u003cT\u003e`. It represents a named\n///      value containing no data.\n///  - **unit_variant**\n///    - For example the `E::A` and `E::B` in `enum E { A, B }`.\n///  - **newtype_struct**\n///    - For example `struct Millimeters(u8)`.\n///  - **newtype_variant**\n///    - For example the `E::N` in `enum E { N(u8) }`.\n///  - **seq**\n///    - A variably sized heterogeneous sequence of values, for example\n///      `Vec\u003cT\u003e` or `HashSet\u003cT\u003e`. When serializing, the length may or may not\n///      be known before iterating through all the data. When deserializing,\n///      the length is determined by looking at the serialized data.\n///  - **tuple**\n///    - A statically sized heterogeneous sequence of values for which the\n///      length will be known at deserialization time without looking at the\n///      serialized data, for example `(u8,)` or `(String, u64, Vec\u003cT\u003e)` or\n///      `[u64; 10]`.\n///  - **tuple_struct**\n///    - A named tuple, for example `struct Rgb(u8, u8, u8)`.\n///  - **tuple_variant**\n///    - For example the `E::T` in `enum E { T(u8, u8) }`.\n///  - **map**\n///    - A heterogeneous key-value pairing, for example `BTreeMap\u003cK, V\u003e`.\n///  - **struct**\n///    - A heterogeneous key-value pairing in which the keys are strings and\n///      will be known at deserialization time without looking at the\n///      serialized data, for example `struct S { r: u8, g: u8, b: u8 }`.\n///  - **struct_variant**\n///    - For example the `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`.\n///\n/// Many Serde serializers produce text or binary data as output, for example\n/// JSON or Bincode. This is not a requirement of the `Serializer` trait, and\n/// there are serializers that do not produce text or binary output. One example\n/// is the `serde_json::value::Serializer` (distinct from the main `serde_json`\n/// serializer) that produces a `serde_json::Value` data structure in memory as\n/// output.\n///\n/// [Serde data model]: https://serde.rs/data-model.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website contains example code for\n/// a basic JSON `Serializer`.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait Serializer: Sized {\n    /// The output type produced by this `Serializer` during successful\n    /// serialization. Most serializers that produce text or binary output\n    /// should set `Ok = ()` and serialize into an [`io::Write`] or buffer\n    /// contained within the `Serializer` instance. Serializers that build\n    /// in-memory data structures may be simplified by using `Ok` to propagate\n    /// the data structure around.\n    ///\n    /// [`io::Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n    type Ok;\n\n    /// The error type when some error occurs during serialization.\n    type Error: Error;\n\n    /// Type returned from [`serialize_seq`] for serializing the content of the\n    /// sequence.\n    ///\n    /// [`serialize_seq`]: #tymethod.serialize_seq\n    type SerializeSeq: SerializeSeq\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Type returned from [`serialize_tuple`] for serializing the content of\n    /// the tuple.\n    ///\n    /// [`serialize_tuple`]: #tymethod.serialize_tuple\n    type SerializeTuple: SerializeTuple\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Type returned from [`serialize_tuple_struct`] for serializing the\n    /// content of the tuple struct.\n    ///\n    /// [`serialize_tuple_struct`]: #tymethod.serialize_tuple_struct\n    type SerializeTupleStruct: SerializeTupleStruct\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Type returned from [`serialize_tuple_variant`] for serializing the\n    /// content of the tuple variant.\n    ///\n    /// [`serialize_tuple_variant`]: #tymethod.serialize_tuple_variant\n    type SerializeTupleVariant: SerializeTupleVariant\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Type returned from [`serialize_map`] for serializing the content of the\n    /// map.\n    ///\n    /// [`serialize_map`]: #tymethod.serialize_map\n    type SerializeMap: SerializeMap\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Type returned from [`serialize_struct`] for serializing the content of\n    /// the struct.\n    ///\n    /// [`serialize_struct`]: #tymethod.serialize_struct\n    type SerializeStruct: SerializeStruct\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Type returned from [`serialize_struct_variant`] for serializing the\n    /// content of the struct variant.\n    ///\n    /// [`serialize_struct_variant`]: #tymethod.serialize_struct_variant\n    type SerializeStructVariant: SerializeStructVariant\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Serialize a `bool` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for bool {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_bool(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_bool(self, v: bool) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize an `i8` value.\n    ///\n    /// If the format does not differentiate between `i8` and `i64`, a\n    /// reasonable implementation would be to cast the value to `i64` and\n    /// forward to `serialize_i64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for i8 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_i8(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_i8(self, v: i8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize an `i16` value.\n    ///\n    /// If the format does not differentiate between `i16` and `i64`, a\n    /// reasonable implementation would be to cast the value to `i64` and\n    /// forward to `serialize_i64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for i16 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_i16(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_i16(self, v: i16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize an `i32` value.\n    ///\n    /// If the format does not differentiate between `i32` and `i64`, a\n    /// reasonable implementation would be to cast the value to `i64` and\n    /// forward to `serialize_i64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for i32 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_i32(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_i32(self, v: i32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize an `i64` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for i64 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_i64(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_i64(self, v: i64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    serde_if_integer128! {\n        /// Serialize an `i128` value.\n        ///\n        /// ```edition2018\n        /// # use serde::Serializer;\n        /// #\n        /// # serde::__private_serialize!();\n        /// #\n        /// impl Serialize for i128 {\n        ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n        ///     where\n        ///         S: Serializer,\n        ///     {\n        ///         serializer.serialize_i128(*self)\n        ///     }\n        /// }\n        /// ```\n        ///\n        /// This method is available only on Rust compiler versions \u003e=1.26. The\n        /// default behavior unconditionally returns an error.\n        fn serialize_i128(self, v: i128) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n            let _ = v;\n            Err(Error::custom(\"i128 is not supported\"))\n        }\n    }\n\n    /// Serialize a `u8` value.\n    ///\n    /// If the format does not differentiate between `u8` and `u64`, a\n    /// reasonable implementation would be to cast the value to `u64` and\n    /// forward to `serialize_u64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for u8 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_u8(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_u8(self, v: u8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a `u16` value.\n    ///\n    /// If the format does not differentiate between `u16` and `u64`, a\n    /// reasonable implementation would be to cast the value to `u64` and\n    /// forward to `serialize_u64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for u16 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_u16(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_u16(self, v: u16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a `u32` value.\n    ///\n    /// If the format does not differentiate between `u32` and `u64`, a\n    /// reasonable implementation would be to cast the value to `u64` and\n    /// forward to `serialize_u64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for u32 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_u32(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_u32(self, v: u32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a `u64` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for u64 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_u64(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_u64(self, v: u64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    serde_if_integer128! {\n        /// Serialize a `u128` value.\n        ///\n        /// ```edition2018\n        /// # use serde::Serializer;\n        /// #\n        /// # serde::__private_serialize!();\n        /// #\n        /// impl Serialize for u128 {\n        ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n        ///     where\n        ///         S: Serializer,\n        ///     {\n        ///         serializer.serialize_u128(*self)\n        ///     }\n        /// }\n        /// ```\n        ///\n        /// This method is available only on Rust compiler versions \u003e=1.26. The\n        /// default behavior unconditionally returns an error.\n        fn serialize_u128(self, v: u128) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n            let _ = v;\n            Err(Error::custom(\"u128 is not supported\"))\n        }\n    }\n\n    /// Serialize an `f32` value.\n    ///\n    /// If the format does not differentiate between `f32` and `f64`, a\n    /// reasonable implementation would be to cast the value to `f64` and\n    /// forward to `serialize_f64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for f32 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_f32(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_f32(self, v: f32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize an `f64` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for f64 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_f64(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_f64(self, v: f64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a character.\n    ///\n    /// If the format does not support characters, it is reasonable to serialize\n    /// it as a single element `str` or a `u32`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for char {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_char(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_char(self, v: char) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a `\u0026str`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for str {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_str(self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_str(self, v: \u0026str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a chunk of raw byte data.\n    ///\n    /// Enables serializers to serialize byte slices more compactly or more\n    /// efficiently than other types of slices. If no efficient implementation\n    /// is available, a reasonable implementation would be to forward to\n    /// `serialize_seq`. If forwarded, the implementation looks usually just\n    /// like this:\n    ///\n    /// ```edition2018\n    /// # use serde::ser::{Serializer, SerializeSeq};\n    /// # use serde::private::ser::Error;\n    /// #\n    /// # struct MySerializer;\n    /// #\n    /// # impl Serializer for MySerializer {\n    /// #     type Ok = ();\n    /// #     type Error = Error;\n    /// #\n    /// fn serialize_bytes(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n    ///     let mut seq = self.serialize_seq(Some(v.len()))?;\n    ///     for b in v {\n    ///         seq.serialize_element(b)?;\n    ///     }\n    ///     seq.end()\n    /// }\n    /// #\n    /// #     serde::__serialize_unimplemented! {\n    /// #         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str none some\n    /// #         unit unit_struct unit_variant newtype_struct newtype_variant\n    /// #         seq tuple tuple_struct tuple_variant map struct struct_variant\n    /// #     }\n    /// # }\n    /// ```\n    fn serialize_bytes(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a [`None`] value.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Serializer};\n    /// #\n    /// # enum Option\u003cT\u003e {\n    /// #     Some(T),\n    /// #     None,\n    /// # }\n    /// #\n    /// # use self::Option::{Some, None};\n    /// #\n    /// impl\u003cT\u003e Serialize for Option\u003cT\u003e\n    /// where\n    ///     T: Serialize,\n    /// {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             Some(ref value) =\u003e serializer.serialize_some(value),\n    ///             None =\u003e serializer.serialize_none(),\n    ///         }\n    ///     }\n    /// }\n    /// #\n    /// # fn main() {}\n    /// ```\n    ///\n    /// [`None`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n    fn serialize_none(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a [`Some(T)`] value.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Serializer};\n    /// #\n    /// # enum Option\u003cT\u003e {\n    /// #     Some(T),\n    /// #     None,\n    /// # }\n    /// #\n    /// # use self::Option::{Some, None};\n    /// #\n    /// impl\u003cT\u003e Serialize for Option\u003cT\u003e\n    /// where\n    ///     T: Serialize,\n    /// {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             Some(ref value) =\u003e serializer.serialize_some(value),\n    ///             None =\u003e serializer.serialize_none(),\n    ///         }\n    ///     }\n    /// }\n    /// #\n    /// # fn main() {}\n    /// ```\n    ///\n    /// [`Some(T)`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some\n    fn serialize_some\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Serialize a `()` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for () {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_unit()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_unit(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a unit struct like `struct Unit` or `PhantomData\u003cT\u003e`.\n    ///\n    /// A reasonable implementation would be to forward to `serialize_unit`.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// struct Nothing;\n    ///\n    /// impl Serialize for Nothing {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_unit_struct(\"Nothing\")\n    ///     }\n    /// }\n    /// ```\n    fn serialize_unit_struct(self, name: \u0026'static str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a unit variant like `E::A` in `enum E { A, B }`.\n    ///\n    /// The `name` is the name of the enum, the `variant_index` is the index of\n    /// this variant within the enum, and the `variant` is the name of the\n    /// variant.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// enum E {\n    ///     A,\n    ///     B,\n    /// }\n    ///\n    /// impl Serialize for E {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             E::A =\u003e serializer.serialize_unit_variant(\"E\", 0, \"A\"),\n    ///             E::B =\u003e serializer.serialize_unit_variant(\"E\", 1, \"B\"),\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn serialize_unit_variant(\n        self,\n        name: \u0026'static str,\n        variant_index: u32,\n        variant: \u0026'static str,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a newtype struct like `struct Millimeters(u8)`.\n    ///\n    /// Serializers are encouraged to treat newtype structs as insignificant\n    /// wrappers around the data they contain. A reasonable implementation would\n    /// be to forward to `value.serialize(self)`.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// struct Millimeters(u8);\n    ///\n    /// impl Serialize for Millimeters {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_newtype_struct(\"Millimeters\", \u0026self.0)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_newtype_struct\u003cT: ?Sized\u003e(\n        self,\n        name: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Serialize a newtype variant like `E::N` in `enum E { N(u8) }`.\n    ///\n    /// The `name` is the name of the enum, the `variant_index` is the index of\n    /// this variant within the enum, and the `variant` is the name of the\n    /// variant. The `value` is the data contained within this newtype variant.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// enum E {\n    ///     M(String),\n    ///     N(u8),\n    /// }\n    ///\n    /// impl Serialize for E {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             E::M(ref s) =\u003e serializer.serialize_newtype_variant(\"E\", 0, \"M\", s),\n    ///             E::N(n) =\u003e serializer.serialize_newtype_variant(\"E\", 1, \"N\", \u0026n),\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n        self,\n        name: \u0026'static str,\n        variant_index: u32,\n        variant: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Begin to serialize a variably sized sequence. This call must be\n    /// followed by zero or more calls to `serialize_element`, then a call to\n    /// `end`.\n    ///\n    /// The argument is the number of elements in the sequence, which may or may\n    /// not be computable before the sequence is iterated. Some serializers only\n    /// support sequences whose length is known up front.\n    ///\n    /// ```edition2018\n    /// # use std::marker::PhantomData;\n    /// #\n    /// # struct Vec\u003cT\u003e(PhantomData\u003cT\u003e);\n    /// #\n    /// # impl\u003cT\u003e Vec\u003cT\u003e {\n    /// #     fn len(\u0026self) -\u003e usize {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// # impl\u003c'a, T\u003e IntoIterator for \u0026'a Vec\u003cT\u003e {\n    /// #     type Item = \u0026'a T;\n    /// #     type IntoIter = Box\u003cIterator\u003cItem = \u0026'a T\u003e\u003e;\n    /// #\n    /// #     fn into_iter(self) -\u003e Self::IntoIter {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// use serde::ser::{Serialize, Serializer, SerializeSeq};\n    ///\n    /// impl\u003cT\u003e Serialize for Vec\u003cT\u003e\n    /// where\n    ///     T: Serialize,\n    /// {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut seq = serializer.serialize_seq(Some(self.len()))?;\n    ///         for element in self {\n    ///             seq.serialize_element(element)?;\n    ///         }\n    ///         seq.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_seq(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeSeq, Self::Error\u003e;\n\n    /// Begin to serialize a statically sized sequence whose length will be\n    /// known at deserialization time without looking at the serialized data.\n    /// This call must be followed by zero or more calls to `serialize_element`,\n    /// then a call to `end`.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, Serializer, SerializeTuple};\n    ///\n    /// # mod fool {\n    /// #     trait Serialize {}\n    /// impl\u003cA, B, C\u003e Serialize for (A, B, C)\n    /// #     {}\n    /// # }\n    /// #\n    /// # struct Tuple3\u003cA, B, C\u003e(A, B, C);\n    /// #\n    /// # impl\u003cA, B, C\u003e Serialize for Tuple3\u003cA, B, C\u003e\n    /// where\n    ///     A: Serialize,\n    ///     B: Serialize,\n    ///     C: Serialize,\n    /// {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut tup = serializer.serialize_tuple(3)?;\n    ///         tup.serialize_element(\u0026self.0)?;\n    ///         tup.serialize_element(\u0026self.1)?;\n    ///         tup.serialize_element(\u0026self.2)?;\n    ///         tup.end()\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeTuple, Serializer};\n    ///\n    /// const VRAM_SIZE: usize = 386;\n    /// struct Vram([u16; VRAM_SIZE]);\n    ///\n    /// impl Serialize for Vram {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut seq = serializer.serialize_tuple(VRAM_SIZE)?;\n    ///         for element in \u0026self.0[..] {\n    ///             seq.serialize_element(element)?;\n    ///         }\n    ///         seq.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_tuple(self, len: usize) -\u003e Result\u003cSelf::SerializeTuple, Self::Error\u003e;\n\n    /// Begin to serialize a tuple struct like `struct Rgb(u8, u8, u8)`. This\n    /// call must be followed by zero or more calls to `serialize_field`, then a\n    /// call to `end`.\n    ///\n    /// The `name` is the name of the tuple struct and the `len` is the number\n    /// of data fields that will be serialized.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeTupleStruct, Serializer};\n    ///\n    /// struct Rgb(u8, u8, u8);\n    ///\n    /// impl Serialize for Rgb {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut ts = serializer.serialize_tuple_struct(\"Rgb\", 3)?;\n    ///         ts.serialize_field(\u0026self.0)?;\n    ///         ts.serialize_field(\u0026self.1)?;\n    ///         ts.serialize_field(\u0026self.2)?;\n    ///         ts.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_tuple_struct(\n        self,\n        name: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleStruct, Self::Error\u003e;\n\n    /// Begin to serialize a tuple variant like `E::T` in `enum E { T(u8, u8)\n    /// }`. This call must be followed by zero or more calls to\n    /// `serialize_field`, then a call to `end`.\n    ///\n    /// The `name` is the name of the enum, the `variant_index` is the index of\n    /// this variant within the enum, the `variant` is the name of the variant,\n    /// and the `len` is the number of data fields that will be serialized.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeTupleVariant, Serializer};\n    ///\n    /// enum E {\n    ///     T(u8, u8),\n    ///     U(String, u32, u32),\n    /// }\n    ///\n    /// impl Serialize for E {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             E::T(ref a, ref b) =\u003e {\n    ///                 let mut tv = serializer.serialize_tuple_variant(\"E\", 0, \"T\", 2)?;\n    ///                 tv.serialize_field(a)?;\n    ///                 tv.serialize_field(b)?;\n    ///                 tv.end()\n    ///             }\n    ///             E::U(ref a, ref b, ref c) =\u003e {\n    ///                 let mut tv = serializer.serialize_tuple_variant(\"E\", 1, \"U\", 3)?;\n    ///                 tv.serialize_field(a)?;\n    ///                 tv.serialize_field(b)?;\n    ///                 tv.serialize_field(c)?;\n    ///                 tv.end()\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn serialize_tuple_variant(\n        self,\n        name: \u0026'static str,\n        variant_index: u32,\n        variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleVariant, Self::Error\u003e;\n\n    /// Begin to serialize a map. This call must be followed by zero or more\n    /// calls to `serialize_key` and `serialize_value`, then a call to `end`.\n    ///\n    /// The argument is the number of elements in the map, which may or may not\n    /// be computable before the map is iterated. Some serializers only support\n    /// maps whose length is known up front.\n    ///\n    /// ```edition2018\n    /// # use std::marker::PhantomData;\n    /// #\n    /// # struct HashMap\u003cK, V\u003e(PhantomData\u003cK\u003e, PhantomData\u003cV\u003e);\n    /// #\n    /// # impl\u003cK, V\u003e HashMap\u003cK, V\u003e {\n    /// #     fn len(\u0026self) -\u003e usize {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// # impl\u003c'a, K, V\u003e IntoIterator for \u0026'a HashMap\u003cK, V\u003e {\n    /// #     type Item = (\u0026'a K, \u0026'a V);\n    /// #     type IntoIter = Box\u003cIterator\u003cItem = (\u0026'a K, \u0026'a V)\u003e\u003e;\n    /// #\n    /// #     fn into_iter(self) -\u003e Self::IntoIter {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// use serde::ser::{Serialize, Serializer, SerializeMap};\n    ///\n    /// impl\u003cK, V\u003e Serialize for HashMap\u003cK, V\u003e\n    /// where\n    ///     K: Serialize,\n    ///     V: Serialize,\n    /// {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut map = serializer.serialize_map(Some(self.len()))?;\n    ///         for (k, v) in self {\n    ///             map.serialize_entry(k, v)?;\n    ///         }\n    ///         map.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_map(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeMap, Self::Error\u003e;\n\n    /// Begin to serialize a struct like `struct Rgb { r: u8, g: u8, b: u8 }`.\n    /// This call must be followed by zero or more calls to `serialize_field`,\n    /// then a call to `end`.\n    ///\n    /// The `name` is the name of the struct and the `len` is the number of\n    /// data fields that will be serialized.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeStruct, Serializer};\n    ///\n    /// struct Rgb {\n    ///     r: u8,\n    ///     g: u8,\n    ///     b: u8,\n    /// }\n    ///\n    /// impl Serialize for Rgb {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut rgb = serializer.serialize_struct(\"Rgb\", 3)?;\n    ///         rgb.serialize_field(\"r\", \u0026self.r)?;\n    ///         rgb.serialize_field(\"g\", \u0026self.g)?;\n    ///         rgb.serialize_field(\"b\", \u0026self.b)?;\n    ///         rgb.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_struct(\n        self,\n        name: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStruct, Self::Error\u003e;\n\n    /// Begin to serialize a struct variant like `E::S` in `enum E { S { r: u8,\n    /// g: u8, b: u8 } }`. This call must be followed by zero or more calls to\n    /// `serialize_field`, then a call to `end`.\n    ///\n    /// The `name` is the name of the enum, the `variant_index` is the index of\n    /// this variant within the enum, the `variant` is the name of the variant,\n    /// and the `len` is the number of data fields that will be serialized.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeStructVariant, Serializer};\n    ///\n    /// enum E {\n    ///     S { r: u8, g: u8, b: u8 },\n    /// }\n    ///\n    /// impl Serialize for E {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             E::S {\n    ///                 ref r,\n    ///                 ref g,\n    ///                 ref b,\n    ///             } =\u003e {\n    ///                 let mut sv = serializer.serialize_struct_variant(\"E\", 0, \"S\", 3)?;\n    ///                 sv.serialize_field(\"r\", r)?;\n    ///                 sv.serialize_field(\"g\", g)?;\n    ///                 sv.serialize_field(\"b\", b)?;\n    ///                 sv.end()\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn serialize_struct_variant(\n        self,\n        name: \u0026'static str,\n        variant_index: u32,\n        variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStructVariant, Self::Error\u003e;\n\n    /// Collect an iterator as a sequence.\n    ///\n    /// The default implementation serializes each item yielded by the iterator\n    /// using [`serialize_seq`]. Implementors should not need to override this\n    /// method.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// struct SecretlyOneHigher {\n    ///     data: Vec\u003ci32\u003e,\n    /// }\n    ///\n    /// impl Serialize for SecretlyOneHigher {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.collect_seq(self.data.iter().map(|x| x + 1))\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`serialize_seq`]: #tymethod.serialize_seq\n    fn collect_seq\u003cI\u003e(self, iter: I) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        I: IntoIterator,\n        \u003cI as IntoIterator\u003e::Item: Serialize,\n    {\n        let iter = iter.into_iter();\n        let mut serializer = try!(self.serialize_seq(iter.len_hint()));\n        for item in iter {\n            try!(serializer.serialize_element(\u0026item));\n        }\n        serializer.end()\n    }\n\n    /// Collect an iterator as a map.\n    ///\n    /// The default implementation serializes each pair yielded by the iterator\n    /// using [`serialize_map`]. Implementors should not need to override this\n    /// method.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    /// use std::collections::BTreeSet;\n    ///\n    /// struct MapToUnit {\n    ///     keys: BTreeSet\u003ci32\u003e,\n    /// }\n    ///\n    /// // Serializes as a map in which the values are all unit.\n    /// impl Serialize for MapToUnit {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.collect_map(self.keys.iter().map(|k| (k, ())))\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`serialize_map`]: #tymethod.serialize_map\n    fn collect_map\u003cK, V, I\u003e(self, iter: I) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        K: Serialize,\n        V: Serialize,\n        I: IntoIterator\u003cItem = (K, V)\u003e,\n    {\n        let iter = iter.into_iter();\n        let mut serializer = try!(self.serialize_map(iter.len_hint()));\n        for (key, value) in iter {\n            try!(serializer.serialize_entry(\u0026key, \u0026value));\n        }\n        serializer.end()\n    }\n\n    /// Serialize a string produced by an implementation of `Display`.\n    ///\n    /// The default implementation builds a heap-allocated [`String`] and\n    /// delegates to [`serialize_str`]. Serializers are encouraged to provide a\n    /// more efficient implementation if possible.\n    ///\n    /// ```edition2018\n    /// # struct DateTime;\n    /// #\n    /// # impl DateTime {\n    /// #     fn naive_local(\u0026self) -\u003e () { () }\n    /// #     fn offset(\u0026self) -\u003e () { () }\n    /// # }\n    /// #\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// impl Serialize for DateTime {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.collect_str(\u0026format_args!(\"{:?}{:?}\",\n    ///                                              self.naive_local(),\n    ///                                              self.offset()))\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`String`]: https://doc.rust-lang.org/std/string/struct.String.html\n    /// [`serialize_str`]: #tymethod.serialize_str\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn collect_str\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Display,\n    {\n        use lib::fmt::Write;\n        let mut string = String::new();\n        write!(string, \"{}\", value).unwrap();\n        self.serialize_str(\u0026string)\n    }\n\n    /// Serialize a string produced by an implementation of `Display`.\n    ///\n    /// Serializers that use `no_std` are required to provide an implementation\n    /// of this method. If no more sensible behavior is possible, the\n    /// implementation is expected to return an error.\n    ///\n    /// ```edition2018\n    /// # struct DateTime;\n    /// #\n    /// # impl DateTime {\n    /// #     fn naive_local(\u0026self) -\u003e () { () }\n    /// #     fn offset(\u0026self) -\u003e () { () }\n    /// # }\n    /// #\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// impl Serialize for DateTime {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.collect_str(\u0026format_args!(\"{:?}{:?}\",\n    ///                                              self.naive_local(),\n    ///                                              self.offset()))\n    ///     }\n    /// }\n    /// ```\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn collect_str\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Display;\n\n    /// Determine whether `Serialize` implementations should serialize in\n    /// human-readable form.\n    ///\n    /// Some types have a human-readable form that may be somewhat expensive to\n    /// construct, as well as a binary form that is compact and efficient.\n    /// Generally text-based formats like JSON and YAML will prefer to use the\n    /// human-readable one and binary formats like Bincode will prefer the\n    /// compact one.\n    ///\n    /// ```edition2018\n    /// # use std::fmt::{self, Display};\n    /// #\n    /// # struct Timestamp;\n    /// #\n    /// # impl Timestamp {\n    /// #     fn seconds_since_epoch(\u0026self) -\u003e u64 { unimplemented!() }\n    /// # }\n    /// #\n    /// # impl Display for Timestamp {\n    /// #     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// impl Serialize for Timestamp {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         if serializer.is_human_readable() {\n    ///             // Serialize to a human-readable string \"2015-05-15T17:01:00Z\".\n    ///             self.to_string().serialize(serializer)\n    ///         } else {\n    ///             // Serialize to a compact binary representation.\n    ///             self.seconds_since_epoch().serialize(serializer)\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// The default implementation of this method returns `true`. Data formats\n    /// may override this to `false` to request a compact form for types that\n    /// support one. Note that modifying this method to change a format from\n    /// human-readable to compact or vice versa should be regarded as a breaking\n    /// change, as a value serialized in human-readable mode is not required to\n    /// deserialize from the same data in compact mode.\n    #[inline]\n    fn is_human_readable(\u0026self) -\u003e bool {\n        true\n    }\n}\n\n/// Returned from `Serializer::serialize_seq`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// # use std::marker::PhantomData;\n/// #\n/// # struct Vec\u003cT\u003e(PhantomData\u003cT\u003e);\n/// #\n/// # impl\u003cT\u003e Vec\u003cT\u003e {\n/// #     fn len(\u0026self) -\u003e usize {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// # impl\u003c'a, T\u003e IntoIterator for \u0026'a Vec\u003cT\u003e {\n/// #     type Item = \u0026'a T;\n/// #     type IntoIter = Box\u003cIterator\u003cItem = \u0026'a T\u003e\u003e;\n/// #     fn into_iter(self) -\u003e Self::IntoIter {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// use serde::ser::{Serialize, Serializer, SerializeSeq};\n///\n/// impl\u003cT\u003e Serialize for Vec\u003cT\u003e\n/// where\n///     T: Serialize,\n/// {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         let mut seq = serializer.serialize_seq(Some(self.len()))?;\n///         for element in self {\n///             seq.serialize_element(element)?;\n///         }\n///         seq.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeSeq` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeSeq {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a sequence element.\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Finish serializing a sequence.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\n/// Returned from `Serializer::serialize_tuple`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, Serializer, SerializeTuple};\n///\n/// # mod fool {\n/// #     trait Serialize {}\n/// impl\u003cA, B, C\u003e Serialize for (A, B, C)\n/// #     {}\n/// # }\n/// #\n/// # struct Tuple3\u003cA, B, C\u003e(A, B, C);\n/// #\n/// # impl\u003cA, B, C\u003e Serialize for Tuple3\u003cA, B, C\u003e\n/// where\n///     A: Serialize,\n///     B: Serialize,\n///     C: Serialize,\n/// {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         let mut tup = serializer.serialize_tuple(3)?;\n///         tup.serialize_element(\u0026self.0)?;\n///         tup.serialize_element(\u0026self.1)?;\n///         tup.serialize_element(\u0026self.2)?;\n///         tup.end()\n///     }\n/// }\n/// ```\n///\n/// ```edition2018\n/// # use std::marker::PhantomData;\n/// #\n/// # struct Array\u003cT\u003e(PhantomData\u003cT\u003e);\n/// #\n/// # impl\u003cT\u003e Array\u003cT\u003e {\n/// #     fn len(\u0026self) -\u003e usize {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// # impl\u003c'a, T\u003e IntoIterator for \u0026'a Array\u003cT\u003e {\n/// #     type Item = \u0026'a T;\n/// #     type IntoIter = Box\u003cIterator\u003cItem = \u0026'a T\u003e\u003e;\n/// #     fn into_iter(self) -\u003e Self::IntoIter {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// use serde::ser::{Serialize, Serializer, SerializeTuple};\n///\n/// # mod fool {\n/// #     trait Serialize {}\n/// impl\u003cT\u003e Serialize for [T; 16]\n/// #     {}\n/// # }\n/// #\n/// # impl\u003cT\u003e Serialize for Array\u003cT\u003e\n/// where\n///     T: Serialize,\n/// {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         let mut seq = serializer.serialize_tuple(16)?;\n///         for element in self {\n///             seq.serialize_element(element)?;\n///         }\n///         seq.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeTuple` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeTuple {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a tuple element.\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Finish serializing a tuple.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\n/// Returned from `Serializer::serialize_tuple_struct`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, SerializeTupleStruct, Serializer};\n///\n/// struct Rgb(u8, u8, u8);\n///\n/// impl Serialize for Rgb {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         let mut ts = serializer.serialize_tuple_struct(\"Rgb\", 3)?;\n///         ts.serialize_field(\u0026self.0)?;\n///         ts.serialize_field(\u0026self.1)?;\n///         ts.serialize_field(\u0026self.2)?;\n///         ts.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeTupleStruct` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeTupleStruct {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a tuple struct field.\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Finish serializing a tuple struct.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\n/// Returned from `Serializer::serialize_tuple_variant`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, SerializeTupleVariant, Serializer};\n///\n/// enum E {\n///     T(u8, u8),\n///     U(String, u32, u32),\n/// }\n///\n/// impl Serialize for E {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         match *self {\n///             E::T(ref a, ref b) =\u003e {\n///                 let mut tv = serializer.serialize_tuple_variant(\"E\", 0, \"T\", 2)?;\n///                 tv.serialize_field(a)?;\n///                 tv.serialize_field(b)?;\n///                 tv.end()\n///             }\n///             E::U(ref a, ref b, ref c) =\u003e {\n///                 let mut tv = serializer.serialize_tuple_variant(\"E\", 1, \"U\", 3)?;\n///                 tv.serialize_field(a)?;\n///                 tv.serialize_field(b)?;\n///                 tv.serialize_field(c)?;\n///                 tv.end()\n///             }\n///         }\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeTupleVariant` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeTupleVariant {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a tuple variant field.\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Finish serializing a tuple variant.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\n/// Returned from `Serializer::serialize_map`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// # use std::marker::PhantomData;\n/// #\n/// # struct HashMap\u003cK, V\u003e(PhantomData\u003cK\u003e, PhantomData\u003cV\u003e);\n/// #\n/// # impl\u003cK, V\u003e HashMap\u003cK, V\u003e {\n/// #     fn len(\u0026self) -\u003e usize {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// # impl\u003c'a, K, V\u003e IntoIterator for \u0026'a HashMap\u003cK, V\u003e {\n/// #     type Item = (\u0026'a K, \u0026'a V);\n/// #     type IntoIter = Box\u003cIterator\u003cItem = (\u0026'a K, \u0026'a V)\u003e\u003e;\n/// #\n/// #     fn into_iter(self) -\u003e Self::IntoIter {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// use serde::ser::{Serialize, Serializer, SerializeMap};\n///\n/// impl\u003cK, V\u003e Serialize for HashMap\u003cK, V\u003e\n/// where\n///     K: Serialize,\n///     V: Serialize,\n/// {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         let mut map = serializer.serialize_map(Some(self.len()))?;\n///         for (k, v) in self {\n///             map.serialize_entry(k, v)?;\n///         }\n///         map.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeMap` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeMap {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a map key.\n    ///\n    /// If possible, `Serialize` implementations are encouraged to use\n    /// `serialize_entry` instead as it may be implemented more efficiently in\n    /// some formats compared to a pair of calls to `serialize_key` and\n    /// `serialize_value`.\n    fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Serialize a map value.\n    ///\n    /// # Panics\n    ///\n    /// Calling `serialize_value` before `serialize_key` is incorrect and is\n    /// allowed to panic or produce bogus results.\n    fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Serialize a map entry consisting of a key and a value.\n    ///\n    /// Some [`Serialize`] types are not able to hold a key and value in memory\n    /// at the same time so `SerializeMap` implementations are required to\n    /// support [`serialize_key`] and [`serialize_value`] individually. The\n    /// `serialize_entry` method allows serializers to optimize for the case\n    /// where key and value are both available. [`Serialize`] implementations\n    /// are encouraged to use `serialize_entry` if possible.\n    ///\n    /// The default implementation delegates to [`serialize_key`] and\n    /// [`serialize_value`]. This is appropriate for serializers that do not\n    /// care about performance or are not able to optimize `serialize_entry` any\n    /// better than this.\n    ///\n    /// [`Serialize`]: ../trait.Serialize.html\n    /// [`serialize_key`]: #tymethod.serialize_key\n    /// [`serialize_value`]: #tymethod.serialize_value\n    fn serialize_entry\u003cK: ?Sized, V: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026K,\n        value: \u0026V,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        K: Serialize,\n        V: Serialize,\n    {\n        try!(self.serialize_key(key));\n        self.serialize_value(value)\n    }\n\n    /// Finish serializing a map.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\n/// Returned from `Serializer::serialize_struct`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, SerializeStruct, Serializer};\n///\n/// struct Rgb {\n///     r: u8,\n///     g: u8,\n///     b: u8,\n/// }\n///\n/// impl Serialize for Rgb {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         let mut rgb = serializer.serialize_struct(\"Rgb\", 3)?;\n///         rgb.serialize_field(\"r\", \u0026self.r)?;\n///         rgb.serialize_field(\"g\", \u0026self.g)?;\n///         rgb.serialize_field(\"b\", \u0026self.b)?;\n///         rgb.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeStruct` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeStruct {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a struct field.\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Indicate that a struct field has been skipped.\n    #[inline]\n    fn skip_field(\u0026mut self, key: \u0026'static str) -\u003e Result\u003c(), Self::Error\u003e {\n        let _ = key;\n        Ok(())\n    }\n\n    /// Finish serializing a struct.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\n/// Returned from `Serializer::serialize_struct_variant`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, SerializeStructVariant, Serializer};\n///\n/// enum E {\n///     S { r: u8, g: u8, b: u8 },\n/// }\n///\n/// impl Serialize for E {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         match *self {\n///             E::S {\n///                 ref r,\n///                 ref g,\n///                 ref b,\n///             } =\u003e {\n///                 let mut sv = serializer.serialize_struct_variant(\"E\", 0, \"S\", 3)?;\n///                 sv.serialize_field(\"r\", r)?;\n///                 sv.serialize_field(\"g\", g)?;\n///                 sv.serialize_field(\"b\", b)?;\n///                 sv.end()\n///             }\n///         }\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeStructVariant` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeStructVariant {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a struct variant field.\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Indicate that a struct variant field has been skipped.\n    #[inline]\n    fn skip_field(\u0026mut self, key: \u0026'static str) -\u003e Result\u003c(), Self::Error\u003e {\n        let _ = key;\n        Ok(())\n    }\n\n    /// Finish serializing a struct variant.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\ntrait LenHint: Iterator {\n    fn len_hint(\u0026self) -\u003e Option\u003cusize\u003e;\n}\n\nimpl\u003cI\u003e LenHint for I\nwhere\n    I: Iterator,\n{\n    #[cfg(not(feature = \"unstable\"))]\n    fn len_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        iterator_len_hint(self)\n    }\n\n    #[cfg(feature = \"unstable\")]\n    default fn len_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        iterator_len_hint(self)\n    }\n}\n\n#[cfg(feature = \"unstable\")]\nimpl\u003cI\u003e LenHint for I\nwhere\n    I: ExactSizeIterator,\n{\n    fn len_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        Some(self.len())\n    }\n}\n\nfn iterator_len_hint\u003cI\u003e(iter: \u0026I) -\u003e Option\u003cusize\u003e\nwhere\n    I: Iterator,\n{\n    match iter.size_hint() {\n        (lo, Some(hi)) if lo == hi =\u003e Some(lo),\n        _ =\u003e None,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","std_error.rs"],"content":"use lib::{Debug, Display};\n\n/// Either a re-export of std::error::Error or a new identical trait, depending\n/// on whether Serde's \"std\" feature is enabled.\n///\n/// Serde's error traits [`serde::ser::Error`] and [`serde::de::Error`] require\n/// [`std::error::Error`] as a supertrait, but only when Serde is built with\n/// \"std\" enabled. Data formats that don't care about no\\_std support should\n/// generally provide their error types with a `std::error::Error` impl\n/// directly:\n///\n/// ```edition2018\n/// #[derive(Debug)]\n/// struct MySerError {...}\n///\n/// impl serde::ser::Error for MySerError {...}\n///\n/// impl std::fmt::Display for MySerError {...}\n///\n/// // We don't support no_std!\n/// impl std::error::Error for MySerError {}\n/// ```\n///\n/// Data formats that *do* support no\\_std may either have a \"std\" feature of\n/// their own:\n///\n/// ```toml\n/// [features]\n/// std = [\"serde/std\"]\n/// ```\n///\n/// ```edition2018\n/// #[cfg(feature = \"std\")]\n/// impl std::error::Error for MySerError {}\n/// ```\n///\n/// ... or else provide the std Error impl unconditionally via Serde's\n/// re-export:\n///\n/// ```edition2018\n/// impl serde::ser::StdError for MySerError {}\n/// ```\npub trait Error: Debug + Display {\n    /// The underlying cause of this error, if any.\n    fn source(\u0026self) -\u003e Option\u003c\u0026(Error + 'static)\u003e {\n        None\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","bound.rs"],"content":"use std::collections::HashSet;\n\nuse syn;\nuse syn::punctuated::{Pair, Punctuated};\nuse syn::visit::{self, Visit};\n\nuse internals::ast::{Container, Data};\nuse internals::attr;\n\nuse proc_macro2::Span;\n\n// Remove the default from every type parameter because in the generated impls\n// they look like associated types: \"error: associated type bindings are not\n// allowed here\".\npub fn without_defaults(generics: \u0026syn::Generics) -\u003e syn::Generics {\n    syn::Generics {\n        params: generics\n            .params\n            .iter()\n            .map(|param| match *param {\n                syn::GenericParam::Type(ref param) =\u003e syn::GenericParam::Type(syn::TypeParam {\n                    eq_token: None,\n                    default: None,\n                    ..param.clone()\n                }),\n                _ =\u003e param.clone(),\n            })\n            .collect(),\n        ..generics.clone()\n    }\n}\n\npub fn with_where_predicates(\n    generics: \u0026syn::Generics,\n    predicates: \u0026[syn::WherePredicate],\n) -\u003e syn::Generics {\n    let mut generics = generics.clone();\n    generics\n        .make_where_clause()\n        .predicates\n        .extend(predicates.iter().cloned());\n    generics\n}\n\npub fn with_where_predicates_from_fields(\n    cont: \u0026Container,\n    generics: \u0026syn::Generics,\n    from_field: fn(\u0026attr::Field) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e,\n) -\u003e syn::Generics {\n    let predicates = cont\n        .data\n        .all_fields()\n        .flat_map(|field| from_field(\u0026field.attrs))\n        .flat_map(|predicates| predicates.to_vec());\n\n    let mut generics = generics.clone();\n    generics.make_where_clause().predicates.extend(predicates);\n    generics\n}\n\npub fn with_where_predicates_from_variants(\n    cont: \u0026Container,\n    generics: \u0026syn::Generics,\n    from_variant: fn(\u0026attr::Variant) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e,\n) -\u003e syn::Generics {\n    let variants = match cont.data {\n        Data::Enum(ref variants) =\u003e variants,\n        Data::Struct(_, _) =\u003e {\n            return generics.clone();\n        }\n    };\n\n    let predicates = variants\n        .iter()\n        .flat_map(|variant| from_variant(\u0026variant.attrs))\n        .flat_map(|predicates| predicates.to_vec());\n\n    let mut generics = generics.clone();\n    generics.make_where_clause().predicates.extend(predicates);\n    generics\n}\n\n// Puts the given bound on any generic type parameters that are used in fields\n// for which filter returns true.\n//\n// For example, the following struct needs the bound `A: Serialize, B:\n// Serialize`.\n//\n//     struct S\u003c'b, A, B: 'b, C\u003e {\n//         a: A,\n//         b: Option\u003c\u0026'b B\u003e\n//         #[serde(skip_serializing)]\n//         c: C,\n//     }\npub fn with_bound(\n    cont: \u0026Container,\n    generics: \u0026syn::Generics,\n    filter: fn(\u0026attr::Field, Option\u003c\u0026attr::Variant\u003e) -\u003e bool,\n    bound: \u0026syn::Path,\n) -\u003e syn::Generics {\n    struct FindTyParams\u003c'ast\u003e {\n        // Set of all generic type parameters on the current struct (A, B, C in\n        // the example). Initialized up front.\n        all_type_params: HashSet\u003csyn::Ident\u003e,\n\n        // Set of generic type parameters used in fields for which filter\n        // returns true (A and B in the example). Filled in as the visitor sees\n        // them.\n        relevant_type_params: HashSet\u003csyn::Ident\u003e,\n\n        // Fields whose type is an associated type of one of the generic type\n        // parameters.\n        associated_type_usage: Vec\u003c\u0026'ast syn::TypePath\u003e,\n    }\n    impl\u003c'ast\u003e Visit\u003c'ast\u003e for FindTyParams\u003c'ast\u003e {\n        fn visit_field(\u0026mut self, field: \u0026'ast syn::Field) {\n            if let syn::Type::Path(ref ty) = field.ty {\n                if let Some(Pair::Punctuated(ref t, _)) = ty.path.segments.pairs().next() {\n                    if self.all_type_params.contains(\u0026t.ident) {\n                        self.associated_type_usage.push(ty);\n                    }\n                }\n            }\n            self.visit_type(\u0026field.ty);\n        }\n\n        fn visit_path(\u0026mut self, path: \u0026'ast syn::Path) {\n            if let Some(seg) = path.segments.last() {\n                if seg.ident == \"PhantomData\" {\n                    // Hardcoded exception, because PhantomData\u003cT\u003e implements\n                    // Serialize and Deserialize whether or not T implements it.\n                    return;\n                }\n            }\n            if path.leading_colon.is_none() \u0026\u0026 path.segments.len() == 1 {\n                let id = \u0026path.segments[0].ident;\n                if self.all_type_params.contains(id) {\n                    self.relevant_type_params.insert(id.clone());\n                }\n            }\n            visit::visit_path(self, path);\n        }\n\n        // Type parameter should not be considered used by a macro path.\n        //\n        //     struct TypeMacro\u003cT\u003e {\n        //         mac: T!(),\n        //         marker: PhantomData\u003cT\u003e,\n        //     }\n        fn visit_macro(\u0026mut self, _mac: \u0026'ast syn::Macro) {}\n    }\n\n    let all_type_params = generics\n        .type_params()\n        .map(|param| param.ident.clone())\n        .collect();\n\n    let mut visitor = FindTyParams {\n        all_type_params: all_type_params,\n        relevant_type_params: HashSet::new(),\n        associated_type_usage: Vec::new(),\n    };\n    match cont.data {\n        Data::Enum(ref variants) =\u003e {\n            for variant in variants.iter() {\n                let relevant_fields = variant\n                    .fields\n                    .iter()\n                    .filter(|field| filter(\u0026field.attrs, Some(\u0026variant.attrs)));\n                for field in relevant_fields {\n                    visitor.visit_field(field.original);\n                }\n            }\n        }\n        Data::Struct(_, ref fields) =\u003e {\n            for field in fields.iter().filter(|field| filter(\u0026field.attrs, None)) {\n                visitor.visit_field(field.original);\n            }\n        }\n    }\n\n    let relevant_type_params = visitor.relevant_type_params;\n    let associated_type_usage = visitor.associated_type_usage;\n    let new_predicates = generics\n        .type_params()\n        .map(|param| param.ident.clone())\n        .filter(|id| relevant_type_params.contains(id))\n        .map(|id| syn::TypePath {\n            qself: None,\n            path: id.into(),\n        })\n        .chain(associated_type_usage.into_iter().cloned())\n        .map(|bounded_ty| {\n            syn::WherePredicate::Type(syn::PredicateType {\n                lifetimes: None,\n                // the type parameter that is being bounded e.g. T\n                bounded_ty: syn::Type::Path(bounded_ty),\n                colon_token: \u003cToken![:]\u003e::default(),\n                // the bound e.g. Serialize\n                bounds: vec![syn::TypeParamBound::Trait(syn::TraitBound {\n                    paren_token: None,\n                    modifier: syn::TraitBoundModifier::None,\n                    lifetimes: None,\n                    path: bound.clone(),\n                })]\n                .into_iter()\n                .collect(),\n            })\n        });\n\n    let mut generics = generics.clone();\n    generics\n        .make_where_clause()\n        .predicates\n        .extend(new_predicates);\n    generics\n}\n\npub fn with_self_bound(\n    cont: \u0026Container,\n    generics: \u0026syn::Generics,\n    bound: \u0026syn::Path,\n) -\u003e syn::Generics {\n    let mut generics = generics.clone();\n    generics\n        .make_where_clause()\n        .predicates\n        .push(syn::WherePredicate::Type(syn::PredicateType {\n            lifetimes: None,\n            // the type that is being bounded e.g. MyStruct\u003c'a, T\u003e\n            bounded_ty: type_of_item(cont),\n            colon_token: \u003cToken![:]\u003e::default(),\n            // the bound e.g. Default\n            bounds: vec![syn::TypeParamBound::Trait(syn::TraitBound {\n                paren_token: None,\n                modifier: syn::TraitBoundModifier::None,\n                lifetimes: None,\n                path: bound.clone(),\n            })]\n            .into_iter()\n            .collect(),\n        }));\n    generics\n}\n\npub fn with_lifetime_bound(generics: \u0026syn::Generics, lifetime: \u0026str) -\u003e syn::Generics {\n    let bound = syn::Lifetime::new(lifetime, Span::call_site());\n    let def = syn::LifetimeDef {\n        attrs: Vec::new(),\n        lifetime: bound.clone(),\n        colon_token: None,\n        bounds: Punctuated::new(),\n    };\n\n    let params = Some(syn::GenericParam::Lifetime(def))\n        .into_iter()\n        .chain(generics.params.iter().cloned().map(|mut param| {\n            match param {\n                syn::GenericParam::Lifetime(ref mut param) =\u003e {\n                    param.bounds.push(bound.clone());\n                }\n                syn::GenericParam::Type(ref mut param) =\u003e {\n                    param\n                        .bounds\n                        .push(syn::TypeParamBound::Lifetime(bound.clone()));\n                }\n                syn::GenericParam::Const(_) =\u003e {}\n            }\n            param\n        }))\n        .collect();\n\n    syn::Generics {\n        params: params,\n        ..generics.clone()\n    }\n}\n\nfn type_of_item(cont: \u0026Container) -\u003e syn::Type {\n    syn::Type::Path(syn::TypePath {\n        qself: None,\n        path: syn::Path {\n            leading_colon: None,\n            segments: vec![syn::PathSegment {\n                ident: cont.ident.clone(),\n                arguments: syn::PathArguments::AngleBracketed(\n                    syn::AngleBracketedGenericArguments {\n                        colon2_token: None,\n                        lt_token: \u003cToken![\u003c]\u003e::default(),\n                        args: cont\n                            .generics\n                            .params\n                            .iter()\n                            .map(|param| match *param {\n                                syn::GenericParam::Type(ref param) =\u003e {\n                                    syn::GenericArgument::Type(syn::Type::Path(syn::TypePath {\n                                        qself: None,\n                                        path: param.ident.clone().into(),\n                                    }))\n                                }\n                                syn::GenericParam::Lifetime(ref param) =\u003e {\n                                    syn::GenericArgument::Lifetime(param.lifetime.clone())\n                                }\n                                syn::GenericParam::Const(_) =\u003e {\n                                    panic!(\"Serde does not support const generics yet\");\n                                }\n                            })\n                            .collect(),\n                        gt_token: \u003cToken![\u003e]\u003e::default(),\n                    },\n                ),\n            }]\n            .into_iter()\n            .collect(),\n        },\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","de.rs"],"content":"use proc_macro2::{Literal, Span, TokenStream};\nuse quote::ToTokens;\nuse syn::punctuated::Punctuated;\nuse syn::spanned::Spanned;\nuse syn::{self, Ident, Index, Member};\n\nuse bound;\nuse dummy;\nuse fragment::{Expr, Fragment, Match, Stmts};\nuse internals::ast::{Container, Data, Field, Style, Variant};\nuse internals::{attr, Ctxt, Derive};\nuse pretend;\n\nuse std::collections::BTreeSet;\n\npub fn expand_derive_deserialize(input: \u0026syn::DeriveInput) -\u003e Result\u003cTokenStream, Vec\u003csyn::Error\u003e\u003e {\n    let ctxt = Ctxt::new();\n    let cont = match Container::from_ast(\u0026ctxt, input, Derive::Deserialize) {\n        Some(cont) =\u003e cont,\n        None =\u003e return Err(ctxt.check().unwrap_err()),\n    };\n    precondition(\u0026ctxt, \u0026cont);\n    ctxt.check()?;\n\n    let ident = \u0026cont.ident;\n    let params = Parameters::new(\u0026cont);\n    let (de_impl_generics, _, ty_generics, where_clause) = split_with_de_lifetime(\u0026params);\n    let body = Stmts(deserialize_body(\u0026cont, \u0026params));\n    let delife = params.borrowed.de_lifetime();\n    let serde = cont.attrs.serde_path();\n\n    let impl_block = if let Some(remote) = cont.attrs.remote() {\n        let vis = \u0026input.vis;\n        let used = pretend::pretend_used(\u0026cont);\n        quote! {\n            impl #de_impl_generics #ident #ty_generics #where_clause {\n                #vis fn deserialize\u003c__D\u003e(__deserializer: __D) -\u003e #serde::export::Result\u003c#remote #ty_generics, __D::Error\u003e\n                where\n                    __D: #serde::Deserializer\u003c#delife\u003e,\n                {\n                    #used\n                    #body\n                }\n            }\n        }\n    } else {\n        let fn_deserialize_in_place = deserialize_in_place_body(\u0026cont, \u0026params);\n\n        quote! {\n            #[automatically_derived]\n            impl #de_impl_generics #serde::Deserialize\u003c#delife\u003e for #ident #ty_generics #where_clause {\n                fn deserialize\u003c__D\u003e(__deserializer: __D) -\u003e #serde::export::Result\u003cSelf, __D::Error\u003e\n                where\n                    __D: #serde::Deserializer\u003c#delife\u003e,\n                {\n                    #body\n                }\n\n                #fn_deserialize_in_place\n            }\n        }\n    };\n\n    Ok(dummy::wrap_in_const(\n        cont.attrs.custom_serde_path(),\n        \"DESERIALIZE\",\n        ident,\n        impl_block,\n    ))\n}\n\nfn precondition(cx: \u0026Ctxt, cont: \u0026Container) {\n    precondition_sized(cx, cont);\n    precondition_no_de_lifetime(cx, cont);\n}\n\nfn precondition_sized(cx: \u0026Ctxt, cont: \u0026Container) {\n    if let Data::Struct(_, ref fields) = cont.data {\n        if let Some(last) = fields.last() {\n            if let syn::Type::Slice(_) = *last.ty {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"cannot deserialize a dynamically sized struct\",\n                );\n            }\n        }\n    }\n}\n\nfn precondition_no_de_lifetime(cx: \u0026Ctxt, cont: \u0026Container) {\n    if let BorrowedLifetimes::Borrowed(_) = borrowed_lifetimes(cont) {\n        for param in cont.generics.lifetimes() {\n            if param.lifetime.to_string() == \"'de\" {\n                cx.error_spanned_by(\n                    \u0026param.lifetime,\n                    \"cannot deserialize when there is a lifetime parameter called 'de\",\n                );\n                return;\n            }\n        }\n    }\n}\n\nstruct Parameters {\n    /// Name of the type the `derive` is on.\n    local: syn::Ident,\n\n    /// Path to the type the impl is for. Either a single `Ident` for local\n    /// types or `some::remote::Ident` for remote types. Does not include\n    /// generic parameters.\n    this: syn::Path,\n\n    /// Generics including any explicit and inferred bounds for the impl.\n    generics: syn::Generics,\n\n    /// Lifetimes borrowed from the deserializer. These will become bounds on\n    /// the `'de` lifetime of the deserializer.\n    borrowed: BorrowedLifetimes,\n\n    /// At least one field has a serde(getter) attribute, implying that the\n    /// remote type has a private field.\n    has_getter: bool,\n}\n\nimpl Parameters {\n    fn new(cont: \u0026Container) -\u003e Self {\n        let local = cont.ident.clone();\n        let this = match cont.attrs.remote() {\n            Some(remote) =\u003e remote.clone(),\n            None =\u003e cont.ident.clone().into(),\n        };\n        let borrowed = borrowed_lifetimes(cont);\n        let generics = build_generics(cont, \u0026borrowed);\n        let has_getter = cont.data.has_getter();\n\n        Parameters {\n            local: local,\n            this: this,\n            generics: generics,\n            borrowed: borrowed,\n            has_getter: has_getter,\n        }\n    }\n\n    /// Type name to use in error messages and `\u0026'static str` arguments to\n    /// various Deserializer methods.\n    fn type_name(\u0026self) -\u003e String {\n        self.this.segments.last().unwrap().ident.to_string()\n    }\n}\n\n// All the generics in the input, plus a bound `T: Deserialize` for each generic\n// field type that will be deserialized by us, plus a bound `T: Default` for\n// each generic field type that will be set to a default value.\nfn build_generics(cont: \u0026Container, borrowed: \u0026BorrowedLifetimes) -\u003e syn::Generics {\n    let generics = bound::without_defaults(cont.generics);\n\n    let generics = bound::with_where_predicates_from_fields(cont, \u0026generics, attr::Field::de_bound);\n\n    let generics =\n        bound::with_where_predicates_from_variants(cont, \u0026generics, attr::Variant::de_bound);\n\n    match cont.attrs.de_bound() {\n        Some(predicates) =\u003e bound::with_where_predicates(\u0026generics, predicates),\n        None =\u003e {\n            let generics = match *cont.attrs.default() {\n                attr::Default::Default =\u003e {\n                    bound::with_self_bound(cont, \u0026generics, \u0026parse_quote!(_serde::export::Default))\n                }\n                attr::Default::None | attr::Default::Path(_) =\u003e generics,\n            };\n\n            let delife = borrowed.de_lifetime();\n            let generics = bound::with_bound(\n                cont,\n                \u0026generics,\n                needs_deserialize_bound,\n                \u0026parse_quote!(_serde::Deserialize\u003c#delife\u003e),\n            );\n\n            bound::with_bound(\n                cont,\n                \u0026generics,\n                requires_default,\n                \u0026parse_quote!(_serde::export::Default),\n            )\n        }\n    }\n}\n\n// Fields with a `skip_deserializing` or `deserialize_with` attribute, or which\n// belong to a variant with a `skip_deserializing` or `deserialize_with`\n// attribute, are not deserialized by us so we do not generate a bound. Fields\n// with a `bound` attribute specify their own bound so we do not generate one.\n// All other fields may need a `T: Deserialize` bound where T is the type of the\n// field.\nfn needs_deserialize_bound(field: \u0026attr::Field, variant: Option\u003c\u0026attr::Variant\u003e) -\u003e bool {\n    !field.skip_deserializing()\n        \u0026\u0026 field.deserialize_with().is_none()\n        \u0026\u0026 field.de_bound().is_none()\n        \u0026\u0026 variant.map_or(true, |variant| {\n            !variant.skip_deserializing()\n                \u0026\u0026 variant.deserialize_with().is_none()\n                \u0026\u0026 variant.de_bound().is_none()\n        })\n}\n\n// Fields with a `default` attribute (not `default=...`), and fields with a\n// `skip_deserializing` attribute that do not also have `default=...`.\nfn requires_default(field: \u0026attr::Field, _variant: Option\u003c\u0026attr::Variant\u003e) -\u003e bool {\n    if let attr::Default::Default = *field.default() {\n        true\n    } else {\n        false\n    }\n}\n\nenum BorrowedLifetimes {\n    Borrowed(BTreeSet\u003csyn::Lifetime\u003e),\n    Static,\n}\n\nimpl BorrowedLifetimes {\n    fn de_lifetime(\u0026self) -\u003e syn::Lifetime {\n        match *self {\n            BorrowedLifetimes::Borrowed(_) =\u003e syn::Lifetime::new(\"'de\", Span::call_site()),\n            BorrowedLifetimes::Static =\u003e syn::Lifetime::new(\"'static\", Span::call_site()),\n        }\n    }\n\n    fn de_lifetime_def(\u0026self) -\u003e Option\u003csyn::LifetimeDef\u003e {\n        match *self {\n            BorrowedLifetimes::Borrowed(ref bounds) =\u003e Some(syn::LifetimeDef {\n                attrs: Vec::new(),\n                lifetime: syn::Lifetime::new(\"'de\", Span::call_site()),\n                colon_token: None,\n                bounds: bounds.iter().cloned().collect(),\n            }),\n            BorrowedLifetimes::Static =\u003e None,\n        }\n    }\n}\n\n// The union of lifetimes borrowed by each field of the container.\n//\n// These turn into bounds on the `'de` lifetime of the Deserialize impl. If\n// lifetimes `'a` and `'b` are borrowed but `'c` is not, the impl is:\n//\n//     impl\u003c'de: 'a + 'b, 'a, 'b, 'c\u003e Deserialize\u003c'de\u003e for S\u003c'a, 'b, 'c\u003e\n//\n// If any borrowed lifetime is `'static`, then `'de: 'static` would be redundant\n// and we use plain `'static` instead of `'de`.\nfn borrowed_lifetimes(cont: \u0026Container) -\u003e BorrowedLifetimes {\n    let mut lifetimes = BTreeSet::new();\n    for field in cont.data.all_fields() {\n        if !field.attrs.skip_deserializing() {\n            lifetimes.extend(field.attrs.borrowed_lifetimes().iter().cloned());\n        }\n    }\n    if lifetimes.iter().any(|b| b.to_string() == \"'static\") {\n        BorrowedLifetimes::Static\n    } else {\n        BorrowedLifetimes::Borrowed(lifetimes)\n    }\n}\n\nfn deserialize_body(cont: \u0026Container, params: \u0026Parameters) -\u003e Fragment {\n    if cont.attrs.transparent() {\n        deserialize_transparent(cont, params)\n    } else if let Some(type_from) = cont.attrs.type_from() {\n        deserialize_from(type_from)\n    } else if let Some(type_try_from) = cont.attrs.type_try_from() {\n        deserialize_try_from(type_try_from)\n    } else if let attr::Identifier::No = cont.attrs.identifier() {\n        match cont.data {\n            Data::Enum(ref variants) =\u003e deserialize_enum(params, variants, \u0026cont.attrs),\n            Data::Struct(Style::Struct, ref fields) =\u003e {\n                deserialize_struct(None, params, fields, \u0026cont.attrs, None, \u0026Untagged::No)\n            }\n            Data::Struct(Style::Tuple, ref fields) | Data::Struct(Style::Newtype, ref fields) =\u003e {\n                deserialize_tuple(None, params, fields, \u0026cont.attrs, None)\n            }\n            Data::Struct(Style::Unit, _) =\u003e deserialize_unit_struct(params, \u0026cont.attrs),\n        }\n    } else {\n        match cont.data {\n            Data::Enum(ref variants) =\u003e {\n                deserialize_custom_identifier(params, variants, \u0026cont.attrs)\n            }\n            Data::Struct(_, _) =\u003e unreachable!(\"checked in serde_derive_internals\"),\n        }\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_in_place_body(cont: \u0026Container, params: \u0026Parameters) -\u003e Option\u003cStmts\u003e {\n    // Only remote derives have getters, and we do not generate\n    // deserialize_in_place for remote derives.\n    assert!(!params.has_getter);\n\n    if cont.attrs.transparent()\n        || cont.attrs.type_from().is_some()\n        || cont.attrs.type_try_from().is_some()\n        || cont.attrs.identifier().is_some()\n        || cont\n            .data\n            .all_fields()\n            .all(|f| f.attrs.deserialize_with().is_some())\n    {\n        return None;\n    }\n\n    let code = match cont.data {\n        Data::Struct(Style::Struct, ref fields) =\u003e {\n            if let Some(code) = deserialize_struct_in_place(None, params, fields, \u0026cont.attrs, None)\n            {\n                code\n            } else {\n                return None;\n            }\n        }\n        Data::Struct(Style::Tuple, ref fields) | Data::Struct(Style::Newtype, ref fields) =\u003e {\n            deserialize_tuple_in_place(None, params, fields, \u0026cont.attrs, None)\n        }\n        Data::Enum(_) | Data::Struct(Style::Unit, _) =\u003e {\n            return None;\n        }\n    };\n\n    let delife = params.borrowed.de_lifetime();\n    let stmts = Stmts(code);\n\n    let fn_deserialize_in_place = quote_block! {\n        fn deserialize_in_place\u003c__D\u003e(__deserializer: __D, __place: \u0026mut Self) -\u003e _serde::export::Result\u003c(), __D::Error\u003e\n        where\n            __D: _serde::Deserializer\u003c#delife\u003e,\n        {\n            #stmts\n        }\n    };\n\n    Some(Stmts(fn_deserialize_in_place))\n}\n\n#[cfg(not(feature = \"deserialize_in_place\"))]\nfn deserialize_in_place_body(_cont: \u0026Container, _params: \u0026Parameters) -\u003e Option\u003cStmts\u003e {\n    None\n}\n\nfn deserialize_transparent(cont: \u0026Container, params: \u0026Parameters) -\u003e Fragment {\n    let fields = match cont.data {\n        Data::Struct(_, ref fields) =\u003e fields,\n        Data::Enum(_) =\u003e unreachable!(),\n    };\n\n    let this = \u0026params.this;\n    let transparent_field = fields.iter().find(|f| f.attrs.transparent()).unwrap();\n\n    let path = match transparent_field.attrs.deserialize_with() {\n        Some(path) =\u003e quote!(#path),\n        None =\u003e {\n            let span = transparent_field.original.span();\n            quote_spanned!(span=\u003e _serde::Deserialize::deserialize)\n        }\n    };\n\n    let assign = fields.iter().map(|field| {\n        let member = \u0026field.member;\n        if field as *const Field == transparent_field as *const Field {\n            quote!(#member: __transparent)\n        } else {\n            let value = match *field.attrs.default() {\n                attr::Default::Default =\u003e quote!(_serde::export::Default::default()),\n                attr::Default::Path(ref path) =\u003e quote!(#path()),\n                attr::Default::None =\u003e quote!(_serde::export::PhantomData),\n            };\n            quote!(#member: #value)\n        }\n    });\n\n    quote_block! {\n        _serde::export::Result::map(\n            #path(__deserializer),\n            |__transparent| #this { #(#assign),* })\n    }\n}\n\nfn deserialize_from(type_from: \u0026syn::Type) -\u003e Fragment {\n    quote_block! {\n        _serde::export::Result::map(\n            \u003c#type_from as _serde::Deserialize\u003e::deserialize(__deserializer),\n            _serde::export::From::from)\n    }\n}\n\nfn deserialize_try_from(type_try_from: \u0026syn::Type) -\u003e Fragment {\n    quote_block! {\n        _serde::export::Result::and_then(\n            \u003c#type_try_from as _serde::Deserialize\u003e::deserialize(__deserializer),\n            |v| _serde::export::TryFrom::try_from(v).map_err(_serde::de::Error::custom))\n    }\n}\n\nfn deserialize_unit_struct(params: \u0026Parameters, cattrs: \u0026attr::Container) -\u003e Fragment {\n    let this = \u0026params.this;\n    let type_name = cattrs.name().deserialize_name();\n\n    let expecting = format!(\"unit struct {}\", params.type_name());\n\n    quote_block! {\n        struct __Visitor;\n\n        impl\u003c'de\u003e _serde::de::Visitor\u003c'de\u003e for __Visitor {\n            type Value = #this;\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #[inline]\n            fn visit_unit\u003c__E\u003e(self) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(#this)\n            }\n        }\n\n        _serde::Deserializer::deserialize_unit_struct(__deserializer, #type_name, __Visitor)\n    }\n}\n\nfn deserialize_tuple(\n    variant_ident: Option\u003c\u0026syn::Ident\u003e,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n    deserializer: Option\u003cTokenStream\u003e,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    assert!(!cattrs.has_flatten());\n\n    // If there are getters (implying private fields), construct the local type\n    // and use an `Into` conversion to get the remote type. If there are no\n    // getters then construct the target type directly.\n    let construct = if params.has_getter {\n        let local = \u0026params.local;\n        quote!(#local)\n    } else {\n        quote!(#this)\n    };\n\n    let is_enum = variant_ident.is_some();\n    let type_path = match variant_ident {\n        Some(ref variant_ident) =\u003e quote!(#construct::#variant_ident),\n        None =\u003e construct,\n    };\n    let expecting = match variant_ident {\n        Some(variant_ident) =\u003e format!(\"tuple variant {}::{}\", params.type_name(), variant_ident),\n        None =\u003e format!(\"tuple struct {}\", params.type_name()),\n    };\n\n    let nfields = fields.len();\n\n    let visit_newtype_struct = if !is_enum \u0026\u0026 nfields == 1 {\n        Some(deserialize_newtype_struct(\u0026type_path, params, \u0026fields[0]))\n    } else {\n        None\n    };\n\n    let visit_seq = Stmts(deserialize_seq(\n        \u0026type_path, params, fields, false, cattrs, \u0026expecting,\n    ));\n\n    let visitor_expr = quote! {\n        __Visitor {\n            marker: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData,\n        }\n    };\n    let dispatch = if let Some(deserializer) = deserializer {\n        quote!(_serde::Deserializer::deserialize_tuple(#deserializer, #nfields, #visitor_expr))\n    } else if is_enum {\n        quote!(_serde::de::VariantAccess::tuple_variant(__variant, #nfields, #visitor_expr))\n    } else if nfields == 1 {\n        let type_name = cattrs.name().deserialize_name();\n        quote!(_serde::Deserializer::deserialize_newtype_struct(__deserializer, #type_name, #visitor_expr))\n    } else {\n        let type_name = cattrs.name().deserialize_name();\n        quote!(_serde::Deserializer::deserialize_tuple_struct(__deserializer, #type_name, #nfields, #visitor_expr))\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let visitor_var = if all_skipped {\n        quote!(_)\n    } else {\n        quote!(mut __seq)\n    };\n\n    quote_block! {\n        struct __Visitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor\u003c#delife\u003e for __Visitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #visit_newtype_struct\n\n            #[inline]\n            fn visit_seq\u003c__A\u003e(self, #visitor_var: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::SeqAccess\u003c#delife\u003e,\n            {\n                #visit_seq\n            }\n        }\n\n        #dispatch\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_tuple_in_place(\n    variant_ident: Option\u003csyn::Ident\u003e,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n    deserializer: Option\u003cTokenStream\u003e,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    assert!(!cattrs.has_flatten());\n\n    let is_enum = variant_ident.is_some();\n    let expecting = match variant_ident {\n        Some(variant_ident) =\u003e format!(\"tuple variant {}::{}\", params.type_name(), variant_ident),\n        None =\u003e format!(\"tuple struct {}\", params.type_name()),\n    };\n\n    let nfields = fields.len();\n\n    let visit_newtype_struct = if !is_enum \u0026\u0026 nfields == 1 {\n        Some(deserialize_newtype_struct_in_place(params, \u0026fields[0]))\n    } else {\n        None\n    };\n\n    let visit_seq = Stmts(deserialize_seq_in_place(params, fields, cattrs, \u0026expecting));\n\n    let visitor_expr = quote! {\n        __Visitor {\n            place: __place,\n            lifetime: _serde::export::PhantomData,\n        }\n    };\n\n    let dispatch = if let Some(deserializer) = deserializer {\n        quote!(_serde::Deserializer::deserialize_tuple(#deserializer, #nfields, #visitor_expr))\n    } else if is_enum {\n        quote!(_serde::de::VariantAccess::tuple_variant(__variant, #nfields, #visitor_expr))\n    } else if nfields == 1 {\n        let type_name = cattrs.name().deserialize_name();\n        quote!(_serde::Deserializer::deserialize_newtype_struct(__deserializer, #type_name, #visitor_expr))\n    } else {\n        let type_name = cattrs.name().deserialize_name();\n        quote!(_serde::Deserializer::deserialize_tuple_struct(__deserializer, #type_name, #nfields, #visitor_expr))\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let visitor_var = if all_skipped {\n        quote!(_)\n    } else {\n        quote!(mut __seq)\n    };\n\n    let in_place_impl_generics = de_impl_generics.in_place();\n    let in_place_ty_generics = de_ty_generics.in_place();\n    let place_life = place_lifetime();\n\n    quote_block! {\n        struct __Visitor #in_place_impl_generics #where_clause {\n            place: \u0026#place_life mut #this #ty_generics,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #in_place_impl_generics _serde::de::Visitor\u003c#delife\u003e for __Visitor #in_place_ty_generics #where_clause {\n            type Value = ();\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #visit_newtype_struct\n\n            #[inline]\n            fn visit_seq\u003c__A\u003e(self, #visitor_var: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::SeqAccess\u003c#delife\u003e,\n            {\n                #visit_seq\n            }\n        }\n\n        #dispatch\n    }\n}\n\nfn deserialize_seq(\n    type_path: \u0026TokenStream,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    is_struct: bool,\n    cattrs: \u0026attr::Container,\n    expecting: \u0026str,\n) -\u003e Fragment {\n    let vars = (0..fields.len()).map(field_i as fn(_) -\u003e _);\n\n    let deserialized_count = fields\n        .iter()\n        .filter(|field| !field.attrs.skip_deserializing())\n        .count();\n    let expecting = if deserialized_count == 1 {\n        format!(\"{} with 1 element\", expecting)\n    } else {\n        format!(\"{} with {} elements\", expecting, deserialized_count)\n    };\n\n    let mut index_in_seq = 0_usize;\n    let let_values = vars.clone().zip(fields).map(|(var, field)| {\n        if field.attrs.skip_deserializing() {\n            let default = Expr(expr_is_missing(field, cattrs));\n            quote! {\n                let #var = #default;\n            }\n        } else {\n            let visit = match field.attrs.deserialize_with() {\n                None =\u003e {\n                    let field_ty = field.ty;\n                    let span = field.original.span();\n                    let func =\n                        quote_spanned!(span=\u003e _serde::de::SeqAccess::next_element::\u003c#field_ty\u003e);\n                    quote!(try!(#func(\u0026mut __seq)))\n                }\n                Some(path) =\u003e {\n                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n                    quote!({\n                        #wrapper\n                        _serde::export::Option::map(\n                            try!(_serde::de::SeqAccess::next_element::\u003c#wrapper_ty\u003e(\u0026mut __seq)),\n                            |__wrap| __wrap.value)\n                    })\n                }\n            };\n            let value_if_none = match *field.attrs.default() {\n                attr::Default::Default =\u003e quote!(_serde::export::Default::default()),\n                attr::Default::Path(ref path) =\u003e quote!(#path()),\n                attr::Default::None =\u003e quote!(\n                    return _serde::export::Err(_serde::de::Error::invalid_length(#index_in_seq, \u0026#expecting));\n                ),\n            };\n            let assign = quote! {\n                let #var = match #visit {\n                    _serde::export::Some(__value) =\u003e __value,\n                    _serde::export::None =\u003e {\n                        #value_if_none\n                    }\n                };\n            };\n            index_in_seq += 1;\n            assign\n        }\n    });\n\n    let mut result = if is_struct {\n        let names = fields.iter().map(|f| \u0026f.member);\n        quote! {\n            #type_path { #( #names: #vars ),* }\n        }\n    } else {\n        quote! {\n            #type_path ( #(#vars),* )\n        }\n    };\n\n    if params.has_getter {\n        let this = \u0026params.this;\n        result = quote! {\n            _serde::export::Into::\u003c#this\u003e::into(#result)\n        };\n    }\n\n    let let_default = match *cattrs.default() {\n        attr::Default::Default =\u003e Some(quote!(\n            let __default: Self::Value = _serde::export::Default::default();\n        )),\n        attr::Default::Path(ref path) =\u003e Some(quote!(\n            let __default: Self::Value = #path();\n        )),\n        attr::Default::None =\u003e {\n            // We don't need the default value, to prevent an unused variable warning\n            // we'll leave the line empty.\n            None\n        }\n    };\n\n    quote_block! {\n        #let_default\n        #(#let_values)*\n        _serde::export::Ok(#result)\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_seq_in_place(\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n    expecting: \u0026str,\n) -\u003e Fragment {\n    let deserialized_count = fields\n        .iter()\n        .filter(|field| !field.attrs.skip_deserializing())\n        .count();\n    let expecting = if deserialized_count == 1 {\n        format!(\"{} with 1 element\", expecting)\n    } else {\n        format!(\"{} with {} elements\", expecting, deserialized_count)\n    };\n\n    let mut index_in_seq = 0usize;\n    let write_values = fields.iter().map(|field| {\n        let member = \u0026field.member;\n\n        if field.attrs.skip_deserializing() {\n            let default = Expr(expr_is_missing(field, cattrs));\n            quote! {\n                self.place.#member = #default;\n            }\n        } else {\n            let value_if_none = match *field.attrs.default() {\n                attr::Default::Default =\u003e quote!(\n                    self.place.#member = _serde::export::Default::default();\n                ),\n                attr::Default::Path(ref path) =\u003e quote!(\n                    self.place.#member = #path();\n                ),\n                attr::Default::None =\u003e quote!(\n                    return _serde::export::Err(_serde::de::Error::invalid_length(#index_in_seq, \u0026#expecting));\n                ),\n            };\n            let write = match field.attrs.deserialize_with() {\n                None =\u003e {\n                    quote! {\n                        if let _serde::export::None = try!(_serde::de::SeqAccess::next_element_seed(\u0026mut __seq,\n                            _serde::private::de::InPlaceSeed(\u0026mut self.place.#member)))\n                        {\n                            #value_if_none\n                        }\n                    }\n                }\n                Some(path) =\u003e {\n                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n                    quote!({\n                        #wrapper\n                        match try!(_serde::de::SeqAccess::next_element::\u003c#wrapper_ty\u003e(\u0026mut __seq)) {\n                            _serde::export::Some(__wrap) =\u003e {\n                                self.place.#member = __wrap.value;\n                            }\n                            _serde::export::None =\u003e {\n                                #value_if_none\n                            }\n                        }\n                    })\n                }\n            };\n            index_in_seq += 1;\n            write\n        }\n    });\n\n    let this = \u0026params.this;\n    let (_, ty_generics, _) = params.generics.split_for_impl();\n    let let_default = match *cattrs.default() {\n        attr::Default::Default =\u003e Some(quote!(\n            let __default: #this #ty_generics  = _serde::export::Default::default();\n        )),\n        attr::Default::Path(ref path) =\u003e Some(quote!(\n            let __default: #this #ty_generics  = #path();\n        )),\n        attr::Default::None =\u003e {\n            // We don't need the default value, to prevent an unused variable warning\n            // we'll leave the line empty.\n            None\n        }\n    };\n\n    quote_block! {\n        #let_default\n        #(#write_values)*\n        _serde::export::Ok(())\n    }\n}\n\nfn deserialize_newtype_struct(\n    type_path: \u0026TokenStream,\n    params: \u0026Parameters,\n    field: \u0026Field,\n) -\u003e TokenStream {\n    let delife = params.borrowed.de_lifetime();\n    let field_ty = field.ty;\n\n    let value = match field.attrs.deserialize_with() {\n        None =\u003e {\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e \u003c#field_ty as _serde::Deserialize\u003e::deserialize);\n            quote! {\n                try!(#func(__e))\n            }\n        }\n        Some(path) =\u003e {\n            quote! {\n                try!(#path(__e))\n            }\n        }\n    };\n\n    let mut result = quote!(#type_path(__field0));\n    if params.has_getter {\n        let this = \u0026params.this;\n        result = quote! {\n            _serde::export::Into::\u003c#this\u003e::into(#result)\n        };\n    }\n\n    quote! {\n        #[inline]\n        fn visit_newtype_struct\u003c__E\u003e(self, __e: __E) -\u003e _serde::export::Result\u003cSelf::Value, __E::Error\u003e\n        where\n            __E: _serde::Deserializer\u003c#delife\u003e,\n        {\n            let __field0: #field_ty = #value;\n            _serde::export::Ok(#result)\n        }\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_newtype_struct_in_place(params: \u0026Parameters, field: \u0026Field) -\u003e TokenStream {\n    // We do not generate deserialize_in_place if every field has a\n    // deserialize_with.\n    assert!(field.attrs.deserialize_with().is_none());\n\n    let delife = params.borrowed.de_lifetime();\n\n    quote! {\n        #[inline]\n        fn visit_newtype_struct\u003c__E\u003e(self, __e: __E) -\u003e _serde::export::Result\u003cSelf::Value, __E::Error\u003e\n        where\n            __E: _serde::Deserializer\u003c#delife\u003e,\n        {\n            _serde::Deserialize::deserialize_in_place(__e, \u0026mut self.place.0)\n        }\n    }\n}\n\nenum Untagged {\n    Yes,\n    No,\n}\n\nfn deserialize_struct(\n    variant_ident: Option\u003c\u0026syn::Ident\u003e,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n    deserializer: Option\u003cTokenStream\u003e,\n    untagged: \u0026Untagged,\n) -\u003e Fragment {\n    let is_enum = variant_ident.is_some();\n\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    // If there are getters (implying private fields), construct the local type\n    // and use an `Into` conversion to get the remote type. If there are no\n    // getters then construct the target type directly.\n    let construct = if params.has_getter {\n        let local = \u0026params.local;\n        quote!(#local)\n    } else {\n        quote!(#this)\n    };\n\n    let type_path = match variant_ident {\n        Some(ref variant_ident) =\u003e quote!(#construct::#variant_ident),\n        None =\u003e construct,\n    };\n    let expecting = match variant_ident {\n        Some(variant_ident) =\u003e format!(\"struct variant {}::{}\", params.type_name(), variant_ident),\n        None =\u003e format!(\"struct {}\", params.type_name()),\n    };\n\n    let visit_seq = Stmts(deserialize_seq(\n        \u0026type_path, params, fields, true, cattrs, \u0026expecting,\n    ));\n\n    let (field_visitor, fields_stmt, visit_map) = if cattrs.has_flatten() {\n        deserialize_struct_as_map_visitor(\u0026type_path, params, fields, cattrs)\n    } else {\n        deserialize_struct_as_struct_visitor(\u0026type_path, params, fields, cattrs)\n    };\n    let field_visitor = Stmts(field_visitor);\n    let fields_stmt = fields_stmt.map(Stmts);\n    let visit_map = Stmts(visit_map);\n\n    let visitor_expr = quote! {\n        __Visitor {\n            marker: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData,\n        }\n    };\n    let dispatch = if let Some(deserializer) = deserializer {\n        quote! {\n            _serde::Deserializer::deserialize_any(#deserializer, #visitor_expr)\n        }\n    } else if is_enum \u0026\u0026 cattrs.has_flatten() {\n        quote! {\n            _serde::de::VariantAccess::newtype_variant_seed(__variant, #visitor_expr)\n        }\n    } else if is_enum {\n        quote! {\n            _serde::de::VariantAccess::struct_variant(__variant, FIELDS, #visitor_expr)\n        }\n    } else if cattrs.has_flatten() {\n        quote! {\n            _serde::Deserializer::deserialize_map(__deserializer, #visitor_expr)\n        }\n    } else {\n        let type_name = cattrs.name().deserialize_name();\n        quote! {\n            _serde::Deserializer::deserialize_struct(__deserializer, #type_name, FIELDS, #visitor_expr)\n        }\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let visitor_var = if all_skipped {\n        quote!(_)\n    } else {\n        quote!(mut __seq)\n    };\n\n    // untagged struct variants do not get a visit_seq method. The same applies to\n    // structs that only have a map representation.\n    let visit_seq = match *untagged {\n        Untagged::No if !cattrs.has_flatten() =\u003e Some(quote! {\n            #[inline]\n            fn visit_seq\u003c__A\u003e(self, #visitor_var: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::SeqAccess\u003c#delife\u003e,\n            {\n                #visit_seq\n            }\n        }),\n        _ =\u003e None,\n    };\n\n    let visitor_seed = if is_enum \u0026\u0026 cattrs.has_flatten() {\n        Some(quote! {\n            impl #de_impl_generics _serde::de::DeserializeSeed\u003c#delife\u003e for __Visitor #de_ty_generics #where_clause {\n                type Value = #this #ty_generics;\n\n                fn deserialize\u003c__D\u003e(self, __deserializer: __D) -\u003e _serde::export::Result\u003cSelf::Value, __D::Error\u003e\n                where\n                    __D: _serde::Deserializer\u003c'de\u003e,\n                {\n                    _serde::Deserializer::deserialize_map(__deserializer, self)\n                }\n            }\n        })\n    } else {\n        None\n    };\n\n    quote_block! {\n        #field_visitor\n\n        struct __Visitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor\u003c#delife\u003e for __Visitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #visit_seq\n\n            #[inline]\n            fn visit_map\u003c__A\u003e(self, mut __map: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::MapAccess\u003c#delife\u003e,\n            {\n                #visit_map\n            }\n        }\n\n        #visitor_seed\n\n        #fields_stmt\n\n        #dispatch\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_struct_in_place(\n    variant_ident: Option\u003csyn::Ident\u003e,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n    deserializer: Option\u003cTokenStream\u003e,\n) -\u003e Option\u003cFragment\u003e {\n    let is_enum = variant_ident.is_some();\n\n    // for now we do not support in_place deserialization for structs that\n    // are represented as map.\n    if cattrs.has_flatten() {\n        return None;\n    }\n\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    let expecting = match variant_ident {\n        Some(variant_ident) =\u003e format!(\"struct variant {}::{}\", params.type_name(), variant_ident),\n        None =\u003e format!(\"struct {}\", params.type_name()),\n    };\n\n    let visit_seq = Stmts(deserialize_seq_in_place(params, fields, cattrs, \u0026expecting));\n\n    let (field_visitor, fields_stmt, visit_map) =\n        deserialize_struct_as_struct_in_place_visitor(params, fields, cattrs);\n\n    let field_visitor = Stmts(field_visitor);\n    let fields_stmt = Stmts(fields_stmt);\n    let visit_map = Stmts(visit_map);\n\n    let visitor_expr = quote! {\n        __Visitor {\n            place: __place,\n            lifetime: _serde::export::PhantomData,\n        }\n    };\n    let dispatch = if let Some(deserializer) = deserializer {\n        quote! {\n            _serde::Deserializer::deserialize_any(#deserializer, #visitor_expr)\n        }\n    } else if is_enum {\n        quote! {\n            _serde::de::VariantAccess::struct_variant(__variant, FIELDS, #visitor_expr)\n        }\n    } else {\n        let type_name = cattrs.name().deserialize_name();\n        quote! {\n            _serde::Deserializer::deserialize_struct(__deserializer, #type_name, FIELDS, #visitor_expr)\n        }\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let visitor_var = if all_skipped {\n        quote!(_)\n    } else {\n        quote!(mut __seq)\n    };\n\n    let visit_seq = quote! {\n        #[inline]\n        fn visit_seq\u003c__A\u003e(self, #visitor_var: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n        where\n            __A: _serde::de::SeqAccess\u003c#delife\u003e,\n        {\n            #visit_seq\n        }\n    };\n\n    let in_place_impl_generics = de_impl_generics.in_place();\n    let in_place_ty_generics = de_ty_generics.in_place();\n    let place_life = place_lifetime();\n\n    Some(quote_block! {\n        #field_visitor\n\n        struct __Visitor #in_place_impl_generics #where_clause {\n            place: \u0026#place_life mut #this #ty_generics,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #in_place_impl_generics _serde::de::Visitor\u003c#delife\u003e for __Visitor #in_place_ty_generics #where_clause {\n            type Value = ();\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #visit_seq\n\n            #[inline]\n            fn visit_map\u003c__A\u003e(self, mut __map: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::MapAccess\u003c#delife\u003e,\n            {\n                #visit_map\n            }\n        }\n\n        #fields_stmt\n\n        #dispatch\n    })\n}\n\nfn deserialize_enum(\n    params: \u0026Parameters,\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    match *cattrs.tag() {\n        attr::TagType::External =\u003e deserialize_externally_tagged_enum(params, variants, cattrs),\n        attr::TagType::Internal { ref tag } =\u003e {\n            deserialize_internally_tagged_enum(params, variants, cattrs, tag)\n        }\n        attr::TagType::Adjacent {\n            ref tag,\n            ref content,\n        } =\u003e deserialize_adjacently_tagged_enum(params, variants, cattrs, tag, content),\n        attr::TagType::None =\u003e deserialize_untagged_enum(params, variants, cattrs),\n    }\n}\n\nfn prepare_enum_variant_enum(\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n) -\u003e (TokenStream, Stmts) {\n    let variant_names_idents: Vec\u003c_\u003e = variants\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, variant)| !variant.attrs.skip_deserializing())\n        .map(|(i, variant)| {\n            (\n                variant.attrs.name().deserialize_name(),\n                field_i(i),\n                variant.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let other_idx = variants\n        .iter()\n        .position(|ref variant| variant.attrs.other());\n\n    let variants_stmt = {\n        let variant_names = variant_names_idents.iter().map(|\u0026(ref name, _, _)| name);\n        quote! {\n            const VARIANTS: \u0026'static [\u0026'static str] = \u0026[ #(#variant_names),* ];\n        }\n    };\n\n    let variant_visitor = Stmts(deserialize_generated_identifier(\n        \u0026variant_names_idents,\n        cattrs,\n        true,\n        other_idx,\n    ));\n\n    (variants_stmt, variant_visitor)\n}\n\nfn deserialize_externally_tagged_enum(\n    params: \u0026Parameters,\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    let type_name = cattrs.name().deserialize_name();\n    let expecting = format!(\"enum {}\", params.type_name());\n\n    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n\n    // Match arms to extract a variant from a string\n    let variant_arms = variants\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, variant)| !variant.attrs.skip_deserializing())\n        .map(|(i, variant)| {\n            let variant_name = field_i(i);\n\n            let block = Match(deserialize_externally_tagged_variant(\n                params, variant, cattrs,\n            ));\n\n            quote! {\n                (__Field::#variant_name, __variant) =\u003e #block\n            }\n        });\n\n    let all_skipped = variants\n        .iter()\n        .all(|variant| variant.attrs.skip_deserializing());\n    let match_variant = if all_skipped {\n        // This is an empty enum like `enum Impossible {}` or an enum in which\n        // all variants have `#[serde(skip_deserializing)]`.\n        quote! {\n            // FIXME: Once we drop support for Rust 1.15:\n            // let _serde::export::Err(__err) = _serde::de::EnumAccess::variant::\u003c__Field\u003e(__data);\n            // _serde::export::Err(__err)\n            _serde::export::Result::map(\n                _serde::de::EnumAccess::variant::\u003c__Field\u003e(__data),\n                |(__impossible, _)| match __impossible {})\n        }\n    } else {\n        quote! {\n            match try!(_serde::de::EnumAccess::variant(__data)) {\n                #(#variant_arms)*\n            }\n        }\n    };\n\n    quote_block! {\n        #variant_visitor\n\n        struct __Visitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor\u003c#delife\u003e for __Visitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            fn visit_enum\u003c__A\u003e(self, __data: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::EnumAccess\u003c#delife\u003e,\n            {\n                #match_variant\n            }\n        }\n\n        #variants_stmt\n\n        _serde::Deserializer::deserialize_enum(\n            __deserializer,\n            #type_name,\n            VARIANTS,\n            __Visitor {\n                marker: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n                lifetime: _serde::export::PhantomData,\n            },\n        )\n    }\n}\n\nfn deserialize_internally_tagged_enum(\n    params: \u0026Parameters,\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n    tag: \u0026str,\n) -\u003e Fragment {\n    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n\n    // Match arms to extract a variant from a string\n    let variant_arms = variants\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, variant)| !variant.attrs.skip_deserializing())\n        .map(|(i, variant)| {\n            let variant_name = field_i(i);\n\n            let block = Match(deserialize_internally_tagged_variant(\n                params,\n                variant,\n                cattrs,\n                quote! {\n                    _serde::private::de::ContentDeserializer::\u003c__D::Error\u003e::new(__tagged.content)\n                },\n            ));\n\n            quote! {\n                __Field::#variant_name =\u003e #block\n            }\n        });\n\n    quote_block! {\n        #variant_visitor\n\n        #variants_stmt\n\n        let __tagged = try!(_serde::Deserializer::deserialize_any(\n            __deserializer,\n            _serde::private::de::TaggedContentVisitor::\u003c__Field\u003e::new(#tag)));\n\n        match __tagged.tag {\n            #(#variant_arms)*\n        }\n    }\n}\n\nfn deserialize_adjacently_tagged_enum(\n    params: \u0026Parameters,\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n    tag: \u0026str,\n    content: \u0026str,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n\n    let variant_arms: \u0026Vec\u003c_\u003e = \u0026variants\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, variant)| !variant.attrs.skip_deserializing())\n        .map(|(i, variant)| {\n            let variant_index = field_i(i);\n\n            let block = Match(deserialize_untagged_variant(\n                params,\n                variant,\n                cattrs,\n                quote!(__deserializer),\n            ));\n\n            quote! {\n                __Field::#variant_index =\u003e #block\n            }\n        })\n        .collect();\n\n    let expecting = format!(\"adjacently tagged enum {}\", params.type_name());\n    let type_name = cattrs.name().deserialize_name();\n    let deny_unknown_fields = cattrs.deny_unknown_fields();\n\n    // If unknown fields are allowed, we pick the visitor that can step over\n    // those. Otherwise we pick the visitor that fails on unknown keys.\n    let field_visitor_ty = if deny_unknown_fields {\n        quote! { _serde::private::de::TagOrContentFieldVisitor }\n    } else {\n        quote! { _serde::private::de::TagContentOtherFieldVisitor }\n    };\n\n    let tag_or_content = quote! {\n        #field_visitor_ty {\n            tag: #tag,\n            content: #content,\n        }\n    };\n\n    fn is_unit(variant: \u0026Variant) -\u003e bool {\n        match variant.style {\n            Style::Unit =\u003e true,\n            Style::Struct | Style::Tuple | Style::Newtype =\u003e false,\n        }\n    }\n\n    let mut missing_content = quote! {\n        _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::missing_field(#content))\n    };\n    if variants.iter().any(is_unit) {\n        let fallthrough = if variants.iter().all(is_unit) {\n            None\n        } else {\n            Some(quote! {\n                _ =\u003e #missing_content\n            })\n        };\n        let arms = variants\n            .iter()\n            .enumerate()\n            .filter(|\u0026(_, variant)| !variant.attrs.skip_deserializing() \u0026\u0026 is_unit(variant))\n            .map(|(i, variant)| {\n                let variant_index = field_i(i);\n                let variant_ident = \u0026variant.ident;\n                quote! {\n                    __Field::#variant_index =\u003e _serde::export::Ok(#this::#variant_ident),\n                }\n            });\n        missing_content = quote! {\n            match __field {\n                #(#arms)*\n                #fallthrough\n            }\n        };\n    }\n\n    // Advance the map by one key, returning early in case of error.\n    let next_key = quote! {\n        try!(_serde::de::MapAccess::next_key_seed(\u0026mut __map, #tag_or_content))\n    };\n\n    // When allowing unknown fields, we want to transparently step through keys\n    // we don't care about until we find `tag`, `content`, or run out of keys.\n    let next_relevant_key = if deny_unknown_fields {\n        next_key\n    } else {\n        quote!({\n            let mut __rk : _serde::export::Option\u003c_serde::private::de::TagOrContentField\u003e = _serde::export::None;\n            while let _serde::export::Some(__k) = #next_key {\n                match __k {\n                    _serde::private::de::TagContentOtherField::Other =\u003e {\n                        try!(_serde::de::MapAccess::next_value::\u003c_serde::de::IgnoredAny\u003e(\u0026mut __map));\n                        continue;\n                    },\n                    _serde::private::de::TagContentOtherField::Tag =\u003e {\n                        __rk = _serde::export::Some(_serde::private::de::TagOrContentField::Tag);\n                        break;\n                    }\n                    _serde::private::de::TagContentOtherField::Content =\u003e {\n                        __rk = _serde::export::Some(_serde::private::de::TagOrContentField::Content);\n                        break;\n                    }\n                }\n            }\n\n            __rk\n        })\n    };\n\n    // Step through remaining keys, looking for duplicates of previously-seen\n    // keys. When unknown fields are denied, any key that isn't a duplicate will\n    // at this point immediately produce an error.\n    let visit_remaining_keys = quote! {\n        match #next_relevant_key {\n            _serde::export::Some(_serde::private::de::TagOrContentField::Tag) =\u003e {\n                _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::duplicate_field(#tag))\n            }\n            _serde::export::Some(_serde::private::de::TagOrContentField::Content) =\u003e {\n                _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::duplicate_field(#content))\n            }\n            _serde::export::None =\u003e _serde::export::Ok(__ret),\n        }\n    };\n\n    let finish_content_then_tag = if variant_arms.is_empty() {\n        quote! {\n            match try!(_serde::de::MapAccess::next_value::\u003c__Field\u003e(\u0026mut __map)) {}\n        }\n    } else {\n        quote! {\n            let __ret = try!(match try!(_serde::de::MapAccess::next_value(\u0026mut __map)) {\n                // Deserialize the buffered content now that we know the variant.\n                #(#variant_arms)*\n            });\n            // Visit remaining keys, looking for duplicates.\n            #visit_remaining_keys\n        }\n    };\n\n    quote_block! {\n        #variant_visitor\n\n        #variants_stmt\n\n        struct __Seed #de_impl_generics #where_clause {\n            field: __Field,\n            marker: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::de::DeserializeSeed\u003c#delife\u003e for __Seed #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn deserialize\u003c__D\u003e(self, __deserializer: __D) -\u003e _serde::export::Result\u003cSelf::Value, __D::Error\u003e\n            where\n                __D: _serde::Deserializer\u003c#delife\u003e,\n            {\n                match self.field {\n                    #(#variant_arms)*\n                }\n            }\n        }\n\n        struct __Visitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor\u003c#delife\u003e for __Visitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            fn visit_map\u003c__A\u003e(self, mut __map: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::MapAccess\u003c#delife\u003e,\n            {\n                // Visit the first relevant key.\n                match #next_relevant_key {\n                    // First key is the tag.\n                    _serde::export::Some(_serde::private::de::TagOrContentField::Tag) =\u003e {\n                        // Parse the tag.\n                        let __field = try!(_serde::de::MapAccess::next_value(\u0026mut __map));\n                        // Visit the second key.\n                        match #next_relevant_key {\n                            // Second key is a duplicate of the tag.\n                            _serde::export::Some(_serde::private::de::TagOrContentField::Tag) =\u003e {\n                                _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::duplicate_field(#tag))\n                            }\n                            // Second key is the content.\n                            _serde::export::Some(_serde::private::de::TagOrContentField::Content) =\u003e {\n                                let __ret = try!(_serde::de::MapAccess::next_value_seed(\u0026mut __map,\n                                    __Seed {\n                                        field: __field,\n                                        marker: _serde::export::PhantomData,\n                                        lifetime: _serde::export::PhantomData,\n                                    }));\n                                // Visit remaining keys, looking for duplicates.\n                                #visit_remaining_keys\n                            }\n                            // There is no second key; might be okay if the we have a unit variant.\n                            _serde::export::None =\u003e #missing_content\n                        }\n                    }\n                    // First key is the content.\n                    _serde::export::Some(_serde::private::de::TagOrContentField::Content) =\u003e {\n                        // Buffer up the content.\n                        let __content = try!(_serde::de::MapAccess::next_value::\u003c_serde::private::de::Content\u003e(\u0026mut __map));\n                        // Visit the second key.\n                        match #next_relevant_key {\n                            // Second key is the tag.\n                            _serde::export::Some(_serde::private::de::TagOrContentField::Tag) =\u003e {\n                                let __deserializer = _serde::private::de::ContentDeserializer::\u003c__A::Error\u003e::new(__content);\n                                #finish_content_then_tag\n                            }\n                            // Second key is a duplicate of the content.\n                            _serde::export::Some(_serde::private::de::TagOrContentField::Content) =\u003e {\n                                _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::duplicate_field(#content))\n                            }\n                            // There is no second key.\n                            _serde::export::None =\u003e {\n                                _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::missing_field(#tag))\n                            }\n                        }\n                    }\n                    // There is no first key.\n                    _serde::export::None =\u003e {\n                        _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::missing_field(#tag))\n                    }\n                }\n            }\n\n            fn visit_seq\u003c__A\u003e(self, mut __seq: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::SeqAccess\u003c#delife\u003e,\n            {\n                // Visit the first element - the tag.\n                match try!(_serde::de::SeqAccess::next_element(\u0026mut __seq)) {\n                    _serde::export::Some(__field) =\u003e {\n                        // Visit the second element - the content.\n                        match try!(_serde::de::SeqAccess::next_element_seed(\n                            \u0026mut __seq,\n                            __Seed {\n                                field: __field,\n                                marker: _serde::export::PhantomData,\n                                lifetime: _serde::export::PhantomData,\n                            },\n                        )) {\n                            _serde::export::Some(__ret) =\u003e _serde::export::Ok(__ret),\n                            // There is no second element.\n                            _serde::export::None =\u003e {\n                                _serde::export::Err(_serde::de::Error::invalid_length(1, \u0026self))\n                            }\n                        }\n                    }\n                    // There is no first element.\n                    _serde::export::None =\u003e {\n                        _serde::export::Err(_serde::de::Error::invalid_length(0, \u0026self))\n                    }\n                }\n            }\n        }\n\n        const FIELDS: \u0026'static [\u0026'static str] = \u0026[#tag, #content];\n        _serde::Deserializer::deserialize_struct(\n            __deserializer,\n            #type_name,\n            FIELDS,\n            __Visitor {\n                marker: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n                lifetime: _serde::export::PhantomData,\n            },\n        )\n    }\n}\n\nfn deserialize_untagged_enum(\n    params: \u0026Parameters,\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let attempts = variants\n        .iter()\n        .filter(|variant| !variant.attrs.skip_deserializing())\n        .map(|variant| {\n            Expr(deserialize_untagged_variant(\n                params,\n                variant,\n                cattrs,\n                quote!(_serde::private::de::ContentRefDeserializer::\u003c__D::Error\u003e::new(\u0026__content)),\n            ))\n        });\n\n    // TODO this message could be better by saving the errors from the failed\n    // attempts. The heuristic used by TOML was to count the number of fields\n    // processed before an error, and use the error that happened after the\n    // largest number of fields. I'm not sure I like that. Maybe it would be\n    // better to save all the errors and combine them into one message that\n    // explains why none of the variants matched.\n    let fallthrough_msg = format!(\n        \"data did not match any variant of untagged enum {}\",\n        params.type_name()\n    );\n\n    quote_block! {\n        let __content = try!(\u003c_serde::private::de::Content as _serde::Deserialize\u003e::deserialize(__deserializer));\n\n        #(\n            if let _serde::export::Ok(__ok) = #attempts {\n                return _serde::export::Ok(__ok);\n            }\n        )*\n\n        _serde::export::Err(_serde::de::Error::custom(#fallthrough_msg))\n    }\n}\n\nfn deserialize_externally_tagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    if let Some(path) = variant.attrs.deserialize_with() {\n        let (wrapper, wrapper_ty, unwrap_fn) = wrap_deserialize_variant_with(params, variant, path);\n        return quote_block! {\n            #wrapper\n            _serde::export::Result::map(\n                _serde::de::VariantAccess::newtype_variant::\u003c#wrapper_ty\u003e(__variant), #unwrap_fn)\n        };\n    }\n\n    let variant_ident = \u0026variant.ident;\n\n    match variant.style {\n        Style::Unit =\u003e {\n            let this = \u0026params.this;\n            quote_block! {\n                try!(_serde::de::VariantAccess::unit_variant(__variant));\n                _serde::export::Ok(#this::#variant_ident)\n            }\n        }\n        Style::Newtype =\u003e {\n            deserialize_externally_tagged_newtype_variant(variant_ident, params, \u0026variant.fields[0])\n        }\n        Style::Tuple =\u003e {\n            deserialize_tuple(Some(variant_ident), params, \u0026variant.fields, cattrs, None)\n        }\n        Style::Struct =\u003e deserialize_struct(\n            Some(variant_ident),\n            params,\n            \u0026variant.fields,\n            cattrs,\n            None,\n            \u0026Untagged::No,\n        ),\n    }\n}\n\nfn deserialize_internally_tagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    cattrs: \u0026attr::Container,\n    deserializer: TokenStream,\n) -\u003e Fragment {\n    if variant.attrs.deserialize_with().is_some() {\n        return deserialize_untagged_variant(params, variant, cattrs, deserializer);\n    }\n\n    let variant_ident = \u0026variant.ident;\n\n    match variant.style {\n        Style::Unit =\u003e {\n            let this = \u0026params.this;\n            let type_name = params.type_name();\n            let variant_name = variant.ident.to_string();\n            quote_block! {\n                try!(_serde::Deserializer::deserialize_any(#deserializer, _serde::private::de::InternallyTaggedUnitVisitor::new(#type_name, #variant_name)));\n                _serde::export::Ok(#this::#variant_ident)\n            }\n        }\n        Style::Newtype =\u003e deserialize_untagged_newtype_variant(\n            variant_ident,\n            params,\n            \u0026variant.fields[0],\n            \u0026deserializer,\n        ),\n        Style::Struct =\u003e deserialize_struct(\n            Some(variant_ident),\n            params,\n            \u0026variant.fields,\n            cattrs,\n            Some(deserializer),\n            \u0026Untagged::No,\n        ),\n        Style::Tuple =\u003e unreachable!(\"checked in serde_derive_internals\"),\n    }\n}\n\nfn deserialize_untagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    cattrs: \u0026attr::Container,\n    deserializer: TokenStream,\n) -\u003e Fragment {\n    if let Some(path) = variant.attrs.deserialize_with() {\n        let (wrapper, wrapper_ty, unwrap_fn) = wrap_deserialize_variant_with(params, variant, path);\n        return quote_block! {\n            #wrapper\n            _serde::export::Result::map(\n                \u003c#wrapper_ty as _serde::Deserialize\u003e::deserialize(#deserializer), #unwrap_fn)\n        };\n    }\n\n    let variant_ident = \u0026variant.ident;\n\n    match variant.style {\n        Style::Unit =\u003e {\n            let this = \u0026params.this;\n            let type_name = params.type_name();\n            let variant_name = variant.ident.to_string();\n            quote_expr! {\n                match _serde::Deserializer::deserialize_any(\n                    #deserializer,\n                    _serde::private::de::UntaggedUnitVisitor::new(#type_name, #variant_name)\n                ) {\n                    _serde::export::Ok(()) =\u003e _serde::export::Ok(#this::#variant_ident),\n                    _serde::export::Err(__err) =\u003e _serde::export::Err(__err),\n                }\n            }\n        }\n        Style::Newtype =\u003e deserialize_untagged_newtype_variant(\n            variant_ident,\n            params,\n            \u0026variant.fields[0],\n            \u0026deserializer,\n        ),\n        Style::Tuple =\u003e deserialize_tuple(\n            Some(variant_ident),\n            params,\n            \u0026variant.fields,\n            cattrs,\n            Some(deserializer),\n        ),\n        Style::Struct =\u003e deserialize_struct(\n            Some(variant_ident),\n            params,\n            \u0026variant.fields,\n            cattrs,\n            Some(deserializer),\n            \u0026Untagged::Yes,\n        ),\n    }\n}\n\nfn deserialize_externally_tagged_newtype_variant(\n    variant_ident: \u0026syn::Ident,\n    params: \u0026Parameters,\n    field: \u0026Field,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    match field.attrs.deserialize_with() {\n        None =\u003e {\n            let field_ty = field.ty;\n            let span = field.original.span();\n            let func =\n                quote_spanned!(span=\u003e _serde::de::VariantAccess::newtype_variant::\u003c#field_ty\u003e);\n            quote_expr! {\n                _serde::export::Result::map(#func(__variant), #this::#variant_ident)\n            }\n        }\n        Some(path) =\u003e {\n            let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n            quote_block! {\n                #wrapper\n                _serde::export::Result::map(\n                    _serde::de::VariantAccess::newtype_variant::\u003c#wrapper_ty\u003e(__variant),\n                    |__wrapper| #this::#variant_ident(__wrapper.value))\n            }\n        }\n    }\n}\n\nfn deserialize_untagged_newtype_variant(\n    variant_ident: \u0026syn::Ident,\n    params: \u0026Parameters,\n    field: \u0026Field,\n    deserializer: \u0026TokenStream,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    let field_ty = field.ty;\n    match field.attrs.deserialize_with() {\n        None =\u003e {\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e \u003c#field_ty as _serde::Deserialize\u003e::deserialize);\n            quote_expr! {\n                _serde::export::Result::map(#func(#deserializer), #this::#variant_ident)\n            }\n        }\n        Some(path) =\u003e {\n            quote_block! {\n                let __value: _serde::export::Result\u003c#field_ty, _\u003e = #path(#deserializer);\n                _serde::export::Result::map(__value, #this::#variant_ident)\n            }\n        }\n    }\n}\n\nfn deserialize_generated_identifier(\n    fields: \u0026[(String, Ident, Vec\u003cString\u003e)],\n    cattrs: \u0026attr::Container,\n    is_variant: bool,\n    other_idx: Option\u003cusize\u003e,\n) -\u003e Fragment {\n    let this = quote!(__Field);\n    let field_idents: \u0026Vec\u003c_\u003e = \u0026fields.iter().map(|\u0026(_, ref ident, _)| ident).collect();\n\n    let (ignore_variant, fallthrough) = if !is_variant \u0026\u0026 cattrs.has_flatten() {\n        let ignore_variant = quote!(__other(_serde::private::de::Content\u003c'de\u003e),);\n        let fallthrough = quote!(_serde::export::Ok(__Field::__other(__value)));\n        (Some(ignore_variant), Some(fallthrough))\n    } else if let Some(other_idx) = other_idx {\n        let ignore_variant = fields[other_idx].1.clone();\n        let fallthrough = quote!(_serde::export::Ok(__Field::#ignore_variant));\n        (None, Some(fallthrough))\n    } else if is_variant || cattrs.deny_unknown_fields() {\n        (None, None)\n    } else {\n        let ignore_variant = quote!(__ignore,);\n        let fallthrough = quote!(_serde::export::Ok(__Field::__ignore));\n        (Some(ignore_variant), Some(fallthrough))\n    };\n\n    let visitor_impl = Stmts(deserialize_identifier(\n        \u0026this,\n        fields,\n        is_variant,\n        fallthrough,\n        !is_variant \u0026\u0026 cattrs.has_flatten(),\n    ));\n\n    let lifetime = if !is_variant \u0026\u0026 cattrs.has_flatten() {\n        Some(quote!(\u003c'de\u003e))\n    } else {\n        None\n    };\n\n    quote_block! {\n        #[allow(non_camel_case_types)]\n        enum __Field #lifetime {\n            #(#field_idents,)*\n            #ignore_variant\n        }\n\n        struct __FieldVisitor;\n\n        impl\u003c'de\u003e _serde::de::Visitor\u003c'de\u003e for __FieldVisitor {\n            type Value = __Field #lifetime;\n\n            #visitor_impl\n        }\n\n        impl\u003c'de\u003e _serde::Deserialize\u003c'de\u003e for __Field #lifetime {\n            #[inline]\n            fn deserialize\u003c__D\u003e(__deserializer: __D) -\u003e _serde::export::Result\u003cSelf, __D::Error\u003e\n            where\n                __D: _serde::Deserializer\u003c'de\u003e,\n            {\n                _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)\n            }\n        }\n    }\n}\n\nfn deserialize_custom_identifier(\n    params: \u0026Parameters,\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let is_variant = match cattrs.identifier() {\n        attr::Identifier::Variant =\u003e true,\n        attr::Identifier::Field =\u003e false,\n        attr::Identifier::No =\u003e unreachable!(),\n    };\n\n    let this = \u0026params.this;\n    let this = quote!(#this);\n\n    let (ordinary, fallthrough) = if let Some(last) = variants.last() {\n        let last_ident = \u0026last.ident;\n        if last.attrs.other() {\n            let ordinary = \u0026variants[..variants.len() - 1];\n            let fallthrough = quote!(_serde::export::Ok(#this::#last_ident));\n            (ordinary, Some(fallthrough))\n        } else if let Style::Newtype = last.style {\n            let ordinary = \u0026variants[..variants.len() - 1];\n            let deserializer = quote!(_serde::private::de::IdentifierDeserializer::from(__value));\n            let fallthrough = quote! {\n                _serde::export::Result::map(\n                    _serde::Deserialize::deserialize(#deserializer),\n                    #this::#last_ident)\n            };\n            (ordinary, Some(fallthrough))\n        } else {\n            (variants, None)\n        }\n    } else {\n        (variants, None)\n    };\n\n    let names_idents: Vec\u003c_\u003e = ordinary\n        .iter()\n        .map(|variant| {\n            (\n                variant.attrs.name().deserialize_name(),\n                variant.ident.clone(),\n                variant.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let names = names_idents.iter().map(|\u0026(ref name, _, _)| name);\n\n    let names_const = if fallthrough.is_some() {\n        None\n    } else if is_variant {\n        let variants = quote! {\n            const VARIANTS: \u0026'static [\u0026'static str] = \u0026[ #(#names),* ];\n        };\n        Some(variants)\n    } else {\n        let fields = quote! {\n            const FIELDS: \u0026'static [\u0026'static str] = \u0026[ #(#names),* ];\n        };\n        Some(fields)\n    };\n\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n    let visitor_impl = Stmts(deserialize_identifier(\n        \u0026this,\n        \u0026names_idents,\n        is_variant,\n        fallthrough,\n        false,\n    ));\n\n    quote_block! {\n        #names_const\n\n        struct __FieldVisitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor\u003c#delife\u003e for __FieldVisitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            #visitor_impl\n        }\n\n        let __visitor = __FieldVisitor {\n            marker: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData,\n        };\n        _serde::Deserializer::deserialize_identifier(__deserializer, __visitor)\n    }\n}\n\nfn deserialize_identifier(\n    this: \u0026TokenStream,\n    fields: \u0026[(String, Ident, Vec\u003cString\u003e)],\n    is_variant: bool,\n    fallthrough: Option\u003cTokenStream\u003e,\n    collect_other_fields: bool,\n) -\u003e Fragment {\n    let mut flat_fields = Vec::new();\n    for \u0026(_, ref ident, ref aliases) in fields {\n        flat_fields.extend(aliases.iter().map(|alias| (alias, ident)))\n    }\n\n    let field_strs = flat_fields.iter().map(|\u0026(ref name, _)| name);\n    let field_borrowed_strs = flat_fields.iter().map(|\u0026(ref name, _)| name);\n    let field_bytes = flat_fields\n        .iter()\n        .map(|\u0026(ref name, _)| Literal::byte_string(name.as_bytes()));\n    let field_borrowed_bytes = flat_fields\n        .iter()\n        .map(|\u0026(ref name, _)| Literal::byte_string(name.as_bytes()));\n\n    let constructors: \u0026Vec\u003c_\u003e = \u0026flat_fields\n        .iter()\n        .map(|\u0026(_, ref ident)| quote!(#this::#ident))\n        .collect();\n    let main_constructors: \u0026Vec\u003c_\u003e = \u0026fields\n        .iter()\n        .map(|\u0026(_, ref ident, _)| quote!(#this::#ident))\n        .collect();\n\n    let expecting = if is_variant {\n        \"variant identifier\"\n    } else {\n        \"field identifier\"\n    };\n\n    let index_expecting = if is_variant { \"variant\" } else { \"field\" };\n\n    let bytes_to_str = if fallthrough.is_some() || collect_other_fields {\n        None\n    } else {\n        Some(quote! {\n            let __value = \u0026_serde::export::from_utf8_lossy(__value);\n        })\n    };\n\n    let (\n        value_as_str_content,\n        value_as_borrowed_str_content,\n        value_as_bytes_content,\n        value_as_borrowed_bytes_content,\n    ) = if collect_other_fields {\n        (\n            Some(quote! {\n                let __value = _serde::private::de::Content::String(_serde::export::ToString::to_string(__value));\n            }),\n            Some(quote! {\n                let __value = _serde::private::de::Content::Str(__value);\n            }),\n            Some(quote! {\n                let __value = _serde::private::de::Content::ByteBuf(__value.to_vec());\n            }),\n            Some(quote! {\n                let __value = _serde::private::de::Content::Bytes(__value);\n            }),\n        )\n    } else {\n        (None, None, None, None)\n    };\n\n    let fallthrough_arm = if let Some(fallthrough) = fallthrough {\n        fallthrough\n    } else if is_variant {\n        quote! {\n            _serde::export::Err(_serde::de::Error::unknown_variant(__value, VARIANTS))\n        }\n    } else {\n        quote! {\n            _serde::export::Err(_serde::de::Error::unknown_field(__value, FIELDS))\n        }\n    };\n\n    let variant_indices = 0_u64..;\n    let fallthrough_msg = format!(\"{} index 0 \u003c= i \u003c {}\", index_expecting, fields.len());\n    let visit_other = if collect_other_fields {\n        quote! {\n            fn visit_bool\u003c__E\u003e(self, __value: bool) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::Bool(__value)))\n            }\n\n            fn visit_i8\u003c__E\u003e(self, __value: i8) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I8(__value)))\n            }\n\n            fn visit_i16\u003c__E\u003e(self, __value: i16) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I16(__value)))\n            }\n\n            fn visit_i32\u003c__E\u003e(self, __value: i32) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I32(__value)))\n            }\n\n            fn visit_i64\u003c__E\u003e(self, __value: i64) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I64(__value)))\n            }\n\n            fn visit_u8\u003c__E\u003e(self, __value: u8) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U8(__value)))\n            }\n\n            fn visit_u16\u003c__E\u003e(self, __value: u16) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U16(__value)))\n            }\n\n            fn visit_u32\u003c__E\u003e(self, __value: u32) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U32(__value)))\n            }\n\n            fn visit_u64\u003c__E\u003e(self, __value: u64) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U64(__value)))\n            }\n\n            fn visit_f32\u003c__E\u003e(self, __value: f32) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::F32(__value)))\n            }\n\n            fn visit_f64\u003c__E\u003e(self, __value: f64) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::F64(__value)))\n            }\n\n            fn visit_char\u003c__E\u003e(self, __value: char) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::Char(__value)))\n            }\n\n            fn visit_unit\u003c__E\u003e(self) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::Unit))\n            }\n\n            fn visit_borrowed_str\u003c__E\u003e(self, __value: \u0026'de str) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                match __value {\n                    #(\n                        #field_borrowed_strs =\u003e _serde::export::Ok(#constructors),\n                    )*\n                    _ =\u003e {\n                        #value_as_borrowed_str_content\n                        #fallthrough_arm\n                    }\n                }\n            }\n\n            fn visit_borrowed_bytes\u003c__E\u003e(self, __value: \u0026'de [u8]) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                match __value {\n                    #(\n                        #field_borrowed_bytes =\u003e _serde::export::Ok(#constructors),\n                    )*\n                    _ =\u003e {\n                        #bytes_to_str\n                        #value_as_borrowed_bytes_content\n                        #fallthrough_arm\n                    }\n                }\n            }\n        }\n    } else {\n        quote! {\n            fn visit_u64\u003c__E\u003e(self, __value: u64) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                match __value {\n                    #(\n                        #variant_indices =\u003e _serde::export::Ok(#main_constructors),\n                    )*\n                    _ =\u003e _serde::export::Err(_serde::de::Error::invalid_value(\n                        _serde::de::Unexpected::Unsigned(__value),\n                        \u0026#fallthrough_msg,\n                    ))\n                }\n            }\n        }\n    };\n\n    quote_block! {\n        fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n            _serde::export::Formatter::write_str(__formatter, #expecting)\n        }\n\n        #visit_other\n\n        fn visit_str\u003c__E\u003e(self, __value: \u0026str) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n        where\n            __E: _serde::de::Error,\n        {\n            match __value {\n                #(\n                    #field_strs =\u003e _serde::export::Ok(#constructors),\n                )*\n                _ =\u003e {\n                    #value_as_str_content\n                    #fallthrough_arm\n                }\n            }\n        }\n\n        fn visit_bytes\u003c__E\u003e(self, __value: \u0026[u8]) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n        where\n            __E: _serde::de::Error,\n        {\n            match __value {\n                #(\n                    #field_bytes =\u003e _serde::export::Ok(#constructors),\n                )*\n                _ =\u003e {\n                    #bytes_to_str\n                    #value_as_bytes_content\n                    #fallthrough_arm\n                }\n            }\n        }\n    }\n}\n\nfn deserialize_struct_as_struct_visitor(\n    struct_path: \u0026TokenStream,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e (Fragment, Option\u003cFragment\u003e, Fragment) {\n    assert!(!cattrs.has_flatten());\n\n    let field_names_idents: Vec\u003c_\u003e = fields\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, field)| !field.attrs.skip_deserializing())\n        .map(|(i, field)| {\n            (\n                field.attrs.name().deserialize_name(),\n                field_i(i),\n                field.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let fields_stmt = {\n        let field_names = field_names_idents.iter().map(|\u0026(ref name, _, _)| name);\n        quote_block! {\n            const FIELDS: \u0026'static [\u0026'static str] = \u0026[ #(#field_names),* ];\n        }\n    };\n\n    let field_visitor = deserialize_generated_identifier(\u0026field_names_idents, cattrs, false, None);\n\n    let visit_map = deserialize_map(struct_path, params, fields, cattrs);\n\n    (field_visitor, Some(fields_stmt), visit_map)\n}\n\nfn deserialize_struct_as_map_visitor(\n    struct_path: \u0026TokenStream,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e (Fragment, Option\u003cFragment\u003e, Fragment) {\n    let field_names_idents: Vec\u003c_\u003e = fields\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, field)| !field.attrs.skip_deserializing() \u0026\u0026 !field.attrs.flatten())\n        .map(|(i, field)| {\n            (\n                field.attrs.name().deserialize_name(),\n                field_i(i),\n                field.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let field_visitor = deserialize_generated_identifier(\u0026field_names_idents, cattrs, false, None);\n\n    let visit_map = deserialize_map(struct_path, params, fields, cattrs);\n\n    (field_visitor, None, visit_map)\n}\n\nfn deserialize_map(\n    struct_path: \u0026TokenStream,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    // Create the field names for the fields.\n    let fields_names: Vec\u003c_\u003e = fields\n        .iter()\n        .enumerate()\n        .map(|(i, field)| (field, field_i(i)))\n        .collect();\n\n    // Declare each field that will be deserialized.\n    let let_values = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| !field.attrs.skip_deserializing() \u0026\u0026 !field.attrs.flatten())\n        .map(|\u0026(field, ref name)| {\n            let field_ty = field.ty;\n            quote! {\n                let mut #name: _serde::export::Option\u003c#field_ty\u003e = _serde::export::None;\n            }\n        });\n\n    // Collect contents for flatten fields into a buffer\n    let let_collect = if cattrs.has_flatten() {\n        Some(quote! {\n            let mut __collect = _serde::export::Vec::\u003c_serde::export::Option\u003c(\n                _serde::private::de::Content,\n                _serde::private::de::Content\n            )\u003e\u003e::new();\n        })\n    } else {\n        None\n    };\n\n    // Match arms to extract a value for a field.\n    let value_arms = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| !field.attrs.skip_deserializing() \u0026\u0026 !field.attrs.flatten())\n        .map(|\u0026(field, ref name)| {\n            let deser_name = field.attrs.name().deserialize_name();\n\n            let visit = match field.attrs.deserialize_with() {\n                None =\u003e {\n                    let field_ty = field.ty;\n                    let span = field.original.span();\n                    let func =\n                        quote_spanned!(span=\u003e _serde::de::MapAccess::next_value::\u003c#field_ty\u003e);\n                    quote! {\n                        try!(#func(\u0026mut __map))\n                    }\n                }\n                Some(path) =\u003e {\n                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n                    quote!({\n                        #wrapper\n                        match _serde::de::MapAccess::next_value::\u003c#wrapper_ty\u003e(\u0026mut __map) {\n                            _serde::export::Ok(__wrapper) =\u003e __wrapper.value,\n                            _serde::export::Err(__err) =\u003e {\n                                return _serde::export::Err(__err);\n                            }\n                        }\n                    })\n                }\n            };\n            quote! {\n                __Field::#name =\u003e {\n                    if _serde::export::Option::is_some(\u0026#name) {\n                        return _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::duplicate_field(#deser_name));\n                    }\n                    #name = _serde::export::Some(#visit);\n                }\n            }\n        });\n\n    // Visit ignored values to consume them\n    let ignored_arm = if cattrs.has_flatten() {\n        Some(quote! {\n            __Field::__other(__name) =\u003e {\n                __collect.push(_serde::export::Some((\n                    __name,\n                    try!(_serde::de::MapAccess::next_value(\u0026mut __map)))));\n            }\n        })\n    } else if cattrs.deny_unknown_fields() {\n        None\n    } else {\n        Some(quote! {\n            _ =\u003e { let _ = try!(_serde::de::MapAccess::next_value::\u003c_serde::de::IgnoredAny\u003e(\u0026mut __map)); }\n        })\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let match_keys = if cattrs.deny_unknown_fields() \u0026\u0026 all_skipped {\n        quote! {\n            // FIXME: Once we drop support for Rust 1.15:\n            // let _serde::export::None::\u003c__Field\u003e = try!(_serde::de::MapAccess::next_key(\u0026mut __map));\n            _serde::export::Option::map(\n                try!(_serde::de::MapAccess::next_key::\u003c__Field\u003e(\u0026mut __map)),\n                |__impossible| match __impossible {});\n        }\n    } else {\n        quote! {\n            while let _serde::export::Some(__key) = try!(_serde::de::MapAccess::next_key::\u003c__Field\u003e(\u0026mut __map)) {\n                match __key {\n                    #(#value_arms)*\n                    #ignored_arm\n                }\n            }\n        }\n    };\n\n    let extract_values = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| !field.attrs.skip_deserializing() \u0026\u0026 !field.attrs.flatten())\n        .map(|\u0026(field, ref name)| {\n            let missing_expr = Match(expr_is_missing(field, cattrs));\n\n            quote! {\n                let #name = match #name {\n                    _serde::export::Some(#name) =\u003e #name,\n                    _serde::export::None =\u003e #missing_expr\n                };\n            }\n        });\n\n    let extract_collected = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| field.attrs.flatten() \u0026\u0026 !field.attrs.skip_deserializing())\n        .map(|\u0026(field, ref name)| {\n            let field_ty = field.ty;\n            let func = match field.attrs.deserialize_with() {\n                None =\u003e {\n                    let span = field.original.span();\n                    quote_spanned!(span=\u003e _serde::de::Deserialize::deserialize)\n                }\n                Some(path) =\u003e quote!(#path),\n            };\n            quote! {\n                let #name: #field_ty = try!(#func(\n                    _serde::private::de::FlatMapDeserializer(\n                        \u0026mut __collect,\n                        _serde::export::PhantomData)));\n            }\n        });\n\n    let collected_deny_unknown_fields = if cattrs.has_flatten() \u0026\u0026 cattrs.deny_unknown_fields() {\n        Some(quote! {\n            if let _serde::export::Some(_serde::export::Some((__key, _))) =\n                __collect.into_iter().filter(_serde::export::Option::is_some).next()\n            {\n                if let _serde::export::Some(__key) = __key.as_str() {\n                    return _serde::export::Err(\n                        _serde::de::Error::custom(format_args!(\"unknown field `{}`\", \u0026__key)));\n                } else {\n                    return _serde::export::Err(\n                        _serde::de::Error::custom(format_args!(\"unexpected map key\")));\n                }\n            }\n        })\n    } else {\n        None\n    };\n\n    let result = fields_names.iter().map(|\u0026(field, ref name)| {\n        let member = \u0026field.member;\n        if field.attrs.skip_deserializing() {\n            let value = Expr(expr_is_missing(field, cattrs));\n            quote!(#member: #value)\n        } else {\n            quote!(#member: #name)\n        }\n    });\n\n    let let_default = match *cattrs.default() {\n        attr::Default::Default =\u003e Some(quote!(\n            let __default: Self::Value = _serde::export::Default::default();\n        )),\n        attr::Default::Path(ref path) =\u003e Some(quote!(\n            let __default: Self::Value = #path();\n        )),\n        attr::Default::None =\u003e {\n            // We don't need the default value, to prevent an unused variable warning\n            // we'll leave the line empty.\n            None\n        }\n    };\n\n    let mut result = quote!(#struct_path { #(#result),* });\n    if params.has_getter {\n        let this = \u0026params.this;\n        result = quote! {\n            _serde::export::Into::\u003c#this\u003e::into(#result)\n        };\n    }\n\n    quote_block! {\n        #(#let_values)*\n\n        #let_collect\n\n        #match_keys\n\n        #let_default\n\n        #(#extract_values)*\n\n        #(#extract_collected)*\n\n        #collected_deny_unknown_fields\n\n        _serde::export::Ok(#result)\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_struct_as_struct_in_place_visitor(\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e (Fragment, Fragment, Fragment) {\n    assert!(!cattrs.has_flatten());\n\n    let field_names_idents: Vec\u003c_\u003e = fields\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, field)| !field.attrs.skip_deserializing())\n        .map(|(i, field)| {\n            (\n                field.attrs.name().deserialize_name(),\n                field_i(i),\n                field.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let fields_stmt = {\n        let field_names = field_names_idents.iter().map(|\u0026(ref name, _, _)| name);\n        quote_block! {\n            const FIELDS: \u0026'static [\u0026'static str] = \u0026[ #(#field_names),* ];\n        }\n    };\n\n    let field_visitor = deserialize_generated_identifier(\u0026field_names_idents, cattrs, false, None);\n\n    let visit_map = deserialize_map_in_place(params, fields, cattrs);\n\n    (field_visitor, fields_stmt, visit_map)\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_map_in_place(\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    assert!(!cattrs.has_flatten());\n\n    // Create the field names for the fields.\n    let fields_names: Vec\u003c_\u003e = fields\n        .iter()\n        .enumerate()\n        .map(|(i, field)| (field, field_i(i)))\n        .collect();\n\n    // For deserialize_in_place, declare booleans for each field that will be\n    // deserialized.\n    let let_flags = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| !field.attrs.skip_deserializing())\n        .map(|\u0026(_, ref name)| {\n            quote! {\n                let mut #name: bool = false;\n            }\n        });\n\n    // Match arms to extract a value for a field.\n    let value_arms_from = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| !field.attrs.skip_deserializing())\n        .map(|\u0026(field, ref name)| {\n            let deser_name = field.attrs.name().deserialize_name();\n            let member = \u0026field.member;\n\n            let visit = match field.attrs.deserialize_with() {\n                None =\u003e {\n                    quote! {\n                        try!(_serde::de::MapAccess::next_value_seed(\u0026mut __map, _serde::private::de::InPlaceSeed(\u0026mut self.place.#member)))\n                    }\n                }\n                Some(path) =\u003e {\n                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n                    quote!({\n                        #wrapper\n                        self.place.#member = match _serde::de::MapAccess::next_value::\u003c#wrapper_ty\u003e(\u0026mut __map) {\n                            _serde::export::Ok(__wrapper) =\u003e __wrapper.value,\n                            _serde::export::Err(__err) =\u003e {\n                                return _serde::export::Err(__err);\n                            }\n                        };\n                    })\n                }\n            };\n            quote! {\n                __Field::#name =\u003e {\n                    if #name {\n                        return _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::duplicate_field(#deser_name));\n                    }\n                    #visit;\n                    #name = true;\n                }\n            }\n        });\n\n    // Visit ignored values to consume them\n    let ignored_arm = if cattrs.deny_unknown_fields() {\n        None\n    } else {\n        Some(quote! {\n            _ =\u003e { let _ = try!(_serde::de::MapAccess::next_value::\u003c_serde::de::IgnoredAny\u003e(\u0026mut __map)); }\n        })\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n\n    let match_keys = if cattrs.deny_unknown_fields() \u0026\u0026 all_skipped {\n        quote! {\n            // FIXME: Once we drop support for Rust 1.15:\n            // let _serde::export::None::\u003c__Field\u003e = try!(_serde::de::MapAccess::next_key(\u0026mut __map));\n            _serde::export::Option::map(\n                try!(_serde::de::MapAccess::next_key::\u003c__Field\u003e(\u0026mut __map)),\n                |__impossible| match __impossible {});\n        }\n    } else {\n        quote! {\n            while let _serde::export::Some(__key) = try!(_serde::de::MapAccess::next_key::\u003c__Field\u003e(\u0026mut __map)) {\n                match __key {\n                    #(#value_arms_from)*\n                    #ignored_arm\n                }\n            }\n        }\n    };\n\n    let check_flags = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| !field.attrs.skip_deserializing())\n        .map(|\u0026(field, ref name)| {\n            let missing_expr = expr_is_missing(field, cattrs);\n            // If missing_expr unconditionally returns an error, don't try\n            // to assign its value to self.place.\n            if field.attrs.default().is_none()\n                \u0026\u0026 cattrs.default().is_none()\n                \u0026\u0026 field.attrs.deserialize_with().is_some()\n            {\n                let missing_expr = Stmts(missing_expr);\n                quote! {\n                    if !#name {\n                        #missing_expr;\n                    }\n                }\n            } else {\n                let member = \u0026field.member;\n                let missing_expr = Expr(missing_expr);\n                quote! {\n                    if !#name {\n                        self.place.#member = #missing_expr;\n                    };\n                }\n            }\n        });\n\n    let this = \u0026params.this;\n    let (_, _, ty_generics, _) = split_with_de_lifetime(params);\n\n    let let_default = match *cattrs.default() {\n        attr::Default::Default =\u003e Some(quote!(\n            let __default: #this #ty_generics = _serde::export::Default::default();\n        )),\n        attr::Default::Path(ref path) =\u003e Some(quote!(\n            let __default: #this #ty_generics = #path();\n        )),\n        attr::Default::None =\u003e {\n            // We don't need the default value, to prevent an unused variable warning\n            // we'll leave the line empty.\n            None\n        }\n    };\n\n    quote_block! {\n        #(#let_flags)*\n\n        #match_keys\n\n        #let_default\n\n        #(#check_flags)*\n\n        _serde::export::Ok(())\n    }\n}\n\nfn field_i(i: usize) -\u003e Ident {\n    Ident::new(\u0026format!(\"__field{}\", i), Span::call_site())\n}\n\n/// This function wraps the expression in `#[serde(deserialize_with = \"...\")]`\n/// in a trait to prevent it from accessing the internal `Deserialize` state.\nfn wrap_deserialize_with(\n    params: \u0026Parameters,\n    value_ty: \u0026TokenStream,\n    deserialize_with: \u0026syn::ExprPath,\n) -\u003e (TokenStream, TokenStream) {\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    let wrapper = quote! {\n        struct __DeserializeWith #de_impl_generics #where_clause {\n            value: #value_ty,\n            phantom: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::Deserialize\u003c#delife\u003e for __DeserializeWith #de_ty_generics #where_clause {\n            fn deserialize\u003c__D\u003e(__deserializer: __D) -\u003e _serde::export::Result\u003cSelf, __D::Error\u003e\n            where\n                __D: _serde::Deserializer\u003c#delife\u003e,\n            {\n                _serde::export::Ok(__DeserializeWith {\n                    value: try!(#deserialize_with(__deserializer)),\n                    phantom: _serde::export::PhantomData,\n                    lifetime: _serde::export::PhantomData,\n                })\n            }\n        }\n    };\n\n    let wrapper_ty = quote!(__DeserializeWith #de_ty_generics);\n\n    (wrapper, wrapper_ty)\n}\n\nfn wrap_deserialize_field_with(\n    params: \u0026Parameters,\n    field_ty: \u0026syn::Type,\n    deserialize_with: \u0026syn::ExprPath,\n) -\u003e (TokenStream, TokenStream) {\n    wrap_deserialize_with(params, \u0026quote!(#field_ty), deserialize_with)\n}\n\nfn wrap_deserialize_variant_with(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    deserialize_with: \u0026syn::ExprPath,\n) -\u003e (TokenStream, TokenStream, TokenStream) {\n    let this = \u0026params.this;\n    let variant_ident = \u0026variant.ident;\n\n    let field_tys = variant.fields.iter().map(|field| field.ty);\n    let (wrapper, wrapper_ty) =\n        wrap_deserialize_with(params, \u0026quote!((#(#field_tys),*)), deserialize_with);\n\n    let field_access = (0..variant.fields.len()).map(|n| {\n        Member::Unnamed(Index {\n            index: n as u32,\n            span: Span::call_site(),\n        })\n    });\n    let unwrap_fn = match variant.style {\n        Style::Struct if variant.fields.len() == 1 =\u003e {\n            let member = \u0026variant.fields[0].member;\n            quote! {\n                |__wrap| #this::#variant_ident { #member: __wrap.value }\n            }\n        }\n        Style::Struct =\u003e {\n            let members = variant.fields.iter().map(|field| \u0026field.member);\n            quote! {\n                |__wrap| #this::#variant_ident { #(#members: __wrap.value.#field_access),* }\n            }\n        }\n        Style::Tuple =\u003e quote! {\n            |__wrap| #this::#variant_ident(#(__wrap.value.#field_access),*)\n        },\n        Style::Newtype =\u003e quote! {\n            |__wrap| #this::#variant_ident(__wrap.value)\n        },\n        Style::Unit =\u003e quote! {\n            |__wrap| #this::#variant_ident\n        },\n    };\n\n    (wrapper, wrapper_ty, unwrap_fn)\n}\n\nfn expr_is_missing(field: \u0026Field, cattrs: \u0026attr::Container) -\u003e Fragment {\n    match *field.attrs.default() {\n        attr::Default::Default =\u003e {\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e _serde::export::Default::default);\n            return quote_expr!(#func());\n        }\n        attr::Default::Path(ref path) =\u003e {\n            return quote_expr!(#path());\n        }\n        attr::Default::None =\u003e { /* below */ }\n    }\n\n    match *cattrs.default() {\n        attr::Default::Default | attr::Default::Path(_) =\u003e {\n            let member = \u0026field.member;\n            return quote_expr!(__default.#member);\n        }\n        attr::Default::None =\u003e { /* below */ }\n    }\n\n    let name = field.attrs.name().deserialize_name();\n    match field.attrs.deserialize_with() {\n        None =\u003e {\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e _serde::private::de::missing_field);\n            quote_expr! {\n                try!(#func(#name))\n            }\n        }\n        Some(_) =\u003e {\n            quote_expr! {\n                return _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::missing_field(#name))\n            }\n        }\n    }\n}\n\nstruct DeImplGenerics\u003c'a\u003e(\u0026'a Parameters);\n#[cfg(feature = \"deserialize_in_place\")]\nstruct InPlaceImplGenerics\u003c'a\u003e(\u0026'a Parameters);\n\nimpl\u003c'a\u003e ToTokens for DeImplGenerics\u003c'a\u003e {\n    fn to_tokens(\u0026self, tokens: \u0026mut TokenStream) {\n        let mut generics = self.0.generics.clone();\n        if let Some(de_lifetime) = self.0.borrowed.de_lifetime_def() {\n            generics.params = Some(syn::GenericParam::Lifetime(de_lifetime))\n                .into_iter()\n                .chain(generics.params)\n                .collect();\n        }\n        let (impl_generics, _, _) = generics.split_for_impl();\n        impl_generics.to_tokens(tokens);\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nimpl\u003c'a\u003e ToTokens for InPlaceImplGenerics\u003c'a\u003e {\n    fn to_tokens(\u0026self, tokens: \u0026mut TokenStream) {\n        let place_lifetime = place_lifetime();\n        let mut generics = self.0.generics.clone();\n\n        // Add lifetime for `\u0026'place mut Self, and `'a: 'place`\n        for param in \u0026mut generics.params {\n            match *param {\n                syn::GenericParam::Lifetime(ref mut param) =\u003e {\n                    param.bounds.push(place_lifetime.lifetime.clone());\n                }\n                syn::GenericParam::Type(ref mut param) =\u003e {\n                    param.bounds.push(syn::TypeParamBound::Lifetime(\n                        place_lifetime.lifetime.clone(),\n                    ));\n                }\n                syn::GenericParam::Const(_) =\u003e {}\n            }\n        }\n        generics.params = Some(syn::GenericParam::Lifetime(place_lifetime))\n            .into_iter()\n            .chain(generics.params)\n            .collect();\n        if let Some(de_lifetime) = self.0.borrowed.de_lifetime_def() {\n            generics.params = Some(syn::GenericParam::Lifetime(de_lifetime))\n                .into_iter()\n                .chain(generics.params)\n                .collect();\n        }\n        let (impl_generics, _, _) = generics.split_for_impl();\n        impl_generics.to_tokens(tokens);\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nimpl\u003c'a\u003e DeImplGenerics\u003c'a\u003e {\n    fn in_place(self) -\u003e InPlaceImplGenerics\u003c'a\u003e {\n        InPlaceImplGenerics(self.0)\n    }\n}\n\nstruct DeTypeGenerics\u003c'a\u003e(\u0026'a Parameters);\n#[cfg(feature = \"deserialize_in_place\")]\nstruct InPlaceTypeGenerics\u003c'a\u003e(\u0026'a Parameters);\n\nimpl\u003c'a\u003e ToTokens for DeTypeGenerics\u003c'a\u003e {\n    fn to_tokens(\u0026self, tokens: \u0026mut TokenStream) {\n        let mut generics = self.0.generics.clone();\n        if self.0.borrowed.de_lifetime_def().is_some() {\n            let def = syn::LifetimeDef {\n                attrs: Vec::new(),\n                lifetime: syn::Lifetime::new(\"'de\", Span::call_site()),\n                colon_token: None,\n                bounds: Punctuated::new(),\n            };\n            generics.params = Some(syn::GenericParam::Lifetime(def))\n                .into_iter()\n                .chain(generics.params)\n                .collect();\n        }\n        let (_, ty_generics, _) = generics.split_for_impl();\n        ty_generics.to_tokens(tokens);\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nimpl\u003c'a\u003e ToTokens for InPlaceTypeGenerics\u003c'a\u003e {\n    fn to_tokens(\u0026self, tokens: \u0026mut TokenStream) {\n        let mut generics = self.0.generics.clone();\n        generics.params = Some(syn::GenericParam::Lifetime(place_lifetime()))\n            .into_iter()\n            .chain(generics.params)\n            .collect();\n\n        if self.0.borrowed.de_lifetime_def().is_some() {\n            let def = syn::LifetimeDef {\n                attrs: Vec::new(),\n                lifetime: syn::Lifetime::new(\"'de\", Span::call_site()),\n                colon_token: None,\n                bounds: Punctuated::new(),\n            };\n            generics.params = Some(syn::GenericParam::Lifetime(def))\n                .into_iter()\n                .chain(generics.params)\n                .collect();\n        }\n        let (_, ty_generics, _) = generics.split_for_impl();\n        ty_generics.to_tokens(tokens);\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nimpl\u003c'a\u003e DeTypeGenerics\u003c'a\u003e {\n    fn in_place(self) -\u003e InPlaceTypeGenerics\u003c'a\u003e {\n        InPlaceTypeGenerics(self.0)\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn place_lifetime() -\u003e syn::LifetimeDef {\n    syn::LifetimeDef {\n        attrs: Vec::new(),\n        lifetime: syn::Lifetime::new(\"'place\", Span::call_site()),\n        colon_token: None,\n        bounds: Punctuated::new(),\n    }\n}\n\nfn split_with_de_lifetime(\n    params: \u0026Parameters,\n) -\u003e (\n    DeImplGenerics,\n    DeTypeGenerics,\n    syn::TypeGenerics,\n    Option\u003c\u0026syn::WhereClause\u003e,\n) {\n    let de_impl_generics = DeImplGenerics(params);\n    let de_ty_generics = DeTypeGenerics(params);\n    let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n    (de_impl_generics, de_ty_generics, ty_generics, where_clause)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","dummy.rs"],"content":"use proc_macro2::{Ident, Span, TokenStream};\n\nuse syn;\nuse try;\n\npub fn wrap_in_const(\n    serde_path: Option\u003c\u0026syn::Path\u003e,\n    trait_: \u0026str,\n    ty: \u0026Ident,\n    code: TokenStream,\n) -\u003e TokenStream {\n    let try_replacement = try::replacement();\n\n    let dummy_const = Ident::new(\n        \u0026format!(\"_IMPL_{}_FOR_{}\", trait_, unraw(ty)),\n        Span::call_site(),\n    );\n\n    let use_serde = match serde_path {\n        Some(path) =\u003e quote! {\n            use #path as _serde;\n        },\n        None =\u003e quote! {\n            #[allow(unknown_lints)]\n            #[cfg_attr(feature = \"cargo-clippy\", allow(useless_attribute))]\n            #[allow(rust_2018_idioms)]\n            extern crate serde as _serde;\n        },\n    };\n\n    quote! {\n        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n        const #dummy_const: () = {\n            #use_serde\n            #try_replacement\n            #code\n        };\n    }\n}\n\n#[allow(deprecated)]\nfn unraw(ident: \u0026Ident) -\u003e String {\n    // str::trim_start_matches was added in 1.30, trim_left_matches deprecated\n    // in 1.33. We currently support rustc back to 1.15 so we need to continue\n    // to use the deprecated one.\n    ident.to_string().trim_left_matches(\"r#\").to_owned()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","fragment.rs"],"content":"use proc_macro2::TokenStream;\nuse quote::ToTokens;\nuse syn::token;\n\npub enum Fragment {\n    /// Tokens that can be used as an expression.\n    Expr(TokenStream),\n    /// Tokens that can be used inside a block. The surrounding curly braces are\n    /// not part of these tokens.\n    Block(TokenStream),\n}\n\nmacro_rules! quote_expr {\n    ($($tt:tt)*) =\u003e {\n        $crate::fragment::Fragment::Expr(quote!($($tt)*))\n    }\n}\n\nmacro_rules! quote_block {\n    ($($tt:tt)*) =\u003e {\n        $crate::fragment::Fragment::Block(quote!($($tt)*))\n    }\n}\n\n/// Interpolate a fragment in place of an expression. This involves surrounding\n/// Block fragments in curly braces.\npub struct Expr(pub Fragment);\nimpl ToTokens for Expr {\n    fn to_tokens(\u0026self, out: \u0026mut TokenStream) {\n        match self.0 {\n            Fragment::Expr(ref expr) =\u003e expr.to_tokens(out),\n            Fragment::Block(ref block) =\u003e {\n                token::Brace::default().surround(out, |out| block.to_tokens(out));\n            }\n        }\n    }\n}\n\n/// Interpolate a fragment as the statements of a block.\npub struct Stmts(pub Fragment);\nimpl ToTokens for Stmts {\n    fn to_tokens(\u0026self, out: \u0026mut TokenStream) {\n        match self.0 {\n            Fragment::Expr(ref expr) =\u003e expr.to_tokens(out),\n            Fragment::Block(ref block) =\u003e block.to_tokens(out),\n        }\n    }\n}\n\n/// Interpolate a fragment as the value part of a `match` expression. This\n/// involves putting a comma after expressions and curly braces around blocks.\npub struct Match(pub Fragment);\nimpl ToTokens for Match {\n    fn to_tokens(\u0026self, out: \u0026mut TokenStream) {\n        match self.0 {\n            Fragment::Expr(ref expr) =\u003e {\n                expr.to_tokens(out);\n                \u003cToken![,]\u003e::default().to_tokens(out);\n            }\n            Fragment::Block(ref block) =\u003e {\n                token::Brace::default().surround(out, |out| block.to_tokens(out));\n            }\n        }\n    }\n}\n\nimpl AsRef\u003cTokenStream\u003e for Fragment {\n    fn as_ref(\u0026self) -\u003e \u0026TokenStream {\n        match *self {\n            Fragment::Expr(ref expr) =\u003e expr,\n            Fragment::Block(ref block) =\u003e block,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","ast.rs"],"content":"//! A Serde ast, parsed from the Syn ast and ready to generate Rust code.\n\nuse internals::attr;\nuse internals::check;\nuse internals::{Ctxt, Derive};\nuse syn;\nuse syn::punctuated::Punctuated;\n\n/// A source data structure annotated with `#[derive(Serialize)]` and/or `#[derive(Deserialize)]`,\n/// parsed into an internal representation.\npub struct Container\u003c'a\u003e {\n    /// The struct or enum name (without generics).\n    pub ident: syn::Ident,\n    /// Attributes on the structure, parsed for Serde.\n    pub attrs: attr::Container,\n    /// The contents of the struct or enum.\n    pub data: Data\u003c'a\u003e,\n    /// Any generics on the struct or enum.\n    pub generics: \u0026'a syn::Generics,\n    /// Original input.\n    pub original: \u0026'a syn::DeriveInput,\n}\n\n/// The fields of a struct or enum.\n///\n/// Analagous to `syn::Data`.\npub enum Data\u003c'a\u003e {\n    Enum(Vec\u003cVariant\u003c'a\u003e\u003e),\n    Struct(Style, Vec\u003cField\u003c'a\u003e\u003e),\n}\n\n/// A variant of an enum.\npub struct Variant\u003c'a\u003e {\n    pub ident: syn::Ident,\n    pub attrs: attr::Variant,\n    pub style: Style,\n    pub fields: Vec\u003cField\u003c'a\u003e\u003e,\n    pub original: \u0026'a syn::Variant,\n}\n\n/// A field of a struct.\npub struct Field\u003c'a\u003e {\n    pub member: syn::Member,\n    pub attrs: attr::Field,\n    pub ty: \u0026'a syn::Type,\n    pub original: \u0026'a syn::Field,\n}\n\n#[derive(Copy, Clone)]\npub enum Style {\n    /// Named fields.\n    Struct,\n    /// Many unnamed fields.\n    Tuple,\n    /// One unnamed field.\n    Newtype,\n    /// No fields.\n    Unit,\n}\n\nimpl\u003c'a\u003e Container\u003c'a\u003e {\n    /// Convert the raw Syn ast into a parsed container object, collecting errors in `cx`.\n    pub fn from_ast(\n        cx: \u0026Ctxt,\n        item: \u0026'a syn::DeriveInput,\n        derive: Derive,\n    ) -\u003e Option\u003cContainer\u003c'a\u003e\u003e {\n        let mut attrs = attr::Container::from_ast(cx, item);\n\n        let mut data = match item.data {\n            syn::Data::Enum(ref data) =\u003e {\n                Data::Enum(enum_from_ast(cx, \u0026data.variants, attrs.default()))\n            }\n            syn::Data::Struct(ref data) =\u003e {\n                let (style, fields) = struct_from_ast(cx, \u0026data.fields, None, attrs.default());\n                Data::Struct(style, fields)\n            }\n            syn::Data::Union(_) =\u003e {\n                cx.error_spanned_by(item, \"Serde does not support derive for unions\");\n                return None;\n            }\n        };\n\n        let mut has_flatten = false;\n        match data {\n            Data::Enum(ref mut variants) =\u003e {\n                for variant in variants {\n                    variant.attrs.rename_by_rules(attrs.rename_all_rules());\n                    for field in \u0026mut variant.fields {\n                        if field.attrs.flatten() {\n                            has_flatten = true;\n                        }\n                        field\n                            .attrs\n                            .rename_by_rules(variant.attrs.rename_all_rules());\n                    }\n                }\n            }\n            Data::Struct(_, ref mut fields) =\u003e {\n                for field in fields {\n                    if field.attrs.flatten() {\n                        has_flatten = true;\n                    }\n                    field.attrs.rename_by_rules(attrs.rename_all_rules());\n                }\n            }\n        }\n\n        if has_flatten {\n            attrs.mark_has_flatten();\n        }\n\n        let mut item = Container {\n            ident: item.ident.clone(),\n            attrs: attrs,\n            data: data,\n            generics: \u0026item.generics,\n            original: item,\n        };\n        check::check(cx, \u0026mut item, derive);\n        Some(item)\n    }\n}\n\nimpl\u003c'a\u003e Data\u003c'a\u003e {\n    pub fn all_fields(\u0026'a self) -\u003e Box\u003cIterator\u003cItem = \u0026'a Field\u003c'a\u003e\u003e + 'a\u003e {\n        match *self {\n            Data::Enum(ref variants) =\u003e {\n                Box::new(variants.iter().flat_map(|variant| variant.fields.iter()))\n            }\n            Data::Struct(_, ref fields) =\u003e Box::new(fields.iter()),\n        }\n    }\n\n    pub fn has_getter(\u0026self) -\u003e bool {\n        self.all_fields().any(|f| f.attrs.getter().is_some())\n    }\n}\n\nfn enum_from_ast\u003c'a\u003e(\n    cx: \u0026Ctxt,\n    variants: \u0026'a Punctuated\u003csyn::Variant, Token![,]\u003e,\n    container_default: \u0026attr::Default,\n) -\u003e Vec\u003cVariant\u003c'a\u003e\u003e {\n    variants\n        .iter()\n        .map(|variant| {\n            let attrs = attr::Variant::from_ast(cx, variant);\n            let (style, fields) =\n                struct_from_ast(cx, \u0026variant.fields, Some(\u0026attrs), container_default);\n            Variant {\n                ident: variant.ident.clone(),\n                attrs: attrs,\n                style: style,\n                fields: fields,\n                original: variant,\n            }\n        })\n        .collect()\n}\n\nfn struct_from_ast\u003c'a\u003e(\n    cx: \u0026Ctxt,\n    fields: \u0026'a syn::Fields,\n    attrs: Option\u003c\u0026attr::Variant\u003e,\n    container_default: \u0026attr::Default,\n) -\u003e (Style, Vec\u003cField\u003c'a\u003e\u003e) {\n    match *fields {\n        syn::Fields::Named(ref fields) =\u003e (\n            Style::Struct,\n            fields_from_ast(cx, \u0026fields.named, attrs, container_default),\n        ),\n        syn::Fields::Unnamed(ref fields) if fields.unnamed.len() == 1 =\u003e (\n            Style::Newtype,\n            fields_from_ast(cx, \u0026fields.unnamed, attrs, container_default),\n        ),\n        syn::Fields::Unnamed(ref fields) =\u003e (\n            Style::Tuple,\n            fields_from_ast(cx, \u0026fields.unnamed, attrs, container_default),\n        ),\n        syn::Fields::Unit =\u003e (Style::Unit, Vec::new()),\n    }\n}\n\nfn fields_from_ast\u003c'a\u003e(\n    cx: \u0026Ctxt,\n    fields: \u0026'a Punctuated\u003csyn::Field, Token![,]\u003e,\n    attrs: Option\u003c\u0026attr::Variant\u003e,\n    container_default: \u0026attr::Default,\n) -\u003e Vec\u003cField\u003c'a\u003e\u003e {\n    fields\n        .iter()\n        .enumerate()\n        .map(|(i, field)| Field {\n            member: match field.ident {\n                Some(ref ident) =\u003e syn::Member::Named(ident.clone()),\n                None =\u003e syn::Member::Unnamed(i.into()),\n            },\n            attrs: attr::Field::from_ast(cx, i, field, attrs, container_default),\n            ty: \u0026field.ty,\n            original: field,\n        })\n        .collect()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","attr.rs"],"content":"use internals::symbol::*;\nuse internals::Ctxt;\nuse proc_macro2::{Group, Span, TokenStream, TokenTree};\nuse quote::ToTokens;\nuse std::borrow::Cow;\nuse std::collections::BTreeSet;\nuse std::str::FromStr;\nuse syn;\nuse syn::parse::{self, Parse, ParseStream};\nuse syn::punctuated::Punctuated;\nuse syn::Ident;\nuse syn::Meta::{List, NameValue, Path};\nuse syn::NestedMeta::{Lit, Meta};\n\n// This module handles parsing of `#[serde(...)]` attributes. The entrypoints\n// are `attr::Container::from_ast`, `attr::Variant::from_ast`, and\n// `attr::Field::from_ast`. Each returns an instance of the corresponding\n// struct. Note that none of them return a Result. Unrecognized, malformed, or\n// duplicated attributes result in a span_err but otherwise are ignored. The\n// user will see errors simultaneously for all bad attributes in the crate\n// rather than just the first.\n\npub use internals::case::RenameRule;\n\nstruct Attr\u003c'c, T\u003e {\n    cx: \u0026'c Ctxt,\n    name: Symbol,\n    tokens: TokenStream,\n    value: Option\u003cT\u003e,\n}\n\nimpl\u003c'c, T\u003e Attr\u003c'c, T\u003e {\n    fn none(cx: \u0026'c Ctxt, name: Symbol) -\u003e Self {\n        Attr {\n            cx: cx,\n            name: name,\n            tokens: TokenStream::new(),\n            value: None,\n        }\n    }\n\n    fn set\u003cA: ToTokens\u003e(\u0026mut self, obj: A, value: T) {\n        let tokens = obj.into_token_stream();\n\n        if self.value.is_some() {\n            self.cx\n                .error_spanned_by(tokens, format!(\"duplicate serde attribute `{}`\", self.name));\n        } else {\n            self.tokens = tokens;\n            self.value = Some(value);\n        }\n    }\n\n    fn set_opt\u003cA: ToTokens\u003e(\u0026mut self, obj: A, value: Option\u003cT\u003e) {\n        if let Some(value) = value {\n            self.set(obj, value);\n        }\n    }\n\n    fn set_if_none(\u0026mut self, value: T) {\n        if self.value.is_none() {\n            self.value = Some(value);\n        }\n    }\n\n    fn get(self) -\u003e Option\u003cT\u003e {\n        self.value\n    }\n\n    fn get_with_tokens(self) -\u003e Option\u003c(TokenStream, T)\u003e {\n        match self.value {\n            Some(v) =\u003e Some((self.tokens, v)),\n            None =\u003e None,\n        }\n    }\n}\n\nstruct BoolAttr\u003c'c\u003e(Attr\u003c'c, ()\u003e);\n\nimpl\u003c'c\u003e BoolAttr\u003c'c\u003e {\n    fn none(cx: \u0026'c Ctxt, name: Symbol) -\u003e Self {\n        BoolAttr(Attr::none(cx, name))\n    }\n\n    fn set_true\u003cA: ToTokens\u003e(\u0026mut self, obj: A) {\n        self.0.set(obj, ());\n    }\n\n    fn get(\u0026self) -\u003e bool {\n        self.0.value.is_some()\n    }\n}\n\nstruct VecAttr\u003c'c, T\u003e {\n    cx: \u0026'c Ctxt,\n    name: Symbol,\n    first_dup_tokens: TokenStream,\n    values: Vec\u003cT\u003e,\n}\n\nimpl\u003c'c, T\u003e VecAttr\u003c'c, T\u003e {\n    fn none(cx: \u0026'c Ctxt, name: Symbol) -\u003e Self {\n        VecAttr {\n            cx: cx,\n            name: name,\n            first_dup_tokens: TokenStream::new(),\n            values: Vec::new(),\n        }\n    }\n\n    fn insert\u003cA: ToTokens\u003e(\u0026mut self, obj: A, value: T) {\n        if self.values.len() == 1 {\n            self.first_dup_tokens = obj.into_token_stream();\n        }\n        self.values.push(value);\n    }\n\n    fn at_most_one(mut self) -\u003e Result\u003cOption\u003cT\u003e, ()\u003e {\n        if self.values.len() \u003e 1 {\n            let dup_token = self.first_dup_tokens;\n            self.cx.error_spanned_by(\n                dup_token,\n                format!(\"duplicate serde attribute `{}`\", self.name),\n            );\n            Err(())\n        } else {\n            Ok(self.values.pop())\n        }\n    }\n\n    fn get(self) -\u003e Vec\u003cT\u003e {\n        self.values\n    }\n}\n\npub struct Name {\n    serialize: String,\n    serialize_renamed: bool,\n    deserialize: String,\n    deserialize_renamed: bool,\n    deserialize_aliases: Vec\u003cString\u003e,\n}\n\n#[allow(deprecated)]\nfn unraw(ident: \u0026Ident) -\u003e String {\n    // str::trim_start_matches was added in 1.30, trim_left_matches deprecated\n    // in 1.33. We currently support rustc back to 1.15 so we need to continue\n    // to use the deprecated one.\n    ident.to_string().trim_left_matches(\"r#\").to_owned()\n}\n\nimpl Name {\n    fn from_attrs(\n        source_name: String,\n        ser_name: Attr\u003cString\u003e,\n        de_name: Attr\u003cString\u003e,\n        de_aliases: Option\u003cVecAttr\u003cString\u003e\u003e,\n    ) -\u003e Name {\n        let deserialize_aliases = match de_aliases {\n            Some(de_aliases) =\u003e {\n                let mut alias_list = BTreeSet::new();\n                for alias_name in de_aliases.get() {\n                    alias_list.insert(alias_name);\n                }\n                alias_list.into_iter().collect()\n            }\n            None =\u003e Vec::new(),\n        };\n\n        let ser_name = ser_name.get();\n        let ser_renamed = ser_name.is_some();\n        let de_name = de_name.get();\n        let de_renamed = de_name.is_some();\n        Name {\n            serialize: ser_name.unwrap_or_else(|| source_name.clone()),\n            serialize_renamed: ser_renamed,\n            deserialize: de_name.unwrap_or(source_name),\n            deserialize_renamed: de_renamed,\n            deserialize_aliases: deserialize_aliases,\n        }\n    }\n\n    /// Return the container name for the container when serializing.\n    pub fn serialize_name(\u0026self) -\u003e String {\n        self.serialize.clone()\n    }\n\n    /// Return the container name for the container when deserializing.\n    pub fn deserialize_name(\u0026self) -\u003e String {\n        self.deserialize.clone()\n    }\n\n    fn deserialize_aliases(\u0026self) -\u003e Vec\u003cString\u003e {\n        let mut aliases = self.deserialize_aliases.clone();\n        let main_name = self.deserialize_name();\n        if !aliases.contains(\u0026main_name) {\n            aliases.push(main_name);\n        }\n        aliases\n    }\n}\n\npub struct RenameAllRules {\n    serialize: RenameRule,\n    deserialize: RenameRule,\n}\n\n/// Represents struct or enum attribute information.\npub struct Container {\n    name: Name,\n    transparent: bool,\n    deny_unknown_fields: bool,\n    default: Default,\n    rename_all_rules: RenameAllRules,\n    ser_bound: Option\u003cVec\u003csyn::WherePredicate\u003e\u003e,\n    de_bound: Option\u003cVec\u003csyn::WherePredicate\u003e\u003e,\n    tag: TagType,\n    type_from: Option\u003csyn::Type\u003e,\n    type_try_from: Option\u003csyn::Type\u003e,\n    type_into: Option\u003csyn::Type\u003e,\n    remote: Option\u003csyn::Path\u003e,\n    identifier: Identifier,\n    has_flatten: bool,\n    serde_path: Option\u003csyn::Path\u003e,\n}\n\n/// Styles of representing an enum.\npub enum TagType {\n    /// The default.\n    ///\n    /// ```json\n    /// {\"variant1\": {\"key1\": \"value1\", \"key2\": \"value2\"}}\n    /// ```\n    External,\n\n    /// `#[serde(tag = \"type\")]`\n    ///\n    /// ```json\n    /// {\"type\": \"variant1\", \"key1\": \"value1\", \"key2\": \"value2\"}\n    /// ```\n    Internal { tag: String },\n\n    /// `#[serde(tag = \"t\", content = \"c\")]`\n    ///\n    /// ```json\n    /// {\"t\": \"variant1\", \"c\": {\"key1\": \"value1\", \"key2\": \"value2\"}}\n    /// ```\n    Adjacent { tag: String, content: String },\n\n    /// `#[serde(untagged)]`\n    ///\n    /// ```json\n    /// {\"key1\": \"value1\", \"key2\": \"value2\"}\n    /// ```\n    None,\n}\n\n/// Whether this enum represents the fields of a struct or the variants of an\n/// enum.\n#[derive(Copy, Clone)]\npub enum Identifier {\n    /// It does not.\n    No,\n\n    /// This enum represents the fields of a struct. All of the variants must be\n    /// unit variants, except possibly one which is annotated with\n    /// `#[serde(other)]` and is a newtype variant.\n    Field,\n\n    /// This enum represents the variants of an enum. All of the variants must\n    /// be unit variants.\n    Variant,\n}\n\nimpl Identifier {\n    #[cfg(feature = \"deserialize_in_place\")]\n    pub fn is_some(self) -\u003e bool {\n        match self {\n            Identifier::No =\u003e false,\n            Identifier::Field | Identifier::Variant =\u003e true,\n        }\n    }\n}\n\nimpl Container {\n    /// Extract out the `#[serde(...)]` attributes from an item.\n    pub fn from_ast(cx: \u0026Ctxt, item: \u0026syn::DeriveInput) -\u003e Self {\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut transparent = BoolAttr::none(cx, TRANSPARENT);\n        let mut deny_unknown_fields = BoolAttr::none(cx, DENY_UNKNOWN_FIELDS);\n        let mut default = Attr::none(cx, DEFAULT);\n        let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);\n        let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut untagged = BoolAttr::none(cx, UNTAGGED);\n        let mut internal_tag = Attr::none(cx, TAG);\n        let mut content = Attr::none(cx, CONTENT);\n        let mut type_from = Attr::none(cx, FROM);\n        let mut type_try_from = Attr::none(cx, TRY_FROM);\n        let mut type_into = Attr::none(cx, INTO);\n        let mut remote = Attr::none(cx, REMOTE);\n        let mut field_identifier = BoolAttr::none(cx, FIELD_IDENTIFIER);\n        let mut variant_identifier = BoolAttr::none(cx, VARIANT_IDENTIFIER);\n        let mut serde_path = Attr::none(cx, CRATE);\n\n        for meta_items in item.attrs.iter().filter_map(get_serde_meta_items) {\n            for meta_item in meta_items {\n                match meta_item {\n                    // Parse `#[serde(rename = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME =\u003e {\n                        if let Ok(s) = get_lit_str(cx, RENAME, \u0026m.lit) {\n                            ser_name.set(\u0026m.path, s.value());\n                            de_name.set(\u0026m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME =\u003e {\n                        if let Ok((ser, de)) = get_renames(cx, \u0026m.nested) {\n                            ser_name.set_opt(\u0026m.path, ser.map(syn::LitStr::value));\n                            de_name.set_opt(\u0026m.path, de.map(syn::LitStr::value));\n                        }\n                    }\n\n                    // Parse `#[serde(rename_all = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME_ALL =\u003e {\n                        if let Ok(s) = get_lit_str(cx, RENAME_ALL, \u0026m.lit) {\n                            match RenameRule::from_str(\u0026s.value()) {\n                                Ok(rename_rule) =\u003e {\n                                    rename_all_ser_rule.set(\u0026m.path, rename_rule);\n                                    rename_all_de_rule.set(\u0026m.path, rename_rule);\n                                }\n                                Err(()) =\u003e cx.error_spanned_by(\n                                    s,\n                                    format!(\n                                        \"unknown rename rule for #[serde(rename_all \\\n                                         = {:?})]\",\n                                        s.value(),\n                                    ),\n                                ),\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME_ALL =\u003e {\n                        if let Ok((ser, de)) = get_renames(cx, \u0026m.nested) {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(\u0026ser.value()) {\n                                    Ok(rename_rule) =\u003e {\n                                        rename_all_ser_rule.set(\u0026m.path, rename_rule)\n                                    }\n                                    Err(()) =\u003e cx.error_spanned_by(\n                                        ser,\n                                        format!(\n                                            \"unknown rename rule for #[serde(rename_all \\\n                                             = {:?})]\",\n                                            ser.value(),\n                                        ),\n                                    ),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(\u0026de.value()) {\n                                    Ok(rename_rule) =\u003e rename_all_de_rule.set(\u0026m.path, rename_rule),\n                                    Err(()) =\u003e cx.error_spanned_by(\n                                        de,\n                                        format!(\n                                            \"unknown rename rule for #[serde(rename_all \\\n                                             = {:?})]\",\n                                            de.value(),\n                                        ),\n                                    ),\n                                }\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(transparent)]`\n                    Meta(Path(ref word)) if word == TRANSPARENT =\u003e {\n                        transparent.set_true(word);\n                    }\n\n                    // Parse `#[serde(deny_unknown_fields)]`\n                    Meta(Path(ref word)) if word == DENY_UNKNOWN_FIELDS =\u003e {\n                        deny_unknown_fields.set_true(word);\n                    }\n\n                    // Parse `#[serde(default)]`\n                    Meta(Path(ref word)) if word == DEFAULT =\u003e match item.data {\n                        syn::Data::Struct(syn::DataStruct { ref fields, .. }) =\u003e match *fields {\n                            syn::Fields::Named(_) =\u003e {\n                                default.set(word, Default::Default);\n                            }\n                            syn::Fields::Unnamed(_) | syn::Fields::Unit =\u003e cx.error_spanned_by(\n                                fields,\n                                \"#[serde(default)] can only be used on structs \\\n                                 with named fields\",\n                            ),\n                        },\n                        syn::Data::Enum(syn::DataEnum { ref enum_token, .. }) =\u003e cx\n                            .error_spanned_by(\n                                enum_token,\n                                \"#[serde(default)] can only be used on structs \\\n                                 with named fields\",\n                            ),\n                        syn::Data::Union(syn::DataUnion {\n                            ref union_token, ..\n                        }) =\u003e cx.error_spanned_by(\n                            union_token,\n                            \"#[serde(default)] can only be used on structs \\\n                             with named fields\",\n                        ),\n                    },\n\n                    // Parse `#[serde(default = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == DEFAULT =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, DEFAULT, \u0026m.lit) {\n                            match item.data {\n                                syn::Data::Struct(syn::DataStruct { ref fields, .. }) =\u003e {\n                                    match *fields {\n                                        syn::Fields::Named(_) =\u003e {\n                                            default.set(\u0026m.path, Default::Path(path));\n                                        }\n                                        syn::Fields::Unnamed(_) | syn::Fields::Unit =\u003e cx\n                                            .error_spanned_by(\n                                                fields,\n                                                \"#[serde(default = \\\"...\\\")] can only be used \\\n                                                 on structs with named fields\",\n                                            ),\n                                    }\n                                }\n                                syn::Data::Enum(syn::DataEnum { ref enum_token, .. }) =\u003e cx\n                                    .error_spanned_by(\n                                        enum_token,\n                                        \"#[serde(default = \\\"...\\\")] can only be used \\\n                                         on structs with named fields\",\n                                    ),\n                                syn::Data::Union(syn::DataUnion {\n                                    ref union_token, ..\n                                }) =\u003e cx.error_spanned_by(\n                                    union_token,\n                                    \"#[serde(default = \\\"...\\\")] can only be used \\\n                                     on structs with named fields\",\n                                ),\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(bound = \"T: SomeBound\")]`\n                    Meta(NameValue(ref m)) if m.path == BOUND =\u003e {\n                        if let Ok(where_predicates) = parse_lit_into_where(cx, BOUND, BOUND, \u0026m.lit)\n                        {\n                            ser_bound.set(\u0026m.path, where_predicates.clone());\n                            de_bound.set(\u0026m.path, where_predicates);\n                        }\n                    }\n\n                    // Parse `#[serde(bound(serialize = \"...\", deserialize = \"...\"))]`\n                    Meta(List(ref m)) if m.path == BOUND =\u003e {\n                        if let Ok((ser, de)) = get_where_predicates(cx, \u0026m.nested) {\n                            ser_bound.set_opt(\u0026m.path, ser);\n                            de_bound.set_opt(\u0026m.path, de);\n                        }\n                    }\n\n                    // Parse `#[serde(untagged)]`\n                    Meta(Path(ref word)) if word == UNTAGGED =\u003e match item.data {\n                        syn::Data::Enum(_) =\u003e {\n                            untagged.set_true(word);\n                        }\n                        syn::Data::Struct(syn::DataStruct {\n                            ref struct_token, ..\n                        }) =\u003e {\n                            cx.error_spanned_by(\n                                struct_token,\n                                \"#[serde(untagged)] can only be used on enums\",\n                            );\n                        }\n                        syn::Data::Union(syn::DataUnion {\n                            ref union_token, ..\n                        }) =\u003e {\n                            cx.error_spanned_by(\n                                union_token,\n                                \"#[serde(untagged)] can only be used on enums\",\n                            );\n                        }\n                    },\n\n                    // Parse `#[serde(tag = \"type\")]`\n                    Meta(NameValue(ref m)) if m.path == TAG =\u003e {\n                        if let Ok(s) = get_lit_str(cx, TAG, \u0026m.lit) {\n                            match item.data {\n                                syn::Data::Enum(_) =\u003e {\n                                    internal_tag.set(\u0026m.path, s.value());\n                                }\n                                syn::Data::Struct(syn::DataStruct { ref fields, .. }) =\u003e {\n                                    match *fields {\n                                        syn::Fields::Named(_) =\u003e {\n                                            internal_tag.set(\u0026m.path, s.value());\n                                        }\n                                        syn::Fields::Unnamed(_) | syn::Fields::Unit =\u003e {\n                                            cx.error_spanned_by(\n                                                fields,\n                                                \"#[serde(tag = \\\"...\\\")] can only be used on enums \\\n                                                and structs with named fields\",\n                                            );\n                                        }\n                                    }\n                                }\n                                syn::Data::Union(syn::DataUnion {\n                                    ref union_token, ..\n                                }) =\u003e {\n                                    cx.error_spanned_by(\n                                        union_token,\n                                        \"#[serde(tag = \\\"...\\\")] can only be used on enums \\\n                                         and structs with named fields\",\n                                    );\n                                }\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(content = \"c\")]`\n                    Meta(NameValue(ref m)) if m.path == CONTENT =\u003e {\n                        if let Ok(s) = get_lit_str(cx, CONTENT, \u0026m.lit) {\n                            match item.data {\n                                syn::Data::Enum(_) =\u003e {\n                                    content.set(\u0026m.path, s.value());\n                                }\n                                syn::Data::Struct(syn::DataStruct {\n                                    ref struct_token, ..\n                                }) =\u003e {\n                                    cx.error_spanned_by(\n                                        struct_token,\n                                        \"#[serde(content = \\\"...\\\")] can only be used on enums\",\n                                    );\n                                }\n                                syn::Data::Union(syn::DataUnion {\n                                    ref union_token, ..\n                                }) =\u003e {\n                                    cx.error_spanned_by(\n                                        union_token,\n                                        \"#[serde(content = \\\"...\\\")] can only be used on enums\",\n                                    );\n                                }\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(from = \"Type\")]\n                    Meta(NameValue(ref m)) if m.path == FROM =\u003e {\n                        if let Ok(from_ty) = parse_lit_into_ty(cx, FROM, \u0026m.lit) {\n                            type_from.set_opt(\u0026m.path, Some(from_ty));\n                        }\n                    }\n\n                    // Parse `#[serde(try_from = \"Type\")]\n                    Meta(NameValue(ref m)) if m.path == TRY_FROM =\u003e {\n                        if let Ok(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, \u0026m.lit) {\n                            type_try_from.set_opt(\u0026m.path, Some(try_from_ty));\n                        }\n                    }\n\n                    // Parse `#[serde(into = \"Type\")]\n                    Meta(NameValue(ref m)) if m.path == INTO =\u003e {\n                        if let Ok(into_ty) = parse_lit_into_ty(cx, INTO, \u0026m.lit) {\n                            type_into.set_opt(\u0026m.path, Some(into_ty));\n                        }\n                    }\n\n                    // Parse `#[serde(remote = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == REMOTE =\u003e {\n                        if let Ok(path) = parse_lit_into_path(cx, REMOTE, \u0026m.lit) {\n                            if is_primitive_path(\u0026path, \"Self\") {\n                                remote.set(\u0026m.path, item.ident.clone().into());\n                            } else {\n                                remote.set(\u0026m.path, path);\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(field_identifier)]`\n                    Meta(Path(ref word)) if word == FIELD_IDENTIFIER =\u003e {\n                        field_identifier.set_true(word);\n                    }\n\n                    // Parse `#[serde(variant_identifier)]`\n                    Meta(Path(ref word)) if word == VARIANT_IDENTIFIER =\u003e {\n                        variant_identifier.set_true(word);\n                    }\n\n                    // Parse `#[serde(crate = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == CRATE =\u003e {\n                        if let Ok(path) = parse_lit_into_path(cx, CRATE, \u0026m.lit) {\n                            serde_path.set(\u0026m.path, path)\n                        }\n                    }\n\n                    Meta(ref meta_item) =\u003e {\n                        let path = meta_item\n                            .path()\n                            .into_token_stream()\n                            .to_string()\n                            .replace(' ', \"\");\n                        cx.error_spanned_by(\n                            meta_item.path(),\n                            format!(\"unknown serde container attribute `{}`\", path),\n                        );\n                    }\n\n                    Lit(ref lit) =\u003e {\n                        cx.error_spanned_by(lit, \"unexpected literal in serde container attribute\");\n                    }\n                }\n            }\n        }\n\n        Container {\n            name: Name::from_attrs(unraw(\u0026item.ident), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            has_flatten: false,\n            serde_path: serde_path.get(),\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026Name {\n        \u0026self.name\n    }\n\n    pub fn rename_all_rules(\u0026self) -\u003e \u0026RenameAllRules {\n        \u0026self.rename_all_rules\n    }\n\n    pub fn transparent(\u0026self) -\u003e bool {\n        self.transparent\n    }\n\n    pub fn deny_unknown_fields(\u0026self) -\u003e bool {\n        self.deny_unknown_fields\n    }\n\n    pub fn default(\u0026self) -\u003e \u0026Default {\n        \u0026self.default\n    }\n\n    pub fn ser_bound(\u0026self) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e {\n        self.ser_bound.as_ref().map(|vec| \u0026vec[..])\n    }\n\n    pub fn de_bound(\u0026self) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e {\n        self.de_bound.as_ref().map(|vec| \u0026vec[..])\n    }\n\n    pub fn tag(\u0026self) -\u003e \u0026TagType {\n        \u0026self.tag\n    }\n\n    pub fn type_from(\u0026self) -\u003e Option\u003c\u0026syn::Type\u003e {\n        self.type_from.as_ref()\n    }\n\n    pub fn type_try_from(\u0026self) -\u003e Option\u003c\u0026syn::Type\u003e {\n        self.type_try_from.as_ref()\n    }\n\n    pub fn type_into(\u0026self) -\u003e Option\u003c\u0026syn::Type\u003e {\n        self.type_into.as_ref()\n    }\n\n    pub fn remote(\u0026self) -\u003e Option\u003c\u0026syn::Path\u003e {\n        self.remote.as_ref()\n    }\n\n    pub fn identifier(\u0026self) -\u003e Identifier {\n        self.identifier\n    }\n\n    pub fn has_flatten(\u0026self) -\u003e bool {\n        self.has_flatten\n    }\n\n    pub fn mark_has_flatten(\u0026mut self) {\n        self.has_flatten = true;\n    }\n\n    pub fn custom_serde_path(\u0026self) -\u003e Option\u003c\u0026syn::Path\u003e {\n        self.serde_path.as_ref()\n    }\n\n    pub fn serde_path(\u0026self) -\u003e Cow\u003csyn::Path\u003e {\n        self.custom_serde_path()\n            .map_or_else(|| Cow::Owned(parse_quote!(_serde)), Cow::Borrowed)\n    }\n}\n\nfn decide_tag(\n    cx: \u0026Ctxt,\n    item: \u0026syn::DeriveInput,\n    untagged: BoolAttr,\n    internal_tag: Attr\u003cString\u003e,\n    content: Attr\u003cString\u003e,\n) -\u003e TagType {\n    match (\n        untagged.0.get_with_tokens(),\n        internal_tag.get_with_tokens(),\n        content.get_with_tokens(),\n    ) {\n        (None, None, None) =\u003e TagType::External,\n        (Some(_), None, None) =\u003e TagType::None,\n        (None, Some((_, tag)), None) =\u003e {\n            // Check that there are no tuple variants.\n            if let syn::Data::Enum(ref data) = item.data {\n                for variant in \u0026data.variants {\n                    match variant.fields {\n                        syn::Fields::Named(_) | syn::Fields::Unit =\u003e {}\n                        syn::Fields::Unnamed(ref fields) =\u003e {\n                            if fields.unnamed.len() != 1 {\n                                cx.error_spanned_by(\n                                    variant,\n                                    \"#[serde(tag = \\\"...\\\")] cannot be used with tuple \\\n                                     variants\",\n                                );\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            TagType::Internal { tag: tag }\n        }\n        (Some((untagged_tokens, _)), Some((tag_tokens, _)), None) =\u003e {\n            cx.error_spanned_by(\n                untagged_tokens,\n                \"enum cannot be both untagged and internally tagged\",\n            );\n            cx.error_spanned_by(\n                tag_tokens,\n                \"enum cannot be both untagged and internally tagged\",\n            );\n            TagType::External // doesn't matter, will error\n        }\n        (None, None, Some((content_tokens, _))) =\u003e {\n            cx.error_spanned_by(\n                content_tokens,\n                \"#[serde(tag = \\\"...\\\", content = \\\"...\\\")] must be used together\",\n            );\n            TagType::External\n        }\n        (Some((untagged_tokens, _)), None, Some((content_tokens, _))) =\u003e {\n            cx.error_spanned_by(\n                untagged_tokens,\n                \"untagged enum cannot have #[serde(content = \\\"...\\\")]\",\n            );\n            cx.error_spanned_by(\n                content_tokens,\n                \"untagged enum cannot have #[serde(content = \\\"...\\\")]\",\n            );\n            TagType::External\n        }\n        (None, Some((_, tag)), Some((_, content))) =\u003e TagType::Adjacent {\n            tag: tag,\n            content: content,\n        },\n        (Some((untagged_tokens, _)), Some((tag_tokens, _)), Some((content_tokens, _))) =\u003e {\n            cx.error_spanned_by(\n                untagged_tokens,\n                \"untagged enum cannot have #[serde(tag = \\\"...\\\", content = \\\"...\\\")]\",\n            );\n            cx.error_spanned_by(\n                tag_tokens,\n                \"untagged enum cannot have #[serde(tag = \\\"...\\\", content = \\\"...\\\")]\",\n            );\n            cx.error_spanned_by(\n                content_tokens,\n                \"untagged enum cannot have #[serde(tag = \\\"...\\\", content = \\\"...\\\")]\",\n            );\n            TagType::External\n        }\n    }\n}\n\nfn decide_identifier(\n    cx: \u0026Ctxt,\n    item: \u0026syn::DeriveInput,\n    field_identifier: BoolAttr,\n    variant_identifier: BoolAttr,\n) -\u003e Identifier {\n    match (\n        \u0026item.data,\n        field_identifier.0.get_with_tokens(),\n        variant_identifier.0.get_with_tokens(),\n    ) {\n        (_, None, None) =\u003e Identifier::No,\n        (_, Some((field_identifier_tokens, _)), Some((variant_identifier_tokens, _))) =\u003e {\n            cx.error_spanned_by(\n                field_identifier_tokens,\n                \"#[serde(field_identifier)] and #[serde(variant_identifier)] cannot both be set\",\n            );\n            cx.error_spanned_by(\n                variant_identifier_tokens,\n                \"#[serde(field_identifier)] and #[serde(variant_identifier)] cannot both be set\",\n            );\n            Identifier::No\n        }\n        (\u0026syn::Data::Enum(_), Some(_), None) =\u003e Identifier::Field,\n        (\u0026syn::Data::Enum(_), None, Some(_)) =\u003e Identifier::Variant,\n        (\n            \u0026syn::Data::Struct(syn::DataStruct {\n                ref struct_token, ..\n            }),\n            Some(_),\n            None,\n        ) =\u003e {\n            cx.error_spanned_by(\n                struct_token,\n                \"#[serde(field_identifier)] can only be used on an enum\",\n            );\n            Identifier::No\n        }\n        (\n            \u0026syn::Data::Union(syn::DataUnion {\n                ref union_token, ..\n            }),\n            Some(_),\n            None,\n        ) =\u003e {\n            cx.error_spanned_by(\n                union_token,\n                \"#[serde(field_identifier)] can only be used on an enum\",\n            );\n            Identifier::No\n        }\n        (\n            \u0026syn::Data::Struct(syn::DataStruct {\n                ref struct_token, ..\n            }),\n            None,\n            Some(_),\n        ) =\u003e {\n            cx.error_spanned_by(\n                struct_token,\n                \"#[serde(variant_identifier)] can only be used on an enum\",\n            );\n            Identifier::No\n        }\n        (\n            \u0026syn::Data::Union(syn::DataUnion {\n                ref union_token, ..\n            }),\n            None,\n            Some(_),\n        ) =\u003e {\n            cx.error_spanned_by(\n                union_token,\n                \"#[serde(variant_identifier)] can only be used on an enum\",\n            );\n            Identifier::No\n        }\n    }\n}\n\n/// Represents variant attribute information\npub struct Variant {\n    name: Name,\n    rename_all_rules: RenameAllRules,\n    ser_bound: Option\u003cVec\u003csyn::WherePredicate\u003e\u003e,\n    de_bound: Option\u003cVec\u003csyn::WherePredicate\u003e\u003e,\n    skip_deserializing: bool,\n    skip_serializing: bool,\n    other: bool,\n    serialize_with: Option\u003csyn::ExprPath\u003e,\n    deserialize_with: Option\u003csyn::ExprPath\u003e,\n    borrow: Option\u003csyn::Meta\u003e,\n}\n\nimpl Variant {\n    pub fn from_ast(cx: \u0026Ctxt, variant: \u0026syn::Variant) -\u003e Self {\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut de_aliases = VecAttr::none(cx, RENAME);\n        let mut skip_deserializing = BoolAttr::none(cx, SKIP_DESERIALIZING);\n        let mut skip_serializing = BoolAttr::none(cx, SKIP_SERIALIZING);\n        let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);\n        let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut other = BoolAttr::none(cx, OTHER);\n        let mut serialize_with = Attr::none(cx, SERIALIZE_WITH);\n        let mut deserialize_with = Attr::none(cx, DESERIALIZE_WITH);\n        let mut borrow = Attr::none(cx, BORROW);\n\n        for meta_items in variant.attrs.iter().filter_map(get_serde_meta_items) {\n            for meta_item in meta_items {\n                match meta_item {\n                    // Parse `#[serde(rename = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME =\u003e {\n                        if let Ok(s) = get_lit_str(cx, RENAME, \u0026m.lit) {\n                            ser_name.set(\u0026m.path, s.value());\n                            de_name.set_if_none(s.value());\n                            de_aliases.insert(\u0026m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME =\u003e {\n                        if let Ok((ser, de)) = get_multiple_renames(cx, \u0026m.nested) {\n                            ser_name.set_opt(\u0026m.path, ser.map(syn::LitStr::value));\n                            for de_value in de {\n                                de_name.set_if_none(de_value.value());\n                                de_aliases.insert(\u0026m.path, de_value.value());\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(alias = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == ALIAS =\u003e {\n                        if let Ok(s) = get_lit_str(cx, ALIAS, \u0026m.lit) {\n                            de_aliases.insert(\u0026m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(rename_all = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME_ALL =\u003e {\n                        if let Ok(s) = get_lit_str(cx, RENAME_ALL, \u0026m.lit) {\n                            match RenameRule::from_str(\u0026s.value()) {\n                                Ok(rename_rule) =\u003e {\n                                    rename_all_ser_rule.set(\u0026m.path, rename_rule);\n                                    rename_all_de_rule.set(\u0026m.path, rename_rule);\n                                }\n                                Err(()) =\u003e cx.error_spanned_by(\n                                    s,\n                                    format!(\n                                        \"unknown rename rule for #[serde(rename_all \\\n                                         = {:?})]\",\n                                        s.value()\n                                    ),\n                                ),\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME_ALL =\u003e {\n                        if let Ok((ser, de)) = get_renames(cx, \u0026m.nested) {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(\u0026ser.value()) {\n                                    Ok(rename_rule) =\u003e {\n                                        rename_all_ser_rule.set(\u0026m.path, rename_rule)\n                                    }\n                                    Err(()) =\u003e cx.error_spanned_by(\n                                        ser,\n                                        format!(\n                                            \"unknown rename rule for #[serde(rename_all \\\n                                             = {:?})]\",\n                                            ser.value(),\n                                        ),\n                                    ),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(\u0026de.value()) {\n                                    Ok(rename_rule) =\u003e rename_all_de_rule.set(\u0026m.path, rename_rule),\n                                    Err(()) =\u003e cx.error_spanned_by(\n                                        de,\n                                        format!(\n                                            \"unknown rename rule for #[serde(rename_all \\\n                                             = {:?})]\",\n                                            de.value(),\n                                        ),\n                                    ),\n                                }\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(skip)]`\n                    Meta(Path(ref word)) if word == SKIP =\u003e {\n                        skip_serializing.set_true(word);\n                        skip_deserializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip_deserializing)]`\n                    Meta(Path(ref word)) if word == SKIP_DESERIALIZING =\u003e {\n                        skip_deserializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip_serializing)]`\n                    Meta(Path(ref word)) if word == SKIP_SERIALIZING =\u003e {\n                        skip_serializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(other)]`\n                    Meta(Path(ref word)) if word == OTHER =\u003e {\n                        other.set_true(word);\n                    }\n\n                    // Parse `#[serde(bound = \"T: SomeBound\")]`\n                    Meta(NameValue(ref m)) if m.path == BOUND =\u003e {\n                        if let Ok(where_predicates) = parse_lit_into_where(cx, BOUND, BOUND, \u0026m.lit)\n                        {\n                            ser_bound.set(\u0026m.path, where_predicates.clone());\n                            de_bound.set(\u0026m.path, where_predicates);\n                        }\n                    }\n\n                    // Parse `#[serde(bound(serialize = \"...\", deserialize = \"...\"))]`\n                    Meta(List(ref m)) if m.path == BOUND =\u003e {\n                        if let Ok((ser, de)) = get_where_predicates(cx, \u0026m.nested) {\n                            ser_bound.set_opt(\u0026m.path, ser);\n                            de_bound.set_opt(\u0026m.path, de);\n                        }\n                    }\n\n                    // Parse `#[serde(with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == WITH =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, WITH, \u0026m.lit) {\n                            let mut ser_path = path.clone();\n                            ser_path\n                                .path\n                                .segments\n                                .push(Ident::new(\"serialize\", Span::call_site()).into());\n                            serialize_with.set(\u0026m.path, ser_path);\n                            let mut de_path = path;\n                            de_path\n                                .path\n                                .segments\n                                .push(Ident::new(\"deserialize\", Span::call_site()).into());\n                            deserialize_with.set(\u0026m.path, de_path);\n                        }\n                    }\n\n                    // Parse `#[serde(serialize_with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == SERIALIZE_WITH =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, \u0026m.lit) {\n                            serialize_with.set(\u0026m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(deserialize_with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == DESERIALIZE_WITH =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, \u0026m.lit) {\n                            deserialize_with.set(\u0026m.path, path);\n                        }\n                    }\n\n                    // Defer `#[serde(borrow)]` and `#[serde(borrow = \"'a + 'b\")]`\n                    Meta(ref m) if m.path() == BORROW =\u003e match variant.fields {\n                        syn::Fields::Unnamed(ref fields) if fields.unnamed.len() == 1 =\u003e {\n                            borrow.set(m.path(), m.clone());\n                        }\n                        _ =\u003e {\n                            cx.error_spanned_by(\n                                variant,\n                                \"#[serde(borrow)] may only be used on newtype variants\",\n                            );\n                        }\n                    },\n\n                    Meta(ref meta_item) =\u003e {\n                        let path = meta_item\n                            .path()\n                            .into_token_stream()\n                            .to_string()\n                            .replace(' ', \"\");\n                        cx.error_spanned_by(\n                            meta_item.path(),\n                            format!(\"unknown serde variant attribute `{}`\", path),\n                        );\n                    }\n\n                    Lit(ref lit) =\u003e {\n                        cx.error_spanned_by(lit, \"unexpected literal in serde variant attribute\");\n                    }\n                }\n            }\n        }\n\n        Variant {\n            name: Name::from_attrs(unraw(\u0026variant.ident), ser_name, de_name, Some(de_aliases)),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing: skip_serializing.get(),\n            other: other.get(),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            borrow: borrow.get(),\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026Name {\n        \u0026self.name\n    }\n\n    pub fn aliases(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.name.deserialize_aliases()\n    }\n\n    pub fn rename_by_rules(\u0026mut self, rules: \u0026RenameAllRules) {\n        if !self.name.serialize_renamed {\n            self.name.serialize = rules.serialize.apply_to_variant(\u0026self.name.serialize);\n        }\n        if !self.name.deserialize_renamed {\n            self.name.deserialize = rules.deserialize.apply_to_variant(\u0026self.name.deserialize);\n        }\n    }\n\n    pub fn rename_all_rules(\u0026self) -\u003e \u0026RenameAllRules {\n        \u0026self.rename_all_rules\n    }\n\n    pub fn ser_bound(\u0026self) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e {\n        self.ser_bound.as_ref().map(|vec| \u0026vec[..])\n    }\n\n    pub fn de_bound(\u0026self) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e {\n        self.de_bound.as_ref().map(|vec| \u0026vec[..])\n    }\n\n    pub fn skip_deserializing(\u0026self) -\u003e bool {\n        self.skip_deserializing\n    }\n\n    pub fn skip_serializing(\u0026self) -\u003e bool {\n        self.skip_serializing\n    }\n\n    pub fn other(\u0026self) -\u003e bool {\n        self.other\n    }\n\n    pub fn serialize_with(\u0026self) -\u003e Option\u003c\u0026syn::ExprPath\u003e {\n        self.serialize_with.as_ref()\n    }\n\n    pub fn deserialize_with(\u0026self) -\u003e Option\u003c\u0026syn::ExprPath\u003e {\n        self.deserialize_with.as_ref()\n    }\n}\n\n/// Represents field attribute information\npub struct Field {\n    name: Name,\n    skip_serializing: bool,\n    skip_deserializing: bool,\n    skip_serializing_if: Option\u003csyn::ExprPath\u003e,\n    default: Default,\n    serialize_with: Option\u003csyn::ExprPath\u003e,\n    deserialize_with: Option\u003csyn::ExprPath\u003e,\n    ser_bound: Option\u003cVec\u003csyn::WherePredicate\u003e\u003e,\n    de_bound: Option\u003cVec\u003csyn::WherePredicate\u003e\u003e,\n    borrowed_lifetimes: BTreeSet\u003csyn::Lifetime\u003e,\n    getter: Option\u003csyn::ExprPath\u003e,\n    flatten: bool,\n    transparent: bool,\n}\n\n/// Represents the default to use for a field when deserializing.\npub enum Default {\n    /// Field must always be specified because it does not have a default.\n    None,\n    /// The default is given by `std::default::Default::default()`.\n    Default,\n    /// The default is given by this function.\n    Path(syn::ExprPath),\n}\n\nimpl Default {\n    pub fn is_none(\u0026self) -\u003e bool {\n        match *self {\n            Default::None =\u003e true,\n            Default::Default | Default::Path(_) =\u003e false,\n        }\n    }\n}\n\nimpl Field {\n    /// Extract out the `#[serde(...)]` attributes from a struct field.\n    pub fn from_ast(\n        cx: \u0026Ctxt,\n        index: usize,\n        field: \u0026syn::Field,\n        attrs: Option\u003c\u0026Variant\u003e,\n        container_default: \u0026Default,\n    ) -\u003e Self {\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut de_aliases = VecAttr::none(cx, RENAME);\n        let mut skip_serializing = BoolAttr::none(cx, SKIP_SERIALIZING);\n        let mut skip_deserializing = BoolAttr::none(cx, SKIP_DESERIALIZING);\n        let mut skip_serializing_if = Attr::none(cx, SKIP_SERIALIZING_IF);\n        let mut default = Attr::none(cx, DEFAULT);\n        let mut serialize_with = Attr::none(cx, SERIALIZE_WITH);\n        let mut deserialize_with = Attr::none(cx, DESERIALIZE_WITH);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut borrowed_lifetimes = Attr::none(cx, BORROW);\n        let mut getter = Attr::none(cx, GETTER);\n        let mut flatten = BoolAttr::none(cx, FLATTEN);\n\n        let ident = match field.ident {\n            Some(ref ident) =\u003e unraw(ident),\n            None =\u003e index.to_string(),\n        };\n\n        let variant_borrow = attrs\n            .and_then(|variant| variant.borrow.as_ref())\n            .map(|borrow| vec![Meta(borrow.clone())]);\n\n        for meta_items in field\n            .attrs\n            .iter()\n            .filter_map(get_serde_meta_items)\n            .chain(variant_borrow)\n        {\n            for meta_item in meta_items {\n                match meta_item {\n                    // Parse `#[serde(rename = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME =\u003e {\n                        if let Ok(s) = get_lit_str(cx, RENAME, \u0026m.lit) {\n                            ser_name.set(\u0026m.path, s.value());\n                            de_name.set_if_none(s.value());\n                            de_aliases.insert(\u0026m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME =\u003e {\n                        if let Ok((ser, de)) = get_multiple_renames(cx, \u0026m.nested) {\n                            ser_name.set_opt(\u0026m.path, ser.map(syn::LitStr::value));\n                            for de_value in de {\n                                de_name.set_if_none(de_value.value());\n                                de_aliases.insert(\u0026m.path, de_value.value());\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(alias = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == ALIAS =\u003e {\n                        if let Ok(s) = get_lit_str(cx, ALIAS, \u0026m.lit) {\n                            de_aliases.insert(\u0026m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(default)]`\n                    Meta(Path(ref word)) if word == DEFAULT =\u003e {\n                        default.set(word, Default::Default);\n                    }\n\n                    // Parse `#[serde(default = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == DEFAULT =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, DEFAULT, \u0026m.lit) {\n                            default.set(\u0026m.path, Default::Path(path));\n                        }\n                    }\n\n                    // Parse `#[serde(skip_serializing)]`\n                    Meta(Path(ref word)) if word == SKIP_SERIALIZING =\u003e {\n                        skip_serializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip_deserializing)]`\n                    Meta(Path(ref word)) if word == SKIP_DESERIALIZING =\u003e {\n                        skip_deserializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip)]`\n                    Meta(Path(ref word)) if word == SKIP =\u003e {\n                        skip_serializing.set_true(word);\n                        skip_deserializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip_serializing_if = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == SKIP_SERIALIZING_IF =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, SKIP_SERIALIZING_IF, \u0026m.lit)\n                        {\n                            skip_serializing_if.set(\u0026m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(serialize_with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == SERIALIZE_WITH =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, \u0026m.lit) {\n                            serialize_with.set(\u0026m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(deserialize_with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == DESERIALIZE_WITH =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, \u0026m.lit) {\n                            deserialize_with.set(\u0026m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == WITH =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, WITH, \u0026m.lit) {\n                            let mut ser_path = path.clone();\n                            ser_path\n                                .path\n                                .segments\n                                .push(Ident::new(\"serialize\", Span::call_site()).into());\n                            serialize_with.set(\u0026m.path, ser_path);\n                            let mut de_path = path;\n                            de_path\n                                .path\n                                .segments\n                                .push(Ident::new(\"deserialize\", Span::call_site()).into());\n                            deserialize_with.set(\u0026m.path, de_path);\n                        }\n                    }\n\n                    // Parse `#[serde(bound = \"T: SomeBound\")]`\n                    Meta(NameValue(ref m)) if m.path == BOUND =\u003e {\n                        if let Ok(where_predicates) = parse_lit_into_where(cx, BOUND, BOUND, \u0026m.lit)\n                        {\n                            ser_bound.set(\u0026m.path, where_predicates.clone());\n                            de_bound.set(\u0026m.path, where_predicates);\n                        }\n                    }\n\n                    // Parse `#[serde(bound(serialize = \"...\", deserialize = \"...\"))]`\n                    Meta(List(ref m)) if m.path == BOUND =\u003e {\n                        if let Ok((ser, de)) = get_where_predicates(cx, \u0026m.nested) {\n                            ser_bound.set_opt(\u0026m.path, ser);\n                            de_bound.set_opt(\u0026m.path, de);\n                        }\n                    }\n\n                    // Parse `#[serde(borrow)]`\n                    Meta(Path(ref word)) if word == BORROW =\u003e {\n                        if let Ok(borrowable) = borrowable_lifetimes(cx, \u0026ident, field) {\n                            borrowed_lifetimes.set(word, borrowable);\n                        }\n                    }\n\n                    // Parse `#[serde(borrow = \"'a + 'b\")]`\n                    Meta(NameValue(ref m)) if m.path == BORROW =\u003e {\n                        if let Ok(lifetimes) = parse_lit_into_lifetimes(cx, BORROW, \u0026m.lit) {\n                            if let Ok(borrowable) = borrowable_lifetimes(cx, \u0026ident, field) {\n                                for lifetime in \u0026lifetimes {\n                                    if !borrowable.contains(lifetime) {\n                                        cx.error_spanned_by(\n                                            field,\n                                            format!(\n                                                \"field `{}` does not have lifetime {}\",\n                                                ident, lifetime\n                                            ),\n                                        );\n                                    }\n                                }\n                                borrowed_lifetimes.set(\u0026m.path, lifetimes);\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(getter = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == GETTER =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, GETTER, \u0026m.lit) {\n                            getter.set(\u0026m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(flatten)]`\n                    Meta(Path(ref word)) if word == FLATTEN =\u003e {\n                        flatten.set_true(word);\n                    }\n\n                    Meta(ref meta_item) =\u003e {\n                        let path = meta_item\n                            .path()\n                            .into_token_stream()\n                            .to_string()\n                            .replace(' ', \"\");\n                        cx.error_spanned_by(\n                            meta_item.path(),\n                            format!(\"unknown serde field attribute `{}`\", path),\n                        );\n                    }\n\n                    Lit(ref lit) =\u003e {\n                        cx.error_spanned_by(lit, \"unexpected literal in serde field attribute\");\n                    }\n                }\n            }\n        }\n\n        // Is skip_deserializing, initialize the field to Default::default() unless a\n        // different default is specified by `#[serde(default = \"...\")]` on\n        // ourselves or our container (e.g. the struct we are in).\n        if let Default::None = *container_default {\n            if skip_deserializing.0.value.is_some() {\n                default.set_if_none(Default::Default);\n            }\n        }\n\n        let mut borrowed_lifetimes = borrowed_lifetimes.get().unwrap_or_default();\n        if !borrowed_lifetimes.is_empty() {\n            // Cow\u003cstr\u003e and Cow\u003c[u8]\u003e never borrow by default:\n            //\n            //     impl\u003c'de, 'a, T: ?Sized\u003e Deserialize\u003c'de\u003e for Cow\u003c'a, T\u003e\n            //\n            // A #[serde(borrow)] attribute enables borrowing that corresponds\n            // roughly to these impls:\n            //\n            //     impl\u003c'de: 'a, 'a\u003e Deserialize\u003c'de\u003e for Cow\u003c'a, str\u003e\n            //     impl\u003c'de: 'a, 'a\u003e Deserialize\u003c'de\u003e for Cow\u003c'a, [u8]\u003e\n            if is_cow(\u0026field.ty, is_str) {\n                let mut path = syn::Path {\n                    leading_colon: None,\n                    segments: Punctuated::new(),\n                };\n                path.segments\n                    .push(Ident::new(\"_serde\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"private\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"de\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"borrow_cow_str\", Span::call_site()).into());\n                let expr = syn::ExprPath {\n                    attrs: Vec::new(),\n                    qself: None,\n                    path: path,\n                };\n                deserialize_with.set_if_none(expr);\n            } else if is_cow(\u0026field.ty, is_slice_u8) {\n                let mut path = syn::Path {\n                    leading_colon: None,\n                    segments: Punctuated::new(),\n                };\n                path.segments\n                    .push(Ident::new(\"_serde\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"private\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"de\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"borrow_cow_bytes\", Span::call_site()).into());\n                let expr = syn::ExprPath {\n                    attrs: Vec::new(),\n                    qself: None,\n                    path: path,\n                };\n                deserialize_with.set_if_none(expr);\n            }\n        } else if is_implicitly_borrowed(\u0026field.ty) {\n            // Types \u0026str and \u0026[u8] are always implicitly borrowed. No need for\n            // a #[serde(borrow)].\n            collect_lifetimes(\u0026field.ty, \u0026mut borrowed_lifetimes);\n        }\n\n        Field {\n            name: Name::from_attrs(ident, ser_name, de_name, Some(de_aliases)),\n            skip_serializing: skip_serializing.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing_if: skip_serializing_if.get(),\n            default: default.get().unwrap_or(Default::None),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            borrowed_lifetimes: borrowed_lifetimes,\n            getter: getter.get(),\n            flatten: flatten.get(),\n            transparent: false,\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026Name {\n        \u0026self.name\n    }\n\n    pub fn aliases(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.name.deserialize_aliases()\n    }\n\n    pub fn rename_by_rules(\u0026mut self, rules: \u0026RenameAllRules) {\n        if !self.name.serialize_renamed {\n            self.name.serialize = rules.serialize.apply_to_field(\u0026self.name.serialize);\n        }\n        if !self.name.deserialize_renamed {\n            self.name.deserialize = rules.deserialize.apply_to_field(\u0026self.name.deserialize);\n        }\n    }\n\n    pub fn skip_serializing(\u0026self) -\u003e bool {\n        self.skip_serializing\n    }\n\n    pub fn skip_deserializing(\u0026self) -\u003e bool {\n        self.skip_deserializing\n    }\n\n    pub fn skip_serializing_if(\u0026self) -\u003e Option\u003c\u0026syn::ExprPath\u003e {\n        self.skip_serializing_if.as_ref()\n    }\n\n    pub fn default(\u0026self) -\u003e \u0026Default {\n        \u0026self.default\n    }\n\n    pub fn serialize_with(\u0026self) -\u003e Option\u003c\u0026syn::ExprPath\u003e {\n        self.serialize_with.as_ref()\n    }\n\n    pub fn deserialize_with(\u0026self) -\u003e Option\u003c\u0026syn::ExprPath\u003e {\n        self.deserialize_with.as_ref()\n    }\n\n    pub fn ser_bound(\u0026self) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e {\n        self.ser_bound.as_ref().map(|vec| \u0026vec[..])\n    }\n\n    pub fn de_bound(\u0026self) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e {\n        self.de_bound.as_ref().map(|vec| \u0026vec[..])\n    }\n\n    pub fn borrowed_lifetimes(\u0026self) -\u003e \u0026BTreeSet\u003csyn::Lifetime\u003e {\n        \u0026self.borrowed_lifetimes\n    }\n\n    pub fn getter(\u0026self) -\u003e Option\u003c\u0026syn::ExprPath\u003e {\n        self.getter.as_ref()\n    }\n\n    pub fn flatten(\u0026self) -\u003e bool {\n        self.flatten\n    }\n\n    pub fn transparent(\u0026self) -\u003e bool {\n        self.transparent\n    }\n\n    pub fn mark_transparent(\u0026mut self) {\n        self.transparent = true;\n    }\n}\n\ntype SerAndDe\u003cT\u003e = (Option\u003cT\u003e, Option\u003cT\u003e);\n\nfn get_ser_and_de\u003c'a, 'b, T, F\u003e(\n    cx: \u0026'b Ctxt,\n    attr_name: Symbol,\n    metas: \u0026'a Punctuated\u003csyn::NestedMeta, Token![,]\u003e,\n    f: F,\n) -\u003e Result\u003c(VecAttr\u003c'b, T\u003e, VecAttr\u003c'b, T\u003e), ()\u003e\nwhere\n    T: 'a,\n    F: Fn(\u0026Ctxt, Symbol, Symbol, \u0026'a syn::Lit) -\u003e Result\u003cT, ()\u003e,\n{\n    let mut ser_meta = VecAttr::none(cx, attr_name);\n    let mut de_meta = VecAttr::none(cx, attr_name);\n\n    for meta in metas {\n        match *meta {\n            Meta(NameValue(ref meta)) if meta.path == SERIALIZE =\u003e {\n                if let Ok(v) = f(cx, attr_name, SERIALIZE, \u0026meta.lit) {\n                    ser_meta.insert(\u0026meta.path, v);\n                }\n            }\n\n            Meta(NameValue(ref meta)) if meta.path == DESERIALIZE =\u003e {\n                if let Ok(v) = f(cx, attr_name, DESERIALIZE, \u0026meta.lit) {\n                    de_meta.insert(\u0026meta.path, v);\n                }\n            }\n\n            _ =\u003e {\n                cx.error_spanned_by(\n                    meta,\n                    format!(\n                        \"malformed {0} attribute, expected `{0}(serialize = ..., \\\n                         deserialize = ...)`\",\n                        attr_name\n                    ),\n                );\n                return Err(());\n            }\n        }\n    }\n\n    Ok((ser_meta, de_meta))\n}\n\nfn get_renames\u003c'a\u003e(\n    cx: \u0026Ctxt,\n    items: \u0026'a Punctuated\u003csyn::NestedMeta, Token![,]\u003e,\n) -\u003e Result\u003cSerAndDe\u003c\u0026'a syn::LitStr\u003e, ()\u003e {\n    let (ser, de) = get_ser_and_de(cx, RENAME, items, get_lit_str2)?;\n    Ok((ser.at_most_one()?, de.at_most_one()?))\n}\n\nfn get_multiple_renames\u003c'a\u003e(\n    cx: \u0026Ctxt,\n    items: \u0026'a Punctuated\u003csyn::NestedMeta, Token![,]\u003e,\n) -\u003e Result\u003c(Option\u003c\u0026'a syn::LitStr\u003e, Vec\u003c\u0026'a syn::LitStr\u003e), ()\u003e {\n    let (ser, de) = get_ser_and_de(cx, RENAME, items, get_lit_str2)?;\n    Ok((ser.at_most_one()?, de.get()))\n}\n\nfn get_where_predicates(\n    cx: \u0026Ctxt,\n    items: \u0026Punctuated\u003csyn::NestedMeta, Token![,]\u003e,\n) -\u003e Result\u003cSerAndDe\u003cVec\u003csyn::WherePredicate\u003e\u003e, ()\u003e {\n    let (ser, de) = get_ser_and_de(cx, BOUND, items, parse_lit_into_where)?;\n    Ok((ser.at_most_one()?, de.at_most_one()?))\n}\n\npub fn get_serde_meta_items(attr: \u0026syn::Attribute) -\u003e Option\u003cVec\u003csyn::NestedMeta\u003e\u003e {\n    if attr.path == SERDE {\n        match attr.parse_meta() {\n            Ok(List(ref meta)) =\u003e Some(meta.nested.iter().cloned().collect()),\n            _ =\u003e {\n                // TODO: produce an error\n                None\n            }\n        }\n    } else {\n        None\n    }\n}\n\nfn get_lit_str\u003c'a\u003e(cx: \u0026Ctxt, attr_name: Symbol, lit: \u0026'a syn::Lit) -\u003e Result\u003c\u0026'a syn::LitStr, ()\u003e {\n    get_lit_str2(cx, attr_name, attr_name, lit)\n}\n\nfn get_lit_str2\u003c'a\u003e(\n    cx: \u0026Ctxt,\n    attr_name: Symbol,\n    meta_item_name: Symbol,\n    lit: \u0026'a syn::Lit,\n) -\u003e Result\u003c\u0026'a syn::LitStr, ()\u003e {\n    if let syn::Lit::Str(ref lit) = *lit {\n        Ok(lit)\n    } else {\n        cx.error_spanned_by(\n            lit,\n            format!(\n                \"expected serde {} attribute to be a string: `{} = \\\"...\\\"`\",\n                attr_name, meta_item_name\n            ),\n        );\n        Err(())\n    }\n}\n\nfn parse_lit_into_path(cx: \u0026Ctxt, attr_name: Symbol, lit: \u0026syn::Lit) -\u003e Result\u003csyn::Path, ()\u003e {\n    let string = get_lit_str(cx, attr_name, lit)?;\n    parse_lit_str(string).map_err(|_| {\n        cx.error_spanned_by(lit, format!(\"failed to parse path: {:?}\", string.value()))\n    })\n}\n\nfn parse_lit_into_expr_path(\n    cx: \u0026Ctxt,\n    attr_name: Symbol,\n    lit: \u0026syn::Lit,\n) -\u003e Result\u003csyn::ExprPath, ()\u003e {\n    let string = get_lit_str(cx, attr_name, lit)?;\n    parse_lit_str(string).map_err(|_| {\n        cx.error_spanned_by(lit, format!(\"failed to parse path: {:?}\", string.value()))\n    })\n}\n\nfn parse_lit_into_where(\n    cx: \u0026Ctxt,\n    attr_name: Symbol,\n    meta_item_name: Symbol,\n    lit: \u0026syn::Lit,\n) -\u003e Result\u003cVec\u003csyn::WherePredicate\u003e, ()\u003e {\n    let string = get_lit_str2(cx, attr_name, meta_item_name, lit)?;\n    if string.value().is_empty() {\n        return Ok(Vec::new());\n    }\n\n    let where_string = syn::LitStr::new(\u0026format!(\"where {}\", string.value()), string.span());\n\n    parse_lit_str::\u003csyn::WhereClause\u003e(\u0026where_string)\n        .map(|wh| wh.predicates.into_iter().collect())\n        .map_err(|err| cx.error_spanned_by(lit, err))\n}\n\nfn parse_lit_into_ty(cx: \u0026Ctxt, attr_name: Symbol, lit: \u0026syn::Lit) -\u003e Result\u003csyn::Type, ()\u003e {\n    let string = get_lit_str(cx, attr_name, lit)?;\n\n    parse_lit_str(string).map_err(|_| {\n        cx.error_spanned_by(\n            lit,\n            format!(\"failed to parse type: {} = {:?}\", attr_name, string.value()),\n        )\n    })\n}\n\n// Parses a string literal like \"'a + 'b + 'c\" containing a nonempty list of\n// lifetimes separated by `+`.\nfn parse_lit_into_lifetimes(\n    cx: \u0026Ctxt,\n    attr_name: Symbol,\n    lit: \u0026syn::Lit,\n) -\u003e Result\u003cBTreeSet\u003csyn::Lifetime\u003e, ()\u003e {\n    let string = get_lit_str(cx, attr_name, lit)?;\n    if string.value().is_empty() {\n        cx.error_spanned_by(lit, \"at least one lifetime must be borrowed\");\n        return Err(());\n    }\n\n    struct BorrowedLifetimes(Punctuated\u003csyn::Lifetime, Token![+]\u003e);\n\n    impl Parse for BorrowedLifetimes {\n        fn parse(input: ParseStream) -\u003e parse::Result\u003cSelf\u003e {\n            Punctuated::parse_separated_nonempty(input).map(BorrowedLifetimes)\n        }\n    }\n\n    if let Ok(BorrowedLifetimes(lifetimes)) = parse_lit_str(string) {\n        let mut set = BTreeSet::new();\n        for lifetime in lifetimes {\n            if !set.insert(lifetime.clone()) {\n                cx.error_spanned_by(lit, format!(\"duplicate borrowed lifetime `{}`\", lifetime));\n            }\n        }\n        return Ok(set);\n    }\n\n    cx.error_spanned_by(\n        lit,\n        format!(\"failed to parse borrowed lifetimes: {:?}\", string.value()),\n    );\n    Err(())\n}\n\nfn is_implicitly_borrowed(ty: \u0026syn::Type) -\u003e bool {\n    is_implicitly_borrowed_reference(ty) || is_option(ty, is_implicitly_borrowed_reference)\n}\n\nfn is_implicitly_borrowed_reference(ty: \u0026syn::Type) -\u003e bool {\n    is_reference(ty, is_str) || is_reference(ty, is_slice_u8)\n}\n\n// Whether the type looks like it might be `std::borrow::Cow\u003cT\u003e` where elem=\"T\".\n// This can have false negatives and false positives.\n//\n// False negative:\n//\n//     use std::borrow::Cow as Pig;\n//\n//     #[derive(Deserialize)]\n//     struct S\u003c'a\u003e {\n//         #[serde(borrow)]\n//         pig: Pig\u003c'a, str\u003e,\n//     }\n//\n// False positive:\n//\n//     type str = [i16];\n//\n//     #[derive(Deserialize)]\n//     struct S\u003c'a\u003e {\n//         #[serde(borrow)]\n//         cow: Cow\u003c'a, str\u003e,\n//     }\nfn is_cow(ty: \u0026syn::Type, elem: fn(\u0026syn::Type) -\u003e bool) -\u003e bool {\n    let path = match *ty {\n        syn::Type::Path(ref ty) =\u003e \u0026ty.path,\n        _ =\u003e {\n            return false;\n        }\n    };\n    let seg = match path.segments.last() {\n        Some(seg) =\u003e seg,\n        None =\u003e {\n            return false;\n        }\n    };\n    let args = match seg.arguments {\n        syn::PathArguments::AngleBracketed(ref bracketed) =\u003e \u0026bracketed.args,\n        _ =\u003e {\n            return false;\n        }\n    };\n    seg.ident == \"Cow\"\n        \u0026\u0026 args.len() == 2\n        \u0026\u0026 match (\u0026args[0], \u0026args[1]) {\n            (\u0026syn::GenericArgument::Lifetime(_), \u0026syn::GenericArgument::Type(ref arg)) =\u003e elem(arg),\n            _ =\u003e false,\n        }\n}\n\nfn is_option(ty: \u0026syn::Type, elem: fn(\u0026syn::Type) -\u003e bool) -\u003e bool {\n    let path = match *ty {\n        syn::Type::Path(ref ty) =\u003e \u0026ty.path,\n        _ =\u003e {\n            return false;\n        }\n    };\n    let seg = match path.segments.last() {\n        Some(seg) =\u003e seg,\n        None =\u003e {\n            return false;\n        }\n    };\n    let args = match seg.arguments {\n        syn::PathArguments::AngleBracketed(ref bracketed) =\u003e \u0026bracketed.args,\n        _ =\u003e {\n            return false;\n        }\n    };\n    seg.ident == \"Option\"\n        \u0026\u0026 args.len() == 1\n        \u0026\u0026 match args[0] {\n            syn::GenericArgument::Type(ref arg) =\u003e elem(arg),\n            _ =\u003e false,\n        }\n}\n\n// Whether the type looks like it might be `\u0026T` where elem=\"T\". This can have\n// false negatives and false positives.\n//\n// False negative:\n//\n//     type Yarn = str;\n//\n//     #[derive(Deserialize)]\n//     struct S\u003c'a\u003e {\n//         r: \u0026'a Yarn,\n//     }\n//\n// False positive:\n//\n//     type str = [i16];\n//\n//     #[derive(Deserialize)]\n//     struct S\u003c'a\u003e {\n//         r: \u0026'a str,\n//     }\nfn is_reference(ty: \u0026syn::Type, elem: fn(\u0026syn::Type) -\u003e bool) -\u003e bool {\n    match *ty {\n        syn::Type::Reference(ref ty) =\u003e ty.mutability.is_none() \u0026\u0026 elem(\u0026ty.elem),\n        _ =\u003e false,\n    }\n}\n\nfn is_str(ty: \u0026syn::Type) -\u003e bool {\n    is_primitive_type(ty, \"str\")\n}\n\nfn is_slice_u8(ty: \u0026syn::Type) -\u003e bool {\n    match *ty {\n        syn::Type::Slice(ref ty) =\u003e is_primitive_type(\u0026ty.elem, \"u8\"),\n        _ =\u003e false,\n    }\n}\n\nfn is_primitive_type(ty: \u0026syn::Type, primitive: \u0026str) -\u003e bool {\n    match *ty {\n        syn::Type::Path(ref ty) =\u003e ty.qself.is_none() \u0026\u0026 is_primitive_path(\u0026ty.path, primitive),\n        _ =\u003e false,\n    }\n}\n\nfn is_primitive_path(path: \u0026syn::Path, primitive: \u0026str) -\u003e bool {\n    path.leading_colon.is_none()\n        \u0026\u0026 path.segments.len() == 1\n        \u0026\u0026 path.segments[0].ident == primitive\n        \u0026\u0026 path.segments[0].arguments.is_empty()\n}\n\n// All lifetimes that this type could borrow from a Deserializer.\n//\n// For example a type `S\u003c'a, 'b\u003e` could borrow `'a` and `'b`. On the other hand\n// a type `for\u003c'a\u003e fn(\u0026'a str)` could not borrow `'a` from the Deserializer.\n//\n// This is used when there is an explicit or implicit `#[serde(borrow)]`\n// attribute on the field so there must be at least one borrowable lifetime.\nfn borrowable_lifetimes(\n    cx: \u0026Ctxt,\n    name: \u0026str,\n    field: \u0026syn::Field,\n) -\u003e Result\u003cBTreeSet\u003csyn::Lifetime\u003e, ()\u003e {\n    let mut lifetimes = BTreeSet::new();\n    collect_lifetimes(\u0026field.ty, \u0026mut lifetimes);\n    if lifetimes.is_empty() {\n        cx.error_spanned_by(\n            field,\n            format!(\"field `{}` has no lifetimes to borrow\", name),\n        );\n        Err(())\n    } else {\n        Ok(lifetimes)\n    }\n}\n\nfn collect_lifetimes(ty: \u0026syn::Type, out: \u0026mut BTreeSet\u003csyn::Lifetime\u003e) {\n    match *ty {\n        syn::Type::Slice(ref ty) =\u003e {\n            collect_lifetimes(\u0026ty.elem, out);\n        }\n        syn::Type::Array(ref ty) =\u003e {\n            collect_lifetimes(\u0026ty.elem, out);\n        }\n        syn::Type::Ptr(ref ty) =\u003e {\n            collect_lifetimes(\u0026ty.elem, out);\n        }\n        syn::Type::Reference(ref ty) =\u003e {\n            out.extend(ty.lifetime.iter().cloned());\n            collect_lifetimes(\u0026ty.elem, out);\n        }\n        syn::Type::Tuple(ref ty) =\u003e {\n            for elem in \u0026ty.elems {\n                collect_lifetimes(elem, out);\n            }\n        }\n        syn::Type::Path(ref ty) =\u003e {\n            if let Some(ref qself) = ty.qself {\n                collect_lifetimes(\u0026qself.ty, out);\n            }\n            for seg in \u0026ty.path.segments {\n                if let syn::PathArguments::AngleBracketed(ref bracketed) = seg.arguments {\n                    for arg in \u0026bracketed.args {\n                        match *arg {\n                            syn::GenericArgument::Lifetime(ref lifetime) =\u003e {\n                                out.insert(lifetime.clone());\n                            }\n                            syn::GenericArgument::Type(ref ty) =\u003e {\n                                collect_lifetimes(ty, out);\n                            }\n                            syn::GenericArgument::Binding(ref binding) =\u003e {\n                                collect_lifetimes(\u0026binding.ty, out);\n                            }\n                            syn::GenericArgument::Constraint(_)\n                            | syn::GenericArgument::Const(_) =\u003e {}\n                        }\n                    }\n                }\n            }\n        }\n        syn::Type::Paren(ref ty) =\u003e {\n            collect_lifetimes(\u0026ty.elem, out);\n        }\n        syn::Type::Group(ref ty) =\u003e {\n            collect_lifetimes(\u0026ty.elem, out);\n        }\n        syn::Type::BareFn(_)\n        | syn::Type::Never(_)\n        | syn::Type::TraitObject(_)\n        | syn::Type::ImplTrait(_)\n        | syn::Type::Infer(_)\n        | syn::Type::Macro(_)\n        | syn::Type::Verbatim(_)\n        | _ =\u003e {}\n    }\n}\n\nfn parse_lit_str\u003cT\u003e(s: \u0026syn::LitStr) -\u003e parse::Result\u003cT\u003e\nwhere\n    T: Parse,\n{\n    let tokens = spanned_tokens(s)?;\n    syn::parse2(tokens)\n}\n\nfn spanned_tokens(s: \u0026syn::LitStr) -\u003e parse::Result\u003cTokenStream\u003e {\n    let stream = syn::parse_str(\u0026s.value())?;\n    Ok(respan_token_stream(stream, s.span()))\n}\n\nfn respan_token_stream(stream: TokenStream, span: Span) -\u003e TokenStream {\n    stream\n        .into_iter()\n        .map(|token| respan_token_tree(token, span))\n        .collect()\n}\n\nfn respan_token_tree(mut token: TokenTree, span: Span) -\u003e TokenTree {\n    if let TokenTree::Group(ref mut g) = token {\n        *g = Group::new(g.delimiter(), respan_token_stream(g.stream().clone(), span));\n    }\n    token.set_span(span);\n    token\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","case.rs"],"content":"//! Code to convert the Rust-styled field/variant (e.g. `my_field`, `MyType`) to the\n//! case of the source (e.g. `my-field`, `MY_FIELD`).\n\n// See https://users.rust-lang.org/t/psa-dealing-with-warning-unused-import-std-ascii-asciiext-in-today-s-nightly/13726\n#[allow(deprecated, unused_imports)]\nuse std::ascii::AsciiExt;\n\nuse std::str::FromStr;\n\nuse self::RenameRule::*;\n\n/// The different possible ways to change case of fields in a struct, or variants in an enum.\n#[derive(Copy, Clone, PartialEq)]\npub enum RenameRule {\n    /// Don't apply a default rename rule.\n    None,\n    /// Rename direct children to \"lowercase\" style.\n    LowerCase,\n    /// Rename direct children to \"UPPERCASE\" style.\n    UPPERCASE,\n    /// Rename direct children to \"PascalCase\" style, as typically used for\n    /// enum variants.\n    PascalCase,\n    /// Rename direct children to \"camelCase\" style.\n    CamelCase,\n    /// Rename direct children to \"snake_case\" style, as commonly used for\n    /// fields.\n    SnakeCase,\n    /// Rename direct children to \"SCREAMING_SNAKE_CASE\" style, as commonly\n    /// used for constants.\n    ScreamingSnakeCase,\n    /// Rename direct children to \"kebab-case\" style.\n    KebabCase,\n    /// Rename direct children to \"SCREAMING-KEBAB-CASE\" style.\n    ScreamingKebabCase,\n}\n\nimpl RenameRule {\n    /// Apply a renaming rule to an enum variant, returning the version expected in the source.\n    pub fn apply_to_variant(\u0026self, variant: \u0026str) -\u003e String {\n        match *self {\n            None | PascalCase =\u003e variant.to_owned(),\n            LowerCase =\u003e variant.to_ascii_lowercase(),\n            UPPERCASE =\u003e variant.to_ascii_uppercase(),\n            CamelCase =\u003e variant[..1].to_ascii_lowercase() + \u0026variant[1..],\n            SnakeCase =\u003e {\n                let mut snake = String::new();\n                for (i, ch) in variant.char_indices() {\n                    if i \u003e 0 \u0026\u0026 ch.is_uppercase() {\n                        snake.push('_');\n                    }\n                    snake.push(ch.to_ascii_lowercase());\n                }\n                snake\n            }\n            ScreamingSnakeCase =\u003e SnakeCase.apply_to_variant(variant).to_ascii_uppercase(),\n            KebabCase =\u003e SnakeCase.apply_to_variant(variant).replace('_', \"-\"),\n            ScreamingKebabCase =\u003e ScreamingSnakeCase\n                .apply_to_variant(variant)\n                .replace('_', \"-\"),\n        }\n    }\n\n    /// Apply a renaming rule to a struct field, returning the version expected in the source.\n    pub fn apply_to_field(\u0026self, field: \u0026str) -\u003e String {\n        match *self {\n            None | LowerCase | SnakeCase =\u003e field.to_owned(),\n            UPPERCASE =\u003e field.to_ascii_uppercase(),\n            PascalCase =\u003e {\n                let mut pascal = String::new();\n                let mut capitalize = true;\n                for ch in field.chars() {\n                    if ch == '_' {\n                        capitalize = true;\n                    } else if capitalize {\n                        pascal.push(ch.to_ascii_uppercase());\n                        capitalize = false;\n                    } else {\n                        pascal.push(ch);\n                    }\n                }\n                pascal\n            }\n            CamelCase =\u003e {\n                let pascal = PascalCase.apply_to_field(field);\n                pascal[..1].to_ascii_lowercase() + \u0026pascal[1..]\n            }\n            ScreamingSnakeCase =\u003e field.to_ascii_uppercase(),\n            KebabCase =\u003e field.replace('_', \"-\"),\n            ScreamingKebabCase =\u003e ScreamingSnakeCase.apply_to_field(field).replace('_', \"-\"),\n        }\n    }\n}\n\nimpl FromStr for RenameRule {\n    type Err = ();\n\n    fn from_str(rename_all_str: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match rename_all_str {\n            \"lowercase\" =\u003e Ok(LowerCase),\n            \"UPPERCASE\" =\u003e Ok(UPPERCASE),\n            \"PascalCase\" =\u003e Ok(PascalCase),\n            \"camelCase\" =\u003e Ok(CamelCase),\n            \"snake_case\" =\u003e Ok(SnakeCase),\n            \"SCREAMING_SNAKE_CASE\" =\u003e Ok(ScreamingSnakeCase),\n            \"kebab-case\" =\u003e Ok(KebabCase),\n            \"SCREAMING-KEBAB-CASE\" =\u003e Ok(ScreamingKebabCase),\n            _ =\u003e Err(()),\n        }\n    }\n}\n\n#[test]\nfn rename_variants() {\n    for \u0026(original, lower, upper, camel, snake, screaming, kebab, screaming_kebab) in \u0026[\n        (\n            \"Outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"OUTCOME\",\n        ),\n        (\n            \"VeryTasty\",\n            \"verytasty\",\n            \"VERYTASTY\",\n            \"veryTasty\",\n            \"very_tasty\",\n            \"VERY_TASTY\",\n            \"very-tasty\",\n            \"VERY-TASTY\",\n        ),\n        (\"A\", \"a\", \"A\", \"a\", \"a\", \"A\", \"a\", \"A\"),\n        (\"Z42\", \"z42\", \"Z42\", \"z42\", \"z42\", \"Z42\", \"z42\", \"Z42\"),\n    ] {\n        assert_eq!(None.apply_to_variant(original), original);\n        assert_eq!(LowerCase.apply_to_variant(original), lower);\n        assert_eq!(UPPERCASE.apply_to_variant(original), upper);\n        assert_eq!(PascalCase.apply_to_variant(original), original);\n        assert_eq!(CamelCase.apply_to_variant(original), camel);\n        assert_eq!(SnakeCase.apply_to_variant(original), snake);\n        assert_eq!(ScreamingSnakeCase.apply_to_variant(original), screaming);\n        assert_eq!(KebabCase.apply_to_variant(original), kebab);\n        assert_eq!(\n            ScreamingKebabCase.apply_to_variant(original),\n            screaming_kebab\n        );\n    }\n}\n\n#[test]\nfn rename_fields() {\n    for \u0026(original, upper, pascal, camel, screaming, kebab, screaming_kebab) in \u0026[\n        (\n            \"outcome\", \"OUTCOME\", \"Outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"OUTCOME\",\n        ),\n        (\n            \"very_tasty\",\n            \"VERY_TASTY\",\n            \"VeryTasty\",\n            \"veryTasty\",\n            \"VERY_TASTY\",\n            \"very-tasty\",\n            \"VERY-TASTY\",\n        ),\n        (\"a\", \"A\", \"A\", \"a\", \"A\", \"a\", \"A\"),\n        (\"z42\", \"Z42\", \"Z42\", \"z42\", \"Z42\", \"z42\", \"Z42\"),\n    ] {\n        assert_eq!(None.apply_to_field(original), original);\n        assert_eq!(UPPERCASE.apply_to_field(original), upper);\n        assert_eq!(PascalCase.apply_to_field(original), pascal);\n        assert_eq!(CamelCase.apply_to_field(original), camel);\n        assert_eq!(SnakeCase.apply_to_field(original), original);\n        assert_eq!(ScreamingSnakeCase.apply_to_field(original), screaming);\n        assert_eq!(KebabCase.apply_to_field(original), kebab);\n        assert_eq!(ScreamingKebabCase.apply_to_field(original), screaming_kebab);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","check.rs"],"content":"use internals::ast::{Container, Data, Field, Style};\nuse internals::attr::{Identifier, TagType};\nuse internals::{Ctxt, Derive};\nuse syn::{Member, Type};\n\n/// Cross-cutting checks that require looking at more than a single attrs\n/// object. Simpler checks should happen when parsing and building the attrs.\npub fn check(cx: \u0026Ctxt, cont: \u0026mut Container, derive: Derive) {\n    check_getter(cx, cont);\n    check_flatten(cx, cont);\n    check_identifier(cx, cont);\n    check_variant_skip_attrs(cx, cont);\n    check_internal_tag_field_name_conflict(cx, cont);\n    check_adjacent_tag_conflict(cx, cont);\n    check_transparent(cx, cont, derive);\n    check_from_and_try_from(cx, cont);\n}\n\n/// Getters are only allowed inside structs (not enums) with the `remote`\n/// attribute.\nfn check_getter(cx: \u0026Ctxt, cont: \u0026Container) {\n    match cont.data {\n        Data::Enum(_) =\u003e {\n            if cont.data.has_getter() {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(getter = \\\"...\\\")] is not allowed in an enum\",\n                );\n            }\n        }\n        Data::Struct(_, _) =\u003e {\n            if cont.data.has_getter() \u0026\u0026 cont.attrs.remote().is_none() {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(getter = \\\"...\\\")] can only be used in structs \\\n                     that have #[serde(remote = \\\"...\\\")]\",\n                );\n            }\n        }\n    }\n}\n\n/// Flattening has some restrictions we can test.\nfn check_flatten(cx: \u0026Ctxt, cont: \u0026Container) {\n    match cont.data {\n        Data::Enum(ref variants) =\u003e {\n            for variant in variants {\n                for field in \u0026variant.fields {\n                    check_flatten_field(cx, variant.style, field);\n                }\n            }\n        }\n        Data::Struct(style, ref fields) =\u003e {\n            for field in fields {\n                check_flatten_field(cx, style, field);\n            }\n        }\n    }\n}\n\nfn check_flatten_field(cx: \u0026Ctxt, style: Style, field: \u0026Field) {\n    if !field.attrs.flatten() {\n        return;\n    }\n    match style {\n        Style::Tuple =\u003e {\n            cx.error_spanned_by(\n                field.original,\n                \"#[serde(flatten)] cannot be used on tuple structs\",\n            );\n        }\n        Style::Newtype =\u003e {\n            cx.error_spanned_by(\n                field.original,\n                \"#[serde(flatten)] cannot be used on newtype structs\",\n            );\n        }\n        _ =\u003e {}\n    }\n}\n\n/// The `other` attribute must be used at most once and it must be the last\n/// variant of an enum.\n///\n/// Inside a `variant_identifier` all variants must be unit variants. Inside a\n/// `field_identifier` all but possibly one variant must be unit variants. The\n/// last variant may be a newtype variant which is an implicit \"other\" case.\nfn check_identifier(cx: \u0026Ctxt, cont: \u0026Container) {\n    let variants = match cont.data {\n        Data::Enum(ref variants) =\u003e variants,\n        Data::Struct(_, _) =\u003e {\n            return;\n        }\n    };\n\n    for (i, variant) in variants.iter().enumerate() {\n        match (\n            variant.style,\n            cont.attrs.identifier(),\n            variant.attrs.other(),\n            cont.attrs.tag(),\n        ) {\n            // The `other` attribute may not be used in a variant_identifier.\n            (_, Identifier::Variant, true, _) =\u003e {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(other)] may not be used on a variant identifier\",\n                );\n            }\n\n            // Variant with `other` attribute cannot appear in untagged enum\n            (_, Identifier::No, true, \u0026TagType::None) =\u003e {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(other)] cannot appear on untagged enum\",\n                );\n            }\n\n            // Variant with `other` attribute must be the last one.\n            (Style::Unit, Identifier::Field, true, _) | (Style::Unit, Identifier::No, true, _) =\u003e {\n                if i \u003c variants.len() - 1 {\n                    cx.error_spanned_by(\n                        variant.original,\n                        \"#[serde(other)] must be on the last variant\",\n                    );\n                }\n            }\n\n            // Variant with `other` attribute must be a unit variant.\n            (_, Identifier::Field, true, _) | (_, Identifier::No, true, _) =\u003e {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(other)] must be on a unit variant\",\n                );\n            }\n\n            // Any sort of variant is allowed if this is not an identifier.\n            (_, Identifier::No, false, _) =\u003e {}\n\n            // Unit variant without `other` attribute is always fine.\n            (Style::Unit, _, false, _) =\u003e {}\n\n            // The last field is allowed to be a newtype catch-all.\n            (Style::Newtype, Identifier::Field, false, _) =\u003e {\n                if i \u003c variants.len() - 1 {\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\"`{}` must be the last variant\", variant.ident),\n                    );\n                }\n            }\n\n            (_, Identifier::Field, false, _) =\u003e {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(field_identifier)] may only contain unit variants\",\n                );\n            }\n\n            (_, Identifier::Variant, false, _) =\u003e {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(variant_identifier)] may only contain unit variants\",\n                );\n            }\n        }\n    }\n}\n\n/// Skip-(de)serializing attributes are not allowed on variants marked\n/// (de)serialize_with.\nfn check_variant_skip_attrs(cx: \u0026Ctxt, cont: \u0026Container) {\n    let variants = match cont.data {\n        Data::Enum(ref variants) =\u003e variants,\n        Data::Struct(_, _) =\u003e {\n            return;\n        }\n    };\n\n    for variant in variants.iter() {\n        if variant.attrs.serialize_with().is_some() {\n            if variant.attrs.skip_serializing() {\n                cx.error_spanned_by(\n                    variant.original,\n                    format!(\n                        \"variant `{}` cannot have both #[serde(serialize_with)] and \\\n                         #[serde(skip_serializing)]\",\n                        variant.ident\n                    ),\n                );\n            }\n\n            for field in \u0026variant.fields {\n                let member = member_message(\u0026field.member);\n\n                if field.attrs.skip_serializing() {\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\n                            \"variant `{}` cannot have both #[serde(serialize_with)] and \\\n                             a field {} marked with #[serde(skip_serializing)]\",\n                            variant.ident, member\n                        ),\n                    );\n                }\n\n                if field.attrs.skip_serializing_if().is_some() {\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\n                            \"variant `{}` cannot have both #[serde(serialize_with)] and \\\n                             a field {} marked with #[serde(skip_serializing_if)]\",\n                            variant.ident, member\n                        ),\n                    );\n                }\n            }\n        }\n\n        if variant.attrs.deserialize_with().is_some() {\n            if variant.attrs.skip_deserializing() {\n                cx.error_spanned_by(\n                    variant.original,\n                    format!(\n                        \"variant `{}` cannot have both #[serde(deserialize_with)] and \\\n                         #[serde(skip_deserializing)]\",\n                        variant.ident\n                    ),\n                );\n            }\n\n            for field in \u0026variant.fields {\n                if field.attrs.skip_deserializing() {\n                    let member = member_message(\u0026field.member);\n\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\n                            \"variant `{}` cannot have both #[serde(deserialize_with)] \\\n                             and a field {} marked with #[serde(skip_deserializing)]\",\n                            variant.ident, member\n                        ),\n                    );\n                }\n            }\n        }\n    }\n}\n\n/// The tag of an internally-tagged struct variant must not be\n/// the same as either one of its fields, as this would result in\n/// duplicate keys in the serialized output and/or ambiguity in\n/// the to-be-deserialized input.\nfn check_internal_tag_field_name_conflict(cx: \u0026Ctxt, cont: \u0026Container) {\n    let variants = match cont.data {\n        Data::Enum(ref variants) =\u003e variants,\n        Data::Struct(_, _) =\u003e return,\n    };\n\n    let tag = match *cont.attrs.tag() {\n        TagType::Internal { ref tag } =\u003e tag.as_str(),\n        TagType::External | TagType::Adjacent { .. } | TagType::None =\u003e return,\n    };\n\n    let diagnose_conflict = || {\n        cx.error_spanned_by(\n            cont.original,\n            format!(\"variant field name `{}` conflicts with internal tag\", tag),\n        )\n    };\n\n    for variant in variants {\n        match variant.style {\n            Style::Struct =\u003e {\n                for field in \u0026variant.fields {\n                    let check_ser = !field.attrs.skip_serializing();\n                    let check_de = !field.attrs.skip_deserializing();\n                    let name = field.attrs.name();\n                    let ser_name = name.serialize_name();\n\n                    if check_ser \u0026\u0026 ser_name == tag {\n                        diagnose_conflict();\n                        return;\n                    }\n\n                    for de_name in field.attrs.aliases() {\n                        if check_de \u0026\u0026 de_name == tag {\n                            diagnose_conflict();\n                            return;\n                        }\n                    }\n                }\n            }\n            Style::Unit | Style::Newtype | Style::Tuple =\u003e {}\n        }\n    }\n}\n\n/// In the case of adjacently-tagged enums, the type and the\n/// contents tag must differ, for the same reason.\nfn check_adjacent_tag_conflict(cx: \u0026Ctxt, cont: \u0026Container) {\n    let (type_tag, content_tag) = match *cont.attrs.tag() {\n        TagType::Adjacent {\n            ref tag,\n            ref content,\n        } =\u003e (tag, content),\n        TagType::Internal { .. } | TagType::External | TagType::None =\u003e return,\n    };\n\n    if type_tag == content_tag {\n        cx.error_spanned_by(\n            cont.original,\n            format!(\n                \"enum tags `{}` for type and content conflict with each other\",\n                type_tag\n            ),\n        );\n    }\n}\n\n/// Enums and unit structs cannot be transparent.\nfn check_transparent(cx: \u0026Ctxt, cont: \u0026mut Container, derive: Derive) {\n    if !cont.attrs.transparent() {\n        return;\n    }\n\n    if cont.attrs.type_from().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(transparent)] is not allowed with #[serde(from = \\\"...\\\")]\",\n        );\n    }\n\n    if cont.attrs.type_try_from().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(transparent)] is not allowed with #[serde(try_from = \\\"...\\\")]\",\n        );\n    }\n\n    if cont.attrs.type_into().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(transparent)] is not allowed with #[serde(into = \\\"...\\\")]\",\n        );\n    }\n\n    let fields = match cont.data {\n        Data::Enum(_) =\u003e {\n            cx.error_spanned_by(\n                cont.original,\n                \"#[serde(transparent)] is not allowed on an enum\",\n            );\n            return;\n        }\n        Data::Struct(Style::Unit, _) =\u003e {\n            cx.error_spanned_by(\n                cont.original,\n                \"#[serde(transparent)] is not allowed on a unit struct\",\n            );\n            return;\n        }\n        Data::Struct(_, ref mut fields) =\u003e fields,\n    };\n\n    let mut transparent_field = None;\n\n    for field in fields {\n        if allow_transparent(field, derive) {\n            if transparent_field.is_some() {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(transparent)] requires struct to have at most one transparent field\",\n                );\n                return;\n            }\n            transparent_field = Some(field);\n        }\n    }\n\n    match transparent_field {\n        Some(transparent_field) =\u003e transparent_field.attrs.mark_transparent(),\n        None =\u003e match derive {\n            Derive::Serialize =\u003e {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(transparent)] requires at least one field that is not skipped\",\n                );\n            }\n            Derive::Deserialize =\u003e {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(transparent)] requires at least one field that is neither skipped nor has a default\",\n                );\n            }\n        },\n    }\n}\n\nfn member_message(member: \u0026Member) -\u003e String {\n    match *member {\n        Member::Named(ref ident) =\u003e format!(\"`{}`\", ident),\n        Member::Unnamed(ref i) =\u003e format!(\"#{}\", i.index),\n    }\n}\n\nfn allow_transparent(field: \u0026Field, derive: Derive) -\u003e bool {\n    if let Type::Path(ref ty) = *field.ty {\n        if let Some(seg) = ty.path.segments.last() {\n            if seg.ident == \"PhantomData\" {\n                return false;\n            }\n        }\n    }\n\n    match derive {\n        Derive::Serialize =\u003e !field.attrs.skip_serializing(),\n        Derive::Deserialize =\u003e !field.attrs.skip_deserializing() \u0026\u0026 field.attrs.default().is_none(),\n    }\n}\n\nfn check_from_and_try_from(cx: \u0026Ctxt, cont: \u0026mut Container) {\n    if cont.attrs.type_from().is_some() \u0026\u0026 cont.attrs.type_try_from().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(from = \\\"...\\\")] and #[serde(try_from = \\\"...\\\")] conflict with each other\",\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","ctxt.rs"],"content":"use quote::ToTokens;\nuse std::cell::RefCell;\nuse std::fmt::Display;\nuse std::thread;\nuse syn;\n\n/// A type to collect errors together and format them.\n///\n/// Dropping this object will cause a panic. It must be consumed using `check`.\n///\n/// References can be shared since this type uses run-time exclusive mut checking.\n#[derive(Default)]\npub struct Ctxt {\n    // The contents will be set to `None` during checking. This is so that checking can be\n    // enforced.\n    errors: RefCell\u003cOption\u003cVec\u003csyn::Error\u003e\u003e\u003e,\n}\n\nimpl Ctxt {\n    /// Create a new context object.\n    ///\n    /// This object contains no errors, but will still trigger a panic if it is not `check`ed.\n    pub fn new() -\u003e Self {\n        Ctxt {\n            errors: RefCell::new(Some(Vec::new())),\n        }\n    }\n\n    /// Add an error to the context object with a tokenenizable object.\n    ///\n    /// The object is used for spanning in error messages.\n    pub fn error_spanned_by\u003cA: ToTokens, T: Display\u003e(\u0026self, obj: A, msg: T) {\n        self.errors\n            .borrow_mut()\n            .as_mut()\n            .unwrap()\n            // Curb monomorphization from generating too many identical methods.\n            .push(syn::Error::new_spanned(obj.into_token_stream(), msg));\n    }\n\n    /// Consume this object, producing a formatted error string if there are errors.\n    pub fn check(self) -\u003e Result\u003c(), Vec\u003csyn::Error\u003e\u003e {\n        let errors = self.errors.borrow_mut().take().unwrap();\n        match errors.len() {\n            0 =\u003e Ok(()),\n            _ =\u003e Err(errors),\n        }\n    }\n}\n\nimpl Drop for Ctxt {\n    fn drop(\u0026mut self) {\n        if !thread::panicking() \u0026\u0026 self.errors.borrow().is_some() {\n            panic!(\"forgot to check for errors\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","mod.rs"],"content":"pub mod ast;\npub mod attr;\n\nmod ctxt;\npub use self::ctxt::Ctxt;\n\nmod case;\nmod check;\nmod symbol;\n\n#[derive(Copy, Clone)]\npub enum Derive {\n    Serialize,\n    Deserialize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","symbol.rs"],"content":"use std::fmt::{self, Display};\nuse syn::{Ident, Path};\n\n#[derive(Copy, Clone)]\npub struct Symbol(\u0026'static str);\n\npub const ALIAS: Symbol = Symbol(\"alias\");\npub const BORROW: Symbol = Symbol(\"borrow\");\npub const BOUND: Symbol = Symbol(\"bound\");\npub const CONTENT: Symbol = Symbol(\"content\");\npub const CRATE: Symbol = Symbol(\"crate\");\npub const DEFAULT: Symbol = Symbol(\"default\");\npub const DENY_UNKNOWN_FIELDS: Symbol = Symbol(\"deny_unknown_fields\");\npub const DESERIALIZE: Symbol = Symbol(\"deserialize\");\npub const DESERIALIZE_WITH: Symbol = Symbol(\"deserialize_with\");\npub const FIELD_IDENTIFIER: Symbol = Symbol(\"field_identifier\");\npub const FLATTEN: Symbol = Symbol(\"flatten\");\npub const FROM: Symbol = Symbol(\"from\");\npub const GETTER: Symbol = Symbol(\"getter\");\npub const INTO: Symbol = Symbol(\"into\");\npub const OTHER: Symbol = Symbol(\"other\");\npub const REMOTE: Symbol = Symbol(\"remote\");\npub const RENAME: Symbol = Symbol(\"rename\");\npub const RENAME_ALL: Symbol = Symbol(\"rename_all\");\npub const SERDE: Symbol = Symbol(\"serde\");\npub const SERIALIZE: Symbol = Symbol(\"serialize\");\npub const SERIALIZE_WITH: Symbol = Symbol(\"serialize_with\");\npub const SKIP: Symbol = Symbol(\"skip\");\npub const SKIP_DESERIALIZING: Symbol = Symbol(\"skip_deserializing\");\npub const SKIP_SERIALIZING: Symbol = Symbol(\"skip_serializing\");\npub const SKIP_SERIALIZING_IF: Symbol = Symbol(\"skip_serializing_if\");\npub const TAG: Symbol = Symbol(\"tag\");\npub const TRANSPARENT: Symbol = Symbol(\"transparent\");\npub const TRY_FROM: Symbol = Symbol(\"try_from\");\npub const UNTAGGED: Symbol = Symbol(\"untagged\");\npub const VARIANT_IDENTIFIER: Symbol = Symbol(\"variant_identifier\");\npub const WITH: Symbol = Symbol(\"with\");\n\nimpl PartialEq\u003cSymbol\u003e for Ident {\n    fn eq(\u0026self, word: \u0026Symbol) -\u003e bool {\n        self == word.0\n    }\n}\n\nimpl\u003c'a\u003e PartialEq\u003cSymbol\u003e for \u0026'a Ident {\n    fn eq(\u0026self, word: \u0026Symbol) -\u003e bool {\n        *self == word.0\n    }\n}\n\nimpl PartialEq\u003cSymbol\u003e for Path {\n    fn eq(\u0026self, word: \u0026Symbol) -\u003e bool {\n        self.is_ident(word.0)\n    }\n}\n\nimpl\u003c'a\u003e PartialEq\u003cSymbol\u003e for \u0026'a Path {\n    fn eq(\u0026self, word: \u0026Symbol) -\u003e bool {\n        self.is_ident(word.0)\n    }\n}\n\nimpl Display for Symbol {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(self.0)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","lib.rs"],"content":"//! This crate provides Serde's two derive macros.\n//!\n//! ```edition2018\n//! # use serde_derive::{Serialize, Deserialize};\n//! #\n//! #[derive(Serialize, Deserialize)]\n//! # struct S;\n//! #\n//! # fn main() {}\n//! ```\n//!\n//! Please refer to [https://serde.rs/derive.html] for how to set this up.\n//!\n//! [https://serde.rs/derive.html]: https://serde.rs/derive.html\n\n#![doc(html_root_url = \"https://docs.rs/serde_derive/1.0.100\")]\n#![allow(unknown_lints, bare_trait_objects)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(renamed_and_removed_lints))]\n#![cfg_attr(feature = \"cargo-clippy\", deny(clippy, clippy_pedantic))]\n// Ignored clippy lints\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        cognitive_complexity,\n        enum_variant_names,\n        needless_pass_by_value,\n        redundant_field_names,\n        too_many_arguments,\n        trivially_copy_pass_by_ref,\n        used_underscore_binding,\n    )\n)]\n// Ignored clippy_pedantic lints\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        cast_possible_truncation,\n        checked_conversions,\n        doc_markdown,\n        enum_glob_use,\n        filter_map,\n        indexing_slicing,\n        items_after_statements,\n        match_same_arms,\n        module_name_repetitions,\n        similar_names,\n        single_match_else,\n        unseparated_literal_suffix,\n        use_self,\n    )\n)]\n// The `quote!` macro requires deep recursion.\n#![recursion_limit = \"512\"]\n\n#[macro_use]\nextern crate quote;\n#[macro_use]\nextern crate syn;\n\nextern crate proc_macro;\nextern crate proc_macro2;\n\nmod internals;\n\nuse proc_macro::TokenStream;\nuse syn::DeriveInput;\n\n#[macro_use]\nmod bound;\n#[macro_use]\nmod fragment;\n\nmod de;\nmod dummy;\nmod pretend;\nmod ser;\nmod try;\n\n#[proc_macro_derive(Serialize, attributes(serde))]\npub fn derive_serialize(input: TokenStream) -\u003e TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    ser::expand_derive_serialize(\u0026input)\n        .unwrap_or_else(to_compile_errors)\n        .into()\n}\n\n#[proc_macro_derive(Deserialize, attributes(serde))]\npub fn derive_deserialize(input: TokenStream) -\u003e TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    de::expand_derive_deserialize(\u0026input)\n        .unwrap_or_else(to_compile_errors)\n        .into()\n}\n\nfn to_compile_errors(errors: Vec\u003csyn::Error\u003e) -\u003e proc_macro2::TokenStream {\n    let compile_errors = errors.iter().map(syn::Error::to_compile_error);\n    quote!(#(#compile_errors)*)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","pretend.rs"],"content":"use proc_macro2::{Span, TokenStream};\nuse syn::Ident;\n\nuse internals::ast::{Container, Data, Field, Style};\n\n// Suppress dead_code warnings that would otherwise appear when using a remote\n// derive. Other than this pretend code, a struct annotated with remote derive\n// never has its fields referenced and an enum annotated with remote derive\n// never has its variants constructed.\n//\n//     warning: field is never used: `i`\n//      --\u003e src/main.rs:4:20\n//       |\n//     4 | struct StructDef { i: i32 }\n//       |                    ^^^^^^\n//\n//     warning: variant is never constructed: `V`\n//      --\u003e src/main.rs:8:16\n//       |\n//     8 | enum EnumDef { V }\n//       |                ^\n//\npub fn pretend_used(cont: \u0026Container) -\u003e TokenStream {\n    let pretend_fields = pretend_fields_used(cont);\n    let pretend_variants = pretend_variants_used(cont);\n\n    quote! {\n        #pretend_fields\n        #pretend_variants\n    }\n}\n\n// For structs with named fields, expands to:\n//\n//     match None::\u003cT\u003e {\n//         Some(T { a: ref __v0, b: ref __v1 }) =\u003e {}\n//         _ =\u003e {}\n//     }\n//\n// For enums, expands to the following but only including struct variants:\n//\n//     match None::\u003cT\u003e {\n//         Some(T::A { a: ref __v0 }) =\u003e {}\n//         Some(T::B { b: ref __v0 }) =\u003e {}\n//         _ =\u003e {}\n//     }\n//\n// The `ref` is important in case the user has written a Drop impl on their\n// type. Rust does not allow destructuring a struct or enum that has a Drop\n// impl.\nfn pretend_fields_used(cont: \u0026Container) -\u003e TokenStream {\n    let type_ident = \u0026cont.ident;\n    let (_, ty_generics, _) = cont.generics.split_for_impl();\n\n    let patterns = match cont.data {\n        Data::Enum(ref variants) =\u003e variants\n            .iter()\n            .filter_map(|variant| match variant.style {\n                Style::Struct =\u003e {\n                    let variant_ident = \u0026variant.ident;\n                    let pat = struct_pattern(\u0026variant.fields);\n                    Some(quote!(#type_ident::#variant_ident #pat))\n                }\n                _ =\u003e None,\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n        Data::Struct(Style::Struct, ref fields) =\u003e {\n            let pat = struct_pattern(fields);\n            vec![quote!(#type_ident #pat)]\n        }\n        Data::Struct(_, _) =\u003e {\n            return quote!();\n        }\n    };\n\n    quote! {\n        match _serde::export::None::\u003c#type_ident #ty_generics\u003e {\n            #(\n                _serde::export::Some(#patterns) =\u003e {}\n            )*\n            _ =\u003e {}\n        }\n    }\n}\n\n// Expands to one of these per enum variant:\n//\n//     match None {\n//         Some((__v0, __v1,)) =\u003e {\n//             let _ = E::V { a: __v0, b: __v1 };\n//         }\n//         _ =\u003e {}\n//     }\n//\nfn pretend_variants_used(cont: \u0026Container) -\u003e TokenStream {\n    let variants = match cont.data {\n        Data::Enum(ref variants) =\u003e variants,\n        Data::Struct(_, _) =\u003e {\n            return quote!();\n        }\n    };\n\n    let type_ident = \u0026cont.ident;\n    let (_, ty_generics, _) = cont.generics.split_for_impl();\n    let turbofish = ty_generics.as_turbofish();\n\n    let cases = variants.iter().map(|variant| {\n        let variant_ident = \u0026variant.ident;\n        let placeholders = \u0026(0..variant.fields.len())\n            .map(|i| Ident::new(\u0026format!(\"__v{}\", i), Span::call_site()))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let pat = match variant.style {\n            Style::Struct =\u003e {\n                let members = variant.fields.iter().map(|field| \u0026field.member);\n                quote!({ #(#members: #placeholders),* })\n            }\n            Style::Tuple | Style::Newtype =\u003e quote!(( #(#placeholders),* )),\n            Style::Unit =\u003e quote!(),\n        };\n\n        quote! {\n            match _serde::export::None {\n                _serde::export::Some((#(#placeholders,)*)) =\u003e {\n                    let _ = #type_ident::#variant_ident #turbofish #pat;\n                }\n                _ =\u003e {}\n            }\n        }\n    });\n\n    quote!(#(#cases)*)\n}\n\nfn struct_pattern(fields: \u0026[Field]) -\u003e TokenStream {\n    let members = fields.iter().map(|field| \u0026field.member);\n    let placeholders =\n        (0..fields.len()).map(|i| Ident::new(\u0026format!(\"__v{}\", i), Span::call_site()));\n    quote!({ #(#members: ref #placeholders),* })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","ser.rs"],"content":"use proc_macro2::{Span, TokenStream};\nuse syn::spanned::Spanned;\nuse syn::{self, Ident, Index, Member};\n\nuse bound;\nuse dummy;\nuse fragment::{Fragment, Match, Stmts};\nuse internals::ast::{Container, Data, Field, Style, Variant};\nuse internals::{attr, Ctxt, Derive};\nuse pretend;\n\npub fn expand_derive_serialize(input: \u0026syn::DeriveInput) -\u003e Result\u003cTokenStream, Vec\u003csyn::Error\u003e\u003e {\n    let ctxt = Ctxt::new();\n    let cont = match Container::from_ast(\u0026ctxt, input, Derive::Serialize) {\n        Some(cont) =\u003e cont,\n        None =\u003e return Err(ctxt.check().unwrap_err()),\n    };\n    precondition(\u0026ctxt, \u0026cont);\n    ctxt.check()?;\n\n    let ident = \u0026cont.ident;\n    let params = Parameters::new(\u0026cont);\n    let (impl_generics, ty_generics, where_clause) = params.generics.split_for_impl();\n    let body = Stmts(serialize_body(\u0026cont, \u0026params));\n    let serde = cont.attrs.serde_path();\n\n    let impl_block = if let Some(remote) = cont.attrs.remote() {\n        let vis = \u0026input.vis;\n        let used = pretend::pretend_used(\u0026cont);\n        quote! {\n            impl #impl_generics #ident #ty_generics #where_clause {\n                #vis fn serialize\u003c__S\u003e(__self: \u0026#remote #ty_generics, __serializer: __S) -\u003e #serde::export::Result\u003c__S::Ok, __S::Error\u003e\n                where\n                    __S: #serde::Serializer,\n                {\n                    #used\n                    #body\n                }\n            }\n        }\n    } else {\n        quote! {\n            #[automatically_derived]\n            impl #impl_generics #serde::Serialize for #ident #ty_generics #where_clause {\n                fn serialize\u003c__S\u003e(\u0026self, __serializer: __S) -\u003e #serde::export::Result\u003c__S::Ok, __S::Error\u003e\n                where\n                    __S: #serde::Serializer,\n                {\n                    #body\n                }\n            }\n        }\n    };\n\n    Ok(dummy::wrap_in_const(\n        cont.attrs.custom_serde_path(),\n        \"SERIALIZE\",\n        ident,\n        impl_block,\n    ))\n}\n\nfn precondition(cx: \u0026Ctxt, cont: \u0026Container) {\n    match cont.attrs.identifier() {\n        attr::Identifier::No =\u003e {}\n        attr::Identifier::Field =\u003e {\n            cx.error_spanned_by(cont.original, \"field identifiers cannot be serialized\");\n        }\n        attr::Identifier::Variant =\u003e {\n            cx.error_spanned_by(cont.original, \"variant identifiers cannot be serialized\");\n        }\n    }\n}\n\nstruct Parameters {\n    /// Variable holding the value being serialized. Either `self` for local\n    /// types or `__self` for remote types.\n    self_var: Ident,\n\n    /// Path to the type the impl is for. Either a single `Ident` for local\n    /// types or `some::remote::Ident` for remote types. Does not include\n    /// generic parameters.\n    this: syn::Path,\n\n    /// Generics including any explicit and inferred bounds for the impl.\n    generics: syn::Generics,\n\n    /// Type has a `serde(remote = \"...\")` attribute.\n    is_remote: bool,\n}\n\nimpl Parameters {\n    fn new(cont: \u0026Container) -\u003e Self {\n        let is_remote = cont.attrs.remote().is_some();\n        let self_var = if is_remote {\n            Ident::new(\"__self\", Span::call_site())\n        } else {\n            Ident::new(\"self\", Span::call_site())\n        };\n\n        let this = match cont.attrs.remote() {\n            Some(remote) =\u003e remote.clone(),\n            None =\u003e cont.ident.clone().into(),\n        };\n\n        let generics = build_generics(cont);\n\n        Parameters {\n            self_var: self_var,\n            this: this,\n            generics: generics,\n            is_remote: is_remote,\n        }\n    }\n\n    /// Type name to use in error messages and `\u0026'static str` arguments to\n    /// various Serializer methods.\n    fn type_name(\u0026self) -\u003e String {\n        self.this.segments.last().unwrap().ident.to_string()\n    }\n}\n\n// All the generics in the input, plus a bound `T: Serialize` for each generic\n// field type that will be serialized by us.\nfn build_generics(cont: \u0026Container) -\u003e syn::Generics {\n    let generics = bound::without_defaults(cont.generics);\n\n    let generics =\n        bound::with_where_predicates_from_fields(cont, \u0026generics, attr::Field::ser_bound);\n\n    let generics =\n        bound::with_where_predicates_from_variants(cont, \u0026generics, attr::Variant::ser_bound);\n\n    match cont.attrs.ser_bound() {\n        Some(predicates) =\u003e bound::with_where_predicates(\u0026generics, predicates),\n        None =\u003e bound::with_bound(\n            cont,\n            \u0026generics,\n            needs_serialize_bound,\n            \u0026parse_quote!(_serde::Serialize),\n        ),\n    }\n}\n\n// Fields with a `skip_serializing` or `serialize_with` attribute, or which\n// belong to a variant with a 'skip_serializing` or `serialize_with` attribute,\n// are not serialized by us so we do not generate a bound. Fields with a `bound`\n// attribute specify their own bound so we do not generate one. All other fields\n// may need a `T: Serialize` bound where T is the type of the field.\nfn needs_serialize_bound(field: \u0026attr::Field, variant: Option\u003c\u0026attr::Variant\u003e) -\u003e bool {\n    !field.skip_serializing()\n        \u0026\u0026 field.serialize_with().is_none()\n        \u0026\u0026 field.ser_bound().is_none()\n        \u0026\u0026 variant.map_or(true, |variant| {\n            !variant.skip_serializing()\n                \u0026\u0026 variant.serialize_with().is_none()\n                \u0026\u0026 variant.ser_bound().is_none()\n        })\n}\n\nfn serialize_body(cont: \u0026Container, params: \u0026Parameters) -\u003e Fragment {\n    if cont.attrs.transparent() {\n        serialize_transparent(cont, params)\n    } else if let Some(type_into) = cont.attrs.type_into() {\n        serialize_into(params, type_into)\n    } else {\n        match cont.data {\n            Data::Enum(ref variants) =\u003e serialize_enum(params, variants, \u0026cont.attrs),\n            Data::Struct(Style::Struct, ref fields) =\u003e {\n                serialize_struct(params, fields, \u0026cont.attrs)\n            }\n            Data::Struct(Style::Tuple, ref fields) =\u003e {\n                serialize_tuple_struct(params, fields, \u0026cont.attrs)\n            }\n            Data::Struct(Style::Newtype, ref fields) =\u003e {\n                serialize_newtype_struct(params, \u0026fields[0], \u0026cont.attrs)\n            }\n            Data::Struct(Style::Unit, _) =\u003e serialize_unit_struct(\u0026cont.attrs),\n        }\n    }\n}\n\nfn serialize_transparent(cont: \u0026Container, params: \u0026Parameters) -\u003e Fragment {\n    let fields = match cont.data {\n        Data::Struct(_, ref fields) =\u003e fields,\n        Data::Enum(_) =\u003e unreachable!(),\n    };\n\n    let self_var = \u0026params.self_var;\n    let transparent_field = fields.iter().find(|f| f.attrs.transparent()).unwrap();\n    let member = \u0026transparent_field.member;\n\n    let path = match transparent_field.attrs.serialize_with() {\n        Some(path) =\u003e quote!(#path),\n        None =\u003e {\n            let span = transparent_field.original.span();\n            quote_spanned!(span=\u003e _serde::Serialize::serialize)\n        }\n    };\n\n    quote_block! {\n        #path(\u0026#self_var.#member, __serializer)\n    }\n}\n\nfn serialize_into(params: \u0026Parameters, type_into: \u0026syn::Type) -\u003e Fragment {\n    let self_var = \u0026params.self_var;\n    quote_block! {\n        _serde::Serialize::serialize(\n            \u0026_serde::export::Into::\u003c#type_into\u003e::into(_serde::export::Clone::clone(#self_var)),\n            __serializer)\n    }\n}\n\nfn serialize_unit_struct(cattrs: \u0026attr::Container) -\u003e Fragment {\n    let type_name = cattrs.name().serialize_name();\n\n    quote_expr! {\n        _serde::Serializer::serialize_unit_struct(__serializer, #type_name)\n    }\n}\n\nfn serialize_newtype_struct(\n    params: \u0026Parameters,\n    field: \u0026Field,\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let type_name = cattrs.name().serialize_name();\n\n    let mut field_expr = get_member(\n        params,\n        field,\n        \u0026Member::Unnamed(Index {\n            index: 0,\n            span: Span::call_site(),\n        }),\n    );\n    if let Some(path) = field.attrs.serialize_with() {\n        field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n    }\n\n    let span = field.original.span();\n    let func = quote_spanned!(span=\u003e _serde::Serializer::serialize_newtype_struct);\n    quote_expr! {\n        #func(__serializer, #type_name, #field_expr)\n    }\n}\n\nfn serialize_tuple_struct(\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let serialize_stmts =\n        serialize_tuple_struct_visitor(fields, params, false, \u0026TupleTrait::SerializeTupleStruct);\n\n    let type_name = cattrs.name().serialize_name();\n\n    let mut serialized_fields = fields\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, ref field)| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some());\n\n    let len = serialized_fields\n        .map(|(i, field)| match field.attrs.skip_serializing_if() {\n            None =\u003e quote!(1),\n            Some(path) =\u003e {\n                let index = syn::Index {\n                    index: i as u32,\n                    span: Span::call_site(),\n                };\n                let field_expr = get_member(params, field, \u0026Member::Unnamed(index));\n                quote!(if #path(#field_expr) { 0 } else { 1 })\n            }\n        })\n        .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n\n    quote_block! {\n        let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple_struct(__serializer, #type_name, #len));\n        #(#serialize_stmts)*\n        _serde::ser::SerializeTupleStruct::end(__serde_state)\n    }\n}\n\nfn serialize_struct(params: \u0026Parameters, fields: \u0026[Field], cattrs: \u0026attr::Container) -\u003e Fragment {\n    assert!(fields.len() as u64 \u003c= u64::from(u32::max_value()));\n\n    if cattrs.has_flatten() {\n        serialize_struct_as_map(params, fields, cattrs)\n    } else {\n        serialize_struct_as_struct(params, fields, cattrs)\n    }\n}\n\nfn serialize_struct_tag_field(cattrs: \u0026attr::Container, struct_trait: \u0026StructTrait) -\u003e TokenStream {\n    match *cattrs.tag() {\n        attr::TagType::Internal { ref tag } =\u003e {\n            let type_name = cattrs.name().serialize_name();\n            let func = struct_trait.serialize_field(Span::call_site());\n            quote! {\n                try!(#func(\u0026mut __serde_state, #tag, #type_name));\n            }\n        }\n        _ =\u003e quote! {},\n    }\n}\n\nfn serialize_struct_as_struct(\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let serialize_fields =\n        serialize_struct_visitor(fields, params, false, \u0026StructTrait::SerializeStruct);\n\n    let type_name = cattrs.name().serialize_name();\n\n    let tag_field = serialize_struct_tag_field(cattrs, \u0026StructTrait::SerializeStruct);\n    let tag_field_exists = !tag_field.is_empty();\n\n    let mut serialized_fields = fields\n        .iter()\n        .filter(|\u0026field| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some() || tag_field_exists);\n\n    let len = serialized_fields\n        .map(|field| match field.attrs.skip_serializing_if() {\n            None =\u003e quote!(1),\n            Some(path) =\u003e {\n                let field_expr = get_member(params, field, \u0026field.member);\n                quote!(if #path(#field_expr) { 0 } else { 1 })\n            }\n        })\n        .fold(\n            quote!(#tag_field_exists as usize),\n            |sum, expr| quote!(#sum + #expr),\n        );\n\n    quote_block! {\n        let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct(__serializer, #type_name, #len));\n        #tag_field\n        #(#serialize_fields)*\n        _serde::ser::SerializeStruct::end(__serde_state)\n    }\n}\n\nfn serialize_struct_as_map(\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let serialize_fields =\n        serialize_struct_visitor(fields, params, false, \u0026StructTrait::SerializeMap);\n\n    let tag_field = serialize_struct_tag_field(cattrs, \u0026StructTrait::SerializeMap);\n    let tag_field_exists = !tag_field.is_empty();\n\n    let mut serialized_fields = fields\n        .iter()\n        .filter(|\u0026field| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some() || tag_field_exists);\n\n    let len = if cattrs.has_flatten() {\n        quote!(_serde::export::None)\n    } else {\n        let len = serialized_fields\n            .map(|field| match field.attrs.skip_serializing_if() {\n                None =\u003e quote!(1),\n                Some(path) =\u003e {\n                    let field_expr = get_member(params, field, \u0026field.member);\n                    quote!(if #path(#field_expr) { 0 } else { 1 })\n                }\n            })\n            .fold(\n                quote!(#tag_field_exists as usize),\n                |sum, expr| quote!(#sum + #expr),\n            );\n        quote!(_serde::export::Some(#len))\n    };\n\n    quote_block! {\n        let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(__serializer, #len));\n        #tag_field\n        #(#serialize_fields)*\n        _serde::ser::SerializeMap::end(__serde_state)\n    }\n}\n\nfn serialize_enum(params: \u0026Parameters, variants: \u0026[Variant], cattrs: \u0026attr::Container) -\u003e Fragment {\n    assert!(variants.len() as u64 \u003c= u64::from(u32::max_value()));\n\n    let self_var = \u0026params.self_var;\n\n    let arms: Vec\u003c_\u003e = variants\n        .iter()\n        .enumerate()\n        .map(|(variant_index, variant)| {\n            serialize_variant(params, variant, variant_index as u32, cattrs)\n        })\n        .collect();\n\n    quote_expr! {\n        match *#self_var {\n            #(#arms)*\n        }\n    }\n}\n\nfn serialize_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    variant_index: u32,\n    cattrs: \u0026attr::Container,\n) -\u003e TokenStream {\n    let this = \u0026params.this;\n    let variant_ident = \u0026variant.ident;\n\n    if variant.attrs.skip_serializing() {\n        let skipped_msg = format!(\n            \"the enum variant {}::{} cannot be serialized\",\n            params.type_name(),\n            variant_ident\n        );\n        let skipped_err = quote! {\n            _serde::export::Err(_serde::ser::Error::custom(#skipped_msg))\n        };\n        let fields_pat = match variant.style {\n            Style::Unit =\u003e quote!(),\n            Style::Newtype | Style::Tuple =\u003e quote!((..)),\n            Style::Struct =\u003e quote!({ .. }),\n        };\n        quote! {\n            #this::#variant_ident #fields_pat =\u003e #skipped_err,\n        }\n    } else {\n        // variant wasn't skipped\n        let case = match variant.style {\n            Style::Unit =\u003e {\n                quote! {\n                    #this::#variant_ident\n                }\n            }\n            Style::Newtype =\u003e {\n                quote! {\n                    #this::#variant_ident(ref __field0)\n                }\n            }\n            Style::Tuple =\u003e {\n                let field_names = (0..variant.fields.len())\n                    .map(|i| Ident::new(\u0026format!(\"__field{}\", i), Span::call_site()));\n                quote! {\n                    #this::#variant_ident(#(ref #field_names),*)\n                }\n            }\n            Style::Struct =\u003e {\n                let members = variant.fields.iter().map(|f| \u0026f.member);\n                quote! {\n                    #this::#variant_ident { #(ref #members),* }\n                }\n            }\n        };\n\n        let body = Match(match *cattrs.tag() {\n            attr::TagType::External =\u003e {\n                serialize_externally_tagged_variant(params, variant, variant_index, cattrs)\n            }\n            attr::TagType::Internal { ref tag } =\u003e {\n                serialize_internally_tagged_variant(params, variant, cattrs, tag)\n            }\n            attr::TagType::Adjacent {\n                ref tag,\n                ref content,\n            } =\u003e serialize_adjacently_tagged_variant(params, variant, cattrs, tag, content),\n            attr::TagType::None =\u003e serialize_untagged_variant(params, variant, cattrs),\n        });\n\n        quote! {\n            #case =\u003e #body\n        }\n    }\n}\n\nfn serialize_externally_tagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    variant_index: u32,\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let type_name = cattrs.name().serialize_name();\n    let variant_name = variant.attrs.name().serialize_name();\n\n    if let Some(path) = variant.attrs.serialize_with() {\n        let ser = wrap_serialize_variant_with(params, path, variant);\n        return quote_expr! {\n            _serde::Serializer::serialize_newtype_variant(\n                __serializer,\n                #type_name,\n                #variant_index,\n                #variant_name,\n                #ser,\n            )\n        };\n    }\n\n    match variant.style {\n        Style::Unit =\u003e {\n            quote_expr! {\n                _serde::Serializer::serialize_unit_variant(\n                    __serializer,\n                    #type_name,\n                    #variant_index,\n                    #variant_name,\n                )\n            }\n        }\n        Style::Newtype =\u003e {\n            let field = \u0026variant.fields[0];\n            let mut field_expr = quote!(__field0);\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n            }\n\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e _serde::Serializer::serialize_newtype_variant);\n            quote_expr! {\n                #func(\n                    __serializer,\n                    #type_name,\n                    #variant_index,\n                    #variant_name,\n                    #field_expr,\n                )\n            }\n        }\n        Style::Tuple =\u003e serialize_tuple_variant(\n            TupleVariant::ExternallyTagged {\n                type_name: type_name,\n                variant_index: variant_index,\n                variant_name: variant_name,\n            },\n            params,\n            \u0026variant.fields,\n        ),\n        Style::Struct =\u003e serialize_struct_variant(\n            StructVariant::ExternallyTagged {\n                variant_index: variant_index,\n                variant_name: variant_name,\n            },\n            params,\n            \u0026variant.fields,\n            \u0026type_name,\n        ),\n    }\n}\n\nfn serialize_internally_tagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    cattrs: \u0026attr::Container,\n    tag: \u0026str,\n) -\u003e Fragment {\n    let type_name = cattrs.name().serialize_name();\n    let variant_name = variant.attrs.name().serialize_name();\n\n    let enum_ident_str = params.type_name();\n    let variant_ident_str = variant.ident.to_string();\n\n    if let Some(path) = variant.attrs.serialize_with() {\n        let ser = wrap_serialize_variant_with(params, path, variant);\n        return quote_expr! {\n            _serde::private::ser::serialize_tagged_newtype(\n                __serializer,\n                #enum_ident_str,\n                #variant_ident_str,\n                #tag,\n                #variant_name,\n                #ser,\n            )\n        };\n    }\n\n    match variant.style {\n        Style::Unit =\u003e {\n            quote_block! {\n                let mut __struct = try!(_serde::Serializer::serialize_struct(\n                    __serializer, #type_name, 1));\n                try!(_serde::ser::SerializeStruct::serialize_field(\n                    \u0026mut __struct, #tag, #variant_name));\n                _serde::ser::SerializeStruct::end(__struct)\n            }\n        }\n        Style::Newtype =\u003e {\n            let field = \u0026variant.fields[0];\n            let mut field_expr = quote!(__field0);\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n            }\n\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e _serde::private::ser::serialize_tagged_newtype);\n            quote_expr! {\n                #func(\n                    __serializer,\n                    #enum_ident_str,\n                    #variant_ident_str,\n                    #tag,\n                    #variant_name,\n                    #field_expr,\n                )\n            }\n        }\n        Style::Struct =\u003e serialize_struct_variant(\n            StructVariant::InternallyTagged {\n                tag: tag,\n                variant_name: variant_name,\n            },\n            params,\n            \u0026variant.fields,\n            \u0026type_name,\n        ),\n        Style::Tuple =\u003e unreachable!(\"checked in serde_derive_internals\"),\n    }\n}\n\nfn serialize_adjacently_tagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    cattrs: \u0026attr::Container,\n    tag: \u0026str,\n    content: \u0026str,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    let type_name = cattrs.name().serialize_name();\n    let variant_name = variant.attrs.name().serialize_name();\n\n    let inner = Stmts(if let Some(path) = variant.attrs.serialize_with() {\n        let ser = wrap_serialize_variant_with(params, path, variant);\n        quote_expr! {\n            _serde::Serialize::serialize(#ser, __serializer)\n        }\n    } else {\n        match variant.style {\n            Style::Unit =\u003e {\n                return quote_block! {\n                    let mut __struct = try!(_serde::Serializer::serialize_struct(\n                        __serializer, #type_name, 1));\n                    try!(_serde::ser::SerializeStruct::serialize_field(\n                        \u0026mut __struct, #tag, #variant_name));\n                    _serde::ser::SerializeStruct::end(__struct)\n                };\n            }\n            Style::Newtype =\u003e {\n                let field = \u0026variant.fields[0];\n                let mut field_expr = quote!(__field0);\n                if let Some(path) = field.attrs.serialize_with() {\n                    field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n                }\n\n                let span = field.original.span();\n                let func = quote_spanned!(span=\u003e _serde::ser::SerializeStruct::serialize_field);\n                return quote_block! {\n                    let mut __struct = try!(_serde::Serializer::serialize_struct(\n                        __serializer, #type_name, 2));\n                    try!(_serde::ser::SerializeStruct::serialize_field(\n                        \u0026mut __struct, #tag, #variant_name));\n                    try!(#func(\n                        \u0026mut __struct, #content, #field_expr));\n                    _serde::ser::SerializeStruct::end(__struct)\n                };\n            }\n            Style::Tuple =\u003e {\n                serialize_tuple_variant(TupleVariant::Untagged, params, \u0026variant.fields)\n            }\n            Style::Struct =\u003e serialize_struct_variant(\n                StructVariant::Untagged,\n                params,\n                \u0026variant.fields,\n                \u0026variant_name,\n            ),\n        }\n    });\n\n    let fields_ty = variant.fields.iter().map(|f| \u0026f.ty);\n    let fields_ident: \u0026Vec\u003c_\u003e = \u0026match variant.style {\n        Style::Unit =\u003e {\n            if variant.attrs.serialize_with().is_some() {\n                vec![]\n            } else {\n                unreachable!()\n            }\n        }\n        Style::Newtype =\u003e vec![Member::Named(Ident::new(\"__field0\", Span::call_site()))],\n        Style::Tuple =\u003e (0..variant.fields.len())\n            .map(|i| Member::Named(Ident::new(\u0026format!(\"__field{}\", i), Span::call_site())))\n            .collect(),\n        Style::Struct =\u003e variant.fields.iter().map(|f| f.member.clone()).collect(),\n    };\n\n    let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n\n    let wrapper_generics = if fields_ident.is_empty() {\n        params.generics.clone()\n    } else {\n        bound::with_lifetime_bound(\u0026params.generics, \"'__a\")\n    };\n    let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n\n    quote_block! {\n        struct __AdjacentlyTagged #wrapper_generics #where_clause {\n            data: (#(\u0026'__a #fields_ty,)*),\n            phantom: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n        }\n\n        impl #wrapper_impl_generics _serde::Serialize for __AdjacentlyTagged #wrapper_ty_generics #where_clause {\n            fn serialize\u003c__S\u003e(\u0026self, __serializer: __S) -\u003e _serde::export::Result\u003c__S::Ok, __S::Error\u003e\n            where\n                __S: _serde::Serializer,\n            {\n                let (#(#fields_ident,)*) = self.data;\n                #inner\n            }\n        }\n\n        let mut __struct = try!(_serde::Serializer::serialize_struct(\n            __serializer, #type_name, 2));\n        try!(_serde::ser::SerializeStruct::serialize_field(\n            \u0026mut __struct, #tag, #variant_name));\n        try!(_serde::ser::SerializeStruct::serialize_field(\n            \u0026mut __struct, #content, \u0026__AdjacentlyTagged {\n                data: (#(#fields_ident,)*),\n                phantom: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n            }));\n        _serde::ser::SerializeStruct::end(__struct)\n    }\n}\n\nfn serialize_untagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    if let Some(path) = variant.attrs.serialize_with() {\n        let ser = wrap_serialize_variant_with(params, path, variant);\n        return quote_expr! {\n            _serde::Serialize::serialize(#ser, __serializer)\n        };\n    }\n\n    match variant.style {\n        Style::Unit =\u003e {\n            quote_expr! {\n                _serde::Serializer::serialize_unit(__serializer)\n            }\n        }\n        Style::Newtype =\u003e {\n            let field = \u0026variant.fields[0];\n            let mut field_expr = quote!(__field0);\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n            }\n\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e _serde::Serialize::serialize);\n            quote_expr! {\n                #func(#field_expr, __serializer)\n            }\n        }\n        Style::Tuple =\u003e serialize_tuple_variant(TupleVariant::Untagged, params, \u0026variant.fields),\n        Style::Struct =\u003e {\n            let type_name = cattrs.name().serialize_name();\n            serialize_struct_variant(StructVariant::Untagged, params, \u0026variant.fields, \u0026type_name)\n        }\n    }\n}\n\nenum TupleVariant {\n    ExternallyTagged {\n        type_name: String,\n        variant_index: u32,\n        variant_name: String,\n    },\n    Untagged,\n}\n\nfn serialize_tuple_variant(\n    context: TupleVariant,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n) -\u003e Fragment {\n    let tuple_trait = match context {\n        TupleVariant::ExternallyTagged { .. } =\u003e TupleTrait::SerializeTupleVariant,\n        TupleVariant::Untagged =\u003e TupleTrait::SerializeTuple,\n    };\n\n    let serialize_stmts = serialize_tuple_struct_visitor(fields, params, true, \u0026tuple_trait);\n\n    let mut serialized_fields = fields\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, ref field)| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some());\n\n    let len = serialized_fields\n        .map(|(i, field)| match field.attrs.skip_serializing_if() {\n            None =\u003e quote!(1),\n            Some(path) =\u003e {\n                let field_expr = Ident::new(\u0026format!(\"__field{}\", i), Span::call_site());\n                quote!(if #path(#field_expr) { 0 } else { 1 })\n            }\n        })\n        .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n\n    match context {\n        TupleVariant::ExternallyTagged {\n            type_name,\n            variant_index,\n            variant_name,\n        } =\u003e {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple_variant(\n                    __serializer,\n                    #type_name,\n                    #variant_index,\n                    #variant_name,\n                    #len));\n                #(#serialize_stmts)*\n                _serde::ser::SerializeTupleVariant::end(__serde_state)\n            }\n        }\n        TupleVariant::Untagged =\u003e {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple(\n                    __serializer,\n                    #len));\n                #(#serialize_stmts)*\n                _serde::ser::SerializeTuple::end(__serde_state)\n            }\n        }\n    }\n}\n\nenum StructVariant\u003c'a\u003e {\n    ExternallyTagged {\n        variant_index: u32,\n        variant_name: String,\n    },\n    InternallyTagged {\n        tag: \u0026'a str,\n        variant_name: String,\n    },\n    Untagged,\n}\n\nfn serialize_struct_variant\u003c'a\u003e(\n    context: StructVariant\u003c'a\u003e,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    name: \u0026str,\n) -\u003e Fragment {\n    if fields.iter().any(|field| field.attrs.flatten()) {\n        return serialize_struct_variant_with_flatten(context, params, fields, name);\n    }\n\n    let struct_trait = match context {\n        StructVariant::ExternallyTagged { .. } =\u003e (StructTrait::SerializeStructVariant),\n        StructVariant::InternallyTagged { .. } | StructVariant::Untagged =\u003e {\n            (StructTrait::SerializeStruct)\n        }\n    };\n\n    let serialize_fields = serialize_struct_visitor(fields, params, true, \u0026struct_trait);\n\n    let mut serialized_fields = fields\n        .iter()\n        .filter(|\u0026field| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some());\n\n    let len = serialized_fields\n        .map(|field| {\n            let member = \u0026field.member;\n\n            match field.attrs.skip_serializing_if() {\n                Some(path) =\u003e quote!(if #path(#member) { 0 } else { 1 }),\n                None =\u003e quote!(1),\n            }\n        })\n        .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n\n    match context {\n        StructVariant::ExternallyTagged {\n            variant_index,\n            variant_name,\n        } =\u003e {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct_variant(\n                    __serializer,\n                    #name,\n                    #variant_index,\n                    #variant_name,\n                    #len,\n                ));\n                #(#serialize_fields)*\n                _serde::ser::SerializeStructVariant::end(__serde_state)\n            }\n        }\n        StructVariant::InternallyTagged { tag, variant_name } =\u003e {\n            quote_block! {\n                let mut __serde_state = try!(_serde::Serializer::serialize_struct(\n                    __serializer,\n                    #name,\n                    #len + 1,\n                ));\n                try!(_serde::ser::SerializeStruct::serialize_field(\n                    \u0026mut __serde_state,\n                    #tag,\n                    #variant_name,\n                ));\n                #(#serialize_fields)*\n                _serde::ser::SerializeStruct::end(__serde_state)\n            }\n        }\n        StructVariant::Untagged =\u003e {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct(\n                    __serializer,\n                    #name,\n                    #len,\n                ));\n                #(#serialize_fields)*\n                _serde::ser::SerializeStruct::end(__serde_state)\n            }\n        }\n    }\n}\n\nfn serialize_struct_variant_with_flatten\u003c'a\u003e(\n    context: StructVariant\u003c'a\u003e,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    name: \u0026str,\n) -\u003e Fragment {\n    let struct_trait = StructTrait::SerializeMap;\n    let serialize_fields = serialize_struct_visitor(fields, params, true, \u0026struct_trait);\n\n    let mut serialized_fields = fields\n        .iter()\n        .filter(|\u0026field| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some());\n\n    match context {\n        StructVariant::ExternallyTagged {\n            variant_index,\n            variant_name,\n        } =\u003e {\n            let this = \u0026params.this;\n            let fields_ty = fields.iter().map(|f| \u0026f.ty);\n            let members = \u0026fields.iter().map(|f| \u0026f.member).collect::\u003cVec\u003c_\u003e\u003e();\n\n            let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n            let wrapper_generics = bound::with_lifetime_bound(\u0026params.generics, \"'__a\");\n            let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n\n            quote_block! {\n                struct __EnumFlatten #wrapper_generics #where_clause {\n                    data: (#(\u0026'__a #fields_ty,)*),\n                    phantom: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n                }\n\n                impl #wrapper_impl_generics _serde::Serialize for __EnumFlatten #wrapper_ty_generics #where_clause {\n                    fn serialize\u003c__S\u003e(\u0026self, __serializer: __S) -\u003e _serde::export::Result\u003c__S::Ok, __S::Error\u003e\n                    where\n                        __S: _serde::Serializer,\n                    {\n                        let (#(#members,)*) = self.data;\n                        let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(\n                            __serializer,\n                            _serde::export::None));\n                        #(#serialize_fields)*\n                        _serde::ser::SerializeMap::end(__serde_state)\n                    }\n                }\n\n                _serde::Serializer::serialize_newtype_variant(\n                    __serializer,\n                    #name,\n                    #variant_index,\n                    #variant_name,\n                    \u0026__EnumFlatten {\n                        data: (#(#members,)*),\n                        phantom: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n                    })\n            }\n        }\n        StructVariant::InternallyTagged { tag, variant_name } =\u003e {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(\n                    __serializer,\n                    _serde::export::None));\n                try!(_serde::ser::SerializeMap::serialize_entry(\n                    \u0026mut __serde_state,\n                    #tag,\n                    #variant_name,\n                ));\n                #(#serialize_fields)*\n                _serde::ser::SerializeMap::end(__serde_state)\n            }\n        }\n        StructVariant::Untagged =\u003e {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(\n                    __serializer,\n                    _serde::export::None));\n                #(#serialize_fields)*\n                _serde::ser::SerializeMap::end(__serde_state)\n            }\n        }\n    }\n}\n\nfn serialize_tuple_struct_visitor(\n    fields: \u0026[Field],\n    params: \u0026Parameters,\n    is_enum: bool,\n    tuple_trait: \u0026TupleTrait,\n) -\u003e Vec\u003cTokenStream\u003e {\n    fields\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, ref field)| !field.attrs.skip_serializing())\n        .map(|(i, field)| {\n            let mut field_expr = if is_enum {\n                let id = Ident::new(\u0026format!(\"__field{}\", i), Span::call_site());\n                quote!(#id)\n            } else {\n                get_member(\n                    params,\n                    field,\n                    \u0026Member::Unnamed(Index {\n                        index: i as u32,\n                        span: Span::call_site(),\n                    }),\n                )\n            };\n\n            let skip = field\n                .attrs\n                .skip_serializing_if()\n                .map(|path| quote!(#path(#field_expr)));\n\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n            }\n\n            let span = field.original.span();\n            let func = tuple_trait.serialize_element(span);\n            let ser = quote! {\n                try!(#func(\u0026mut __serde_state, #field_expr));\n            };\n\n            match skip {\n                None =\u003e ser,\n                Some(skip) =\u003e quote!(if !#skip { #ser }),\n            }\n        })\n        .collect()\n}\n\nfn serialize_struct_visitor(\n    fields: \u0026[Field],\n    params: \u0026Parameters,\n    is_enum: bool,\n    struct_trait: \u0026StructTrait,\n) -\u003e Vec\u003cTokenStream\u003e {\n    fields\n        .iter()\n        .filter(|\u0026field| !field.attrs.skip_serializing())\n        .map(|field| {\n            let member = \u0026field.member;\n\n            let mut field_expr = if is_enum {\n                quote!(#member)\n            } else {\n                get_member(params, field, \u0026member)\n            };\n\n            let key_expr = field.attrs.name().serialize_name();\n\n            let skip = field\n                .attrs\n                .skip_serializing_if()\n                .map(|path| quote!(#path(#field_expr)));\n\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n            }\n\n            let span = field.original.span();\n            let ser = if field.attrs.flatten() {\n                let func = quote_spanned!(span=\u003e _serde::Serialize::serialize);\n                quote! {\n                    try!(#func(\u0026#field_expr, _serde::private::ser::FlatMapSerializer(\u0026mut __serde_state)));\n                }\n            } else {\n                let func = struct_trait.serialize_field(span);\n                quote! {\n                    try!(#func(\u0026mut __serde_state, #key_expr, #field_expr));\n                }\n            };\n\n            match skip {\n                None =\u003e ser,\n                Some(skip) =\u003e {\n                    if let Some(skip_func) = struct_trait.skip_field(span) {\n                        quote! {\n                            if !#skip {\n                                #ser\n                            } else {\n                                try!(#skip_func(\u0026mut __serde_state, #key_expr));\n                            }\n                        }\n                    } else {\n                        quote! {\n                            if !#skip {\n                                #ser\n                            }\n                        }\n                    }\n                }\n            }\n        })\n        .collect()\n}\n\nfn wrap_serialize_field_with(\n    params: \u0026Parameters,\n    field_ty: \u0026syn::Type,\n    serialize_with: \u0026syn::ExprPath,\n    field_expr: \u0026TokenStream,\n) -\u003e TokenStream {\n    wrap_serialize_with(params, serialize_with, \u0026[field_ty], \u0026[quote!(#field_expr)])\n}\n\nfn wrap_serialize_variant_with(\n    params: \u0026Parameters,\n    serialize_with: \u0026syn::ExprPath,\n    variant: \u0026Variant,\n) -\u003e TokenStream {\n    let field_tys: Vec\u003c_\u003e = variant.fields.iter().map(|field| field.ty).collect();\n    let field_exprs: Vec\u003c_\u003e = variant\n        .fields\n        .iter()\n        .map(|field| {\n            let id = match field.member {\n                Member::Named(ref ident) =\u003e ident.clone(),\n                Member::Unnamed(ref member) =\u003e {\n                    Ident::new(\u0026format!(\"__field{}\", member.index), Span::call_site())\n                }\n            };\n            quote!(#id)\n        })\n        .collect();\n    wrap_serialize_with(\n        params,\n        serialize_with,\n        field_tys.as_slice(),\n        field_exprs.as_slice(),\n    )\n}\n\nfn wrap_serialize_with(\n    params: \u0026Parameters,\n    serialize_with: \u0026syn::ExprPath,\n    field_tys: \u0026[\u0026syn::Type],\n    field_exprs: \u0026[TokenStream],\n) -\u003e TokenStream {\n    let this = \u0026params.this;\n    let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n\n    let wrapper_generics = if field_exprs.is_empty() {\n        params.generics.clone()\n    } else {\n        bound::with_lifetime_bound(\u0026params.generics, \"'__a\")\n    };\n    let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n\n    let field_access = (0..field_exprs.len()).map(|n| {\n        Member::Unnamed(Index {\n            index: n as u32,\n            span: Span::call_site(),\n        })\n    });\n\n    quote!({\n        struct __SerializeWith #wrapper_impl_generics #where_clause {\n            values: (#(\u0026'__a #field_tys, )*),\n            phantom: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n        }\n\n        impl #wrapper_impl_generics _serde::Serialize for __SerializeWith #wrapper_ty_generics #where_clause {\n            fn serialize\u003c__S\u003e(\u0026self, __s: __S) -\u003e _serde::export::Result\u003c__S::Ok, __S::Error\u003e\n            where\n                __S: _serde::Serializer,\n            {\n                #serialize_with(#(self.values.#field_access, )* __s)\n            }\n        }\n\n        \u0026__SerializeWith {\n            values: (#(#field_exprs, )*),\n            phantom: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n        }\n    })\n}\n\n// Serialization of an empty struct results in code like:\n//\n//     let mut __serde_state = try!(serializer.serialize_struct(\"S\", 0));\n//     _serde::ser::SerializeStruct::end(__serde_state)\n//\n// where we want to omit the `mut` to avoid a warning.\nfn mut_if(is_mut: bool) -\u003e Option\u003cTokenStream\u003e {\n    if is_mut {\n        Some(quote!(mut))\n    } else {\n        None\n    }\n}\n\nfn get_member(params: \u0026Parameters, field: \u0026Field, member: \u0026Member) -\u003e TokenStream {\n    let self_var = \u0026params.self_var;\n    match (params.is_remote, field.attrs.getter()) {\n        (false, None) =\u003e quote!(\u0026#self_var.#member),\n        (true, None) =\u003e {\n            let inner = quote!(\u0026#self_var.#member);\n            let ty = field.ty;\n            quote!(_serde::private::ser::constrain::\u003c#ty\u003e(#inner))\n        }\n        (true, Some(getter)) =\u003e {\n            let ty = field.ty;\n            quote!(_serde::private::ser::constrain::\u003c#ty\u003e(\u0026#getter(#self_var)))\n        }\n        (false, Some(_)) =\u003e {\n            unreachable!(\"getter is only allowed for remote impls\");\n        }\n    }\n}\n\nenum StructTrait {\n    SerializeMap,\n    SerializeStruct,\n    SerializeStructVariant,\n}\n\nimpl StructTrait {\n    fn serialize_field(\u0026self, span: Span) -\u003e TokenStream {\n        match *self {\n            StructTrait::SerializeMap =\u003e quote_spanned!(span=\u003e _serde::ser::SerializeMap::serialize_entry),\n            StructTrait::SerializeStruct =\u003e quote_spanned!(span=\u003e _serde::ser::SerializeStruct::serialize_field),\n            StructTrait::SerializeStructVariant =\u003e quote_spanned!(span=\u003e _serde::ser::SerializeStructVariant::serialize_field),\n        }\n    }\n\n    fn skip_field(\u0026self, span: Span) -\u003e Option\u003cTokenStream\u003e {\n        match *self {\n            StructTrait::SerializeMap =\u003e None,\n            StructTrait::SerializeStruct =\u003e {\n                Some(quote_spanned!(span=\u003e _serde::ser::SerializeStruct::skip_field))\n            }\n            StructTrait::SerializeStructVariant =\u003e {\n                Some(quote_spanned!(span=\u003e _serde::ser::SerializeStructVariant::skip_field))\n            }\n        }\n    }\n}\n\nenum TupleTrait {\n    SerializeTuple,\n    SerializeTupleStruct,\n    SerializeTupleVariant,\n}\n\nimpl TupleTrait {\n    fn serialize_element(\u0026self, span: Span) -\u003e TokenStream {\n        match *self {\n            TupleTrait::SerializeTuple =\u003e quote_spanned!(span=\u003e _serde::ser::SerializeTuple::serialize_element),\n            TupleTrait::SerializeTupleStruct =\u003e quote_spanned!(span=\u003e _serde::ser::SerializeTupleStruct::serialize_field),\n            TupleTrait::SerializeTupleVariant =\u003e quote_spanned!(span=\u003e _serde::ser::SerializeTupleVariant::serialize_field),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","try.rs"],"content":"use proc_macro2::{Punct, Spacing, TokenStream};\n\n// None of our generated code requires the `From::from` error conversion\n// performed by the standard library's `try!` macro. With this simplified macro\n// we see a significant improvement in type checking and borrow checking time of\n// the generated code and a slight improvement in binary size.\npub fn replacement() -\u003e TokenStream {\n    // Cannot pass `$expr` to `quote!` prior to Rust 1.17.0 so interpolate it.\n    let dollar = Punct::new('$', Spacing::Alone);\n\n    quote! {\n        #[allow(unused_macros)]\n        macro_rules! try {\n            (#dollar __expr:expr) =\u003e {\n                match #dollar __expr {\n                    _serde::export::Ok(__val) =\u003e __val,\n                    _serde::export::Err(__err) =\u003e {\n                        return _serde::export::Err(__err);\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive_internals","lib.rs"],"content":"#![doc(html_root_url = \"https://docs.rs/serde_derive_internals/0.25.0\")]\n#![allow(unknown_lints, bare_trait_objects)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(renamed_and_removed_lints))]\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        cognitive_complexity,\n        redundant_field_names,\n        trivially_copy_pass_by_ref\n    )\n)]\n\n#[macro_use]\nextern crate syn;\n\nextern crate proc_macro2;\nextern crate quote;\n\n#[path = \"src/mod.rs\"]\nmod internals;\n\npub use internals::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","assert.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse de::Deserializer;\nuse ser::Serializer;\nuse token::Token;\n\nuse std::fmt::Debug;\n\n/// Runs both `assert_ser_tokens` and `assert_de_tokens`.\n///\n/// ```edition2018\n/// # use serde::{Serialize, Deserialize};\n/// # use serde_test::{assert_tokens, Token};\n/// #\n/// # fn main() {\n/// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n/// struct S {\n///     a: u8,\n///     b: u8,\n/// }\n///\n/// let s = S { a: 0, b: 0 };\n/// assert_tokens(\u0026s, \u0026[\n///     Token::Struct { name: \"S\", len: 2 },\n///     Token::Str(\"a\"),\n///     Token::U8(0),\n///     Token::Str(\"b\"),\n///     Token::U8(0),\n///     Token::StructEnd,\n/// ]);\n/// # }\n/// ```\npub fn assert_tokens\u003c'de, T\u003e(value: \u0026T, tokens: \u0026'de [Token])\nwhere\n    T: Serialize + Deserialize\u003c'de\u003e + PartialEq + Debug,\n{\n    assert_ser_tokens(value, tokens);\n    assert_de_tokens(value, tokens);\n}\n\n/// Asserts that `value` serializes to the given `tokens`.\n///\n/// ```edition2018\n/// # use serde::{Serialize, Deserialize};\n/// # use serde_test::{assert_ser_tokens, Token};\n/// #\n/// # fn main() {\n/// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n/// struct S {\n///     a: u8,\n///     b: u8,\n/// }\n///\n/// let s = S { a: 0, b: 0 };\n/// assert_ser_tokens(\u0026s, \u0026[\n///     Token::Struct { name: \"S\", len: 2 },\n///     Token::Str(\"a\"),\n///     Token::U8(0),\n///     Token::Str(\"b\"),\n///     Token::U8(0),\n///     Token::StructEnd,\n/// ]);\n/// # }\n/// ```\npub fn assert_ser_tokens\u003cT\u003e(value: \u0026T, tokens: \u0026[Token])\nwhere\n    T: Serialize,\n{\n    let mut ser = Serializer::new(tokens);\n    match value.serialize(\u0026mut ser) {\n        Ok(_) =\u003e {}\n        Err(err) =\u003e panic!(\"value failed to serialize: {}\", err),\n    }\n\n    if ser.remaining() \u003e 0 {\n        panic!(\"{} remaining tokens\", ser.remaining());\n    }\n}\n\n/// Asserts that `value` serializes to the given `tokens`, and then yields\n/// `error`.\n///\n/// ```edition2018\n/// use std::sync::{Arc, Mutex};\n/// use std::thread;\n///\n/// use serde::Serialize;\n/// use serde_test::{assert_ser_tokens_error, Token};\n///\n/// #[derive(Serialize)]\n/// struct Example {\n///     lock: Arc\u003cMutex\u003cu32\u003e\u003e,\n/// }\n///\n/// fn main() {\n///     let example = Example { lock: Arc::new(Mutex::new(0)) };\n///     let lock = example.lock.clone();\n///\n///     let _ = thread::spawn(move || {\n///         // This thread will acquire the mutex first, unwrapping the result\n///         // of `lock` because the lock has not been poisoned.\n///         let _guard = lock.lock().unwrap();\n///\n///         // This panic while holding the lock (`_guard` is in scope) will\n///         // poison the mutex.\n///         panic!()\n///     }).join();\n///\n///     let expected = \u0026[\n///         Token::Struct { name: \"Example\", len: 1 },\n///         Token::Str(\"lock\"),\n///     ];\n///     let error = \"lock poison error while serializing\";\n///     assert_ser_tokens_error(\u0026example, expected, error);\n/// }\n/// ```\npub fn assert_ser_tokens_error\u003cT\u003e(value: \u0026T, tokens: \u0026[Token], error: \u0026str)\nwhere\n    T: Serialize,\n{\n    let mut ser = Serializer::new(tokens);\n    match value.serialize(\u0026mut ser) {\n        Ok(_) =\u003e panic!(\"value serialized successfully\"),\n        Err(e) =\u003e assert_eq!(e, *error),\n    }\n\n    if ser.remaining() \u003e 0 {\n        panic!(\"{} remaining tokens\", ser.remaining());\n    }\n}\n\n/// Asserts that the given `tokens` deserialize into `value`.\n///\n/// ```edition2018\n/// # use serde::{Serialize, Deserialize};\n/// # use serde_test::{assert_de_tokens, Token};\n/// #\n/// # fn main() {\n/// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n/// struct S {\n///     a: u8,\n///     b: u8,\n/// }\n///\n/// let s = S { a: 0, b: 0 };\n/// assert_de_tokens(\u0026s, \u0026[\n///     Token::Struct { name: \"S\", len: 2 },\n///     Token::Str(\"a\"),\n///     Token::U8(0),\n///     Token::Str(\"b\"),\n///     Token::U8(0),\n///     Token::StructEnd,\n/// ]);\n/// # }\n/// ```\npub fn assert_de_tokens\u003c'de, T\u003e(value: \u0026T, tokens: \u0026'de [Token])\nwhere\n    T: Deserialize\u003c'de\u003e + PartialEq + Debug,\n{\n    let mut de = Deserializer::new(tokens);\n    let mut deserialized_val = match T::deserialize(\u0026mut de) {\n        Ok(v) =\u003e {\n            assert_eq!(v, *value);\n            v\n        }\n        Err(e) =\u003e panic!(\"tokens failed to deserialize: {}\", e),\n    };\n    if de.remaining() \u003e 0 {\n        panic!(\"{} remaining tokens\", de.remaining());\n    }\n\n    // Do the same thing for deserialize_in_place. This isn't *great* because a\n    // no-op impl of deserialize_in_place can technically succeed here. Still,\n    // this should catch a lot of junk.\n    let mut de = Deserializer::new(tokens);\n    match T::deserialize_in_place(\u0026mut de, \u0026mut deserialized_val) {\n        Ok(()) =\u003e {\n            assert_eq!(deserialized_val, *value);\n        }\n        Err(e) =\u003e panic!(\"tokens failed to deserialize_in_place: {}\", e),\n    }\n    if de.remaining() \u003e 0 {\n        panic!(\"{} remaining tokens\", de.remaining());\n    }\n}\n\n/// Asserts that the given `tokens` yield `error` when deserializing.\n///\n/// ```edition2018\n/// # use serde::{Serialize, Deserialize};\n/// # use serde_test::{assert_de_tokens_error, Token};\n/// #\n/// # fn main() {\n/// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n/// #[serde(deny_unknown_fields)]\n/// struct S {\n///     a: u8,\n///     b: u8,\n/// }\n///\n/// assert_de_tokens_error::\u003cS\u003e(\n///     \u0026[\n///         Token::Struct { name: \"S\", len: 2 },\n///         Token::Str(\"x\"),\n///     ],\n///     \"unknown field `x`, expected `a` or `b`\",\n/// );\n/// # }\n/// ```\npub fn assert_de_tokens_error\u003c'de, T\u003e(tokens: \u0026'de [Token], error: \u0026str)\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    let mut de = Deserializer::new(tokens);\n    match T::deserialize(\u0026mut de) {\n        Ok(_) =\u003e panic!(\"tokens deserialized successfully\"),\n        Err(e) =\u003e assert_eq!(e, *error),\n    }\n\n    // There may be one token left if a peek caused the error\n    de.next_token_opt();\n\n    if de.remaining() \u003e 0 {\n        panic!(\"{} remaining tokens\", de.remaining());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","configure.rs"],"content":"use std::fmt;\n\nuse serde::ser::{\n    SerializeMap, SerializeSeq, SerializeStruct, SerializeStructVariant, SerializeTuple,\n    SerializeTupleStruct, SerializeTupleVariant,\n};\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]\npub struct Readable\u003cT: ?Sized\u003e(T);\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]\npub struct Compact\u003cT: ?Sized\u003e(T);\n\n/// Trait to determine whether a value is represented in human-readable or\n/// compact form.\n///\n/// ```edition2018\n/// use serde::{Deserialize, Deserializer, Serialize, Serializer};\n/// use serde_test::{assert_tokens, Configure, Token};\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Example(u8, u8);\n///\n/// impl Serialize for Example {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         if serializer.is_human_readable() {\n///             format!(\"{}.{}\", self.0, self.1).serialize(serializer)\n///         } else {\n///             (self.0, self.1).serialize(serializer)\n///         }\n///     }\n/// }\n///\n/// impl\u003c'de\u003e Deserialize\u003c'de\u003e for Example {\n///     fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n///     where\n///         D: Deserializer\u003c'de\u003e,\n///     {\n///         use serde::de::Error;\n///         if deserializer.is_human_readable() {\n///             let s = String::deserialize(deserializer)?;\n///             let parts: Vec\u003c_\u003e = s.split('.').collect();\n///             Ok(Example(\n///                 parts[0].parse().map_err(D::Error::custom)?,\n///                 parts[1].parse().map_err(D::Error::custom)?,\n///             ))\n///         } else {\n///             let (x, y) = Deserialize::deserialize(deserializer)?;\n///             Ok(Example(x, y))\n///         }\n///     }\n/// }\n///\n/// fn main() {\n///     assert_tokens(\n///         \u0026Example(1, 0).compact(),\n///         \u0026[\n///             Token::Tuple { len: 2 },\n///             Token::U8(1),\n///             Token::U8(0),\n///             Token::TupleEnd,\n///         ],\n///     );\n///     assert_tokens(\u0026Example(1, 0).readable(), \u0026[Token::Str(\"1.0\")]);\n/// }\n/// ```\npub trait Configure {\n    /// Marks `self` as using `is_human_readable == true`\n    fn readable(self) -\u003e Readable\u003cSelf\u003e\n    where\n        Self: Sized,\n    {\n        Readable(self)\n    }\n    /// Marks `self` as using `is_human_readable == false`\n    fn compact(self) -\u003e Compact\u003cSelf\u003e\n    where\n        Self: Sized,\n    {\n        Compact(self)\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Configure for T {}\n\nimpl\u003cT: ?Sized\u003e Serialize for Readable\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.0.serialize(Readable(serializer))\n    }\n}\nimpl\u003cT: ?Sized\u003e Serialize for Compact\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.0.serialize(Compact(serializer))\n    }\n}\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Readable\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(Readable(deserializer)).map(Readable)\n    }\n}\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Compact\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(Compact(deserializer)).map(Compact)\n    }\n}\n\nimpl\u003c'de, T\u003e DeserializeSeed\u003c'de\u003e for Readable\u003cT\u003e\nwhere\n    T: DeserializeSeed\u003c'de\u003e,\n{\n    type Value = T::Value;\n\n    fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        self.0.deserialize(Readable(deserializer))\n    }\n}\nimpl\u003c'de, T\u003e DeserializeSeed\u003c'de\u003e for Compact\u003cT\u003e\nwhere\n    T: DeserializeSeed\u003c'de\u003e,\n{\n    type Value = T::Value;\n\n    fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        self.0.deserialize(Compact(deserializer))\n    }\n}\n\nmacro_rules! forward_method {\n    ($name: ident (self $(, $arg: ident : $arg_type: ty)* ) -\u003e $return_type: ty) =\u003e {\n        fn $name (self $(, $arg : $arg_type)* ) -\u003e $return_type {\n            (self.0).$name( $($arg),* )\n        }\n    };\n}\n\nmacro_rules! forward_serialize_methods {\n    ( $( $name: ident $arg_type: ty ),* ) =\u003e {\n        $(\n            forward_method!($name(self, v : $arg_type) -\u003e Result\u003cSelf::Ok, Self::Error\u003e);\n        )*\n    };\n}\n\nmacro_rules! impl_serializer {\n    ($wrapper:ident, $is_human_readable:expr) =\u003e {\n        impl\u003cS\u003e Serializer for $wrapper\u003cS\u003e\n        where\n            S: Serializer,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n\n            type SerializeSeq = $wrapper\u003cS::SerializeSeq\u003e;\n            type SerializeTuple = $wrapper\u003cS::SerializeTuple\u003e;\n            type SerializeTupleStruct = $wrapper\u003cS::SerializeTupleStruct\u003e;\n            type SerializeTupleVariant = $wrapper\u003cS::SerializeTupleVariant\u003e;\n            type SerializeMap = $wrapper\u003cS::SerializeMap\u003e;\n            type SerializeStruct = $wrapper\u003cS::SerializeStruct\u003e;\n            type SerializeStructVariant = $wrapper\u003cS::SerializeStructVariant\u003e;\n\n            fn is_human_readable(\u0026self) -\u003e bool {\n                $is_human_readable\n            }\n\n            forward_serialize_methods! {\n                serialize_bool bool,\n                serialize_i8 i8,\n                serialize_i16 i16,\n                serialize_i32 i32,\n                serialize_i64 i64,\n                serialize_u8 u8,\n                serialize_u16 u16,\n                serialize_u32 u32,\n                serialize_u64 u64,\n                serialize_f32 f32,\n                serialize_f64 f64,\n                serialize_char char,\n                serialize_str \u0026str,\n                serialize_bytes \u0026[u8],\n                serialize_unit_struct \u0026'static str\n\n            }\n\n            fn serialize_unit(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.serialize_unit()\n            }\n\n            fn serialize_unit_variant(\n                self,\n                name: \u0026'static str,\n                variant_index: u32,\n                variant: \u0026'static str,\n            ) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.serialize_unit_variant(name, variant_index, variant)\n            }\n\n            fn serialize_newtype_struct\u003cT: ?Sized\u003e(\n                self,\n                name: \u0026'static str,\n                value: \u0026T,\n            ) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_newtype_struct(name, \u0026$wrapper(value))\n            }\n\n            fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n                self,\n                name: \u0026'static str,\n                variant_index: u32,\n                variant: \u0026'static str,\n                value: \u0026T,\n            ) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0\n                    .serialize_newtype_variant(name, variant_index, variant, \u0026$wrapper(value))\n            }\n\n            fn serialize_none(self) -\u003e Result\u003cS::Ok, Self::Error\u003e {\n                self.0.serialize_none()\n            }\n\n            fn serialize_some\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cS::Ok, Self::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_some(\u0026$wrapper(value))\n            }\n\n            fn serialize_seq(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeSeq, Self::Error\u003e {\n                self.0.serialize_seq(len).map($wrapper)\n            }\n\n            fn serialize_tuple(self, len: usize) -\u003e Result\u003cSelf::SerializeTuple, Self::Error\u003e {\n                self.0.serialize_tuple(len).map($wrapper)\n            }\n\n            fn serialize_tuple_struct(\n                self,\n                name: \u0026'static str,\n                len: usize,\n            ) -\u003e Result\u003cSelf::SerializeTupleStruct, Self::Error\u003e {\n                self.0.serialize_tuple_struct(name, len).map($wrapper)\n            }\n\n            fn serialize_tuple_variant(\n                self,\n                name: \u0026'static str,\n                variant_index: u32,\n                variant: \u0026'static str,\n                len: usize,\n            ) -\u003e Result\u003cSelf::SerializeTupleVariant, Self::Error\u003e {\n                self.0\n                    .serialize_tuple_variant(name, variant_index, variant, len)\n                    .map($wrapper)\n            }\n\n            fn serialize_map(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeMap, Self::Error\u003e {\n                self.0.serialize_map(len).map($wrapper)\n            }\n\n            fn serialize_struct(\n                self,\n                name: \u0026'static str,\n                len: usize,\n            ) -\u003e Result\u003cSelf::SerializeStruct, Self::Error\u003e {\n                self.0.serialize_struct(name, len).map($wrapper)\n            }\n\n            fn serialize_struct_variant(\n                self,\n                name: \u0026'static str,\n                variant_index: u32,\n                variant: \u0026'static str,\n                len: usize,\n            ) -\u003e Result\u003cSelf::SerializeStructVariant, Self::Error\u003e {\n                self.0\n                    .serialize_struct_variant(name, variant_index, variant, len)\n                    .map($wrapper)\n            }\n        }\n\n        impl\u003cS\u003e SerializeSeq for $wrapper\u003cS\u003e\n        where\n            S: SerializeSeq,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_element(\u0026$wrapper(value))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n\n        impl\u003cS\u003e SerializeTuple for $wrapper\u003cS\u003e\n        where\n            S: SerializeTuple,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_element(\u0026$wrapper(value))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n\n        impl\u003cS\u003e SerializeTupleStruct for $wrapper\u003cS\u003e\n        where\n            S: SerializeTupleStruct,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_field(\u0026$wrapper(value))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n\n        impl\u003cS\u003e SerializeTupleVariant for $wrapper\u003cS\u003e\n        where\n            S: SerializeTupleVariant,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_field(\u0026$wrapper(value))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n\n        impl\u003cS\u003e SerializeMap for $wrapper\u003cS\u003e\n        where\n            S: SerializeMap,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_key(\u0026$wrapper(key))\n            }\n            fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_value(\u0026$wrapper(value))\n            }\n            fn serialize_entry\u003cK: ?Sized, V: ?Sized\u003e(\n                \u0026mut self,\n                key: \u0026K,\n                value: \u0026V,\n            ) -\u003e Result\u003c(), S::Error\u003e\n            where\n                K: Serialize,\n                V: Serialize,\n            {\n                self.0.serialize_entry(key, \u0026$wrapper(value))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n\n        impl\u003cS\u003e SerializeStruct for $wrapper\u003cS\u003e\n        where\n            S: SerializeStruct,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_field\u003cT: ?Sized\u003e(\n                \u0026mut self,\n                name: \u0026'static str,\n                field: \u0026T,\n            ) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_field(name, \u0026$wrapper(field))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n\n        impl\u003cS\u003e SerializeStructVariant for $wrapper\u003cS\u003e\n        where\n            S: SerializeStructVariant,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_field\u003cT: ?Sized\u003e(\n                \u0026mut self,\n                name: \u0026'static str,\n                field: \u0026T,\n            ) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_field(name, \u0026$wrapper(field))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n    };\n}\n\nimpl_serializer!(Readable, true);\nimpl_serializer!(Compact, false);\n\nuse serde::de::{DeserializeSeed, EnumAccess, Error, MapAccess, SeqAccess, VariantAccess, Visitor};\n\nmacro_rules! forward_deserialize_methods {\n    ( $wrapper : ident ( $( $name: ident ),* ) ) =\u003e {\n        $(\n            fn $name\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                (self.0).$name($wrapper(visitor))\n            }\n        )*\n    };\n}\n\nmacro_rules! impl_deserializer {\n    ($wrapper:ident, $is_human_readable:expr) =\u003e {\n        impl\u003c'de, D\u003e Deserializer\u003c'de\u003e for $wrapper\u003cD\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            type Error = D::Error;\n\n            forward_deserialize_methods! {\n                $wrapper (\n                    deserialize_any,\n                    deserialize_bool,\n                    deserialize_u8,\n                    deserialize_u16,\n                    deserialize_u32,\n                    deserialize_u64,\n                    deserialize_i8,\n                    deserialize_i16,\n                    deserialize_i32,\n                    deserialize_i64,\n                    deserialize_f32,\n                    deserialize_f64,\n                    deserialize_char,\n                    deserialize_str,\n                    deserialize_string,\n                    deserialize_bytes,\n                    deserialize_byte_buf,\n                    deserialize_option,\n                    deserialize_unit,\n                    deserialize_seq,\n                    deserialize_map,\n                    deserialize_identifier,\n                    deserialize_ignored_any\n                )\n            }\n\n            fn deserialize_unit_struct\u003cV\u003e(\n                self,\n                name: \u0026'static str,\n                visitor: V,\n            ) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.deserialize_unit_struct(name, $wrapper(visitor))\n            }\n            fn deserialize_newtype_struct\u003cV\u003e(\n                self,\n                name: \u0026'static str,\n                visitor: V,\n            ) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.deserialize_newtype_struct(name, $wrapper(visitor))\n            }\n            fn deserialize_tuple\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.deserialize_tuple(len, $wrapper(visitor))\n            }\n            fn deserialize_tuple_struct\u003cV\u003e(\n                self,\n                name: \u0026'static str,\n                len: usize,\n                visitor: V,\n            ) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0\n                    .deserialize_tuple_struct(name, len, $wrapper(visitor))\n            }\n            fn deserialize_struct\u003cV\u003e(\n                self,\n                name: \u0026'static str,\n                fields: \u0026'static [\u0026'static str],\n                visitor: V,\n            ) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.deserialize_struct(name, fields, $wrapper(visitor))\n            }\n            fn deserialize_enum\u003cV\u003e(\n                self,\n                name: \u0026'static str,\n                variants: \u0026'static [\u0026'static str],\n                visitor: V,\n            ) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.deserialize_enum(name, variants, $wrapper(visitor))\n            }\n\n            fn is_human_readable(\u0026self) -\u003e bool {\n                $is_human_readable\n            }\n        }\n\n        impl\u003c'de, D\u003e Visitor\u003c'de\u003e for $wrapper\u003cD\u003e\n        where\n            D: Visitor\u003c'de\u003e,\n        {\n            type Value = D::Value;\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                self.0.expecting(formatter)\n            }\n            fn visit_bool\u003cE\u003e(self, v: bool) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_bool(v)\n            }\n            fn visit_i8\u003cE\u003e(self, v: i8) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_i8(v)\n            }\n            fn visit_i16\u003cE\u003e(self, v: i16) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_i16(v)\n            }\n            fn visit_i32\u003cE\u003e(self, v: i32) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_i32(v)\n            }\n            fn visit_i64\u003cE\u003e(self, v: i64) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_i64(v)\n            }\n            fn visit_u8\u003cE\u003e(self, v: u8) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_u8(v)\n            }\n            fn visit_u16\u003cE\u003e(self, v: u16) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_u16(v)\n            }\n            fn visit_u32\u003cE\u003e(self, v: u32) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_u32(v)\n            }\n            fn visit_u64\u003cE\u003e(self, v: u64) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_u64(v)\n            }\n            fn visit_f32\u003cE\u003e(self, v: f32) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_f32(v)\n            }\n            fn visit_f64\u003cE\u003e(self, v: f64) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_f64(v)\n            }\n            fn visit_char\u003cE\u003e(self, v: char) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_char(v)\n            }\n            fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_str(v)\n            }\n            fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'de str) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_borrowed_str(v)\n            }\n            fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_string(v)\n            }\n            fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_bytes(v)\n            }\n            fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'de [u8]) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_borrowed_bytes(v)\n            }\n            fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_byte_buf(v)\n            }\n            fn visit_none\u003cE\u003e(self) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_none()\n            }\n            fn visit_some\u003cD2\u003e(self, deserializer: D2) -\u003e Result\u003cSelf::Value, D2::Error\u003e\n            where\n                D2: Deserializer\u003c'de\u003e,\n            {\n                self.0.visit_some($wrapper(deserializer))\n            }\n            fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_unit()\n            }\n            fn visit_newtype_struct\u003cD2\u003e(self, deserializer: D2) -\u003e Result\u003cSelf::Value, D2::Error\u003e\n            where\n                D2: Deserializer\u003c'de\u003e,\n            {\n                self.0.visit_newtype_struct($wrapper(deserializer))\n            }\n            fn visit_seq\u003cV\u003e(self, seq: V) -\u003e Result\u003cD::Value, V::Error\u003e\n            where\n                V: SeqAccess\u003c'de\u003e,\n            {\n                self.0.visit_seq($wrapper(seq))\n            }\n            fn visit_map\u003cV\u003e(self, map: V) -\u003e Result\u003cD::Value, V::Error\u003e\n            where\n                V: MapAccess\u003c'de\u003e,\n            {\n                self.0.visit_map($wrapper(map))\n            }\n            fn visit_enum\u003cV\u003e(self, data: V) -\u003e Result\u003cD::Value, V::Error\u003e\n            where\n                V: EnumAccess\u003c'de\u003e,\n            {\n                self.0.visit_enum($wrapper(data))\n            }\n        }\n\n        impl\u003c'de, D\u003e SeqAccess\u003c'de\u003e for $wrapper\u003cD\u003e\n        where\n            D: SeqAccess\u003c'de\u003e,\n        {\n            type Error = D::Error;\n            fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, D::Error\u003e\n            where\n                T: DeserializeSeed\u003c'de\u003e,\n            {\n                self.0.next_element_seed($wrapper(seed))\n            }\n            fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n                self.0.size_hint()\n            }\n        }\n\n        impl\u003c'de, D\u003e MapAccess\u003c'de\u003e for $wrapper\u003cD\u003e\n        where\n            D: MapAccess\u003c'de\u003e,\n        {\n            type Error = D::Error;\n            fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, D::Error\u003e\n            where\n                K: DeserializeSeed\u003c'de\u003e,\n            {\n                self.0.next_key_seed($wrapper(seed))\n            }\n            fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: DeserializeSeed\u003c'de\u003e,\n            {\n                self.0.next_value_seed($wrapper(seed))\n            }\n            fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n                self.0.size_hint()\n            }\n        }\n\n        impl\u003c'de, D\u003e EnumAccess\u003c'de\u003e for $wrapper\u003cD\u003e\n        where\n            D: EnumAccess\u003c'de\u003e,\n        {\n            type Error = D::Error;\n            type Variant = $wrapper\u003cD::Variant\u003e;\n            fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n            where\n                V: DeserializeSeed\u003c'de\u003e,\n            {\n                self.0\n                    .variant_seed($wrapper(seed))\n                    .map(|(value, variant)| (value, $wrapper(variant)))\n            }\n        }\n\n        impl\u003c'de, D\u003e VariantAccess\u003c'de\u003e for $wrapper\u003cD\u003e\n        where\n            D: VariantAccess\u003c'de\u003e,\n        {\n            type Error = D::Error;\n            fn unit_variant(self) -\u003e Result\u003c(), D::Error\u003e {\n                self.0.unit_variant()\n            }\n            fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, D::Error\u003e\n            where\n                T: DeserializeSeed\u003c'de\u003e,\n            {\n                self.0.newtype_variant_seed($wrapper(seed))\n            }\n            fn tuple_variant\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.tuple_variant(len, $wrapper(visitor))\n            }\n            fn struct_variant\u003cV\u003e(\n                self,\n                fields: \u0026'static [\u0026'static str],\n                visitor: V,\n            ) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.struct_variant(fields, $wrapper(visitor))\n            }\n        }\n    };\n}\n\nimpl_deserializer!(Readable, true);\nimpl_deserializer!(Compact, false);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","de.rs"],"content":"use serde::de::value::{MapAccessDeserializer, SeqAccessDeserializer};\nuse serde::de::{\n    self, Deserialize, DeserializeSeed, EnumAccess, IntoDeserializer, MapAccess, SeqAccess,\n    VariantAccess, Visitor,\n};\n\nuse error::Error;\nuse token::Token;\n\n#[derive(Debug)]\npub struct Deserializer\u003c'de\u003e {\n    tokens: \u0026'de [Token],\n}\n\nmacro_rules! assert_next_token {\n    ($de:expr, $expected:expr) =\u003e {\n        match $de.next_token_opt() {\n            Some(token) if token == $expected =\u003e {}\n            Some(other) =\u003e panic!(\n                \"expected Token::{} but deserialization wants Token::{}\",\n                other, $expected\n            ),\n            None =\u003e panic!(\n                \"end of tokens but deserialization wants Token::{}\",\n                $expected\n            ),\n        }\n    };\n}\n\nmacro_rules! unexpected {\n    ($token:expr) =\u003e {\n        panic!(\"deserialization did not expect this token: {}\", $token)\n    };\n}\n\nmacro_rules! end_of_tokens {\n    () =\u003e {\n        panic!(\"ran out of tokens to deserialize\")\n    };\n}\n\nimpl\u003c'de\u003e Deserializer\u003c'de\u003e {\n    pub fn new(tokens: \u0026'de [Token]) -\u003e Self {\n        Deserializer { tokens: tokens }\n    }\n\n    fn peek_token_opt(\u0026self) -\u003e Option\u003cToken\u003e {\n        self.tokens.first().cloned()\n    }\n\n    fn peek_token(\u0026self) -\u003e Token {\n        match self.peek_token_opt() {\n            Some(token) =\u003e token,\n            None =\u003e end_of_tokens!(),\n        }\n    }\n\n    pub fn next_token_opt(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        match self.tokens.split_first() {\n            Some((\u0026first, rest)) =\u003e {\n                self.tokens = rest;\n                Some(first)\n            }\n            None =\u003e None,\n        }\n    }\n\n    fn next_token(\u0026mut self) -\u003e Token {\n        match self.tokens.split_first() {\n            Some((\u0026first, rest)) =\u003e {\n                self.tokens = rest;\n                first\n            }\n            None =\u003e end_of_tokens!(),\n        }\n    }\n\n    pub fn remaining(\u0026self) -\u003e usize {\n        self.tokens.len()\n    }\n\n    fn visit_seq\u003cV\u003e(\n        \u0026mut self,\n        len: Option\u003cusize\u003e,\n        end: Token,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        let value = visitor.visit_seq(DeserializerSeqVisitor {\n            de: self,\n            len: len,\n            end: end,\n        })?;\n        assert_next_token!(self, end);\n        Ok(value)\n    }\n\n    fn visit_map\u003cV\u003e(\n        \u0026mut self,\n        len: Option\u003cusize\u003e,\n        end: Token,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        let value = visitor.visit_map(DeserializerMapVisitor {\n            de: self,\n            len: len,\n            end: end,\n        })?;\n        assert_next_token!(self, end);\n        Ok(value)\n    }\n}\n\nimpl\u003c'de, 'a\u003e de::Deserializer\u003c'de\u003e for \u0026'a mut Deserializer\u003c'de\u003e {\n    type Error = Error;\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf unit seq map identifier ignored_any\n    }\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        let token = self.next_token();\n        match token {\n            Token::Bool(v) =\u003e visitor.visit_bool(v),\n            Token::I8(v) =\u003e visitor.visit_i8(v),\n            Token::I16(v) =\u003e visitor.visit_i16(v),\n            Token::I32(v) =\u003e visitor.visit_i32(v),\n            Token::I64(v) =\u003e visitor.visit_i64(v),\n            Token::U8(v) =\u003e visitor.visit_u8(v),\n            Token::U16(v) =\u003e visitor.visit_u16(v),\n            Token::U32(v) =\u003e visitor.visit_u32(v),\n            Token::U64(v) =\u003e visitor.visit_u64(v),\n            Token::F32(v) =\u003e visitor.visit_f32(v),\n            Token::F64(v) =\u003e visitor.visit_f64(v),\n            Token::Char(v) =\u003e visitor.visit_char(v),\n            Token::Str(v) =\u003e visitor.visit_str(v),\n            Token::BorrowedStr(v) =\u003e visitor.visit_borrowed_str(v),\n            Token::String(v) =\u003e visitor.visit_string(v.to_owned()),\n            Token::Bytes(v) =\u003e visitor.visit_bytes(v),\n            Token::BorrowedBytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n            Token::ByteBuf(v) =\u003e visitor.visit_byte_buf(v.to_vec()),\n            Token::None =\u003e visitor.visit_none(),\n            Token::Some =\u003e visitor.visit_some(self),\n            Token::Unit | Token::UnitStruct { .. } =\u003e visitor.visit_unit(),\n            Token::NewtypeStruct { .. } =\u003e visitor.visit_newtype_struct(self),\n            Token::Seq { len } =\u003e self.visit_seq(len, Token::SeqEnd, visitor),\n            Token::Tuple { len } =\u003e self.visit_seq(Some(len), Token::TupleEnd, visitor),\n            Token::TupleStruct { len, .. } =\u003e {\n                self.visit_seq(Some(len), Token::TupleStructEnd, visitor)\n            }\n            Token::Map { len } =\u003e self.visit_map(len, Token::MapEnd, visitor),\n            Token::Struct { len, .. } =\u003e self.visit_map(Some(len), Token::StructEnd, visitor),\n            Token::Enum { .. } =\u003e {\n                let variant = self.next_token();\n                let next = self.peek_token();\n                match (variant, next) {\n                    (Token::Str(variant), Token::Unit) =\u003e {\n                        self.next_token();\n                        visitor.visit_str(variant)\n                    }\n                    (Token::Bytes(variant), Token::Unit) =\u003e {\n                        self.next_token();\n                        visitor.visit_bytes(variant)\n                    }\n                    (Token::U32(variant), Token::Unit) =\u003e {\n                        self.next_token();\n                        visitor.visit_u32(variant)\n                    }\n                    (variant, Token::Unit) =\u003e unexpected!(variant),\n                    (variant, _) =\u003e {\n                        visitor.visit_map(EnumMapVisitor::new(self, variant, EnumFormat::Any))\n                    }\n                }\n            }\n            Token::UnitVariant { variant, .. } =\u003e visitor.visit_str(variant),\n            Token::NewtypeVariant { variant, .. } =\u003e visitor.visit_map(EnumMapVisitor::new(\n                self,\n                Token::Str(variant),\n                EnumFormat::Any,\n            )),\n            Token::TupleVariant { variant, .. } =\u003e visitor.visit_map(EnumMapVisitor::new(\n                self,\n                Token::Str(variant),\n                EnumFormat::Seq,\n            )),\n            Token::StructVariant { variant, .. } =\u003e visitor.visit_map(EnumMapVisitor::new(\n                self,\n                Token::Str(variant),\n                EnumFormat::Map,\n            )),\n            Token::SeqEnd\n            | Token::TupleEnd\n            | Token::TupleStructEnd\n            | Token::MapEnd\n            | Token::StructEnd\n            | Token::TupleVariantEnd\n            | Token::StructVariantEnd =\u003e {\n                unexpected!(token);\n            }\n        }\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::Unit | Token::None =\u003e {\n                self.next_token();\n                visitor.visit_none()\n            }\n            Token::Some =\u003e {\n                self.next_token();\n                visitor.visit_some(self)\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        _variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::Enum { name: n } if name == n =\u003e {\n                self.next_token();\n\n                visitor.visit_enum(DeserializerEnumVisitor { de: self })\n            }\n            Token::UnitVariant { name: n, .. }\n            | Token::NewtypeVariant { name: n, .. }\n            | Token::TupleVariant { name: n, .. }\n            | Token::StructVariant { name: n, .. }\n                if name == n =\u003e\n            {\n                visitor.visit_enum(DeserializerEnumVisitor { de: self })\n            }\n            _ =\u003e {\n                unexpected!(self.next_token());\n            }\n        }\n    }\n\n    fn deserialize_unit_struct\u003cV\u003e(self, name: \u0026'static str, visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::UnitStruct { .. } =\u003e {\n                assert_next_token!(self, Token::UnitStruct { name: name });\n                visitor.visit_unit()\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::NewtypeStruct { .. } =\u003e {\n                assert_next_token!(self, Token::NewtypeStruct { name: name });\n                visitor.visit_newtype_struct(self)\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_tuple\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::Unit | Token::UnitStruct { .. } =\u003e {\n                self.next_token();\n                visitor.visit_unit()\n            }\n            Token::Seq { .. } =\u003e {\n                self.next_token();\n                self.visit_seq(Some(len), Token::SeqEnd, visitor)\n            }\n            Token::Tuple { .. } =\u003e {\n                self.next_token();\n                self.visit_seq(Some(len), Token::TupleEnd, visitor)\n            }\n            Token::TupleStruct { .. } =\u003e {\n                self.next_token();\n                self.visit_seq(Some(len), Token::TupleStructEnd, visitor)\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_tuple_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        len: usize,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::Unit =\u003e {\n                self.next_token();\n                visitor.visit_unit()\n            }\n            Token::UnitStruct { .. } =\u003e {\n                assert_next_token!(self, Token::UnitStruct { name: name });\n                visitor.visit_unit()\n            }\n            Token::Seq { .. } =\u003e {\n                self.next_token();\n                self.visit_seq(Some(len), Token::SeqEnd, visitor)\n            }\n            Token::Tuple { .. } =\u003e {\n                self.next_token();\n                self.visit_seq(Some(len), Token::TupleEnd, visitor)\n            }\n            Token::TupleStruct { len: n, .. } =\u003e {\n                assert_next_token!(self, Token::TupleStruct { name: name, len: n });\n                self.visit_seq(Some(len), Token::TupleStructEnd, visitor)\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::Struct { len: n, .. } =\u003e {\n                assert_next_token!(self, Token::Struct { name: name, len: n });\n                self.visit_map(Some(fields.len()), Token::StructEnd, visitor)\n            }\n            Token::Map { .. } =\u003e {\n                self.next_token();\n                self.visit_map(Some(fields.len()), Token::MapEnd, visitor)\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn is_human_readable(\u0026self) -\u003e bool {\n        panic!(\n            \"Types which have different human-readable and compact representations \\\n             must explicitly mark their test cases with `serde_test::Configure`\"\n        );\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nstruct DeserializerSeqVisitor\u003c'a, 'de: 'a\u003e {\n    de: \u0026'a mut Deserializer\u003c'de\u003e,\n    len: Option\u003cusize\u003e,\n    end: Token,\n}\n\nimpl\u003c'de, 'a\u003e SeqAccess\u003c'de\u003e for DeserializerSeqVisitor\u003c'a, 'de\u003e {\n    type Error = Error;\n\n    fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        if self.de.peek_token_opt() == Some(self.end) {\n            return Ok(None);\n        }\n        self.len = self.len.map(|len| len.saturating_sub(1));\n        seed.deserialize(\u0026mut *self.de).map(Some)\n    }\n\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        self.len\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nstruct DeserializerMapVisitor\u003c'a, 'de: 'a\u003e {\n    de: \u0026'a mut Deserializer\u003c'de\u003e,\n    len: Option\u003cusize\u003e,\n    end: Token,\n}\n\nimpl\u003c'de, 'a\u003e MapAccess\u003c'de\u003e for DeserializerMapVisitor\u003c'a, 'de\u003e {\n    type Error = Error;\n\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n    {\n        if self.de.peek_token_opt() == Some(self.end) {\n            return Ok(None);\n        }\n        self.len = self.len.map(|len| len.saturating_sub(1));\n        seed.deserialize(\u0026mut *self.de).map(Some)\n    }\n\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(\u0026mut *self.de)\n    }\n\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        self.len\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nstruct DeserializerEnumVisitor\u003c'a, 'de: 'a\u003e {\n    de: \u0026'a mut Deserializer\u003c'de\u003e,\n}\n\nimpl\u003c'de, 'a\u003e EnumAccess\u003c'de\u003e for DeserializerEnumVisitor\u003c'a, 'de\u003e {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self), Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.de.peek_token() {\n            Token::UnitVariant { variant: v, .. }\n            | Token::NewtypeVariant { variant: v, .. }\n            | Token::TupleVariant { variant: v, .. }\n            | Token::StructVariant { variant: v, .. } =\u003e {\n                let de = v.into_deserializer();\n                let value = seed.deserialize(de)?;\n                Ok((value, self))\n            }\n            _ =\u003e {\n                let value = seed.deserialize(\u0026mut *self.de)?;\n                Ok((value, self))\n            }\n        }\n    }\n}\n\nimpl\u003c'de, 'a\u003e VariantAccess\u003c'de\u003e for DeserializerEnumVisitor\u003c'a, 'de\u003e {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Error\u003e {\n        match self.de.peek_token() {\n            Token::UnitVariant { .. } =\u003e {\n                self.de.next_token();\n                Ok(())\n            }\n            _ =\u003e Deserialize::deserialize(self.de),\n        }\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.de.peek_token() {\n            Token::NewtypeVariant { .. } =\u003e {\n                self.de.next_token();\n                seed.deserialize(self.de)\n            }\n            _ =\u003e seed.deserialize(self.de),\n        }\n    }\n\n    fn tuple_variant\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.de.peek_token() {\n            Token::TupleVariant { len: enum_len, .. } =\u003e {\n                let token = self.de.next_token();\n\n                if len == enum_len {\n                    self.de\n                        .visit_seq(Some(len), Token::TupleVariantEnd, visitor)\n                } else {\n                    unexpected!(token);\n                }\n            }\n            Token::Seq {\n                len: Some(enum_len),\n            } =\u003e {\n                let token = self.de.next_token();\n\n                if len == enum_len {\n                    self.de.visit_seq(Some(len), Token::SeqEnd, visitor)\n                } else {\n                    unexpected!(token);\n                }\n            }\n            _ =\u003e de::Deserializer::deserialize_any(self.de, visitor),\n        }\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.de.peek_token() {\n            Token::StructVariant { len: enum_len, .. } =\u003e {\n                let token = self.de.next_token();\n\n                if fields.len() == enum_len {\n                    self.de\n                        .visit_map(Some(fields.len()), Token::StructVariantEnd, visitor)\n                } else {\n                    unexpected!(token);\n                }\n            }\n            Token::Map {\n                len: Some(enum_len),\n            } =\u003e {\n                let token = self.de.next_token();\n\n                if fields.len() == enum_len {\n                    self.de\n                        .visit_map(Some(fields.len()), Token::MapEnd, visitor)\n                } else {\n                    unexpected!(token);\n                }\n            }\n            _ =\u003e de::Deserializer::deserialize_any(self.de, visitor),\n        }\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nstruct EnumMapVisitor\u003c'a, 'de: 'a\u003e {\n    de: \u0026'a mut Deserializer\u003c'de\u003e,\n    variant: Option\u003cToken\u003e,\n    format: EnumFormat,\n}\n\nenum EnumFormat {\n    Seq,\n    Map,\n    Any,\n}\n\nimpl\u003c'a, 'de\u003e EnumMapVisitor\u003c'a, 'de\u003e {\n    fn new(de: \u0026'a mut Deserializer\u003c'de\u003e, variant: Token, format: EnumFormat) -\u003e Self {\n        EnumMapVisitor {\n            de: de,\n            variant: Some(variant),\n            format: format,\n        }\n    }\n}\n\nimpl\u003c'de, 'a\u003e MapAccess\u003c'de\u003e for EnumMapVisitor\u003c'a, 'de\u003e {\n    type Error = Error;\n\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.variant.take() {\n            Some(Token::Str(variant)) =\u003e seed.deserialize(variant.into_deserializer()).map(Some),\n            Some(Token::Bytes(variant)) =\u003e seed\n                .deserialize(BytesDeserializer { value: variant })\n                .map(Some),\n            Some(Token::U32(variant)) =\u003e seed.deserialize(variant.into_deserializer()).map(Some),\n            Some(other) =\u003e unexpected!(other),\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.format {\n            EnumFormat::Seq =\u003e {\n                let value = {\n                    let visitor = DeserializerSeqVisitor {\n                        de: self.de,\n                        len: None,\n                        end: Token::TupleVariantEnd,\n                    };\n                    seed.deserialize(SeqAccessDeserializer::new(visitor))?\n                };\n                assert_next_token!(self.de, Token::TupleVariantEnd);\n                Ok(value)\n            }\n            EnumFormat::Map =\u003e {\n                let value = {\n                    let visitor = DeserializerMapVisitor {\n                        de: self.de,\n                        len: None,\n                        end: Token::StructVariantEnd,\n                    };\n                    seed.deserialize(MapAccessDeserializer::new(visitor))?\n                };\n                assert_next_token!(self.de, Token::StructVariantEnd);\n                Ok(value)\n            }\n            EnumFormat::Any =\u003e seed.deserialize(\u0026mut *self.de),\n        }\n    }\n}\n\nstruct BytesDeserializer {\n    value: \u0026'static [u8],\n}\n\nimpl\u003c'de\u003e de::Deserializer\u003c'de\u003e for BytesDeserializer {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_bytes(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","error.rs"],"content":"use std::error;\nuse std::fmt::{self, Display};\n\nuse serde::{de, ser};\n\n#[derive(Clone, Debug)]\npub struct Error {\n    msg: String,\n}\n\nimpl ser::Error for Error {\n    fn custom\u003cT: Display\u003e(msg: T) -\u003e Self {\n        Error {\n            msg: msg.to_string(),\n        }\n    }\n}\n\nimpl de::Error for Error {\n    fn custom\u003cT: Display\u003e(msg: T) -\u003e Self {\n        Error {\n            msg: msg.to_string(),\n        }\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\u0026self.msg)\n    }\n}\n\nimpl error::Error for Error {\n    fn description(\u0026self) -\u003e \u0026str {\n        \u0026self.msg\n    }\n}\n\nimpl PartialEq\u003cstr\u003e for Error {\n    fn eq(\u0026self, other: \u0026str) -\u003e bool {\n        self.msg == other\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","lib.rs"],"content":"//! This crate provides a convenient concise way to write unit tests for\n//! implementations of [`Serialize`] and [`Deserialize`].\n//!\n//! [`Serialize`]: https://docs.serde.rs/serde/ser/trait.Serialize.html\n//! [`Deserialize`]: https://docs.serde.rs/serde/de/trait.Deserialize.html\n//!\n//! The `Serialize` impl for a value can be characterized by the sequence of\n//! [`Serializer`] calls that are made in the course of serializing the value,\n//! so `serde_test` provides a [`Token`] abstraction which corresponds roughly\n//! to `Serializer` method calls. There is an [`assert_ser_tokens`] function to\n//! test that a value serializes to a particular sequence of method calls, an\n//! [`assert_de_tokens`] function to test that a value can be deserialized from\n//! a particular sequence of method calls, and an [`assert_tokens`] function to\n//! test both directions. There are also functions to test expected failure\n//! conditions.\n//!\n//! [`Serializer`]: https://docs.serde.rs/serde/ser/trait.Serializer.html\n//! [`Token`]: https://docs.serde.rs/serde_test/enum.Token.html\n//! [`assert_ser_tokens`]: https://docs.serde.rs/serde_test/fn.assert_ser_tokens.html\n//! [`assert_de_tokens`]: https://docs.serde.rs/serde_test/fn.assert_de_tokens.html\n//! [`assert_tokens`]: https://docs.serde.rs/serde_test/fn.assert_tokens.html\n//!\n//! Here is an example from the [`linked-hash-map`] crate.\n//!\n//! [`linked-hash-map`]: https://github.com/contain-rs/linked-hash-map\n//!\n//! ```edition2018\n//! # const IGNORE: \u0026str = stringify! {\n//! use linked_hash_map::LinkedHashMap;\n//! # };\n//! use serde_test::{Token, assert_tokens};\n//!\n//! # use std::fmt;\n//! # use std::marker::PhantomData;\n//! #\n//! # use serde::ser::{Serialize, Serializer, SerializeMap};\n//! # use serde::de::{Deserialize, Deserializer, Visitor, MapAccess};\n//! #\n//! # // Dumb imitation of LinkedHashMap.\n//! # #[derive(PartialEq, Debug)]\n//! # struct LinkedHashMap\u003cK, V\u003e(Vec\u003c(K, V)\u003e);\n//! #\n//! # impl\u003cK, V\u003e LinkedHashMap\u003cK, V\u003e {\n//! #     fn new() -\u003e Self {\n//! #         LinkedHashMap(Vec::new())\n//! #     }\n//! #\n//! #     fn insert(\u0026mut self, k: K, v: V) {\n//! #         self.0.push((k, v));\n//! #     }\n//! # }\n//! #\n//! # impl\u003cK, V\u003e Serialize for LinkedHashMap\u003cK, V\u003e\n//! # where\n//! #     K: Serialize,\n//! #     V: Serialize,\n//! # {\n//! #     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n//! #     where\n//! #         S: Serializer,\n//! #     {\n//! #         let mut map = serializer.serialize_map(Some(self.0.len()))?;\n//! #         for \u0026(ref k, ref v) in \u0026self.0 {\n//! #             map.serialize_entry(k, v)?;\n//! #         }\n//! #         map.end()\n//! #     }\n//! # }\n//! #\n//! # struct LinkedHashMapVisitor\u003cK, V\u003e(PhantomData\u003c(K, V)\u003e);\n//! #\n//! # impl\u003c'de, K, V\u003e Visitor\u003c'de\u003e for LinkedHashMapVisitor\u003cK, V\u003e\n//! # where\n//! #     K: Deserialize\u003c'de\u003e,\n//! #     V: Deserialize\u003c'de\u003e,\n//! # {\n//! #     type Value = LinkedHashMap\u003cK, V\u003e;\n//! #\n//! #     fn expecting(\u0026self, _: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n//! #         unimplemented!()\n//! #     }\n//! #\n//! #     fn visit_map\u003cM\u003e(self, mut access: M) -\u003e Result\u003cSelf::Value, M::Error\u003e\n//! #     where\n//! #         M: MapAccess\u003c'de\u003e,\n//! #     {\n//! #         let mut map = LinkedHashMap::new();\n//! #         while let Some((key, value)) = access.next_entry()? {\n//! #             map.insert(key, value);\n//! #         }\n//! #         Ok(map)\n//! #     }\n//! # }\n//! #\n//! # impl\u003c'de, K, V\u003e Deserialize\u003c'de\u003e for LinkedHashMap\u003cK, V\u003e\n//! # where\n//! #     K: Deserialize\u003c'de\u003e,\n//! #     V: Deserialize\u003c'de\u003e,\n//! # {\n//! #     fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n//! #     where\n//! #         D: Deserializer\u003c'de\u003e,\n//! #     {\n//! #         deserializer.deserialize_map(LinkedHashMapVisitor(PhantomData))\n//! #     }\n//! # }\n//! #\n//! #[test]\n//! # fn not_a_test_ser_de_empty() {}\n//! fn test_ser_de_empty() {\n//!     let map = LinkedHashMap::\u003cchar, u32\u003e::new();\n//!\n//!     assert_tokens(\u0026map, \u0026[\n//!         Token::Map { len: Some(0) },\n//!         Token::MapEnd,\n//!     ]);\n//! }\n//!\n//! #[test]\n//! # fn not_a_test_ser_de() {}\n//! fn test_ser_de() {\n//!     let mut map = LinkedHashMap::new();\n//!     map.insert('b', 20);\n//!     map.insert('a', 10);\n//!     map.insert('c', 30);\n//!\n//!     assert_tokens(\u0026map, \u0026[\n//!         Token::Map { len: Some(3) },\n//!         Token::Char('b'),\n//!         Token::I32(20),\n//!\n//!         Token::Char('a'),\n//!         Token::I32(10),\n//!\n//!         Token::Char('c'),\n//!         Token::I32(30),\n//!         Token::MapEnd,\n//!     ]);\n//! }\n//! #\n//! # fn main() {\n//! #     test_ser_de_empty();\n//! #     test_ser_de();\n//! # }\n//! ```\n\n#![doc(html_root_url = \"https://docs.rs/serde_test/1.0.100\")]\n#![cfg_attr(feature = \"cargo-clippy\", allow(renamed_and_removed_lints))]\n#![cfg_attr(feature = \"cargo-clippy\", deny(clippy, clippy_pedantic))]\n// Ignored clippy lints\n#![cfg_attr(feature = \"cargo-clippy\", allow(float_cmp))]\n// Ignored clippy_pedantic lints\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        empty_line_after_outer_attr,\n        missing_docs_in_private_items,\n        module_name_repetitions,\n        redundant_field_names,\n        use_debug,\n        use_self\n    )\n)]\n\n#[macro_use]\nextern crate serde;\n\nmod de;\nmod error;\nmod ser;\n\nmod assert;\nmod configure;\nmod token;\n\npub use assert::{\n    assert_de_tokens, assert_de_tokens_error, assert_ser_tokens, assert_ser_tokens_error,\n    assert_tokens,\n};\npub use token::Token;\n\npub use configure::{Compact, Configure, Readable};\n\n// Not public API.\n#[doc(hidden)]\npub use de::Deserializer;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","ser.rs"],"content":"use serde::{ser, Serialize};\n\nuse error::Error;\nuse token::Token;\n\n/// A `Serializer` that ensures that a value serializes to a given list of\n/// tokens.\n#[derive(Debug)]\npub struct Serializer\u003c'a\u003e {\n    tokens: \u0026'a [Token],\n}\n\nimpl\u003c'a\u003e Serializer\u003c'a\u003e {\n    /// Creates the serializer.\n    pub fn new(tokens: \u0026'a [Token]) -\u003e Self {\n        Serializer { tokens: tokens }\n    }\n\n    /// Pulls the next token off of the serializer, ignoring it.\n    fn next_token(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if let Some((\u0026first, rest)) = self.tokens.split_first() {\n            self.tokens = rest;\n            Some(first)\n        } else {\n            None\n        }\n    }\n\n    pub fn remaining(\u0026self) -\u003e usize {\n        self.tokens.len()\n    }\n}\n\nmacro_rules! assert_next_token {\n    ($ser:expr, $expected:ident) =\u003e {\n        assert_next_token!($ser, stringify!($expected), Token::$expected, true);\n    };\n    ($ser:expr, $expected:ident($v:expr)) =\u003e {\n        assert_next_token!(\n            $ser,\n            format_args!(concat!(stringify!($expected), \"({:?})\"), $v),\n            Token::$expected(v),\n            v == $v\n        );\n    };\n    ($ser:expr, $expected:ident { $($k:ident),* }) =\u003e {\n        let compare = ($($k,)*);\n        let field_format = || {\n            use std::fmt::Write;\n            let mut buffer = String::new();\n            $(\n                write!(\u0026mut buffer, concat!(stringify!($k), \": {:?}, \"), $k).unwrap();\n            )*\n            buffer\n        };\n        assert_next_token!(\n            $ser,\n            format_args!(concat!(stringify!($expected), \" {{ {}}}\"), field_format()),\n            Token::$expected { $($k),* },\n            ($($k,)*) == compare\n        );\n    };\n    ($ser:expr, $expected:expr, $pat:pat, $guard:expr) =\u003e {\n        match $ser.next_token() {\n            Some($pat) if $guard =\u003e {}\n            Some(other) =\u003e {\n                panic!(\"expected Token::{} but serialized as {}\",\n                       $expected, other);\n            }\n            None =\u003e {\n                panic!(\"expected Token::{} after end of serialized tokens\",\n                       $expected);\n            }\n        }\n    };\n}\n\nimpl\u003c's, 'a\u003e ser::Serializer for \u0026's mut Serializer\u003c'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    type SerializeSeq = Self;\n    type SerializeTuple = Self;\n    type SerializeTupleStruct = Self;\n    type SerializeTupleVariant = Variant\u003c's, 'a\u003e;\n    type SerializeMap = Self;\n    type SerializeStruct = Self;\n    type SerializeStructVariant = Variant\u003c's, 'a\u003e;\n\n    fn serialize_bool(self, v: bool) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, Bool(v));\n        Ok(())\n    }\n\n    fn serialize_i8(self, v: i8) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, I8(v));\n        Ok(())\n    }\n\n    fn serialize_i16(self, v: i16) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, I16(v));\n        Ok(())\n    }\n\n    fn serialize_i32(self, v: i32) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, I32(v));\n        Ok(())\n    }\n\n    fn serialize_i64(self, v: i64) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, I64(v));\n        Ok(())\n    }\n\n    fn serialize_u8(self, v: u8) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, U8(v));\n        Ok(())\n    }\n\n    fn serialize_u16(self, v: u16) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, U16(v));\n        Ok(())\n    }\n\n    fn serialize_u32(self, v: u32) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, U32(v));\n        Ok(())\n    }\n\n    fn serialize_u64(self, v: u64) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, U64(v));\n        Ok(())\n    }\n\n    fn serialize_f32(self, v: f32) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, F32(v));\n        Ok(())\n    }\n\n    fn serialize_f64(self, v: f64) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, F64(v));\n        Ok(())\n    }\n\n    fn serialize_char(self, v: char) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, Char(v));\n        Ok(())\n    }\n\n    fn serialize_str(self, v: \u0026str) -\u003e Result\u003c(), Error\u003e {\n        match self.tokens.first() {\n            Some(\u0026Token::BorrowedStr(_)) =\u003e assert_next_token!(self, BorrowedStr(v)),\n            Some(\u0026Token::String(_)) =\u003e assert_next_token!(self, String(v)),\n            _ =\u003e assert_next_token!(self, Str(v)),\n        }\n        Ok(())\n    }\n\n    fn serialize_bytes(self, v: \u0026[u8]) -\u003e Result\u003c(), Self::Error\u003e {\n        match self.tokens.first() {\n            Some(\u0026Token::BorrowedBytes(_)) =\u003e assert_next_token!(self, BorrowedBytes(v)),\n            Some(\u0026Token::ByteBuf(_)) =\u003e assert_next_token!(self, ByteBuf(v)),\n            _ =\u003e assert_next_token!(self, Bytes(v)),\n        }\n        Ok(())\n    }\n\n    fn serialize_unit(self) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, Unit);\n        Ok(())\n    }\n\n    fn serialize_unit_struct(self, name: \u0026'static str) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, UnitStruct { name });\n        Ok(())\n    }\n\n    fn serialize_unit_variant(\n        self,\n        name: \u0026'static str,\n        _variant_index: u32,\n        variant: \u0026'static str,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if self.tokens.first() == Some(\u0026Token::Enum { name: name }) {\n            self.next_token();\n            assert_next_token!(self, Str(variant));\n            assert_next_token!(self, Unit);\n        } else {\n            assert_next_token!(self, UnitVariant { name, variant });\n        }\n        Ok(())\n    }\n\n    fn serialize_newtype_struct\u003cT: ?Sized\u003e(self, name: \u0026'static str, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        assert_next_token!(self, NewtypeStruct { name });\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n        self,\n        name: \u0026'static str,\n        _variant_index: u32,\n        variant: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        if self.tokens.first() == Some(\u0026Token::Enum { name: name }) {\n            self.next_token();\n            assert_next_token!(self, Str(variant));\n        } else {\n            assert_next_token!(self, NewtypeVariant { name, variant });\n        }\n        value.serialize(self)\n    }\n\n    fn serialize_none(self) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, None);\n        Ok(())\n    }\n\n    fn serialize_some\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        assert_next_token!(self, Some);\n        value.serialize(self)\n    }\n\n    fn serialize_seq(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        assert_next_token!(self, Seq { len });\n        Ok(self)\n    }\n\n    fn serialize_tuple(self, len: usize) -\u003e Result\u003cSelf, Error\u003e {\n        assert_next_token!(self, Tuple { len });\n        Ok(self)\n    }\n\n    fn serialize_tuple_struct(self, name: \u0026'static str, len: usize) -\u003e Result\u003cSelf, Error\u003e {\n        assert_next_token!(self, TupleStruct { name, len });\n        Ok(self)\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        name: \u0026'static str,\n        _variant_index: u32,\n        variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleVariant, Error\u003e {\n        if self.tokens.first() == Some(\u0026Token::Enum { name: name }) {\n            self.next_token();\n            assert_next_token!(self, Str(variant));\n            let len = Some(len);\n            assert_next_token!(self, Seq { len });\n            Ok(Variant {\n                ser: self,\n                end: Token::SeqEnd,\n            })\n        } else {\n            assert_next_token!(self, TupleVariant { name, variant, len });\n            Ok(Variant {\n                ser: self,\n                end: Token::TupleVariantEnd,\n            })\n        }\n    }\n\n    fn serialize_map(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        assert_next_token!(self, Map { len });\n        Ok(self)\n    }\n\n    fn serialize_struct(self, name: \u0026'static str, len: usize) -\u003e Result\u003cSelf, Error\u003e {\n        assert_next_token!(self, Struct { name, len });\n        Ok(self)\n    }\n\n    fn serialize_struct_variant(\n        self,\n        name: \u0026'static str,\n        _variant_index: u32,\n        variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStructVariant, Error\u003e {\n        if self.tokens.first() == Some(\u0026Token::Enum { name: name }) {\n            self.next_token();\n            assert_next_token!(self, Str(variant));\n            let len = Some(len);\n            assert_next_token!(self, Map { len });\n            Ok(Variant {\n                ser: self,\n                end: Token::MapEnd,\n            })\n        } else {\n            assert_next_token!(self, StructVariant { name, variant, len });\n            Ok(Variant {\n                ser: self,\n                end: Token::StructVariantEnd,\n            })\n        }\n    }\n\n    fn is_human_readable(\u0026self) -\u003e bool {\n        panic!(\n            \"Types which have different human-readable and compact representations \\\n             must explicitly mark their test cases with `serde_test::Configure`\"\n        );\n    }\n}\n\npub struct Variant\u003c's, 'a: 's\u003e {\n    ser: \u0026's mut Serializer\u003c'a\u003e,\n    end: Token,\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeSeq for \u0026's mut Serializer\u003c'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(\u0026mut **self)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, SeqEnd);\n        Ok(())\n    }\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeTuple for \u0026's mut Serializer\u003c'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(\u0026mut **self)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, TupleEnd);\n        Ok(())\n    }\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeTupleStruct for \u0026's mut Serializer\u003c'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(\u0026mut **self)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, TupleStructEnd);\n        Ok(())\n    }\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeTupleVariant for Variant\u003c's, 'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(\u0026mut *self.ser)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Error\u003e {\n        match self.end {\n            Token::TupleVariantEnd =\u003e assert_next_token!(self.ser, TupleVariantEnd),\n            Token::SeqEnd =\u003e assert_next_token!(self.ser, SeqEnd),\n            _ =\u003e unreachable!(),\n        }\n        Ok(())\n    }\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeMap for \u0026's mut Serializer\u003c'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        key.serialize(\u0026mut **self)\n    }\n\n    fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(\u0026mut **self)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Self::Error\u003e {\n        assert_next_token!(self, MapEnd);\n        Ok(())\n    }\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeStruct for \u0026's mut Serializer\u003c'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        key.serialize(\u0026mut **self)?;\n        value.serialize(\u0026mut **self)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Self::Error\u003e {\n        assert_next_token!(self, StructEnd);\n        Ok(())\n    }\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeStructVariant for Variant\u003c's, 'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        key.serialize(\u0026mut *self.ser)?;\n        value.serialize(\u0026mut *self.ser)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Self::Error\u003e {\n        match self.end {\n            Token::StructVariantEnd =\u003e assert_next_token!(self.ser, StructVariantEnd),\n            Token::MapEnd =\u003e assert_next_token!(self.ser, MapEnd),\n            _ =\u003e unreachable!(),\n        }\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","token.rs"],"content":"use std::fmt::{self, Debug, Display};\n\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum Token {\n    /// A serialized `bool`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u0026true, \u0026[Token::Bool(true)]);\n    /// ```\n    Bool(bool),\n\n    /// A serialized `i8`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260i8, \u0026[Token::I8(0)]);\n    /// ```\n    I8(i8),\n\n    /// A serialized `i16`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260i16, \u0026[Token::I16(0)]);\n    /// ```\n    I16(i16),\n\n    /// A serialized `i32`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260i32, \u0026[Token::I32(0)]);\n    /// ```\n    I32(i32),\n\n    /// A serialized `i64`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260i64, \u0026[Token::I64(0)]);\n    /// ```\n    I64(i64),\n\n    /// A serialized `u8`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260u8, \u0026[Token::U8(0)]);\n    /// ```\n    U8(u8),\n\n    /// A serialized `u16`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260u16, \u0026[Token::U16(0)]);\n    /// ```\n    U16(u16),\n\n    /// A serialized `u32`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260u32, \u0026[Token::U32(0)]);\n    /// ```\n    U32(u32),\n\n    /// A serialized `u64`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260u64, \u0026[Token::U64(0)]);\n    /// ```\n    U64(u64),\n\n    /// A serialized `f32`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260f32, \u0026[Token::F32(0.0)]);\n    /// ```\n    F32(f32),\n\n    /// A serialized `f64`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260f64, \u0026[Token::F64(0.0)]);\n    /// ```\n    F64(f64),\n\n    /// A serialized `char`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u0026'\\n', \u0026[Token::Char('\\n')]);\n    /// ```\n    Char(char),\n\n    /// A serialized `str`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let s = String::from(\"transient\");\n    /// assert_tokens(\u0026s, \u0026[Token::Str(\"transient\")]);\n    /// ```\n    Str(\u0026'static str),\n\n    /// A borrowed `str`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let s: \u0026str = \"borrowed\";\n    /// assert_tokens(\u0026s, \u0026[Token::BorrowedStr(\"borrowed\")]);\n    /// ```\n    BorrowedStr(\u0026'static str),\n\n    /// A serialized `String`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let s = String::from(\"owned\");\n    /// assert_tokens(\u0026s, \u0026[Token::String(\"owned\")]);\n    /// ```\n    String(\u0026'static str),\n\n    /// A serialized `[u8]`\n    Bytes(\u0026'static [u8]),\n\n    /// A borrowed `[u8]`.\n    BorrowedBytes(\u0026'static [u8]),\n\n    /// A serialized `ByteBuf`\n    ByteBuf(\u0026'static [u8]),\n\n    /// A serialized `Option\u003cT\u003e` containing none.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let opt = None::\u003cchar\u003e;\n    /// assert_tokens(\u0026opt, \u0026[Token::None]);\n    /// ```\n    None,\n\n    /// The header to a serialized `Option\u003cT\u003e` containing some value.\n    ///\n    /// The tokens of the value follow after this header.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let opt = Some('c');\n    /// assert_tokens(\u0026opt, \u0026[\n    ///     Token::Some,\n    ///     Token::Char('c'),\n    /// ]);\n    /// ```\n    Some,\n\n    /// A serialized `()`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u0026(), \u0026[Token::Unit]);\n    /// ```\n    Unit,\n\n    /// A serialized unit struct of the given name.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// struct X;\n    ///\n    /// assert_tokens(\u0026X, \u0026[Token::UnitStruct { name: \"X\" }]);\n    /// # }\n    /// ```\n    UnitStruct { name: \u0026'static str },\n\n    /// A unit variant of an enum.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     A,\n    /// }\n    ///\n    /// let a = E::A;\n    /// assert_tokens(\u0026a, \u0026[Token::UnitVariant { name: \"E\", variant: \"A\" }]);\n    /// # }\n    /// ```\n    UnitVariant {\n        name: \u0026'static str,\n        variant: \u0026'static str,\n    },\n\n    /// The header to a serialized newtype struct of the given name.\n    ///\n    /// After this header is the value contained in the newtype struct.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// struct N(String);\n    ///\n    /// let n = N(\"newtype\".to_owned());\n    /// assert_tokens(\u0026n, \u0026[\n    ///     Token::NewtypeStruct { name: \"N\" },\n    ///     Token::String(\"newtype\"),\n    /// ]);\n    /// # }\n    /// ```\n    NewtypeStruct { name: \u0026'static str },\n\n    /// The header to a newtype variant of an enum.\n    ///\n    /// After this header is the value contained in the newtype variant.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     B(u8),\n    /// }\n    ///\n    /// let b = E::B(0);\n    /// assert_tokens(\u0026b, \u0026[\n    ///     Token::NewtypeVariant { name: \"E\", variant: \"B\" },\n    ///     Token::U8(0),\n    /// ]);\n    /// # }\n    /// ```\n    NewtypeVariant {\n        name: \u0026'static str,\n        variant: \u0026'static str,\n    },\n\n    /// The header to a sequence.\n    ///\n    /// After this header are the elements of the sequence, followed by\n    /// `SeqEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let vec = vec!['a', 'b', 'c'];\n    /// assert_tokens(\u0026vec, \u0026[\n    ///     Token::Seq { len: Some(3) },\n    ///     Token::Char('a'),\n    ///     Token::Char('b'),\n    ///     Token::Char('c'),\n    ///     Token::SeqEnd,\n    /// ]);\n    /// ```\n    Seq { len: Option\u003cusize\u003e },\n\n    /// An indicator of the end of a sequence.\n    SeqEnd,\n\n    /// The header to a tuple.\n    ///\n    /// After this header are the elements of the tuple, followed by `TupleEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let tuple = ('a', 100);\n    /// assert_tokens(\u0026tuple, \u0026[\n    ///     Token::Tuple { len: 2 },\n    ///     Token::Char('a'),\n    ///     Token::I32(100),\n    ///     Token::TupleEnd,\n    /// ]);\n    /// ```\n    Tuple { len: usize },\n\n    /// An indicator of the end of a tuple.\n    TupleEnd,\n\n    /// The header to a tuple struct.\n    ///\n    /// After this header are the fields of the tuple struct, followed by\n    /// `TupleStructEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// struct T(u8, u8);\n    ///\n    /// let t = T(0, 0);\n    /// assert_tokens(\u0026t, \u0026[\n    ///     Token::TupleStruct { name: \"T\", len: 2 },\n    ///     Token::U8(0),\n    ///     Token::U8(0),\n    ///     Token::TupleStructEnd,\n    /// ]);\n    /// # }\n    /// ```\n    TupleStruct { name: \u0026'static str, len: usize },\n\n    /// An indicator of the end of a tuple struct.\n    TupleStructEnd,\n\n    /// The header to a tuple variant of an enum.\n    ///\n    /// After this header are the fields of the tuple variant, followed by\n    /// `TupleVariantEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     C(u8, u8),\n    /// }\n    ///\n    /// let c = E::C(0, 0);\n    /// assert_tokens(\u0026c, \u0026[\n    ///     Token::TupleVariant { name: \"E\", variant: \"C\", len: 2 },\n    ///     Token::U8(0),\n    ///     Token::U8(0),\n    ///     Token::TupleVariantEnd,\n    /// ]);\n    /// # }\n    /// ```\n    TupleVariant {\n        name: \u0026'static str,\n        variant: \u0026'static str,\n        len: usize,\n    },\n\n    /// An indicator of the end of a tuple variant.\n    TupleVariantEnd,\n\n    /// The header to a map.\n    ///\n    /// After this header are the entries of the map, followed by `MapEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert('A', 65);\n    /// map.insert('Z', 90);\n    ///\n    /// assert_tokens(\u0026map, \u0026[\n    ///     Token::Map { len: Some(2) },\n    ///     Token::Char('A'),\n    ///     Token::I32(65),\n    ///     Token::Char('Z'),\n    ///     Token::I32(90),\n    ///     Token::MapEnd,\n    /// ]);\n    /// ```\n    Map { len: Option\u003cusize\u003e },\n\n    /// An indicator of the end of a map.\n    MapEnd,\n\n    /// The header of a struct.\n    ///\n    /// After this header are the fields of the struct, followed by `StructEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// struct S {\n    ///     a: u8,\n    ///     b: u8,\n    /// }\n    ///\n    /// let s = S { a: 0, b: 0 };\n    /// assert_tokens(\u0026s, \u0026[\n    ///     Token::Struct { name: \"S\", len: 2 },\n    ///     Token::Str(\"a\"),\n    ///     Token::U8(0),\n    ///     Token::Str(\"b\"),\n    ///     Token::U8(0),\n    ///     Token::StructEnd,\n    /// ]);\n    /// # }\n    /// ```\n    Struct { name: \u0026'static str, len: usize },\n\n    /// An indicator of the end of a struct.\n    StructEnd,\n\n    /// The header of a struct variant of an enum.\n    ///\n    /// After this header are the fields of the struct variant, followed by\n    /// `StructVariantEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     D { d: u8 },\n    /// }\n    ///\n    /// let d = E::D { d: 0 };\n    /// assert_tokens(\u0026d, \u0026[\n    ///     Token::StructVariant { name: \"E\", variant: \"D\", len: 1 },\n    ///     Token::Str(\"d\"),\n    ///     Token::U8(0),\n    ///     Token::StructVariantEnd,\n    /// ]);\n    /// # }\n    /// ```\n    StructVariant {\n        name: \u0026'static str,\n        variant: \u0026'static str,\n        len: usize,\n    },\n\n    /// An indicator of the end of a struct variant.\n    StructVariantEnd,\n\n    /// The header to an enum of the given name.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     A,\n    ///     B(u8),\n    ///     C(u8, u8),\n    ///     D { d: u8 },\n    /// }\n    ///\n    /// let a = E::A;\n    /// assert_tokens(\u0026a, \u0026[\n    ///     Token::Enum { name: \"E\" },\n    ///     Token::Str(\"A\"),\n    ///     Token::Unit,\n    /// ]);\n    ///\n    /// let b = E::B(0);\n    /// assert_tokens(\u0026b, \u0026[\n    ///     Token::Enum { name: \"E\" },\n    ///     Token::Str(\"B\"),\n    ///     Token::U8(0),\n    /// ]);\n    ///\n    /// let c = E::C(0, 0);\n    /// assert_tokens(\u0026c, \u0026[\n    ///     Token::Enum { name: \"E\" },\n    ///     Token::Str(\"C\"),\n    ///     Token::Seq { len: Some(2) },\n    ///     Token::U8(0),\n    ///     Token::U8(0),\n    ///     Token::SeqEnd,\n    /// ]);\n    ///\n    /// let d = E::D { d: 0 };\n    /// assert_tokens(\u0026d, \u0026[\n    ///     Token::Enum { name: \"E\" },\n    ///     Token::Str(\"D\"),\n    ///     Token::Map { len: Some(1) },\n    ///     Token::Str(\"d\"),\n    ///     Token::U8(0),\n    ///     Token::MapEnd,\n    /// ]);\n    /// # }\n    /// ```\n    Enum { name: \u0026'static str },\n}\n\nimpl Display for Token {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        Debug::fmt(self, formatter)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","no_std","src","main.rs"],"content":"#![feature(lang_items, start)]\n#![no_std]\n\n#[start]\nfn start(_argc: isize, _argv: *const *const u8) -\u003e isize {\n    0\n}\n\n#[lang = \"eh_personality\"]\n#[no_mangle]\npub extern \"C\" fn rust_eh_personality() {}\n\n#[panic_handler]\nfn panic(_info: \u0026core::panic::PanicInfo) -\u003e ! {\n    unsafe {\n        libc::abort();\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize)]\nstruct Unit;\n\n#[derive(Serialize, Deserialize)]\nstruct Newtype(u8);\n\n#[derive(Serialize, Deserialize)]\nstruct Tuple(u8, u8);\n\n#[derive(Serialize, Deserialize)]\nstruct Struct {\n    f: u8,\n}\n\n#[derive(Serialize, Deserialize)]\nenum Enum {\n    Unit,\n    Newtype(u8),\n    Tuple(u8, u8),\n    Struct { f: u8 },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","bytes","mod.rs"],"content":"use serde::de::{Deserializer, Error, SeqAccess, Visitor};\nuse std::fmt;\n\npub fn deserialize\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003cVec\u003cu8\u003e, D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    deserializer.deserialize_byte_buf(ByteBufVisitor)\n}\n\nstruct ByteBufVisitor;\n\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for ByteBufVisitor {\n    type Value = Vec\u003cu8\u003e;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"byte array\")\n    }\n\n    fn visit_seq\u003cV\u003e(self, mut visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n    where\n        V: SeqAccess\u003c'de\u003e,\n    {\n        let mut values = Vec::new();\n        while let Some(value) = visitor.next_element()? {\n            values.push(value);\n        }\n        Ok(values)\n    }\n\n    fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v.to_vec())\n    }\n\n    fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v.as_bytes().to_vec())\n    }\n\n    fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v.into_bytes())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","compiletest.rs"],"content":"#[cfg(not(target_os = \"emscripten\"))]\n#[rustversion::attr(not(nightly), ignore)]\n#[test]\nfn ui() {\n    let t = trybuild::TestCases::new();\n    t.compile_fail(\"tests/ui/**/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","macros","mod.rs"],"content":"macro_rules! btreeset {\n    () =\u003e {\n        BTreeSet::new()\n    };\n    ($($value:expr),+) =\u003e {\n        {\n            let mut set = BTreeSet::new();\n            $(set.insert($value);)+\n            set\n        }\n    }\n}\n\nmacro_rules! btreemap {\n    () =\u003e {\n        BTreeMap::new()\n    };\n    ($($key:expr =\u003e $value:expr),+) =\u003e {\n        {\n            let mut map = BTreeMap::new();\n            $(map.insert($key, $value);)+\n            map\n        }\n    }\n}\n\nmacro_rules! hashset {\n    () =\u003e {\n        HashSet::new()\n    };\n    ($($value:expr),+) =\u003e {\n        {\n            let mut set = HashSet::new();\n            $(set.insert($value);)+\n            set\n        }\n    };\n    ($hasher:ident @ $($value:expr),+) =\u003e {\n        {\n            use std::hash::BuildHasherDefault;\n            let mut set = HashSet::with_hasher(BuildHasherDefault::\u003c$hasher\u003e::default());\n            $(set.insert($value);)+\n            set\n        }\n    }\n}\n\nmacro_rules! hashmap {\n    () =\u003e {\n        HashMap::new()\n    };\n    ($($key:expr =\u003e $value:expr),+) =\u003e {\n        {\n            let mut map = HashMap::new();\n            $(map.insert($key, $value);)+\n            map\n        }\n    };\n    ($hasher:ident @ $($key:expr =\u003e $value:expr),+) =\u003e {\n        {\n            use std::hash::BuildHasherDefault;\n            let mut map = HashMap::with_hasher(BuildHasherDefault::\u003c$hasher\u003e::default());\n            $(map.insert($key, $value);)+\n            map\n        }\n    }\n}\n\nmacro_rules! seq_impl {\n    (seq $first:expr,) =\u003e {\n        seq_impl!(seq $first)\n    };\n    ($first:expr,) =\u003e {\n        seq_impl!($first)\n    };\n    (seq $first:expr) =\u003e {\n        $first.into_iter()\n    };\n    ($first:expr) =\u003e {\n        Some($first).into_iter()\n    };\n    (seq $first:expr , $( $elem: tt)*) =\u003e {\n        $first.into_iter().chain(seq!( $($elem)* ))\n    };\n    ($first:expr , $($elem: tt)*) =\u003e {\n        Some($first).into_iter().chain(seq!( $($elem)* ))\n    }\n}\nmacro_rules! seq {\n    ($($tt: tt)*) =\u003e {\n        seq_impl!($($tt)*).collect::\u003cVec\u003c_\u003e\u003e()\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_annotations.rs"],"content":"#![allow(clippy::cast_lossless, clippy::trivially_copy_pass_by_ref)]\n\nuse serde::de::{self, MapAccess, Unexpected, Visitor};\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\nuse std::collections::{BTreeMap, HashMap};\nuse std::convert::TryFrom;\nuse std::fmt;\nuse std::marker::PhantomData;\n\nuse serde_test::{\n    assert_de_tokens, assert_de_tokens_error, assert_ser_tokens, assert_ser_tokens_error,\n    assert_tokens, Token,\n};\n\ntrait MyDefault: Sized {\n    fn my_default() -\u003e Self;\n}\n\ntrait ShouldSkip: Sized {\n    fn should_skip(\u0026self) -\u003e bool;\n}\n\ntrait SerializeWith: Sized {\n    fn serialize_with\u003cS\u003e(\u0026self, ser: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer;\n}\n\ntrait DeserializeWith: Sized {\n    fn deserialize_with\u003c'de, D\u003e(de: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e;\n}\n\nimpl MyDefault for i32 {\n    fn my_default() -\u003e Self {\n        123\n    }\n}\n\nimpl ShouldSkip for i32 {\n    fn should_skip(\u0026self) -\u003e bool {\n        *self == 123\n    }\n}\n\nimpl SerializeWith for i32 {\n    fn serialize_with\u003cS\u003e(\u0026self, ser: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if *self == 123 {\n            true.serialize(ser)\n        } else {\n            false.serialize(ser)\n        }\n    }\n}\n\nimpl DeserializeWith for i32 {\n    fn deserialize_with\u003c'de, D\u003e(de: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        if Deserialize::deserialize(de)? {\n            Ok(123)\n        } else {\n            Ok(2)\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct DefaultStruct\u003cA, B, C, D, E\u003e\nwhere\n    C: MyDefault,\n    E: MyDefault,\n{\n    a1: A,\n    #[serde(default)]\n    a2: B,\n    #[serde(default = \"MyDefault::my_default\")]\n    a3: C,\n    #[serde(skip_deserializing)]\n    a4: D,\n    #[serde(skip_deserializing, default = \"MyDefault::my_default\")]\n    a5: E,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct DefaultTupleStruct\u003cA, B, C\u003e(\n    A,\n    #[serde(default)] B,\n    #[serde(default = \"MyDefault::my_default\")] C,\n)\nwhere\n    C: MyDefault;\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct CollectOther {\n    a: u32,\n    b: u32,\n    #[serde(flatten)]\n    extra: HashMap\u003cString, u32\u003e,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct FlattenStructEnumWrapper {\n    #[serde(flatten)]\n    data: FlattenStructEnum,\n    #[serde(flatten)]\n    extra: HashMap\u003cString, String\u003e,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\nenum FlattenStructEnum {\n    InsertInteger { index: u32, value: u32 },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct FlattenStructTagContentEnumWrapper {\n    outer: u32,\n    #[serde(flatten)]\n    data: FlattenStructTagContentEnumNewtype,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct FlattenStructTagContentEnumNewtype(pub FlattenStructTagContentEnum);\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\", tag = \"type\", content = \"value\")]\nenum FlattenStructTagContentEnum {\n    InsertInteger { index: u32, value: u32 },\n    NewtypeVariant(FlattenStructTagContentEnumNewtypeVariant),\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct FlattenStructTagContentEnumNewtypeVariant {\n    value: u32,\n}\n\n#[test]\nfn test_default_struct() {\n    assert_de_tokens(\n        \u0026DefaultStruct {\n            a1: 1,\n            a2: 2,\n            a3: 3,\n            a4: 0,\n            a5: 123,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"DefaultStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a2\"),\n            Token::I32(2),\n            Token::Str(\"a3\"),\n            Token::I32(3),\n            Token::Str(\"a4\"),\n            Token::I32(4),\n            Token::Str(\"a5\"),\n            Token::I32(5),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DefaultStruct {\n            a1: 1,\n            a2: 0,\n            a3: 123,\n            a4: 0,\n            a5: 123,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"DefaultStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_default_tuple() {\n    assert_de_tokens(\n        \u0026DefaultTupleStruct(1, 2, 3),\n        \u0026[\n            Token::TupleStruct {\n                name: \"DefaultTupleStruct\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::I32(2),\n            Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DefaultTupleStruct(1, 0, 123),\n        \u0026[\n            Token::TupleStruct {\n                name: \"DefaultTupleStruct\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum DefaultStructVariant\u003cA, B, C, D, E\u003e\nwhere\n    C: MyDefault,\n    E: MyDefault,\n{\n    Struct {\n        a1: A,\n        #[serde(default)]\n        a2: B,\n        #[serde(default = \"MyDefault::my_default\")]\n        a3: C,\n        #[serde(skip_deserializing)]\n        a4: D,\n        #[serde(skip_deserializing, default = \"MyDefault::my_default\")]\n        a5: E,\n    },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum DefaultTupleVariant\u003cA, B, C\u003e\nwhere\n    C: MyDefault,\n{\n    Tuple(\n        A,\n        #[serde(default)] B,\n        #[serde(default = \"MyDefault::my_default\")] C,\n    ),\n}\n\n#[test]\nfn test_default_struct_variant() {\n    assert_de_tokens(\n        \u0026DefaultStructVariant::Struct {\n            a1: 1,\n            a2: 2,\n            a3: 3,\n            a4: 0,\n            a5: 123,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"DefaultStructVariant\",\n                variant: \"Struct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a2\"),\n            Token::I32(2),\n            Token::Str(\"a3\"),\n            Token::I32(3),\n            Token::Str(\"a4\"),\n            Token::I32(4),\n            Token::Str(\"a5\"),\n            Token::I32(5),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DefaultStructVariant::Struct {\n            a1: 1,\n            a2: 0,\n            a3: 123,\n            a4: 0,\n            a5: 123,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"DefaultStructVariant\",\n                variant: \"Struct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_default_tuple_variant() {\n    assert_de_tokens(\n        \u0026DefaultTupleVariant::Tuple(1, 2, 3),\n        \u0026[\n            Token::TupleVariant {\n                name: \"DefaultTupleVariant\",\n                variant: \"Tuple\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::I32(2),\n            Token::I32(3),\n            Token::TupleVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DefaultTupleVariant::Tuple(1, 0, 123),\n        \u0026[\n            Token::TupleVariant {\n                name: \"DefaultTupleVariant\",\n                variant: \"Tuple\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n// Does not implement std::default::Default.\n#[derive(Debug, PartialEq, Deserialize)]\nstruct NoStdDefault(i8);\n\nimpl MyDefault for NoStdDefault {\n    fn my_default() -\u003e Self {\n        NoStdDefault(123)\n    }\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct ContainsNoStdDefault\u003cA: MyDefault\u003e {\n    #[serde(default = \"MyDefault::my_default\")]\n    a: A,\n}\n\n// Tests that a struct field does not need to implement std::default::Default if\n// it is annotated with `default=...`.\n#[test]\nfn test_no_std_default() {\n    assert_de_tokens(\n        \u0026ContainsNoStdDefault {\n            a: NoStdDefault(123),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"ContainsNoStdDefault\",\n                len: 1,\n            },\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026ContainsNoStdDefault { a: NoStdDefault(8) },\n        \u0026[\n            Token::Struct {\n                name: \"ContainsNoStdDefault\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::NewtypeStruct {\n                name: \"NoStdDefault\",\n            },\n            Token::I8(8),\n            Token::StructEnd,\n        ],\n    );\n}\n\n// Does not implement Deserialize.\n#[derive(Debug, PartialEq)]\nstruct NotDeserializeStruct(i8);\n\nimpl Default for NotDeserializeStruct {\n    fn default() -\u003e Self {\n        NotDeserializeStruct(123)\n    }\n}\n\nimpl DeserializeWith for NotDeserializeStruct {\n    fn deserialize_with\u003c'de, D\u003e(_: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        panic!()\n    }\n}\n\n// Does not implement Deserialize.\n#[derive(Debug, PartialEq)]\nenum NotDeserializeEnum {\n    Trouble,\n}\n\nimpl MyDefault for NotDeserializeEnum {\n    fn my_default() -\u003e Self {\n        NotDeserializeEnum::Trouble\n    }\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct ContainsNotDeserialize\u003cA, B, C: DeserializeWith, E: MyDefault\u003e {\n    #[serde(skip_deserializing)]\n    a: A,\n    #[serde(skip_deserializing, default)]\n    b: B,\n    #[serde(deserialize_with = \"DeserializeWith::deserialize_with\", default)]\n    c: C,\n    #[serde(skip_deserializing, default = \"MyDefault::my_default\")]\n    e: E,\n}\n\n// Tests that a struct field does not need to implement Deserialize if it is\n// annotated with skip_deserializing, whether using the std Default or a\n// custom default.\n#[test]\nfn test_elt_not_deserialize() {\n    assert_de_tokens(\n        \u0026ContainsNotDeserialize {\n            a: NotDeserializeStruct(123),\n            b: NotDeserializeStruct(123),\n            c: NotDeserializeStruct(123),\n            e: NotDeserializeEnum::Trouble,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"ContainsNotDeserialize\",\n                len: 1,\n            },\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(deny_unknown_fields)]\nstruct DenyUnknown {\n    a1: i32,\n}\n\n#[test]\nfn test_ignore_unknown() {\n    // 'Default' allows unknown. Basic smoke test of ignore...\n    assert_de_tokens(\n        \u0026DefaultStruct {\n            a1: 1,\n            a2: 2,\n            a3: 3,\n            a4: 0,\n            a5: 123,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"DefaultStruct\",\n                len: 3,\n            },\n            Token::Str(\"whoops1\"),\n            Token::I32(2),\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"whoops2\"),\n            Token::Seq { len: Some(1) },\n            Token::I32(2),\n            Token::SeqEnd,\n            Token::Str(\"a2\"),\n            Token::I32(2),\n            Token::Str(\"whoops3\"),\n            Token::I32(2),\n            Token::Str(\"a3\"),\n            Token::I32(3),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens_error::\u003cDenyUnknown\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"DenyUnknown\",\n                len: 1,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"whoops\"),\n        ],\n        \"unknown field `whoops`, expected `a1`\",\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename = \"Superhero\")]\nstruct RenameStruct {\n    a1: i32,\n    #[serde(rename = \"a3\")]\n    a2: i32,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename(serialize = \"SuperheroSer\", deserialize = \"SuperheroDe\"))]\nstruct RenameStructSerializeDeserialize {\n    a1: i32,\n    #[serde(rename(serialize = \"a4\", deserialize = \"a5\"))]\n    a2: i32,\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\n#[serde(deny_unknown_fields)]\nstruct AliasStruct {\n    a1: i32,\n    #[serde(alias = \"a3\")]\n    a2: i32,\n    #[serde(alias = \"a5\", rename = \"a6\")]\n    a4: i32,\n}\n\n#[test]\nfn test_rename_struct() {\n    assert_tokens(\n        \u0026RenameStruct { a1: 1, a2: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"Superhero\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a3\"),\n            Token::I32(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026RenameStructSerializeDeserialize { a1: 1, a2: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"SuperheroSer\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a4\"),\n            Token::I32(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026RenameStructSerializeDeserialize { a1: 1, a2: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"SuperheroDe\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a5\"),\n            Token::I32(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026AliasStruct {\n            a1: 1,\n            a2: 2,\n            a4: 3,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"AliasStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a2\"),\n            Token::I32(2),\n            Token::Str(\"a5\"),\n            Token::I32(3),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026AliasStruct {\n            a1: 1,\n            a2: 2,\n            a4: 3,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"AliasStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a3\"),\n            Token::I32(2),\n            Token::Str(\"a6\"),\n            Token::I32(3),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_unknown_field_rename_struct() {\n    assert_de_tokens_error::\u003cAliasStruct\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"AliasStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a3\"),\n            Token::I32(2),\n            Token::Str(\"a4\"),\n            Token::I32(3),\n        ],\n        \"unknown field `a4`, expected one of `a1`, `a2`, `a6`\",\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename = \"Superhero\")]\nenum RenameEnum {\n    #[serde(rename = \"bruce_wayne\")]\n    Batman,\n    #[serde(rename = \"clark_kent\")]\n    Superman(i8),\n    #[serde(rename = \"diana_prince\")]\n    WonderWoman(i8, i8),\n    #[serde(rename = \"barry_allan\")]\n    Flash {\n        #[serde(rename = \"b\")]\n        a: i32,\n    },\n}\n\n#[derive(Debug, PartialEq, Deserialize, Serialize)]\n#[serde(rename(serialize = \"SuperheroSer\", deserialize = \"SuperheroDe\"))]\nenum RenameEnumSerializeDeserialize\u003cA\u003e {\n    #[serde(rename(serialize = \"dick_grayson\", deserialize = \"jason_todd\"))]\n    Robin {\n        a: i8,\n        #[serde(rename(serialize = \"c\"))]\n        #[serde(rename(deserialize = \"d\"))]\n        b: A,\n    },\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\n#[serde(deny_unknown_fields)]\nenum AliasEnum {\n    #[serde(rename = \"sailor_moon\", alias = \"usagi_tsukino\")]\n    SailorMoon {\n        a: i8,\n        #[serde(alias = \"c\")]\n        b: i8,\n        #[serde(alias = \"e\", rename = \"f\")]\n        d: i8,\n    },\n}\n\n#[test]\nfn test_rename_enum() {\n    assert_tokens(\n        \u0026RenameEnum::Batman,\n        \u0026[Token::UnitVariant {\n            name: \"Superhero\",\n            variant: \"bruce_wayne\",\n        }],\n    );\n\n    assert_tokens(\n        \u0026RenameEnum::Superman(0),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"Superhero\",\n                variant: \"clark_kent\",\n            },\n            Token::I8(0),\n        ],\n    );\n\n    assert_tokens(\n        \u0026RenameEnum::WonderWoman(0, 1),\n        \u0026[\n            Token::TupleVariant {\n                name: \"Superhero\",\n                variant: \"diana_prince\",\n                len: 2,\n            },\n            Token::I8(0),\n            Token::I8(1),\n            Token::TupleVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026RenameEnum::Flash { a: 1 },\n        \u0026[\n            Token::StructVariant {\n                name: \"Superhero\",\n                variant: \"barry_allan\",\n                len: 1,\n            },\n            Token::Str(\"b\"),\n            Token::I32(1),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026RenameEnumSerializeDeserialize::Robin {\n            a: 0,\n            b: String::new(),\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"SuperheroSer\",\n                variant: \"dick_grayson\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"c\"),\n            Token::Str(\"\"),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026RenameEnumSerializeDeserialize::Robin {\n            a: 0,\n            b: String::new(),\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"SuperheroDe\",\n                variant: \"jason_todd\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"d\"),\n            Token::Str(\"\"),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026AliasEnum::SailorMoon { a: 0, b: 1, d: 2 },\n        \u0026[\n            Token::StructVariant {\n                name: \"AliasEnum\",\n                variant: \"sailor_moon\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"b\"),\n            Token::I8(1),\n            Token::Str(\"e\"),\n            Token::I8(2),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026AliasEnum::SailorMoon { a: 0, b: 1, d: 2 },\n        \u0026[\n            Token::StructVariant {\n                name: \"AliasEnum\",\n                variant: \"usagi_tsukino\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"c\"),\n            Token::I8(1),\n            Token::Str(\"f\"),\n            Token::I8(2),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_unknown_field_rename_enum() {\n    assert_de_tokens_error::\u003cAliasEnum\u003e(\n        \u0026[Token::StructVariant {\n            name: \"AliasEnum\",\n            variant: \"SailorMoon\",\n            len: 3,\n        }],\n        \"unknown variant `SailorMoon`, expected `sailor_moon`\",\n    );\n\n    assert_de_tokens_error::\u003cAliasEnum\u003e(\n        \u0026[\n            Token::StructVariant {\n                name: \"AliasEnum\",\n                variant: \"usagi_tsukino\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"c\"),\n            Token::I8(1),\n            Token::Str(\"d\"),\n            Token::I8(2),\n        ],\n        \"unknown field `d`, expected one of `a`, `b`, `f`\",\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SkipSerializingStruct\u003c'a, B, C\u003e\nwhere\n    C: ShouldSkip,\n{\n    a: \u0026'a i8,\n    #[serde(skip_serializing)]\n    b: B,\n    #[serde(skip_serializing_if = \"ShouldSkip::should_skip\")]\n    c: C,\n}\n\n#[test]\nfn test_skip_serializing_struct() {\n    let a = 1;\n    assert_ser_tokens(\n        \u0026SkipSerializingStruct { a: \u0026a, b: 2, c: 3 },\n        \u0026[\n            Token::Struct {\n                name: \"SkipSerializingStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"c\"),\n            Token::I32(3),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SkipSerializingStruct {\n            a: \u0026a,\n            b: 2,\n            c: 123,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"SkipSerializingStruct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SkipSerializingTupleStruct\u003c'a, B, C\u003e(\n    \u0026'a i8,\n    #[serde(skip_serializing)] B,\n    #[serde(skip_serializing_if = \"ShouldSkip::should_skip\")] C,\n)\nwhere\n    C: ShouldSkip;\n\n#[test]\nfn test_skip_serializing_tuple_struct() {\n    let a = 1;\n    assert_ser_tokens(\n        \u0026SkipSerializingTupleStruct(\u0026a, 2, 3),\n        \u0026[\n            Token::TupleStruct {\n                name: \"SkipSerializingTupleStruct\",\n                len: 2,\n            },\n            Token::I8(1),\n            Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SkipSerializingTupleStruct(\u0026a, 2, 123),\n        \u0026[\n            Token::TupleStruct {\n                name: \"SkipSerializingTupleStruct\",\n                len: 1,\n            },\n            Token::I8(1),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct SkipStruct\u003cB\u003e {\n    a: i8,\n    #[serde(skip)]\n    b: B,\n}\n\n#[test]\nfn test_skip_struct() {\n    assert_ser_tokens(\n        \u0026SkipStruct { a: 1, b: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"SkipStruct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026SkipStruct { a: 1, b: 0 },\n        \u0026[\n            Token::Struct {\n                name: \"SkipStruct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nenum SkipSerializingEnum\u003c'a, B, C\u003e\nwhere\n    C: ShouldSkip,\n{\n    Struct {\n        a: \u0026'a i8,\n        #[serde(skip_serializing)]\n        _b: B,\n        #[serde(skip_serializing_if = \"ShouldSkip::should_skip\")]\n        c: C,\n    },\n    Tuple(\n        \u0026'a i8,\n        #[serde(skip_serializing)] B,\n        #[serde(skip_serializing_if = \"ShouldSkip::should_skip\")] C,\n    ),\n}\n\n#[test]\nfn test_skip_serializing_enum() {\n    let a = 1;\n    assert_ser_tokens(\n        \u0026SkipSerializingEnum::Struct { a: \u0026a, _b: 2, c: 3 },\n        \u0026[\n            Token::StructVariant {\n                name: \"SkipSerializingEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"c\"),\n            Token::I32(3),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SkipSerializingEnum::Struct {\n            a: \u0026a,\n            _b: 2,\n            c: 123,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"SkipSerializingEnum\",\n                variant: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SkipSerializingEnum::Tuple(\u0026a, 2, 3),\n        \u0026[\n            Token::TupleVariant {\n                name: \"SkipSerializingEnum\",\n                variant: \"Tuple\",\n                len: 2,\n            },\n            Token::I8(1),\n            Token::I32(3),\n            Token::TupleVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SkipSerializingEnum::Tuple(\u0026a, 2, 123),\n        \u0026[\n            Token::TupleVariant {\n                name: \"SkipSerializingEnum\",\n                variant: \"Tuple\",\n                len: 1,\n            },\n            Token::I8(1),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq)]\nstruct NotSerializeStruct(i8);\n\n#[derive(Debug, PartialEq)]\nenum NotSerializeEnum {\n    Trouble,\n}\n\nimpl SerializeWith for NotSerializeEnum {\n    fn serialize_with\u003cS\u003e(\u0026self, ser: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        \"trouble\".serialize(ser)\n    }\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct ContainsNotSerialize\u003c'a, B, C, D\u003e\nwhere\n    B: 'a,\n    D: SerializeWith,\n{\n    a: \u0026'a Option\u003ci8\u003e,\n    #[serde(skip_serializing)]\n    b: \u0026'a B,\n    #[serde(skip_serializing)]\n    c: Option\u003cC\u003e,\n    #[serde(serialize_with = \"SerializeWith::serialize_with\")]\n    d: D,\n}\n\n#[test]\nfn test_elt_not_serialize() {\n    let a = 1;\n    assert_ser_tokens(\n        \u0026ContainsNotSerialize {\n            a: \u0026Some(a),\n            b: \u0026NotSerializeStruct(2),\n            c: Some(NotSerializeEnum::Trouble),\n            d: NotSerializeEnum::Trouble,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"ContainsNotSerialize\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::Some,\n            Token::I8(1),\n            Token::Str(\"d\"),\n            Token::Str(\"trouble\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SerializeWithStruct\u003c'a, B\u003e\nwhere\n    B: SerializeWith,\n{\n    a: \u0026'a i8,\n    #[serde(serialize_with = \"SerializeWith::serialize_with\")]\n    b: B,\n}\n\n#[test]\nfn test_serialize_with_struct() {\n    let a = 1;\n    assert_ser_tokens(\n        \u0026SerializeWithStruct { a: \u0026a, b: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"SerializeWithStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(false),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SerializeWithStruct { a: \u0026a, b: 123 },\n        \u0026[\n            Token::Struct {\n                name: \"SerializeWithStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nenum SerializeWithEnum\u003c'a, B\u003e\nwhere\n    B: SerializeWith,\n{\n    Struct {\n        a: \u0026'a i8,\n        #[serde(serialize_with = \"SerializeWith::serialize_with\")]\n        b: B,\n    },\n}\n\n#[test]\nfn test_serialize_with_enum() {\n    let a = 1;\n    assert_ser_tokens(\n        \u0026SerializeWithEnum::Struct { a: \u0026a, b: 2 },\n        \u0026[\n            Token::StructVariant {\n                name: \"SerializeWithEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(false),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SerializeWithEnum::Struct { a: \u0026a, b: 123 },\n        \u0026[\n            Token::StructVariant {\n                name: \"SerializeWithEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum WithVariant {\n    #[serde(serialize_with = \"serialize_unit_variant_as_i8\")]\n    #[serde(deserialize_with = \"deserialize_i8_as_unit_variant\")]\n    Unit,\n\n    #[serde(serialize_with = \"SerializeWith::serialize_with\")]\n    #[serde(deserialize_with = \"DeserializeWith::deserialize_with\")]\n    Newtype(i32),\n\n    #[serde(serialize_with = \"serialize_variant_as_string\")]\n    #[serde(deserialize_with = \"deserialize_string_as_variant\")]\n    Tuple(String, u8),\n\n    #[serde(serialize_with = \"serialize_variant_as_string\")]\n    #[serde(deserialize_with = \"deserialize_string_as_variant\")]\n    Struct { f1: String, f2: u8 },\n}\n\nfn serialize_unit_variant_as_i8\u003cS\u003e(serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\nwhere\n    S: Serializer,\n{\n    serializer.serialize_i8(0)\n}\n\nfn deserialize_i8_as_unit_variant\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003c(), D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    let n = i8::deserialize(deserializer)?;\n    match n {\n        0 =\u003e Ok(()),\n        _ =\u003e Err(de::Error::invalid_value(Unexpected::Signed(n as i64), \u0026\"0\")),\n    }\n}\n\nfn serialize_variant_as_string\u003cS\u003e(f1: \u0026str, f2: \u0026u8, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\nwhere\n    S: Serializer,\n{\n    serializer.serialize_str(format!(\"{};{:?}\", f1, f2).as_str())\n}\n\nfn deserialize_string_as_variant\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003c(String, u8), D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    let s = String::deserialize(deserializer)?;\n    let mut pieces = s.split(';');\n    let f1 = match pieces.next() {\n        Some(x) =\u003e x,\n        None =\u003e return Err(de::Error::invalid_length(0, \u0026\"2\")),\n    };\n    let f2 = match pieces.next() {\n        Some(x) =\u003e x,\n        None =\u003e return Err(de::Error::invalid_length(1, \u0026\"2\")),\n    };\n    let f2 = match f2.parse() {\n        Ok(n) =\u003e n,\n        Err(_) =\u003e {\n            return Err(de::Error::invalid_value(\n                Unexpected::Str(f2),\n                \u0026\"an 8-bit signed integer\",\n            ));\n        }\n    };\n    Ok((f1.into(), f2))\n}\n\n#[test]\nfn test_serialize_with_variant() {\n    assert_ser_tokens(\n        \u0026WithVariant::Unit,\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Unit\",\n            },\n            Token::I8(0),\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026WithVariant::Newtype(123),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Newtype\",\n            },\n            Token::Bool(true),\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026WithVariant::Tuple(\"hello\".into(), 0),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Tuple\",\n            },\n            Token::Str(\"hello;0\"),\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026WithVariant::Struct {\n            f1: \"world\".into(),\n            f2: 1,\n        },\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Struct\",\n            },\n            Token::Str(\"world;1\"),\n        ],\n    );\n}\n\n#[test]\nfn test_deserialize_with_variant() {\n    assert_de_tokens(\n        \u0026WithVariant::Unit,\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Unit\",\n            },\n            Token::I8(0),\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026WithVariant::Newtype(123),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Newtype\",\n            },\n            Token::Bool(true),\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026WithVariant::Tuple(\"hello\".into(), 0),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Tuple\",\n            },\n            Token::Str(\"hello;0\"),\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026WithVariant::Struct {\n            f1: \"world\".into(),\n            f2: 1,\n        },\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Struct\",\n            },\n            Token::Str(\"world;1\"),\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct DeserializeWithStruct\u003cB\u003e\nwhere\n    B: DeserializeWith,\n{\n    a: i8,\n    #[serde(deserialize_with = \"DeserializeWith::deserialize_with\")]\n    b: B,\n}\n\n#[test]\nfn test_deserialize_with_struct() {\n    assert_de_tokens(\n        \u0026DeserializeWithStruct { a: 1, b: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"DeserializeWithStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(false),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DeserializeWithStruct { a: 1, b: 123 },\n        \u0026[\n            Token::Struct {\n                name: \"DeserializeWithStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nenum DeserializeWithEnum\u003cB\u003e\nwhere\n    B: DeserializeWith,\n{\n    Struct {\n        a: i8,\n        #[serde(deserialize_with = \"DeserializeWith::deserialize_with\")]\n        b: B,\n    },\n}\n\n#[test]\nfn test_deserialize_with_enum() {\n    assert_de_tokens(\n        \u0026DeserializeWithEnum::Struct { a: 1, b: 2 },\n        \u0026[\n            Token::StructVariant {\n                name: \"DeserializeWithEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(false),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DeserializeWithEnum::Struct { a: 1, b: 123 },\n        \u0026[\n            Token::StructVariant {\n                name: \"DeserializeWithEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_missing_renamed_field_struct() {\n    assert_de_tokens_error::\u003cRenameStruct\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"Superhero\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::StructEnd,\n        ],\n        \"missing field `a3`\",\n    );\n\n    assert_de_tokens_error::\u003cRenameStructSerializeDeserialize\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"SuperheroDe\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::StructEnd,\n        ],\n        \"missing field `a5`\",\n    );\n}\n\n#[test]\nfn test_missing_renamed_field_enum() {\n    assert_de_tokens_error::\u003cRenameEnum\u003e(\n        \u0026[\n            Token::StructVariant {\n                name: \"Superhero\",\n                variant: \"barry_allan\",\n                len: 1,\n            },\n            Token::StructVariantEnd,\n        ],\n        \"missing field `b`\",\n    );\n\n    assert_de_tokens_error::\u003cRenameEnumSerializeDeserialize\u003ci8\u003e\u003e(\n        \u0026[\n            Token::StructVariant {\n                name: \"SuperheroDe\",\n                variant: \"jason_todd\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::StructVariantEnd,\n        ],\n        \"missing field `d`\",\n    );\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nenum InvalidLengthEnum {\n    A(i32, i32, i32),\n    B(#[serde(skip_deserializing)] i32, i32, i32),\n}\n\n#[test]\nfn test_invalid_length_enum() {\n    assert_de_tokens_error::\u003cInvalidLengthEnum\u003e(\n        \u0026[\n            Token::TupleVariant {\n                name: \"InvalidLengthEnum\",\n                variant: \"A\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::TupleVariantEnd,\n        ],\n        \"invalid length 1, expected tuple variant InvalidLengthEnum::A with 3 elements\",\n    );\n    assert_de_tokens_error::\u003cInvalidLengthEnum\u003e(\n        \u0026[\n            Token::TupleVariant {\n                name: \"InvalidLengthEnum\",\n                variant: \"B\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::TupleVariantEnd,\n        ],\n        \"invalid length 1, expected tuple variant InvalidLengthEnum::B with 2 elements\",\n    );\n}\n\n#[derive(Clone, Serialize, Deserialize, PartialEq, Debug)]\n#[serde(into = \"EnumToU32\", from = \"EnumToU32\")]\nstruct StructFromEnum(Option\u003cu32\u003e);\n\nimpl Into\u003cEnumToU32\u003e for StructFromEnum {\n    fn into(self) -\u003e EnumToU32 {\n        match self {\n            StructFromEnum(v) =\u003e v.into(),\n        }\n    }\n}\n\nimpl From\u003cEnumToU32\u003e for StructFromEnum {\n    fn from(v: EnumToU32) -\u003e Self {\n        StructFromEnum(v.into())\n    }\n}\n\n#[derive(Clone, Serialize, Deserialize, PartialEq, Debug)]\n#[serde(into = \"Option\u003cu32\u003e\", from = \"Option\u003cu32\u003e\")]\nenum EnumToU32 {\n    One,\n    Two,\n    Three,\n    Four,\n    Nothing,\n}\n\nimpl Into\u003cOption\u003cu32\u003e\u003e for EnumToU32 {\n    fn into(self) -\u003e Option\u003cu32\u003e {\n        match self {\n            EnumToU32::One =\u003e Some(1),\n            EnumToU32::Two =\u003e Some(2),\n            EnumToU32::Three =\u003e Some(3),\n            EnumToU32::Four =\u003e Some(4),\n            EnumToU32::Nothing =\u003e None,\n        }\n    }\n}\n\nimpl From\u003cOption\u003cu32\u003e\u003e for EnumToU32 {\n    fn from(v: Option\u003cu32\u003e) -\u003e Self {\n        match v {\n            Some(1) =\u003e EnumToU32::One,\n            Some(2) =\u003e EnumToU32::Two,\n            Some(3) =\u003e EnumToU32::Three,\n            Some(4) =\u003e EnumToU32::Four,\n            _ =\u003e EnumToU32::Nothing,\n        }\n    }\n}\n\n#[derive(Clone, Deserialize, PartialEq, Debug)]\n#[serde(try_from = \"u32\")]\nenum TryFromU32 {\n    One,\n    Two,\n}\n\nimpl TryFrom\u003cu32\u003e for TryFromU32 {\n    type Error = String;\n\n    fn try_from(value: u32) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            1 =\u003e Ok(TryFromU32::One),\n            2 =\u003e Ok(TryFromU32::Two),\n            _ =\u003e Err(\"out of range\".to_owned()),\n        }\n    }\n}\n\n#[test]\nfn test_from_into_traits() {\n    assert_ser_tokens(\u0026EnumToU32::One, \u0026[Token::Some, Token::U32(1)]);\n    assert_ser_tokens(\u0026EnumToU32::Nothing, \u0026[Token::None]);\n    assert_de_tokens(\u0026EnumToU32::Two, \u0026[Token::Some, Token::U32(2)]);\n    assert_ser_tokens(\u0026StructFromEnum(Some(5)), \u0026[Token::None]);\n    assert_ser_tokens(\u0026StructFromEnum(None), \u0026[Token::None]);\n    assert_de_tokens(\u0026StructFromEnum(Some(2)), \u0026[Token::Some, Token::U32(2)]);\n    assert_de_tokens(\u0026TryFromU32::Two, \u0026[Token::U32(2)]);\n    assert_de_tokens_error::\u003cTryFromU32\u003e(\u0026[Token::U32(5)], \"out of range\");\n}\n\n#[test]\nfn test_collect_other() {\n    let mut extra = HashMap::new();\n    extra.insert(\"c\".into(), 3);\n    assert_tokens(\n        \u0026CollectOther { a: 1, b: 2, extra },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::U32(1),\n            Token::Str(\"b\"),\n            Token::U32(2),\n            Token::Str(\"c\"),\n            Token::U32(3),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_struct_enum() {\n    let mut extra = HashMap::new();\n    extra.insert(\"extra_key\".into(), \"extra value\".into());\n    let change_request = FlattenStructEnumWrapper {\n        data: FlattenStructEnum::InsertInteger {\n            index: 0,\n            value: 42,\n        },\n        extra,\n    };\n    assert_de_tokens(\n        \u0026change_request,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"insert_integer\"),\n            Token::Map { len: None },\n            Token::Str(\"index\"),\n            Token::U32(0),\n            Token::Str(\"value\"),\n            Token::U32(42),\n            Token::MapEnd,\n            Token::Str(\"extra_key\"),\n            Token::Str(\"extra value\"),\n            Token::MapEnd,\n        ],\n    );\n    assert_ser_tokens(\n        \u0026change_request,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"insert_integer\"),\n            Token::Struct {\n                len: 2,\n                name: \"insert_integer\",\n            },\n            Token::Str(\"index\"),\n            Token::U32(0),\n            Token::Str(\"value\"),\n            Token::U32(42),\n            Token::StructEnd,\n            Token::Str(\"extra_key\"),\n            Token::Str(\"extra value\"),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_struct_tag_content_enum() {\n    let change_request = FlattenStructTagContentEnumWrapper {\n        outer: 42,\n        data: FlattenStructTagContentEnumNewtype(FlattenStructTagContentEnum::InsertInteger {\n            index: 0,\n            value: 42,\n        }),\n    };\n    assert_de_tokens(\n        \u0026change_request,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::U32(42),\n            Token::Str(\"type\"),\n            Token::Str(\"insert_integer\"),\n            Token::Str(\"value\"),\n            Token::Map { len: None },\n            Token::Str(\"index\"),\n            Token::U32(0),\n            Token::Str(\"value\"),\n            Token::U32(42),\n            Token::MapEnd,\n            Token::MapEnd,\n        ],\n    );\n    assert_ser_tokens(\n        \u0026change_request,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::U32(42),\n            Token::Str(\"type\"),\n            Token::Str(\"insert_integer\"),\n            Token::Str(\"value\"),\n            Token::Struct {\n                len: 2,\n                name: \"insert_integer\",\n            },\n            Token::Str(\"index\"),\n            Token::U32(0),\n            Token::Str(\"value\"),\n            Token::U32(42),\n            Token::StructEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_struct_tag_content_enum_newtype() {\n    let change_request = FlattenStructTagContentEnumWrapper {\n        outer: 42,\n        data: FlattenStructTagContentEnumNewtype(FlattenStructTagContentEnum::NewtypeVariant(\n            FlattenStructTagContentEnumNewtypeVariant { value: 23 },\n        )),\n    };\n    assert_de_tokens(\n        \u0026change_request,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::U32(42),\n            Token::Str(\"type\"),\n            Token::Str(\"newtype_variant\"),\n            Token::Str(\"value\"),\n            Token::Map { len: None },\n            Token::Str(\"value\"),\n            Token::U32(23),\n            Token::MapEnd,\n            Token::MapEnd,\n        ],\n    );\n    assert_ser_tokens(\n        \u0026change_request,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::U32(42),\n            Token::Str(\"type\"),\n            Token::Str(\"newtype_variant\"),\n            Token::Str(\"value\"),\n            Token::Struct {\n                len: 1,\n                name: \"FlattenStructTagContentEnumNewtypeVariant\",\n            },\n            Token::Str(\"value\"),\n            Token::U32(23),\n            Token::StructEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_unknown_field_in_flatten() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct Outer {\n        dummy: String,\n        #[serde(flatten)]\n        inner: Inner,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Inner {\n        foo: HashMap\u003cString, u32\u003e,\n    }\n\n    assert_de_tokens_error::\u003cOuter\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"Outer\",\n                len: 1,\n            },\n            Token::Str(\"dummy\"),\n            Token::Str(\"23\"),\n            Token::Str(\"foo\"),\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::U32(1),\n            Token::Str(\"b\"),\n            Token::U32(2),\n            Token::MapEnd,\n            Token::Str(\"bar\"),\n            Token::U32(23),\n            Token::StructEnd,\n        ],\n        \"unknown field `bar`\",\n    );\n}\n\n#[test]\nfn test_complex_flatten() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Outer {\n        y: u32,\n        #[serde(flatten)]\n        first: First,\n        #[serde(flatten)]\n        second: Second,\n        z: u32,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct First {\n        a: u32,\n        b: bool,\n        c: Vec\u003cString\u003e,\n        d: String,\n        e: Option\u003cu64\u003e,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Second {\n        f: u32,\n    }\n\n    assert_de_tokens(\n        \u0026Outer {\n            y: 0,\n            first: First {\n                a: 1,\n                b: true,\n                c: vec![\"a\".into(), \"b\".into()],\n                d: \"c\".into(),\n                e: Some(2),\n            },\n            second: Second { f: 3 },\n            z: 4,\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"y\"),\n            Token::U32(0),\n            Token::Str(\"a\"),\n            Token::U32(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::Str(\"c\"),\n            Token::Seq { len: Some(2) },\n            Token::Str(\"a\"),\n            Token::Str(\"b\"),\n            Token::SeqEnd,\n            Token::Str(\"d\"),\n            Token::Str(\"c\"),\n            Token::Str(\"e\"),\n            Token::U64(2),\n            Token::Str(\"f\"),\n            Token::U32(3),\n            Token::Str(\"z\"),\n            Token::U32(4),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026Outer {\n            y: 0,\n            first: First {\n                a: 1,\n                b: true,\n                c: vec![\"a\".into(), \"b\".into()],\n                d: \"c\".into(),\n                e: Some(2),\n            },\n            second: Second { f: 3 },\n            z: 4,\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"y\"),\n            Token::U32(0),\n            Token::Str(\"a\"),\n            Token::U32(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::Str(\"c\"),\n            Token::Seq { len: Some(2) },\n            Token::Str(\"a\"),\n            Token::Str(\"b\"),\n            Token::SeqEnd,\n            Token::Str(\"d\"),\n            Token::Str(\"c\"),\n            Token::Str(\"e\"),\n            Token::Some,\n            Token::U64(2),\n            Token::Str(\"f\"),\n            Token::U32(3),\n            Token::Str(\"z\"),\n            Token::U32(4),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_map_twice() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    struct Outer {\n        #[serde(flatten)]\n        first: BTreeMap\u003cString, String\u003e,\n        #[serde(flatten)]\n        between: Inner,\n        #[serde(flatten)]\n        second: BTreeMap\u003cString, String\u003e,\n    }\n\n    #[derive(Debug, PartialEq, Deserialize)]\n    struct Inner {\n        y: String,\n    }\n\n    assert_de_tokens(\n        \u0026Outer {\n            first: {\n                let mut first = BTreeMap::new();\n                first.insert(\"x\".to_owned(), \"X\".to_owned());\n                first.insert(\"y\".to_owned(), \"Y\".to_owned());\n                first\n            },\n            between: Inner { y: \"Y\".to_owned() },\n            second: {\n                let mut second = BTreeMap::new();\n                second.insert(\"x\".to_owned(), \"X\".to_owned());\n                second\n            },\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"x\"),\n            Token::Str(\"X\"),\n            Token::Str(\"y\"),\n            Token::Str(\"Y\"),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_unsupported_type() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Outer {\n        outer: String,\n        #[serde(flatten)]\n        inner: String,\n    }\n\n    assert_ser_tokens_error(\n        \u0026Outer {\n            outer: \"foo\".into(),\n            inner: \"bar\".into(),\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::Str(\"foo\"),\n        ],\n        \"can only flatten structs and maps (got a string)\",\n    );\n    assert_de_tokens_error::\u003cOuter\u003e(\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::Str(\"foo\"),\n            Token::Str(\"a\"),\n            Token::Str(\"b\"),\n            Token::MapEnd,\n        ],\n        \"can only flatten structs and maps\",\n    );\n}\n\n#[test]\nfn test_non_string_keys() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct TestStruct {\n        name: String,\n        age: u32,\n        #[serde(flatten)]\n        mapping: HashMap\u003cu32, u32\u003e,\n    }\n\n    let mut mapping = HashMap::new();\n    mapping.insert(0, 42);\n    assert_tokens(\n        \u0026TestStruct {\n            name: \"peter\".into(),\n            age: 3,\n            mapping,\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"name\"),\n            Token::Str(\"peter\"),\n            Token::Str(\"age\"),\n            Token::U32(3),\n            Token::U32(0),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_lifetime_propagation_for_flatten() {\n    #[derive(Deserialize, Serialize, Debug, PartialEq)]\n    struct A\u003cT\u003e {\n        #[serde(flatten)]\n        t: T,\n    }\n\n    #[derive(Deserialize, Serialize, Debug, PartialEq)]\n    struct B\u003c'a\u003e {\n        #[serde(flatten, borrow)]\n        t: HashMap\u003c\u0026'a str, u32\u003e,\n    }\n\n    #[derive(Deserialize, Serialize, Debug, PartialEq)]\n    struct C\u003c'a\u003e {\n        #[serde(flatten, borrow)]\n        t: HashMap\u003c\u0026'a [u8], u32\u003e,\n    }\n\n    let mut owned_map = HashMap::new();\n    owned_map.insert(\"x\".to_string(), 42u32);\n    assert_tokens(\n        \u0026A { t: owned_map },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"x\"),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n\n    let mut borrowed_map = HashMap::new();\n    borrowed_map.insert(\"x\", 42u32);\n    assert_ser_tokens(\n        \u0026B {\n            t: borrowed_map.clone(),\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::BorrowedStr(\"x\"),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026B { t: borrowed_map },\n        \u0026[\n            Token::Map { len: None },\n            Token::BorrowedStr(\"x\"),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n\n    let mut borrowed_map = HashMap::new();\n    borrowed_map.insert(\u0026b\"x\"[..], 42u32);\n    assert_ser_tokens(\n        \u0026C {\n            t: borrowed_map.clone(),\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Seq { len: Some(1) },\n            Token::U8(120),\n            Token::SeqEnd,\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026C { t: borrowed_map },\n        \u0026[\n            Token::Map { len: None },\n            Token::BorrowedBytes(b\"x\"),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_enum_newtype() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct S {\n        #[serde(flatten)]\n        flat: E,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    enum E {\n        Q(HashMap\u003cString, String\u003e),\n    }\n\n    let e = E::Q({\n        let mut map = HashMap::new();\n        map.insert(\"k\".to_owned(), \"v\".to_owned());\n        map\n    });\n    let s = S { flat: e };\n\n    assert_tokens(\n        \u0026s,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"Q\"),\n            Token::Map { len: Some(1) },\n            Token::Str(\"k\"),\n            Token::Str(\"v\"),\n            Token::MapEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_internally_tagged() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct S {\n        #[serde(flatten)]\n        x: X,\n        #[serde(flatten)]\n        y: Y,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"typeX\")]\n    enum X {\n        A { a: i32 },\n        B { b: i32 },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"typeY\")]\n    enum Y {\n        C { c: i32 },\n        D { d: i32 },\n    }\n\n    let s = S {\n        x: X::B { b: 1 },\n        y: Y::D { d: 2 },\n    };\n\n    assert_tokens(\n        \u0026s,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"typeX\"),\n            Token::Str(\"B\"),\n            Token::Str(\"b\"),\n            Token::I32(1),\n            Token::Str(\"typeY\"),\n            Token::Str(\"D\"),\n            Token::Str(\"d\"),\n            Token::I32(2),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_externally_tagged_enum_containing_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        \u0026data,\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"Data\",\n                variant: \"A\",\n            },\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_enum_containing_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"t\")]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        \u0026data,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"t\"),\n            Token::Str(\"A\"),\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_adjacently_tagged_enum_containing_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        \u0026data,\n        \u0026[\n            Token::Struct {\n                name: \"Data\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"A\"),\n            Token::Str(\"c\"),\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_enum_containing_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(untagged)]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        \u0026data,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_untagged_enum() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Outer {\n        #[serde(flatten)]\n        inner: Inner,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(untagged)]\n    enum Inner {\n        Variant { a: i32 },\n    }\n\n    let data = Outer {\n        inner: Inner::Variant { a: 0 },\n    };\n\n    assert_tokens(\n        \u0026data,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_option() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Outer {\n        #[serde(flatten)]\n        inner1: Option\u003cInner1\u003e,\n        #[serde(flatten)]\n        inner2: Option\u003cInner2\u003e,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Inner1 {\n        inner1: i32,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Inner2 {\n        inner2: i32,\n    }\n\n    assert_tokens(\n        \u0026Outer {\n            inner1: Some(Inner1 { inner1: 1 }),\n            inner2: Some(Inner2 { inner2: 2 }),\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"inner1\"),\n            Token::I32(1),\n            Token::Str(\"inner2\"),\n            Token::I32(2),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer {\n            inner1: Some(Inner1 { inner1: 1 }),\n            inner2: None,\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"inner1\"),\n            Token::I32(1),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer {\n            inner1: None,\n            inner2: Some(Inner2 { inner2: 2 }),\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"inner2\"),\n            Token::I32(2),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer {\n            inner1: None,\n            inner2: None,\n        },\n        \u0026[Token::Map { len: None }, Token::MapEnd],\n    );\n}\n\n#[test]\nfn test_transparent_struct() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(transparent)]\n    struct Transparent {\n        #[serde(skip)]\n        a: bool,\n        b: u32,\n        #[serde(skip)]\n        c: bool,\n        d: PhantomData\u003c()\u003e,\n    }\n\n    assert_tokens(\n        \u0026Transparent {\n            a: false,\n            b: 1,\n            c: false,\n            d: PhantomData,\n        },\n        \u0026[Token::U32(1)],\n    );\n}\n\n#[test]\nfn test_transparent_tuple_struct() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(transparent)]\n    struct Transparent(\n        #[serde(skip)] bool,\n        u32,\n        #[serde(skip)] bool,\n        PhantomData\u003c()\u003e,\n    );\n\n    assert_tokens(\u0026Transparent(false, 1, false, PhantomData), \u0026[Token::U32(1)]);\n}\n\n#[test]\nfn test_internally_tagged_unit_enum_with_unknown_fields() {\n    #[derive(Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"t\")]\n    enum Data {\n        A,\n    }\n\n    let data = Data::A;\n\n    assert_de_tokens(\n        \u0026data,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"t\"),\n            Token::Str(\"A\"),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flattened_internally_tagged_unit_enum_with_unknown_fields() {\n    #[derive(Deserialize, PartialEq, Debug)]\n    struct S {\n        #[serde(flatten)]\n        x: X,\n        #[serde(flatten)]\n        y: Y,\n    }\n\n    #[derive(Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"typeX\")]\n    enum X {\n        A,\n    }\n\n    #[derive(Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"typeY\")]\n    enum Y {\n        B { c: u32 },\n    }\n\n    let s = S {\n        x: X::A,\n        y: Y::B { c: 0 },\n    };\n\n    assert_de_tokens(\n        \u0026s,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"typeX\"),\n            Token::Str(\"A\"),\n            Token::Str(\"typeY\"),\n            Token::Str(\"B\"),\n            Token::Str(\"c\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_any_after_flatten_struct() {\n    #[derive(PartialEq, Debug)]\n    struct Any;\n\n    impl\u003c'de\u003e Deserialize\u003c'de\u003e for Any {\n        fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            struct AnyVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for AnyVisitor {\n                type Value = Any;\n\n                fn expecting(\u0026self, _formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    unimplemented!()\n                }\n\n                fn visit_map\u003cM\u003e(self, mut map: M) -\u003e Result\u003cSelf::Value, M::Error\u003e\n                where\n                    M: MapAccess\u003c'de\u003e,\n                {\n                    while let Some((Any, Any)) = map.next_entry()? {}\n                    Ok(Any)\n                }\n            }\n\n            deserializer.deserialize_any(AnyVisitor)\n        }\n    }\n\n    #[derive(Deserialize, PartialEq, Debug)]\n    struct Outer {\n        #[serde(flatten)]\n        inner: Inner,\n        #[serde(flatten)]\n        extra: Any,\n    }\n\n    #[derive(Deserialize, PartialEq, Debug)]\n    struct Inner {\n        inner: i32,\n    }\n\n    let s = Outer {\n        inner: Inner { inner: 0 },\n        extra: Any,\n    };\n\n    assert_de_tokens(\n        \u0026s,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"inner\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_borrow.rs"],"content":"use serde::{Deserialize, Deserializer};\nuse serde_test::{assert_de_tokens, assert_de_tokens_error, Token};\n\nuse std::borrow::Cow;\n\n#[test]\nfn test_borrowed_str() {\n    assert_de_tokens(\u0026\"borrowed\", \u0026[Token::BorrowedStr(\"borrowed\")]);\n}\n\n#[test]\nfn test_borrowed_str_from_string() {\n    assert_de_tokens_error::\u003c\u0026str\u003e(\n        \u0026[Token::String(\"borrowed\")],\n        \"invalid type: string \\\"borrowed\\\", expected a borrowed string\",\n    );\n}\n\n#[test]\nfn test_borrowed_str_from_str() {\n    assert_de_tokens_error::\u003c\u0026str\u003e(\n        \u0026[Token::Str(\"borrowed\")],\n        \"invalid type: string \\\"borrowed\\\", expected a borrowed string\",\n    );\n}\n\n#[test]\nfn test_string_from_borrowed_str() {\n    assert_de_tokens(\u0026\"owned\".to_owned(), \u0026[Token::BorrowedStr(\"owned\")]);\n}\n\n#[test]\nfn test_borrowed_bytes() {\n    assert_de_tokens(\u0026\u0026b\"borrowed\"[..], \u0026[Token::BorrowedBytes(b\"borrowed\")]);\n}\n\n#[test]\nfn test_borrowed_bytes_from_bytebuf() {\n    assert_de_tokens_error::\u003c\u0026[u8]\u003e(\n        \u0026[Token::ByteBuf(b\"borrowed\")],\n        \"invalid type: byte array, expected a borrowed byte array\",\n    );\n}\n\n#[test]\nfn test_borrowed_bytes_from_bytes() {\n    assert_de_tokens_error::\u003c\u0026[u8]\u003e(\n        \u0026[Token::Bytes(b\"borrowed\")],\n        \"invalid type: byte array, expected a borrowed byte array\",\n    );\n}\n\n#[test]\nfn test_tuple() {\n    assert_de_tokens(\n        \u0026(\"str\", \u0026b\"bytes\"[..]),\n        \u0026[\n            Token::Tuple { len: 2 },\n            Token::BorrowedStr(\"str\"),\n            Token::BorrowedBytes(b\"bytes\"),\n            Token::TupleEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_struct() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    struct Borrowing\u003c'a, 'b\u003e {\n        bs: \u0026'a str,\n        bb: \u0026'b [u8],\n    }\n\n    assert_de_tokens(\n        \u0026Borrowing {\n            bs: \"str\",\n            bb: b\"bytes\",\n        },\n        \u0026[\n            Token::Struct {\n                name: \"Borrowing\",\n                len: 2,\n            },\n            Token::BorrowedStr(\"bs\"),\n            Token::BorrowedStr(\"str\"),\n            Token::BorrowedStr(\"bb\"),\n            Token::BorrowedBytes(b\"bytes\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_cow() {\n    #[derive(Deserialize)]\n    struct Cows\u003c'a, 'b\u003e {\n        copied: Cow\u003c'a, str\u003e,\n\n        #[serde(borrow)]\n        borrowed: Cow\u003c'b, str\u003e,\n    }\n\n    let tokens = \u0026[\n        Token::Struct {\n            name: \"Cows\",\n            len: 2,\n        },\n        Token::Str(\"copied\"),\n        Token::BorrowedStr(\"copied\"),\n        Token::Str(\"borrowed\"),\n        Token::BorrowedStr(\"borrowed\"),\n        Token::StructEnd,\n    ];\n\n    let mut de = serde_test::Deserializer::new(tokens);\n    let cows = Cows::deserialize(\u0026mut de).unwrap();\n\n    match cows.copied {\n        Cow::Owned(ref s) if s == \"copied\" =\u003e {}\n        _ =\u003e panic!(\"expected a copied string\"),\n    }\n\n    match cows.borrowed {\n        Cow::Borrowed(\"borrowed\") =\u003e {}\n        _ =\u003e panic!(\"expected a borrowed string\"),\n    }\n}\n\n#[test]\nfn test_lifetimes() {\n    #[derive(Deserialize)]\n    struct Cows\u003c'a, 'b\u003e {\n        _copied: Cow\u003c'a, str\u003e,\n\n        #[serde(borrow)]\n        _borrowed: Cow\u003c'b, str\u003e,\n    }\n\n    // Tests that `'de: 'a` is not required by the Deserialize impl.\n    fn _cows_lifetimes\u003c'de: 'b, 'a, 'b, D\u003e(deserializer: D) -\u003e Cows\u003c'a, 'b\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Deserialize::deserialize(deserializer).unwrap()\n    }\n\n    #[derive(Deserialize)]\n    struct Wrap\u003c'a, 'b\u003e {\n        #[serde(borrow = \"'b\")]\n        _cows: Cows\u003c'a, 'b\u003e,\n    }\n\n    // Tests that `'de: 'a` is not required by the Deserialize impl.\n    fn _wrap_lifetimes\u003c'de: 'b, 'a, 'b, D\u003e(deserializer: D) -\u003e Wrap\u003c'a, 'b\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Deserialize::deserialize(deserializer).unwrap()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_de.rs"],"content":"#![allow(clippy::decimal_literal_representation, clippy::unreadable_literal)]\n#![cfg_attr(feature = \"unstable\", feature(never_type))]\n\nuse std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\nuse std::default::Default;\nuse std::ffi::{CStr, CString, OsString};\nuse std::fmt::Debug;\nuse std::net;\nuse std::num::Wrapping;\nuse std::ops::Bound;\nuse std::path::{Path, PathBuf};\nuse std::rc::{Rc, Weak as RcWeak};\nuse std::sync::atomic::{\n    AtomicBool, AtomicI16, AtomicI32, AtomicI8, AtomicIsize, AtomicU16, AtomicU32, AtomicU8,\n    AtomicUsize, Ordering,\n};\nuse std::sync::{Arc, Weak as ArcWeak};\nuse std::time::{Duration, UNIX_EPOCH};\n\n#[cfg(target_arch = \"x86_64\")]\nuse std::sync::atomic::{AtomicI64, AtomicU64};\n\nuse fnv::FnvHasher;\nuse serde::de::DeserializeOwned;\nuse serde::{Deserialize, Deserializer};\nuse serde_test::{assert_de_tokens, assert_de_tokens_error, Configure, Token};\n\n#[macro_use]\nmod macros;\n\n//////////////////////////////////////////////////////////////////////////\n\n#[derive(Copy, Clone, PartialEq, Debug, Deserialize)]\nstruct UnitStruct;\n\n#[derive(PartialEq, Debug, Deserialize)]\nstruct NewtypeStruct(i32);\n\n#[derive(PartialEq, Debug, Deserialize)]\nstruct TupleStruct(i32, i32, i32);\n\n#[derive(PartialEq, Debug, Deserialize)]\nstruct Struct {\n    a: i32,\n    b: i32,\n    #[serde(skip_deserializing)]\n    c: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(deny_unknown_fields)]\nstruct StructDenyUnknown {\n    a: i32,\n    #[serde(skip_deserializing)]\n    b: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(default)]\nstruct StructDefault\u003cT\u003e {\n    a: i32,\n    b: T,\n}\n\nimpl Default for StructDefault\u003cString\u003e {\n    fn default() -\u003e Self {\n        StructDefault {\n            a: 100,\n            b: \"default\".to_string(),\n        }\n    }\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\nstruct StructSkipAll {\n    #[serde(skip_deserializing)]\n    a: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(default)]\nstruct StructSkipDefault {\n    #[serde(skip_deserializing)]\n    a: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(default)]\nstruct StructSkipDefaultGeneric\u003cT\u003e {\n    #[serde(skip_deserializing)]\n    t: T,\n}\n\nimpl Default for StructSkipDefault {\n    fn default() -\u003e Self {\n        StructSkipDefault { a: 16 }\n    }\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(deny_unknown_fields)]\nstruct StructSkipAllDenyUnknown {\n    #[serde(skip_deserializing)]\n    a: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\nenum Enum {\n    #[allow(dead_code)]\n    #[serde(skip_deserializing)]\n    Skipped,\n    Unit,\n    Simple(i32),\n    Seq(i32, i32, i32),\n    Map {\n        a: i32,\n        b: i32,\n        c: i32,\n    },\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\nenum EnumSkipAll {\n    #[allow(dead_code)]\n    #[serde(skip_deserializing)]\n    Skipped,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\nenum EnumOther {\n    Unit,\n    #[serde(other)]\n    Other,\n}\n\n#[derive(PartialEq, Debug)]\nstruct IgnoredAny;\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for IgnoredAny {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        serde::de::IgnoredAny::deserialize(deserializer)?;\n        Ok(IgnoredAny)\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nmacro_rules! declare_tests {\n    (\n        $readable:tt\n        $($name:ident { $($value:expr =\u003e $tokens:expr,)+ })+\n    ) =\u003e {\n        $(\n            #[test]\n            fn $name() {\n                $(\n                    // Test ser/de roundtripping\n                    assert_de_tokens(\u0026$value.$readable(), $tokens);\n\n                    // Test that the tokens are ignorable\n                    assert_de_tokens_ignore($tokens);\n                )+\n            }\n        )+\n    };\n\n    ($(\n        $(#[$cfg:meta])*\n        $name:ident { $($value:expr =\u003e $tokens:expr,)+ }\n    )+) =\u003e {\n        $(\n            $(#[$cfg])*\n            #[test]\n            fn $name() {\n                $(\n                    // Test ser/de roundtripping\n                    assert_de_tokens(\u0026$value, $tokens);\n\n                    // Test that the tokens are ignorable\n                    assert_de_tokens_ignore($tokens);\n                )+\n            }\n        )+\n    }\n}\n\nmacro_rules! declare_error_tests {\n    ($($name:ident\u003c$target:ty\u003e { $tokens:expr, $expected:expr, })+) =\u003e {\n        $(\n            #[test]\n            fn $name() {\n                assert_de_tokens_error::\u003c$target\u003e($tokens, $expected);\n            }\n        )+\n    }\n}\n\n#[derive(Debug)]\nstruct SkipPartialEq\u003cT\u003e(T);\n\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for SkipPartialEq\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(deserializer).map(SkipPartialEq)\n    }\n}\n\nimpl\u003cT\u003e PartialEq for SkipPartialEq\u003cT\u003e {\n    fn eq(\u0026self, _other: \u0026Self) -\u003e bool {\n        true\n    }\n}\n\nfn assert_de_tokens_ignore(ignorable_tokens: \u0026[Token]) {\n    #[derive(PartialEq, Debug, Deserialize)]\n    struct IgnoreBase {\n        a: i32,\n    }\n\n    // Embed the tokens to be ignored in the normal token\n    // stream for an IgnoreBase type\n    let concated_tokens: Vec\u003cToken\u003e = vec![\n        Token::Map { len: Some(2) },\n        Token::Str(\"a\"),\n        Token::I32(1),\n        Token::Str(\"ignored\"),\n    ]\n    .into_iter()\n    .chain(ignorable_tokens.to_vec().into_iter())\n    .chain(vec![Token::MapEnd].into_iter())\n    .collect();\n\n    let mut de = serde_test::Deserializer::new(\u0026concated_tokens);\n    let base = IgnoreBase::deserialize(\u0026mut de).unwrap();\n    assert_eq!(base, IgnoreBase { a: 1 });\n}\n\n//////////////////////////////////////////////////////////////////////////\n\ndeclare_tests! {\n    test_bool {\n        true =\u003e \u0026[Token::Bool(true)],\n        false =\u003e \u0026[Token::Bool(false)],\n    }\n    test_isize {\n        0isize =\u003e \u0026[Token::I8(0)],\n        0isize =\u003e \u0026[Token::I16(0)],\n        0isize =\u003e \u0026[Token::I32(0)],\n        0isize =\u003e \u0026[Token::I64(0)],\n        0isize =\u003e \u0026[Token::U8(0)],\n        0isize =\u003e \u0026[Token::U16(0)],\n        0isize =\u003e \u0026[Token::U32(0)],\n        0isize =\u003e \u0026[Token::U64(0)],\n    }\n    test_ints {\n        0i8 =\u003e \u0026[Token::I8(0)],\n        0i16 =\u003e \u0026[Token::I16(0)],\n        0i32 =\u003e \u0026[Token::I32(0)],\n        0i64 =\u003e \u0026[Token::I64(0)],\n    }\n    test_uints {\n        0u8 =\u003e \u0026[Token::U8(0)],\n        0u16 =\u003e \u0026[Token::U16(0)],\n        0u32 =\u003e \u0026[Token::U32(0)],\n        0u64 =\u003e \u0026[Token::U64(0)],\n    }\n    test_floats {\n        0f32 =\u003e \u0026[Token::F32(0.)],\n        0f64 =\u003e \u0026[Token::F64(0.)],\n    }\n    #[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n    test_small_int_to_128 {\n        1i128 =\u003e \u0026[Token::I8(1)],\n        1i128 =\u003e \u0026[Token::I16(1)],\n        1i128 =\u003e \u0026[Token::I32(1)],\n        1i128 =\u003e \u0026[Token::I64(1)],\n\n        1i128 =\u003e \u0026[Token::U8(1)],\n        1i128 =\u003e \u0026[Token::U16(1)],\n        1i128 =\u003e \u0026[Token::U32(1)],\n        1i128 =\u003e \u0026[Token::U64(1)],\n\n        1u128 =\u003e \u0026[Token::I8(1)],\n        1u128 =\u003e \u0026[Token::I16(1)],\n        1u128 =\u003e \u0026[Token::I32(1)],\n        1u128 =\u003e \u0026[Token::I64(1)],\n\n        1u128 =\u003e \u0026[Token::U8(1)],\n        1u128 =\u003e \u0026[Token::U16(1)],\n        1u128 =\u003e \u0026[Token::U32(1)],\n        1u128 =\u003e \u0026[Token::U64(1)],\n    }\n    test_char {\n        'a' =\u003e \u0026[Token::Char('a')],\n        'a' =\u003e \u0026[Token::Str(\"a\")],\n        'a' =\u003e \u0026[Token::String(\"a\")],\n    }\n    test_string {\n        \"abc\".to_owned() =\u003e \u0026[Token::Str(\"abc\")],\n        \"abc\".to_owned() =\u003e \u0026[Token::String(\"abc\")],\n        \"a\".to_owned() =\u003e \u0026[Token::Char('a')],\n    }\n    test_option {\n        None::\u003ci32\u003e =\u003e \u0026[Token::Unit],\n        None::\u003ci32\u003e =\u003e \u0026[Token::None],\n        Some(1) =\u003e \u0026[\n            Token::Some,\n            Token::I32(1),\n        ],\n    }\n    test_result {\n        Ok::\u003ci32, i32\u003e(0) =\u003e \u0026[\n            Token::Enum { name: \"Result\" },\n            Token::Str(\"Ok\"),\n            Token::I32(0),\n        ],\n        Err::\u003ci32, i32\u003e(1) =\u003e \u0026[\n            Token::Enum { name: \"Result\" },\n            Token::Str(\"Err\"),\n            Token::I32(1),\n        ],\n    }\n    test_unit {\n        () =\u003e \u0026[Token::Unit],\n    }\n    test_unit_struct {\n        UnitStruct =\u003e \u0026[Token::Unit],\n        UnitStruct =\u003e \u0026[\n            Token::UnitStruct { name: \"UnitStruct\" },\n        ],\n    }\n    test_newtype_struct {\n        NewtypeStruct(1) =\u003e \u0026[\n            Token::NewtypeStruct { name: \"NewtypeStruct\" },\n            Token::I32(1),\n        ],\n    }\n    test_tuple_struct {\n        TupleStruct(1, 2, 3) =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n        TupleStruct(1, 2, 3) =\u003e \u0026[\n            Token::Seq { len: None },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n        TupleStruct(1, 2, 3) =\u003e \u0026[\n            Token::TupleStruct { name: \"TupleStruct\", len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n        TupleStruct(1, 2, 3) =\u003e \u0026[\n            Token::TupleStruct { name: \"TupleStruct\", len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n    }\n    test_btreeset {\n        BTreeSet::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        btreeset![btreeset![], btreeset![1], btreeset![2, 3]] =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::Seq { len: Some(0) },\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(1) },\n                    Token::I32(1),\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(2) },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::SeqEnd,\n            Token::SeqEnd,\n        ],\n        BTreeSet::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n    }\n    test_hashset {\n        HashSet::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        hashset![1, 2, 3] =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n        HashSet::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n        hashset![FnvHasher @ 1, 2, 3] =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n    }\n    test_vec {\n        Vec::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        vec![vec![], vec![1], vec![2, 3]] =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::Seq { len: Some(0) },\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(1) },\n                    Token::I32(1),\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(2) },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::SeqEnd,\n            Token::SeqEnd,\n        ],\n        Vec::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n    }\n    test_array {\n        [0; 0] =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        [0; 0] =\u003e \u0026[\n            Token::Tuple { len: 0 },\n            Token::TupleEnd,\n        ],\n        ([0; 0], [1], [2, 3]) =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::Seq { len: Some(0) },\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(1) },\n                    Token::I32(1),\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(2) },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::SeqEnd,\n            Token::SeqEnd,\n        ],\n        ([0; 0], [1], [2, 3]) =\u003e \u0026[\n            Token::Tuple { len: 3 },\n                Token::Tuple { len: 0 },\n                Token::TupleEnd,\n\n                Token::Tuple { len: 1 },\n                    Token::I32(1),\n                Token::TupleEnd,\n\n                Token::Tuple { len: 2 },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::TupleEnd,\n            Token::TupleEnd,\n        ],\n        [0; 0] =\u003e \u0026[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n    }\n    test_tuple {\n        (1,) =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n                Token::I32(1),\n            Token::SeqEnd,\n        ],\n        (1, 2, 3) =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n        (1,) =\u003e \u0026[\n            Token::Tuple { len: 1 },\n                Token::I32(1),\n            Token::TupleEnd,\n        ],\n        (1, 2, 3) =\u003e \u0026[\n            Token::Tuple { len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleEnd,\n        ],\n    }\n    test_btreemap {\n        BTreeMap::\u003cisize, isize\u003e::new() =\u003e \u0026[\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n        ],\n        btreemap![1 =\u003e 2] =\u003e \u0026[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        btreemap![1 =\u003e 2, 3 =\u003e 4] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::I32(2),\n\n                Token::I32(3),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n        btreemap![1 =\u003e btreemap![], 2 =\u003e btreemap![3 =\u003e 4, 5 =\u003e 6]] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::Map { len: Some(0) },\n                Token::MapEnd,\n\n                Token::I32(2),\n                Token::Map { len: Some(2) },\n                    Token::I32(3),\n                    Token::I32(4),\n\n                    Token::I32(5),\n                    Token::I32(6),\n                Token::MapEnd,\n            Token::MapEnd,\n        ],\n        BTreeMap::\u003cisize, isize\u003e::new() =\u003e \u0026[\n            Token::Struct { name: \"Anything\", len: 0 },\n            Token::StructEnd,\n        ],\n    }\n    test_hashmap {\n        HashMap::\u003cisize, isize\u003e::new() =\u003e \u0026[\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n        ],\n        hashmap![1 =\u003e 2] =\u003e \u0026[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        hashmap![1 =\u003e 2, 3 =\u003e 4] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::I32(2),\n\n                Token::I32(3),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n        hashmap![1 =\u003e hashmap![], 2 =\u003e hashmap![3 =\u003e 4, 5 =\u003e 6]] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::Map { len: Some(0) },\n                Token::MapEnd,\n\n                Token::I32(2),\n                Token::Map { len: Some(2) },\n                    Token::I32(3),\n                    Token::I32(4),\n\n                    Token::I32(5),\n                    Token::I32(6),\n                Token::MapEnd,\n            Token::MapEnd,\n        ],\n        HashMap::\u003cisize, isize\u003e::new() =\u003e \u0026[\n            Token::Struct { name: \"Anything\", len: 0 },\n            Token::StructEnd,\n        ],\n        hashmap![FnvHasher @ 1 =\u003e 2, 3 =\u003e 4] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::I32(2),\n\n                Token::I32(3),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n    }\n    test_struct {\n        Struct { a: 1, b: 2, c: 0 } =\u003e \u0026[\n            Token::Map { len: Some(3) },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        Struct { a: 1, b: 2, c: 0 } =\u003e \u0026[\n            Token::Map { len: Some(3) },\n                Token::U32(0),\n                Token::I32(1),\n\n                Token::U32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        Struct { a: 1, b: 2, c: 0 } =\u003e \u0026[\n            Token::Struct { name: \"Struct\", len: 2 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n            Token::StructEnd,\n        ],\n        Struct { a: 1, b: 2, c: 0 } =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_struct_with_skip {\n        Struct { a: 1, b: 2, c: 0 } =\u003e \u0026[\n            Token::Map { len: Some(3) },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n\n                Token::Str(\"c\"),\n                Token::I32(3),\n\n                Token::Str(\"d\"),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n        Struct { a: 1, b: 2, c: 0 } =\u003e \u0026[\n            Token::Struct { name: \"Struct\", len: 2 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n\n                Token::Str(\"c\"),\n                Token::I32(3),\n\n                Token::Str(\"d\"),\n                Token::I32(4),\n            Token::StructEnd,\n        ],\n    }\n    test_struct_skip_all {\n        StructSkipAll { a: 0 } =\u003e \u0026[\n            Token::Struct { name: \"StructSkipAll\", len: 0 },\n            Token::StructEnd,\n        ],\n        StructSkipAll { a: 0 } =\u003e \u0026[\n            Token::Struct { name: \"StructSkipAll\", len: 0 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n            Token::StructEnd,\n        ],\n    }\n    test_struct_skip_default {\n        StructSkipDefault { a: 16 } =\u003e \u0026[\n            Token::Struct { name: \"StructSkipDefault\", len: 0 },\n            Token::StructEnd,\n        ],\n    }\n    test_struct_skip_all_deny_unknown {\n        StructSkipAllDenyUnknown { a: 0 } =\u003e \u0026[\n            Token::Struct { name: \"StructSkipAllDenyUnknown\", len: 0 },\n            Token::StructEnd,\n        ],\n    }\n    test_struct_default {\n        StructDefault { a: 50, b: \"overwritten\".to_string() } =\u003e \u0026[\n            Token::Struct { name: \"StructDefault\", len: 2 },\n                Token::Str(\"a\"),\n                Token::I32(50),\n\n                Token::Str(\"b\"),\n                Token::String(\"overwritten\"),\n            Token::StructEnd,\n        ],\n        StructDefault { a: 100, b: \"default\".to_string() } =\u003e \u0026[\n            Token::Struct { name: \"StructDefault\",  len: 2 },\n            Token::StructEnd,\n        ],\n    }\n    test_enum_unit {\n        Enum::Unit =\u003e \u0026[\n            Token::UnitVariant { name: \"Enum\", variant: \"Unit\" },\n        ],\n    }\n    test_enum_simple {\n        Enum::Simple(1) =\u003e \u0026[\n            Token::NewtypeVariant { name: \"Enum\", variant: \"Simple\" },\n            Token::I32(1),\n        ],\n    }\n    test_enum_seq {\n        Enum::Seq(1, 2, 3) =\u003e \u0026[\n            Token::TupleVariant { name: \"Enum\", variant: \"Seq\", len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleVariantEnd,\n        ],\n    }\n    test_enum_map {\n        Enum::Map { a: 1, b: 2, c: 3 } =\u003e \u0026[\n            Token::StructVariant { name: \"Enum\", variant: \"Map\", len: 3 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n\n                Token::Str(\"c\"),\n                Token::I32(3),\n            Token::StructVariantEnd,\n        ],\n    }\n    test_enum_unit_usize {\n        Enum::Unit =\u003e \u0026[\n            Token::Enum { name: \"Enum\" },\n            Token::U32(0),\n            Token::Unit,\n        ],\n    }\n    test_enum_unit_bytes {\n        Enum::Unit =\u003e \u0026[\n            Token::Enum { name: \"Enum\" },\n            Token::Bytes(b\"Unit\"),\n            Token::Unit,\n        ],\n    }\n    test_enum_other_unit {\n        EnumOther::Unit =\u003e \u0026[\n            Token::Enum { name: \"EnumOther\" },\n            Token::Str(\"Unit\"),\n            Token::Unit,\n        ],\n    }\n    test_enum_other {\n        EnumOther::Other =\u003e \u0026[\n            Token::Enum { name: \"EnumOther\" },\n            Token::Str(\"Foo\"),\n            Token::Unit,\n        ],\n    }\n    test_box {\n        Box::new(0i32) =\u003e \u0026[Token::I32(0)],\n    }\n    test_boxed_slice {\n        Box::new([0, 1, 2]) =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n            Token::I32(0),\n            Token::I32(1),\n            Token::I32(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_duration {\n        Duration::new(1, 2) =\u003e \u0026[\n            Token::Struct { name: \"Duration\", len: 2 },\n                Token::Str(\"secs\"),\n                Token::U64(1),\n\n                Token::Str(\"nanos\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n        Duration::new(1, 2) =\u003e \u0026[\n            Token::Seq { len: Some(2) },\n                Token::I64(1),\n                Token::I64(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_system_time {\n        UNIX_EPOCH + Duration::new(1, 2) =\u003e \u0026[\n            Token::Struct { name: \"SystemTime\", len: 2 },\n                Token::Str(\"secs_since_epoch\"),\n                Token::U64(1),\n\n                Token::Str(\"nanos_since_epoch\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n        UNIX_EPOCH + Duration::new(1, 2) =\u003e \u0026[\n            Token::Seq { len: Some(2) },\n                Token::I64(1),\n                Token::I64(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_range {\n        1u32..2u32 =\u003e \u0026[\n            Token::Struct { name: \"Range\", len: 2 },\n                Token::Str(\"start\"),\n                Token::U32(1),\n\n                Token::Str(\"end\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n        1u32..2u32 =\u003e \u0026[\n            Token::Seq { len: Some(2) },\n                Token::U64(1),\n                Token::U64(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_range_inclusive {\n        1u32..=2u32 =\u003e \u0026[\n            Token::Struct { name: \"RangeInclusive\", len: 2 },\n                Token::Str(\"start\"),\n                Token::U32(1),\n\n                Token::Str(\"end\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n        1u32..=2u32 =\u003e \u0026[\n            Token::Seq { len: Some(2) },\n                Token::U64(1),\n                Token::U64(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_bound {\n        Bound::Unbounded::\u003c()\u003e =\u003e \u0026[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Unbounded\"),\n            Token::Unit,\n        ],\n        Bound::Included(0) =\u003e \u0026[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Included\"),\n            Token::U8(0),\n        ],\n        Bound::Excluded(0) =\u003e \u0026[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Excluded\"),\n            Token::U8(0),\n        ],\n    }\n    test_path {\n        Path::new(\"/usr/local/lib\") =\u003e \u0026[\n            Token::BorrowedStr(\"/usr/local/lib\"),\n        ],\n    }\n    test_path_buf {\n        PathBuf::from(\"/usr/local/lib\") =\u003e \u0026[\n            Token::String(\"/usr/local/lib\"),\n        ],\n    }\n    test_cstring {\n        CString::new(\"abc\").unwrap() =\u003e \u0026[\n            Token::Bytes(b\"abc\"),\n        ],\n    }\n    test_rc {\n        Rc::new(true) =\u003e \u0026[\n            Token::Bool(true),\n        ],\n    }\n    test_rc_weak_some {\n        SkipPartialEq(RcWeak::\u003cbool\u003e::new()) =\u003e \u0026[\n            Token::Some,\n            Token::Bool(true),\n        ],\n    }\n    test_rc_weak_none {\n        SkipPartialEq(RcWeak::\u003cbool\u003e::new()) =\u003e \u0026[\n            Token::None,\n        ],\n    }\n    test_arc {\n        Arc::new(true) =\u003e \u0026[\n            Token::Bool(true),\n        ],\n    }\n    test_arc_weak_some {\n        SkipPartialEq(ArcWeak::\u003cbool\u003e::new()) =\u003e \u0026[\n            Token::Some,\n            Token::Bool(true),\n        ],\n    }\n    test_arc_weak_none {\n        SkipPartialEq(ArcWeak::\u003cbool\u003e::new()) =\u003e \u0026[\n            Token::None,\n        ],\n    }\n    test_wrapping {\n        Wrapping(1usize) =\u003e \u0026[\n            Token::U32(1),\n        ],\n        Wrapping(1usize) =\u003e \u0026[\n            Token::U64(1),\n        ],\n    }\n    test_rc_dst {\n        Rc::\u003cstr\u003e::from(\"s\") =\u003e \u0026[\n            Token::Str(\"s\"),\n        ],\n        Rc::\u003c[bool]\u003e::from(\u0026[true][..]) =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n    }\n    test_arc_dst {\n        Arc::\u003cstr\u003e::from(\"s\") =\u003e \u0026[\n            Token::Str(\"s\"),\n        ],\n        Arc::\u003c[bool]\u003e::from(\u0026[true][..]) =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n    }\n    test_ignored_any {\n        IgnoredAny =\u003e \u0026[\n            Token::Str(\"s\"),\n        ],\n        IgnoredAny =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n        IgnoredAny =\u003e \u0026[\n            Token::Enum { name: \"E\" },\n            Token::Str(\"Rust\"),\n            Token::Unit,\n        ],\n    }\n}\n\ndeclare_tests! {\n    readable\n\n    test_net_ipv4addr_readable {\n        \"1.2.3.4\".parse::\u003cnet::Ipv4Addr\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4\")],\n    }\n    test_net_ipv6addr_readable {\n        \"::1\".parse::\u003cnet::Ipv6Addr\u003e().unwrap() =\u003e \u0026[Token::Str(\"::1\")],\n    }\n    test_net_ipaddr_readable {\n        \"1.2.3.4\".parse::\u003cnet::IpAddr\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4\")],\n    }\n    test_net_socketaddr_readable {\n        \"1.2.3.4:1234\".parse::\u003cnet::SocketAddr\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4:1234\")],\n        \"1.2.3.4:1234\".parse::\u003cnet::SocketAddrV4\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4:1234\")],\n        \"[::1]:1234\".parse::\u003cnet::SocketAddrV6\u003e().unwrap() =\u003e \u0026[Token::Str(\"[::1]:1234\")],\n    }\n}\n\ndeclare_tests! {\n    compact\n\n    test_net_ipv4addr_compact {\n        net::Ipv4Addr::from(*b\"1234\") =\u003e \u0026seq![\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd\n        ],\n    }\n    test_net_ipv6addr_compact {\n        net::Ipv6Addr::from(*b\"1234567890123456\") =\u003e \u0026seq![\n            Token::Tuple { len: 4 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd\n        ],\n    }\n    test_net_ipaddr_compact {\n        net::IpAddr::from(*b\"1234\") =\u003e \u0026seq![\n            Token::NewtypeVariant { name: \"IpAddr\", variant: \"V4\" },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd\n        ],\n    }\n    test_net_socketaddr_compact {\n        net::SocketAddr::from((*b\"1234567890123456\", 1234)) =\u003e \u0026seq![\n            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V6\" },\n\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd\n        ],\n        net::SocketAddr::from((*b\"1234\", 1234)) =\u003e \u0026seq![\n            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V4\" },\n\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd\n        ],\n        net::SocketAddrV4::new(net::Ipv4Addr::from(*b\"1234\"), 1234) =\u003e \u0026seq![\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd\n        ],\n        net::SocketAddrV6::new(net::Ipv6Addr::from(*b\"1234567890123456\"), 1234, 0, 0) =\u003e \u0026seq![\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd\n        ],\n    }\n}\n\n#[cfg(feature = \"unstable\")]\ndeclare_tests! {\n    test_never_result {\n        Ok::\u003cu8, !\u003e(0) =\u003e \u0026[\n            Token::NewtypeVariant { name: \"Result\", variant: \"Ok\" },\n            Token::U8(0),\n        ],\n    }\n}\n\n#[cfg(unix)]\n#[test]\nfn test_osstring() {\n    use std::os::unix::ffi::OsStringExt;\n\n    let value = OsString::from_vec(vec![1, 2, 3]);\n    let tokens = [\n        Token::Enum { name: \"OsString\" },\n        Token::Str(\"Unix\"),\n        Token::Seq { len: Some(2) },\n        Token::U8(1),\n        Token::U8(2),\n        Token::U8(3),\n        Token::SeqEnd,\n    ];\n\n    assert_de_tokens(\u0026value, \u0026tokens);\n    assert_de_tokens_ignore(\u0026tokens);\n}\n\n#[cfg(windows)]\n#[test]\nfn test_osstring() {\n    use std::os::windows::ffi::OsStringExt;\n\n    let value = OsString::from_wide(\u0026[1, 2, 3]);\n    let tokens = [\n        Token::Enum { name: \"OsString\" },\n        Token::Str(\"Windows\"),\n        Token::Seq { len: Some(2) },\n        Token::U16(1),\n        Token::U16(2),\n        Token::U16(3),\n        Token::SeqEnd,\n    ];\n\n    assert_de_tokens(\u0026value, \u0026tokens);\n    assert_de_tokens_ignore(\u0026tokens);\n}\n\n#[test]\nfn test_cstr() {\n    assert_de_tokens::\u003cBox\u003cCStr\u003e\u003e(\n        \u0026CString::new(\"abc\").unwrap().into_boxed_c_str(),\n        \u0026[Token::Bytes(b\"abc\")],\n    );\n}\n\n#[test]\nfn test_cstr_internal_null() {\n    assert_de_tokens_error::\u003cBox\u003cCStr\u003e\u003e(\n        \u0026[Token::Bytes(b\"a\\0c\")],\n        \"nul byte found in provided data at position: 1\",\n    );\n}\n\n#[test]\nfn test_cstr_internal_null_end() {\n    assert_de_tokens_error::\u003cBox\u003cCStr\u003e\u003e(\n        \u0026[Token::Bytes(b\"ac\\0\")],\n        \"nul byte found in provided data at position: 2\",\n    );\n}\n\n#[cfg(feature = \"unstable\")]\n#[test]\nfn test_never_type() {\n    assert_de_tokens_error::\u003c!\u003e(\u0026[], \"cannot deserialize `!`\");\n\n    assert_de_tokens_error::\u003cResult\u003cu8, !\u003e\u003e(\n        \u0026[Token::NewtypeVariant {\n            name: \"Result\",\n            variant: \"Err\",\n        }],\n        \"cannot deserialize `!`\",\n    );\n}\n\n#[test]\nfn test_atomics() {\n    fn test\u003cL, A, T\u003e(load: L, val: T, token: Token)\n    where\n        L: Fn(\u0026A, Ordering) -\u003e T,\n        A: DeserializeOwned,\n        T: PartialEq + Debug,\n    {\n        let tokens = \u0026[token];\n        let mut de = serde_test::Deserializer::new(tokens);\n        match A::deserialize(\u0026mut de) {\n            Ok(v) =\u003e {\n                let loaded = load(\u0026v, Ordering::SeqCst);\n                assert_eq!(val, loaded);\n            }\n            Err(e) =\u003e panic!(\"tokens failed to deserialize: {}\", e),\n        };\n        if de.remaining() \u003e 0 {\n            panic!(\"{} remaining tokens\", de.remaining());\n        }\n    }\n\n    test(AtomicBool::load, true, Token::Bool(true));\n    test(AtomicI8::load, -127, Token::I8(-127i8));\n    test(AtomicI16::load, -510, Token::I16(-510i16));\n    test(AtomicI32::load, -131072, Token::I32(-131072i32));\n    test(AtomicIsize::load, -131072isize, Token::I32(-131072));\n    test(AtomicU8::load, 127, Token::U8(127u8));\n    test(AtomicU16::load, 510u16, Token::U16(510u16));\n    test(AtomicU32::load, 131072u32, Token::U32(131072u32));\n    test(AtomicUsize::load, 131072usize, Token::U32(131072));\n\n    #[cfg(target_arch = \"x86_64\")]\n    {\n        test(AtomicI64::load, -8589934592, Token::I64(-8589934592));\n        test(AtomicU64::load, 8589934592u64, Token::U64(8589934592));\n    }\n}\n\ndeclare_error_tests! {\n    test_unknown_field\u003cStructDenyUnknown\u003e {\n        \u0026[\n            Token::Struct { name: \"StructDenyUnknown\", len: 1 },\n                Token::Str(\"a\"),\n                Token::I32(0),\n\n                Token::Str(\"d\"),\n        ],\n        \"unknown field `d`, expected `a`\",\n    }\n    test_skipped_field_is_unknown\u003cStructDenyUnknown\u003e {\n        \u0026[\n            Token::Struct { name: \"StructDenyUnknown\", len: 1 },\n                Token::Str(\"b\"),\n        ],\n        \"unknown field `b`, expected `a`\",\n    }\n    test_skip_all_deny_unknown\u003cStructSkipAllDenyUnknown\u003e {\n        \u0026[\n            Token::Struct { name: \"StructSkipAllDenyUnknown\", len: 0 },\n                Token::Str(\"a\"),\n        ],\n        \"unknown field `a`, there are no fields\",\n    }\n    test_unknown_variant\u003cEnum\u003e {\n        \u0026[\n            Token::UnitVariant { name: \"Enum\", variant: \"Foo\" },\n        ],\n        \"unknown variant `Foo`, expected one of `Unit`, `Simple`, `Seq`, `Map`\",\n    }\n    test_enum_skipped_variant\u003cEnum\u003e {\n        \u0026[\n            Token::UnitVariant { name: \"Enum\", variant: \"Skipped\" },\n        ],\n        \"unknown variant `Skipped`, expected one of `Unit`, `Simple`, `Seq`, `Map`\",\n    }\n    test_enum_skip_all\u003cEnumSkipAll\u003e {\n        \u0026[\n            Token::UnitVariant { name: \"EnumSkipAll\", variant: \"Skipped\" },\n        ],\n        \"unknown variant `Skipped`, there are no variants\",\n    }\n    test_duplicate_field_struct\u003cStruct\u003e {\n        \u0026[\n            Token::Map { len: Some(3) },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"a\"),\n        ],\n        \"duplicate field `a`\",\n    }\n    test_duplicate_field_enum\u003cEnum\u003e {\n        \u0026[\n            Token::StructVariant { name: \"Enum\", variant: \"Map\", len: 3 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"a\"),\n        ],\n        \"duplicate field `a`\",\n    }\n    test_enum_out_of_range\u003cEnum\u003e {\n        \u0026[\n            Token::Enum { name: \"Enum\" },\n            Token::U32(4),\n            Token::Unit,\n        ],\n        \"invalid value: integer `4`, expected variant index 0 \u003c= i \u003c 4\",\n    }\n    test_short_tuple\u003c(u8, u8, u8)\u003e {\n        \u0026[\n            Token::Tuple { len: 1 },\n            Token::U8(1),\n            Token::TupleEnd,\n        ],\n        \"invalid length 1, expected a tuple of size 3\",\n    }\n    test_short_array\u003c[u8; 3]\u003e {\n        \u0026[\n            Token::Seq { len: Some(1) },\n            Token::U8(1),\n            Token::SeqEnd,\n        ],\n        \"invalid length 1, expected an array of length 3\",\n    }\n    test_cstring_internal_null\u003cCString\u003e {\n        \u0026[\n            Token::Bytes(b\"a\\0c\"),\n        ],\n        \"nul byte found in provided data at position: 1\",\n    }\n    test_cstring_internal_null_end\u003cCString\u003e {\n        \u0026[\n            Token::Bytes(b\"ac\\0\"),\n        ],\n        \"nul byte found in provided data at position: 2\",\n    }\n    test_unit_from_empty_seq\u003c()\u003e {\n        \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected unit\",\n    }\n    test_unit_from_empty_seq_without_len\u003c()\u003e {\n        \u0026[\n            Token::Seq { len: None },\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected unit\",\n    }\n    test_unit_from_tuple_struct\u003c()\u003e {\n        \u0026[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n        \"invalid type: sequence, expected unit\",\n    }\n    test_string_from_unit\u003cString\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a string\",\n    }\n    test_btreeset_from_unit\u003cBTreeSet\u003cisize\u003e\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_btreeset_from_unit_struct\u003cBTreeSet\u003cisize\u003e\u003e {\n        \u0026[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_hashset_from_unit\u003cHashSet\u003cisize\u003e\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_hashset_from_unit_struct\u003cHashSet\u003cisize\u003e\u003e {\n        \u0026[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_vec_from_unit\u003cVec\u003cisize\u003e\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_vec_from_unit_struct\u003cVec\u003cisize\u003e\u003e {\n        \u0026[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_zero_array_from_unit\u003c[isize; 0]\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected an empty array\",\n    }\n    test_zero_array_from_unit_struct\u003c[isize; 0]\u003e {\n        \u0026[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected an empty array\",\n    }\n    test_btreemap_from_unit\u003cBTreeMap\u003cisize, isize\u003e\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a map\",\n    }\n    test_btreemap_from_unit_struct\u003cBTreeMap\u003cisize, isize\u003e\u003e {\n        \u0026[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a map\",\n    }\n    test_hashmap_from_unit\u003cHashMap\u003cisize, isize\u003e\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a map\",\n    }\n    test_hashmap_from_unit_struct\u003cHashMap\u003cisize, isize\u003e\u003e {\n        \u0026[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a map\",\n    }\n    test_bool_from_string\u003cbool\u003e {\n        \u0026[\n            Token::Str(\"false\"),\n        ],\n        \"invalid type: string \\\"false\\\", expected a boolean\",\n    }\n    test_number_from_string\u003cisize\u003e {\n        \u0026[\n            Token::Str(\"1\"),\n        ],\n        \"invalid type: string \\\"1\\\", expected isize\",\n    }\n    test_integer_from_float\u003cisize\u003e {\n        \u0026[\n            Token::F32(0.0),\n        ],\n        \"invalid type: floating point `0`, expected isize\",\n    }\n    test_unit_struct_from_seq\u003cUnitStruct\u003e {\n        \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected unit struct UnitStruct\",\n    }\n    test_wrapping_overflow\u003cWrapping\u003cu16\u003e\u003e {\n        \u0026[\n            Token::U32(65_536),\n        ],\n        \"invalid value: integer `65536`, expected u16\",\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_gen.rs"],"content":"// These just test that serde_derive is able to produce code that compiles\n// successfully when there are a variety of generics and non-(de)serializable\n// types involved.\n\n#![deny(warnings)]\n#![cfg_attr(feature = \"unstable\", feature(non_ascii_idents))]\n#![allow(clippy::trivially_copy_pass_by_ref)]\n\nuse serde::de::DeserializeOwned;\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\nuse std::borrow::Cow;\nuse std::marker::PhantomData;\nuse std::option::Option as StdOption;\nuse std::result::Result as StdResult;\n\n// Try to trip up the generated code if it fails to use fully qualified paths.\n#[allow(dead_code)]\nstruct Result;\n#[allow(dead_code)]\nstruct Ok;\n#[allow(dead_code)]\nstruct Err;\n#[allow(dead_code)]\nstruct Option;\n#[allow(dead_code)]\nstruct Some;\n#[allow(dead_code)]\nstruct None;\n\n//////////////////////////////////////////////////////////////////////////\n\n#[test]\nfn test_gen() {\n    #[derive(Serialize, Deserialize)]\n    struct With\u003cT\u003e {\n        t: T,\n        #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n        x: X,\n    }\n    assert::\u003cWith\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct WithTogether\u003cT\u003e {\n        t: T,\n        #[serde(with = \"both_x\")]\n        x: X,\n    }\n    assert::\u003cWithTogether\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct WithRef\u003c'a, T: 'a\u003e {\n        #[serde(skip_deserializing)]\n        t: StdOption\u003c\u0026'a T\u003e,\n        #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n        x: X,\n    }\n    assert::\u003cWithRef\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct PhantomX {\n        x: PhantomData\u003cX\u003e,\n    }\n    assert::\u003cPhantomX\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct PhantomT\u003cT\u003e {\n        t: PhantomData\u003cT\u003e,\n    }\n    assert::\u003cPhantomT\u003cX\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct NoBounds\u003cT\u003e {\n        t: T,\n        option: StdOption\u003cT\u003e,\n        boxed: Box\u003cT\u003e,\n        option_boxed: StdOption\u003cBox\u003cT\u003e\u003e,\n    }\n    assert::\u003cNoBounds\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    enum EnumWith\u003cT\u003e {\n        Unit,\n        Newtype(#[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")] X),\n        Tuple(\n            T,\n            #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")] X,\n        ),\n        Struct {\n            t: T,\n            #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n            x: X,\n        },\n    }\n    assert::\u003cEnumWith\u003ci32\u003e\u003e();\n\n    #[derive(Serialize)]\n    struct MultipleRef\u003c'a, 'b, 'c, T\u003e\n    where\n        T: 'c,\n        'c: 'b,\n        'b: 'a,\n    {\n        t: T,\n        rrrt: \u0026'a \u0026'b \u0026'c T,\n    }\n    assert_ser::\u003cMultipleRef\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct Newtype(#[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")] X);\n    assert::\u003cNewtype\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct Tuple\u003cT\u003e(\n        T,\n        #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")] X,\n    );\n    assert::\u003cTuple\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    enum TreeNode\u003cD\u003e {\n        Split {\n            left: Box\u003cTreeNode\u003cD\u003e\u003e,\n            right: Box\u003cTreeNode\u003cD\u003e\u003e,\n        },\n        Leaf {\n            data: D,\n        },\n    }\n    assert::\u003cTreeNode\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct ListNode\u003cD\u003e {\n        data: D,\n        next: Box\u003cListNode\u003cD\u003e\u003e,\n    }\n    assert::\u003cListNode\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct RecursiveA {\n        b: Box\u003cRecursiveB\u003e,\n    }\n    assert::\u003cRecursiveA\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    enum RecursiveB {\n        A(RecursiveA),\n    }\n    assert::\u003cRecursiveB\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct RecursiveGenericA\u003cT\u003e {\n        t: T,\n        b: Box\u003cRecursiveGenericB\u003cT\u003e\u003e,\n    }\n    assert::\u003cRecursiveGenericA\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    enum RecursiveGenericB\u003cT\u003e {\n        T(T),\n        A(RecursiveGenericA\u003cT\u003e),\n    }\n    assert::\u003cRecursiveGenericB\u003ci32\u003e\u003e();\n\n    #[derive(Serialize)]\n    struct OptionStatic\u003c'a\u003e {\n        a: StdOption\u003c\u0026'a str\u003e,\n        b: StdOption\u003c\u0026'static str\u003e,\n    }\n    assert_ser::\u003cOptionStatic\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound = \"D: SerializeWith + DeserializeWith\")]\n    struct WithTraits1\u003cD, E\u003e {\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\"\n        )]\n        d: D,\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\",\n            bound = \"E: SerializeWith + DeserializeWith\"\n        )]\n        e: E,\n    }\n    assert::\u003cWithTraits1\u003cX, X\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound(serialize = \"D: SerializeWith\", deserialize = \"D: DeserializeWith\"))]\n    struct WithTraits2\u003cD, E\u003e {\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\"\n        )]\n        d: D,\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            bound(serialize = \"E: SerializeWith\")\n        )]\n        #[serde(\n            deserialize_with = \"DeserializeWith::deserialize_with\",\n            bound(deserialize = \"E: DeserializeWith\")\n        )]\n        e: E,\n    }\n    assert::\u003cWithTraits2\u003cX, X\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound = \"D: SerializeWith + DeserializeWith\")]\n    enum VariantWithTraits1\u003cD, E\u003e {\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\"\n        )]\n        D(D),\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\",\n            bound = \"E: SerializeWith + DeserializeWith\"\n        )]\n        E(E),\n    }\n    assert::\u003cVariantWithTraits1\u003cX, X\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound(serialize = \"D: SerializeWith\", deserialize = \"D: DeserializeWith\"))]\n    enum VariantWithTraits2\u003cD, E\u003e {\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\"\n        )]\n        D(D),\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            bound(serialize = \"E: SerializeWith\")\n        )]\n        #[serde(\n            deserialize_with = \"DeserializeWith::deserialize_with\",\n            bound(deserialize = \"E: DeserializeWith\")\n        )]\n        E(E),\n    }\n    assert::\u003cVariantWithTraits2\u003cX, X\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct CowStr\u003c'a\u003e(Cow\u003c'a, str\u003e);\n    assert::\u003cCowStr\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound(deserialize = \"T::Owned: DeserializeOwned\"))]\n    struct CowT\u003c'a, T: ?Sized + 'a + ToOwned\u003e(Cow\u003c'a, T\u003e);\n    assert::\u003cCowT\u003cstr\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct EmptyStruct {}\n    assert::\u003cEmptyStruct\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    enum EmptyEnumVariant {\n        EmptyStruct {},\n    }\n    assert::\u003cEmptyEnumVariant\u003e();\n\n    #[cfg(feature = \"unstable\")]\n    #[derive(Serialize, Deserialize)]\n    struct NonAsciiIdents {\n        :  f64,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct EmptyBraced {}\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct EmptyBracedDenyUnknown {}\n\n    #[derive(Serialize, Deserialize)]\n    struct BracedSkipAll {\n        #[serde(skip_deserializing)]\n        f: u8,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct BracedSkipAllDenyUnknown {\n        #[serde(skip_deserializing)]\n        f: u8,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct EmptyTuple();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct EmptyTupleDenyUnknown();\n\n    #[derive(Serialize, Deserialize)]\n    struct TupleSkipAll(#[serde(skip_deserializing)] u8);\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct TupleSkipAllDenyUnknown(#[serde(skip_deserializing)] u8);\n\n    #[derive(Serialize, Deserialize)]\n    enum EmptyEnum {}\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    enum EmptyEnumDenyUnknown {}\n\n    #[derive(Serialize, Deserialize)]\n    enum EnumSkipAll {\n        #[serde(skip_deserializing)]\n        #[allow(dead_code)]\n        Variant,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    enum EmptyVariants {\n        Braced {},\n        Tuple(),\n        BracedSkip {\n            #[serde(skip_deserializing)]\n            f: u8,\n        },\n        TupleSkip(#[serde(skip_deserializing)] u8),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    enum EmptyVariantsDenyUnknown {\n        Braced {},\n        Tuple(),\n        BracedSkip {\n            #[serde(skip_deserializing)]\n            f: u8,\n        },\n        TupleSkip(#[serde(skip_deserializing)] u8),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct UnitDenyUnknown;\n\n    #[derive(Serialize, Deserialize)]\n    struct EmptyArray {\n        empty: [X; 0],\n    }\n\n    enum Or\u003cA, B\u003e {\n        A(A),\n        B(B),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(untagged, remote = \"Or\")]\n    enum OrDef\u003cA, B\u003e {\n        A(A),\n        B(B),\n    }\n\n    struct Str\u003c'a\u003e(\u0026'a str);\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(remote = \"Str\")]\n    struct StrDef\u003c'a\u003e(\u0026'a str);\n\n    #[derive(Serialize, Deserialize)]\n    struct Remote\u003c'a\u003e {\n        #[serde(with = \"OrDef\")]\n        or: Or\u003cu8, bool\u003e,\n        #[serde(borrow, with = \"StrDef\")]\n        s: Str\u003c'a\u003e,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    enum BorrowVariant\u003c'a\u003e {\n        #[serde(borrow, with = \"StrDef\")]\n        S(Str\u003c'a\u003e),\n    }\n\n    mod vis {\n        use serde::{Deserialize, Serialize};\n\n        pub struct S;\n\n        #[derive(Serialize, Deserialize)]\n        #[serde(remote = \"S\")]\n        pub struct SDef;\n    }\n\n    // This would not work if SDef::serialize / deserialize are private.\n    #[derive(Serialize, Deserialize)]\n    struct RemoteVisibility {\n        #[serde(with = \"vis::SDef\")]\n        s: vis::S,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(remote = \"Self\")]\n    struct RemoteSelf;\n\n    #[derive(Serialize, Deserialize)]\n    enum ExternallyTaggedVariantWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Newtype(X),\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Tuple(String, u8),\n\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Struct1 { x: X },\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Struct { f1: String, f2: u8 },\n\n        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n        #[allow(dead_code)]\n        Unit,\n    }\n    assert_ser::\u003cExternallyTaggedVariantWith\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(tag = \"t\")]\n    enum InternallyTaggedVariantWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Newtype(X),\n\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Struct1 { x: X },\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Struct { f1: String, f2: u8 },\n\n        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n        #[allow(dead_code)]\n        Unit,\n    }\n    assert_ser::\u003cInternallyTaggedVariantWith\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum AdjacentlyTaggedVariantWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Newtype(X),\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Tuple(String, u8),\n\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Struct1 { x: X },\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Struct { f1: String, f2: u8 },\n\n        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n        #[allow(dead_code)]\n        Unit,\n    }\n    assert_ser::\u003cAdjacentlyTaggedVariantWith\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum UntaggedVariantWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Newtype(X),\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Tuple(String, u8),\n\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Struct1 { x: X },\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Struct { f1: String, f2: u8 },\n\n        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n        #[allow(dead_code)]\n        Unit,\n    }\n    assert_ser::\u003cUntaggedVariantWith\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct FlattenWith {\n        #[serde(flatten, serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n        x: X,\n    }\n    assert::\u003cFlattenWith\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct FlattenDenyUnknown\u003cT\u003e {\n        #[serde(flatten)]\n        t: T,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct StaticStrStruct\u003c'a\u003e {\n        a: \u0026'a str,\n        b: \u0026'static str,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct StaticStrTupleStruct\u003c'a\u003e(\u0026'a str, \u0026'static str);\n\n    #[derive(Serialize, Deserialize)]\n    struct StaticStrNewtypeStruct(\u0026'static str);\n\n    #[derive(Serialize, Deserialize)]\n    enum StaticStrEnum\u003c'a\u003e {\n        Struct { a: \u0026'a str, b: \u0026'static str },\n        Tuple(\u0026'a str, \u0026'static str),\n        Newtype(\u0026'static str),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct SkippedStaticStr {\n        #[serde(skip_deserializing)]\n        skipped: \u0026'static str,\n        other: isize,\n    }\n    assert::\u003cSkippedStaticStr\u003e();\n\n    macro_rules! T {\n        () =\u003e {\n            ()\n        };\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct TypeMacro\u003cT\u003e {\n        mac: T!(),\n        marker: PhantomData\u003cT\u003e,\n    }\n    assert::\u003cTypeMacro\u003cX\u003e\u003e();\n\n    #[derive(Serialize)]\n    struct BigArray {\n        #[serde(serialize_with = \"\u003c[_]\u003e::serialize\")]\n        array: [u8; 256],\n    }\n    assert_ser::\u003cBigArray\u003e();\n\n    trait AssocSerde {\n        type Assoc;\n    }\n\n    struct NoSerdeImpl;\n    impl AssocSerde for NoSerdeImpl {\n        type Assoc = u32;\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct AssocDerive\u003cT: AssocSerde\u003e {\n        assoc: T::Assoc,\n    }\n\n    assert::\u003cAssocDerive\u003cNoSerdeImpl\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct AssocDeriveMulti\u003cS, T: AssocSerde\u003e {\n        s: S,\n        assoc: T::Assoc,\n    }\n\n    assert::\u003cAssocDeriveMulti\u003ci32, NoSerdeImpl\u003e\u003e();\n\n    #[derive(Serialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum EmptyAdjacentlyTagged {\n        #[allow(dead_code)]\n        Struct {},\n        #[allow(dead_code)]\n        Tuple(),\n    }\n\n    assert_ser::\u003cEmptyAdjacentlyTagged\u003e();\n\n    mod restricted {\n        mod inner {\n            use serde::{Deserialize, Serialize};\n\n            #[derive(Serialize, Deserialize)]\n            struct Restricted {\n                pub(super) a: usize,\n                pub(in super::inner) b: usize,\n            }\n        }\n    }\n\n    #[derive(Deserialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum AdjacentlyTaggedVoid {}\n\n    #[derive(Serialize, Deserialize)]\n    enum SkippedVariant\u003cT\u003e {\n        #[serde(skip)]\n        #[allow(dead_code)]\n        T(T),\n        Unit,\n    }\n\n    assert::\u003cSkippedVariant\u003cX\u003e\u003e();\n\n    #[derive(Deserialize)]\n    struct ImpliciltyBorrowedOption\u003c'a\u003e {\n        option: std::option::Option\u003c\u0026'a str\u003e,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum UntaggedNewtypeVariantWith {\n        Newtype(\n            #[serde(serialize_with = \"ser_x\")]\n            #[serde(deserialize_with = \"de_x\")]\n            X,\n        ),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(transparent)]\n    struct TransparentWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        x: X,\n    }\n\n    #[derive(Deserialize)]\n    #[serde(untagged)]\n    enum UntaggedWithBorrow\u003c'a\u003e {\n        Single(#[serde(borrow)] RelObject\u003c'a\u003e),\n        Many(#[serde(borrow)] Vec\u003cRelObject\u003c'a\u003e\u003e),\n    }\n\n    #[derive(Deserialize)]\n    struct RelObject\u003c'a\u003e {\n        ty: \u0026'a str,\n        id: String,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct FlattenSkipSerializing\u003cT\u003e {\n        #[serde(flatten, skip_serializing)]\n        #[allow(dead_code)]\n        flat: T,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct FlattenSkipSerializingIf\u003cT\u003e {\n        #[serde(flatten, skip_serializing_if = \"StdOption::is_none\")]\n        flat: StdOption\u003cT\u003e,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct FlattenSkipDeserializing\u003cT\u003e {\n        #[serde(flatten, skip_deserializing)]\n        flat: T,\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nfn assert\u003cT: Serialize + DeserializeOwned\u003e() {}\nfn assert_ser\u003cT: Serialize\u003e() {}\n\ntrait SerializeWith {\n    fn serialize_with\u003cS: Serializer\u003e(_: \u0026Self, _: S) -\u003e StdResult\u003cS::Ok, S::Error\u003e;\n}\n\ntrait DeserializeWith: Sized {\n    fn deserialize_with\u003c'de, D: Deserializer\u003c'de\u003e\u003e(_: D) -\u003e StdResult\u003cSelf, D::Error\u003e;\n}\n\n// Implements neither Serialize nor Deserialize\npub struct X;\n\npub fn ser_x\u003cS: Serializer\u003e(_: \u0026X, _: S) -\u003e StdResult\u003cS::Ok, S::Error\u003e {\n    unimplemented!()\n}\n\npub fn de_x\u003c'de, D: Deserializer\u003c'de\u003e\u003e(_: D) -\u003e StdResult\u003cX, D::Error\u003e {\n    unimplemented!()\n}\n\nmod both_x {\n    pub use super::{de_x as deserialize, ser_x as serialize};\n}\n\nimpl SerializeWith for X {\n    fn serialize_with\u003cS: Serializer\u003e(_: \u0026Self, _: S) -\u003e StdResult\u003cS::Ok, S::Error\u003e {\n        unimplemented!()\n    }\n}\n\nimpl DeserializeWith for X {\n    fn deserialize_with\u003c'de, D: Deserializer\u003c'de\u003e\u003e(_: D) -\u003e StdResult\u003cSelf, D::Error\u003e {\n        unimplemented!()\n    }\n}\n\npub fn serialize_some_unit_variant\u003cS\u003e(_: S) -\u003e StdResult\u003cS::Ok, S::Error\u003e\nwhere\n    S: Serializer,\n{\n    unimplemented!()\n}\n\npub fn deserialize_some_unit_variant\u003c'de, D\u003e(_: D) -\u003e StdResult\u003c(), D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    unimplemented!()\n}\n\npub fn serialize_some_other_variant\u003cS\u003e(_: \u0026str, _: \u0026u8, _: S) -\u003e StdResult\u003cS::Ok, S::Error\u003e\nwhere\n    S: Serializer,\n{\n    unimplemented!()\n}\n\npub fn deserialize_some_other_variant\u003c'de, D\u003e(_: D) -\u003e StdResult\u003c(String, u8), D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    unimplemented!()\n}\n\npub fn is_zero(n: \u0026u8) -\u003e bool {\n    *n == 0\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_identifier.rs"],"content":"use serde::Deserialize;\nuse serde_test::{assert_de_tokens, Token};\n\n#[test]\nfn test_variant_identifier() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(variant_identifier)]\n    enum V {\n        Aaa,\n        Bbb,\n    }\n\n    assert_de_tokens(\u0026V::Aaa, \u0026[Token::U8(0)]);\n    assert_de_tokens(\u0026V::Aaa, \u0026[Token::U16(0)]);\n    assert_de_tokens(\u0026V::Aaa, \u0026[Token::U32(0)]);\n    assert_de_tokens(\u0026V::Aaa, \u0026[Token::U64(0)]);\n    assert_de_tokens(\u0026V::Aaa, \u0026[Token::Str(\"Aaa\")]);\n    assert_de_tokens(\u0026V::Aaa, \u0026[Token::Bytes(b\"Aaa\")]);\n}\n\n#[test]\nfn test_field_identifier() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(field_identifier, rename_all = \"snake_case\")]\n    enum F {\n        Aaa,\n        Bbb,\n    }\n\n    assert_de_tokens(\u0026F::Aaa, \u0026[Token::Str(\"aaa\")]);\n    assert_de_tokens(\u0026F::Aaa, \u0026[Token::Bytes(b\"aaa\")]);\n}\n\n#[test]\nfn test_unit_fallthrough() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(field_identifier, rename_all = \"snake_case\")]\n    enum F {\n        Aaa,\n        Bbb,\n        #[serde(other)]\n        Other,\n    }\n\n    assert_de_tokens(\u0026F::Other, \u0026[Token::Str(\"x\")]);\n}\n\n#[test]\nfn test_newtype_fallthrough() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(field_identifier, rename_all = \"snake_case\")]\n    enum F {\n        Aaa,\n        Bbb,\n        Other(String),\n    }\n\n    assert_de_tokens(\u0026F::Other(\"x\".to_owned()), \u0026[Token::Str(\"x\")]);\n}\n\n#[test]\nfn test_newtype_fallthrough_generic() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(field_identifier, rename_all = \"snake_case\")]\n    enum F\u003cT\u003e {\n        Aaa,\n        Bbb,\n        Other(T),\n    }\n\n    assert_de_tokens(\u0026F::Other(\"x\".to_owned()), \u0026[Token::Str(\"x\")]);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_ignored_any.rs"],"content":"use serde::de::value::{Error, MapDeserializer, SeqDeserializer};\nuse serde::de::{\n    DeserializeSeed, EnumAccess, IgnoredAny, IntoDeserializer, VariantAccess, Visitor,\n};\nuse serde::{forward_to_deserialize_any, Deserialize, Deserializer};\n\n#[derive(PartialEq, Debug, Deserialize)]\nenum Target {\n    Unit,\n    Newtype(i32),\n    Tuple(i32, i32),\n    Struct { a: i32 },\n}\n\nstruct Enum(\u0026'static str);\n\nimpl\u003c'de\u003e Deserializer\u003c'de\u003e for Enum {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\nimpl\u003c'de\u003e EnumAccess\u003c'de\u003e for Enum {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        let v = seed.deserialize(self.0.into_deserializer())?;\n        Ok((v, self))\n    }\n}\n\nimpl\u003c'de\u003e VariantAccess\u003c'de\u003e for Enum {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(10i32.into_deserializer())\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        let seq = SeqDeserializer::new(vec![1i32, 2].into_iter());\n        visitor.visit_seq(seq)\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        let map = MapDeserializer::new(vec![(\"a\", 10i32)].into_iter());\n        visitor.visit_map(map)\n    }\n}\n\n#[test]\nfn test_deserialize_enum() {\n    // First just make sure the Deserializer impl works\n    assert_eq!(Target::Unit, Target::deserialize(Enum(\"Unit\")).unwrap());\n    assert_eq!(\n        Target::Newtype(10),\n        Target::deserialize(Enum(\"Newtype\")).unwrap()\n    );\n    assert_eq!(\n        Target::Tuple(1, 2),\n        Target::deserialize(Enum(\"Tuple\")).unwrap()\n    );\n    assert_eq!(\n        Target::Struct { a: 10 },\n        Target::deserialize(Enum(\"Struct\")).unwrap()\n    );\n\n    // Now try IgnoredAny\n    IgnoredAny::deserialize(Enum(\"Unit\")).unwrap();\n    IgnoredAny::deserialize(Enum(\"Newtype\")).unwrap();\n    IgnoredAny::deserialize(Enum(\"Tuple\")).unwrap();\n    IgnoredAny::deserialize(Enum(\"Struct\")).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_macros.rs"],"content":"#![deny(trivial_numeric_casts)]\n#![allow(clippy::redundant_field_names)]\n\nmod bytes;\n\nuse serde::{Deserialize, Serialize};\nuse serde_test::{\n    assert_de_tokens, assert_de_tokens_error, assert_ser_tokens, assert_tokens, Token,\n};\n\nuse std::collections::BTreeMap;\nuse std::marker::PhantomData;\n\n// That tests that the derived Serialize implementation doesn't trigger\n// any warning about `serializer` not being used, in case of empty enums.\n#[derive(Serialize)]\n#[allow(dead_code)]\n#[deny(unused_variables)]\nenum Void {}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct NamedUnit;\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SerNamedTuple\u003c'a, 'b, A: 'a, B: 'b, C\u003e(\u0026'a A, \u0026'b mut B, C);\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct DeNamedTuple\u003cA, B, C\u003e(A, B, C);\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SerNamedMap\u003c'a, 'b, A: 'a, B: 'b, C\u003e {\n    a: \u0026'a A,\n    b: \u0026'b mut B,\n    c: C,\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct DeNamedMap\u003cA, B, C\u003e {\n    a: A,\n    b: B,\n    c: C,\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nenum SerEnum\u003c'a, B: 'a, C: 'a, D\u003e\nwhere\n    D: 'a,\n{\n    Unit,\n    Seq(i8, B, \u0026'a C, \u0026'a mut D),\n    Map { a: i8, b: B, c: \u0026'a C, d: \u0026'a mut D },\n\n    // Make sure we can support more than one variant.\n    _Unit2,\n    _Seq2(i8, B, \u0026'a C, \u0026'a mut D),\n    _Map2 { a: i8, b: B, c: \u0026'a C, d: \u0026'a mut D },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum DeEnum\u003cB, C, D\u003e {\n    Unit,\n    Seq(i8, B, C, D),\n    Map { a: i8, b: B, c: C, d: D },\n\n    // Make sure we can support more than one variant.\n    _Unit2,\n    _Seq2(i8, B, C, D),\n    _Map2 { a: i8, b: B, c: C, d: D },\n}\n\n#[derive(Serialize)]\nenum Lifetimes\u003c'a\u003e {\n    LifetimeSeq(\u0026'a i32),\n    NoLifetimeSeq(i32),\n    LifetimeMap { a: \u0026'a i32 },\n    NoLifetimeMap { a: i32 },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub struct GenericStruct\u003cT\u003e {\n    x: T,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub struct GenericNewTypeStruct\u003cT\u003e(T);\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub struct GenericTupleStruct\u003cT, U\u003e(T, U);\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub enum GenericEnum\u003cT, U\u003e {\n    Unit,\n    NewType(T),\n    Seq(T, U),\n    Map { x: T, y: U },\n}\n\ntrait AssociatedType {\n    type X;\n}\n\nimpl AssociatedType for i32 {\n    type X = i32;\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct DefaultTyParam\u003cT: AssociatedType\u003cX = i32\u003e = i32\u003e {\n    phantom: PhantomData\u003cT\u003e,\n}\n\n#[test]\nfn test_named_unit() {\n    assert_tokens(\u0026NamedUnit, \u0026[Token::UnitStruct { name: \"NamedUnit\" }]);\n}\n\n#[test]\nfn test_ser_named_tuple() {\n    let a = 5;\n    let mut b = 6;\n    let c = 7;\n    assert_ser_tokens(\n        \u0026SerNamedTuple(\u0026a, \u0026mut b, c),\n        \u0026[\n            Token::TupleStruct {\n                name: \"SerNamedTuple\",\n                len: 3,\n            },\n            Token::I32(5),\n            Token::I32(6),\n            Token::I32(7),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_de_named_tuple() {\n    assert_de_tokens(\n        \u0026DeNamedTuple(5, 6, 7),\n        \u0026[\n            Token::Seq { len: Some(3) },\n            Token::I32(5),\n            Token::I32(6),\n            Token::I32(7),\n            Token::SeqEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DeNamedTuple(5, 6, 7),\n        \u0026[\n            Token::TupleStruct {\n                name: \"DeNamedTuple\",\n                len: 3,\n            },\n            Token::I32(5),\n            Token::I32(6),\n            Token::I32(7),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_ser_named_map() {\n    let a = 5;\n    let mut b = 6;\n    let c = 7;\n\n    assert_ser_tokens(\n        \u0026SerNamedMap {\n            a: \u0026a,\n            b: \u0026mut b,\n            c: c,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"SerNamedMap\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I32(5),\n            Token::Str(\"b\"),\n            Token::I32(6),\n            Token::Str(\"c\"),\n            Token::I32(7),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_de_named_map() {\n    assert_de_tokens(\n        \u0026DeNamedMap { a: 5, b: 6, c: 7 },\n        \u0026[\n            Token::Struct {\n                name: \"DeNamedMap\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I32(5),\n            Token::Str(\"b\"),\n            Token::I32(6),\n            Token::Str(\"c\"),\n            Token::I32(7),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_ser_enum_unit() {\n    assert_ser_tokens(\n        \u0026SerEnum::Unit::\u003cu32, u32, u32\u003e,\n        \u0026[Token::UnitVariant {\n            name: \"SerEnum\",\n            variant: \"Unit\",\n        }],\n    );\n}\n\n#[test]\nfn test_ser_enum_seq() {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let mut d = 4;\n\n    assert_ser_tokens(\n        \u0026SerEnum::Seq(a, b, \u0026c, \u0026mut d),\n        \u0026[\n            Token::TupleVariant {\n                name: \"SerEnum\",\n                variant: \"Seq\",\n                len: 4,\n            },\n            Token::I8(1),\n            Token::I32(2),\n            Token::I32(3),\n            Token::I32(4),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_ser_enum_map() {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let mut d = 4;\n\n    assert_ser_tokens(\n        \u0026SerEnum::Map {\n            a: a,\n            b: b,\n            c: \u0026c,\n            d: \u0026mut d,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"SerEnum\",\n                variant: \"Map\",\n                len: 4,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::I32(2),\n            Token::Str(\"c\"),\n            Token::I32(3),\n            Token::Str(\"d\"),\n            Token::I32(4),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_de_enum_unit() {\n    assert_tokens(\n        \u0026DeEnum::Unit::\u003cu32, u32, u32\u003e,\n        \u0026[Token::UnitVariant {\n            name: \"DeEnum\",\n            variant: \"Unit\",\n        }],\n    );\n}\n\n#[test]\nfn test_de_enum_seq() {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let d = 4;\n\n    assert_tokens(\n        \u0026DeEnum::Seq(a, b, c, d),\n        \u0026[\n            Token::TupleVariant {\n                name: \"DeEnum\",\n                variant: \"Seq\",\n                len: 4,\n            },\n            Token::I8(1),\n            Token::I32(2),\n            Token::I32(3),\n            Token::I32(4),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_de_enum_map() {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let d = 4;\n\n    assert_tokens(\n        \u0026DeEnum::Map {\n            a: a,\n            b: b,\n            c: c,\n            d: d,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"DeEnum\",\n                variant: \"Map\",\n                len: 4,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::I32(2),\n            Token::Str(\"c\"),\n            Token::I32(3),\n            Token::Str(\"d\"),\n            Token::I32(4),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_lifetimes() {\n    let value = 5;\n\n    assert_ser_tokens(\n        \u0026Lifetimes::LifetimeSeq(\u0026value),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"Lifetimes\",\n                variant: \"LifetimeSeq\",\n            },\n            Token::I32(5),\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026Lifetimes::NoLifetimeSeq(5),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"Lifetimes\",\n                variant: \"NoLifetimeSeq\",\n            },\n            Token::I32(5),\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026Lifetimes::LifetimeMap { a: \u0026value },\n        \u0026[\n            Token::StructVariant {\n                name: \"Lifetimes\",\n                variant: \"LifetimeMap\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I32(5),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026Lifetimes::NoLifetimeMap { a: 5 },\n        \u0026[\n            Token::StructVariant {\n                name: \"Lifetimes\",\n                variant: \"NoLifetimeMap\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I32(5),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_struct() {\n    assert_tokens(\n        \u0026GenericStruct { x: 5u32 },\n        \u0026[\n            Token::Struct {\n                name: \"GenericStruct\",\n                len: 1,\n            },\n            Token::Str(\"x\"),\n            Token::U32(5),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_newtype_struct() {\n    assert_tokens(\n        \u0026GenericNewTypeStruct(5u32),\n        \u0026[\n            Token::NewtypeStruct {\n                name: \"GenericNewTypeStruct\",\n            },\n            Token::U32(5),\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_newtype_struct() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum E {\n        Newtype(GenericNewTypeStruct\u003cu32\u003e),\n        Null,\n    }\n\n    assert_tokens(\n        \u0026E::Newtype(GenericNewTypeStruct(5u32)),\n        \u0026[\n            Token::NewtypeStruct {\n                name: \"GenericNewTypeStruct\",\n            },\n            Token::U32(5),\n        ],\n    );\n}\n\n#[test]\nfn test_adjacently_tagged_newtype_struct() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum E {\n        Newtype(GenericNewTypeStruct\u003cu32\u003e),\n        Null,\n    }\n\n    assert_de_tokens(\n        \u0026E::Newtype(GenericNewTypeStruct(5u32)),\n        \u0026[\n            Token::Struct { name: \"E\", len: 2 },\n            Token::Str(\"c\"),\n            Token::NewtypeStruct {\n                name: \"GenericNewTypeStruct\",\n            },\n            Token::U32(5),\n            Token::Str(\"t\"),\n            Token::Str(\"Newtype\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_tuple_struct() {\n    assert_tokens(\n        \u0026GenericTupleStruct(5u32, 6u32),\n        \u0026[\n            Token::TupleStruct {\n                name: \"GenericTupleStruct\",\n                len: 2,\n            },\n            Token::U32(5),\n            Token::U32(6),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_enum_unit() {\n    assert_tokens(\n        \u0026GenericEnum::Unit::\u003cu32, u32\u003e,\n        \u0026[Token::UnitVariant {\n            name: \"GenericEnum\",\n            variant: \"Unit\",\n        }],\n    );\n}\n\n#[test]\nfn test_generic_enum_newtype() {\n    assert_tokens(\n        \u0026GenericEnum::NewType::\u003cu32, u32\u003e(5),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"GenericEnum\",\n                variant: \"NewType\",\n            },\n            Token::U32(5),\n        ],\n    );\n}\n\n#[test]\nfn test_generic_enum_seq() {\n    assert_tokens(\n        \u0026GenericEnum::Seq::\u003cu32, u32\u003e(5, 6),\n        \u0026[\n            Token::TupleVariant {\n                name: \"GenericEnum\",\n                variant: \"Seq\",\n                len: 2,\n            },\n            Token::U32(5),\n            Token::U32(6),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_enum_map() {\n    assert_tokens(\n        \u0026GenericEnum::Map::\u003cu32, u32\u003e { x: 5, y: 6 },\n        \u0026[\n            Token::StructVariant {\n                name: \"GenericEnum\",\n                variant: \"Map\",\n                len: 2,\n            },\n            Token::Str(\"x\"),\n            Token::U32(5),\n            Token::Str(\"y\"),\n            Token::U32(6),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_default_ty_param() {\n    assert_tokens(\n        \u0026DefaultTyParam::\u003ci32\u003e {\n            phantom: PhantomData,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"DefaultTyParam\",\n                len: 1,\n            },\n            Token::Str(\"phantom\"),\n            Token::UnitStruct {\n                name: \"PhantomData\",\n            },\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_enum_state_field() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    enum SomeEnum {\n        Key { key: char, state: bool },\n    }\n\n    assert_tokens(\n        \u0026SomeEnum::Key {\n            key: 'a',\n            state: true,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"SomeEnum\",\n                variant: \"Key\",\n                len: 2,\n            },\n            Token::Str(\"key\"),\n            Token::Char('a'),\n            Token::Str(\"state\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum Untagged {\n        A { a: u8 },\n        B { b: u8 },\n        C,\n        D(u8),\n        E(String),\n        F(u8, u8),\n    }\n\n    assert_tokens(\n        \u0026Untagged::A { a: 1 },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Untagged::B { b: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"b\"),\n            Token::U8(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_tokens(\u0026Untagged::C, \u0026[Token::Unit]);\n\n    assert_tokens(\u0026Untagged::D(4), \u0026[Token::U8(4)]);\n    assert_tokens(\u0026Untagged::E(\"e\".to_owned()), \u0026[Token::Str(\"e\")]);\n\n    assert_tokens(\n        \u0026Untagged::F(1, 2),\n        \u0026[\n            Token::Tuple { len: 2 },\n            Token::U8(1),\n            Token::U8(2),\n            Token::TupleEnd,\n        ],\n    );\n\n    assert_de_tokens_error::\u003cUntagged\u003e(\n        \u0026[Token::None],\n        \"data did not match any variant of untagged enum Untagged\",\n    );\n\n    assert_de_tokens_error::\u003cUntagged\u003e(\n        \u0026[Token::Tuple { len: 1 }, Token::U8(1), Token::TupleEnd],\n        \"data did not match any variant of untagged enum Untagged\",\n    );\n\n    assert_de_tokens_error::\u003cUntagged\u003e(\n        \u0026[\n            Token::Tuple { len: 3 },\n            Token::U8(1),\n            Token::U8(2),\n            Token::U8(3),\n            Token::TupleEnd,\n        ],\n        \"data did not match any variant of untagged enum Untagged\",\n    );\n}\n\n#[test]\nfn test_internally_tagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Newtype(BTreeMap\u003cString, String\u003e);\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Struct {\n        f: u8,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    enum InternallyTagged {\n        A { a: u8 },\n        B,\n        C(BTreeMap\u003cString, String\u003e),\n        D(Newtype),\n        E(Struct),\n    }\n\n    assert_tokens(\n        \u0026InternallyTagged::A { a: 1 },\n        \u0026[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"A\"),\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::A { a: 1 },\n        \u0026[\n            Token::Seq { len: Some(2) },\n            Token::Str(\"A\"),\n            Token::U8(1),\n            Token::SeqEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026InternallyTagged::B,\n        \u0026[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 1,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"B\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::B,\n        \u0026[Token::Seq { len: Some(1) }, Token::Str(\"B\"), Token::SeqEnd],\n    );\n\n    assert_tokens(\n        \u0026InternallyTagged::C(BTreeMap::new()),\n        \u0026[\n            Token::Map { len: Some(1) },\n            Token::Str(\"type\"),\n            Token::Str(\"C\"),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens_error::\u003cInternallyTagged\u003e(\n        \u0026[\n            Token::Seq { len: Some(2) },\n            Token::Str(\"C\"),\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected a map\",\n    );\n\n    assert_tokens(\n        \u0026InternallyTagged::D(Newtype(BTreeMap::new())),\n        \u0026[\n            Token::Map { len: Some(1) },\n            Token::Str(\"type\"),\n            Token::Str(\"D\"),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026InternallyTagged::E(Struct { f: 6 }),\n        \u0026[\n            Token::Struct {\n                name: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"E\"),\n            Token::Str(\"f\"),\n            Token::U8(6),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::E(Struct { f: 6 }),\n        \u0026[\n            Token::Seq { len: Some(2) },\n            Token::Str(\"E\"),\n            Token::U8(6),\n            Token::SeqEnd,\n        ],\n    );\n\n    assert_de_tokens_error::\u003cInternallyTagged\u003e(\n        \u0026[Token::Map { len: Some(0) }, Token::MapEnd],\n        \"missing field `type`\",\n    );\n\n    assert_de_tokens_error::\u003cInternallyTagged\u003e(\n        \u0026[\n            Token::Map { len: Some(1) },\n            Token::Str(\"type\"),\n            Token::Str(\"Z\"),\n            Token::MapEnd,\n        ],\n        \"unknown variant `Z`, expected one of `A`, `B`, `C`, `D`, `E`\",\n    );\n}\n\n#[test]\nfn test_internally_tagged_bytes() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    #[serde(tag = \"type\")]\n    enum InternallyTagged {\n        String {\n            string: String,\n        },\n        Bytes {\n            #[serde(with = \"bytes\")]\n            bytes: Vec\u003cu8\u003e,\n        },\n    }\n\n    assert_de_tokens(\n        \u0026InternallyTagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"String\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"String\"),\n            Token::Str(\"string\"),\n            Token::Str(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"String\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"String\"),\n            Token::Str(\"string\"),\n            Token::String(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"String\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"String\"),\n            Token::Str(\"string\"),\n            Token::Bytes(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"String\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"String\"),\n            Token::Str(\"string\"),\n            Token::ByteBuf(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::Str(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::String(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::Bytes(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::ByteBuf(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::Seq { len: Some(1) },\n            Token::U8(0),\n            Token::SeqEnd,\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_struct_variant_containing_unit_variant() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    pub enum Level {\n        Info,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"action\")]\n    pub enum Message {\n        Log { level: Level },\n    }\n\n    assert_de_tokens(\n        \u0026Message::Log { level: Level::Info },\n        \u0026[\n            Token::Struct {\n                name: \"Message\",\n                len: 2,\n            },\n            Token::Str(\"action\"),\n            Token::Str(\"Log\"),\n            Token::Str(\"level\"),\n            Token::BorrowedStr(\"Info\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_borrow() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    pub enum Input\u003c'a\u003e {\n        Package { name: \u0026'a str },\n    }\n\n    assert_tokens(\n        \u0026Input::Package { name: \"borrowed\" },\n        \u0026[\n            Token::Struct {\n                name: \"Input\",\n                len: 2,\n            },\n            Token::BorrowedStr(\"type\"),\n            Token::BorrowedStr(\"Package\"),\n            Token::BorrowedStr(\"name\"),\n            Token::BorrowedStr(\"borrowed\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_adjacently_tagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum AdjacentlyTagged\u003cT\u003e {\n        Unit,\n        Newtype(T),\n        Tuple(u8, u8),\n        Struct { f: u8 },\n    }\n\n    // unit with no content\n    assert_ser_tokens(\n        \u0026AdjacentlyTagged::Unit::\u003cu8\u003e,\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 1,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // unit with no content\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Unit::\u003cu8\u003e,\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // unit with tag first\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Unit::\u003cu8\u003e,\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::StructEnd,\n        ],\n    );\n\n    // unit with content first\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Unit::\u003cu8\u003e,\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // unit with excess content (f, g, h)\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Unit::\u003cu8\u003e,\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"f\"),\n            Token::Unit,\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"g\"),\n            Token::Unit,\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"h\"),\n            Token::Unit,\n            Token::StructEnd,\n        ],\n    );\n\n    // newtype with tag first\n    assert_tokens(\n        \u0026AdjacentlyTagged::Newtype::\u003cu8\u003e(1),\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Newtype\"),\n            Token::Str(\"c\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    // newtype with content first\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Newtype::\u003cu8\u003e(1),\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::U8(1),\n            Token::Str(\"t\"),\n            Token::Str(\"Newtype\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // tuple with tag first\n    assert_tokens(\n        \u0026AdjacentlyTagged::Tuple::\u003cu8\u003e(1, 1),\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Tuple\"),\n            Token::Str(\"c\"),\n            Token::Tuple { len: 2 },\n            Token::U8(1),\n            Token::U8(1),\n            Token::TupleEnd,\n            Token::StructEnd,\n        ],\n    );\n\n    // tuple with content first\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Tuple::\u003cu8\u003e(1, 1),\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Tuple { len: 2 },\n            Token::U8(1),\n            Token::U8(1),\n            Token::TupleEnd,\n            Token::Str(\"t\"),\n            Token::Str(\"Tuple\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // struct with tag first\n    assert_tokens(\n        \u0026AdjacentlyTagged::Struct::\u003cu8\u003e { f: 1 },\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Struct\"),\n            Token::Str(\"c\"),\n            Token::Struct {\n                name: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"f\"),\n            Token::U8(1),\n            Token::StructEnd,\n            Token::StructEnd,\n        ],\n    );\n\n    // struct with content first\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Struct::\u003cu8\u003e { f: 1 },\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Struct {\n                name: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"f\"),\n            Token::U8(1),\n            Token::StructEnd,\n            Token::Str(\"t\"),\n            Token::Str(\"Struct\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_adjacently_tagged_enum_deny_unknown_fields() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\", deny_unknown_fields)]\n    enum AdjacentlyTagged {\n        Unit,\n    }\n\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Unit,\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens_error::\u003cAdjacentlyTagged\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"h\"),\n        ],\n        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#,\n    );\n\n    assert_de_tokens_error::\u003cAdjacentlyTagged\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"h\"),\n        ],\n        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#,\n    );\n\n    assert_de_tokens_error::\u003cAdjacentlyTagged\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"h\"),\n        ],\n        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#,\n    );\n}\n\n#[test]\nfn test_enum_in_internally_tagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    enum Outer {\n        Inner(Inner),\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    enum Inner {\n        Unit,\n        Newtype(u8),\n        Tuple(u8, u8),\n        Struct { f: u8 },\n    }\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Unit),\n        \u0026[\n            Token::Map { len: Some(2) },\n            Token::Str(\"type\"),\n            Token::Str(\"Inner\"),\n            Token::Str(\"Unit\"),\n            Token::Unit,\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Newtype(1)),\n        \u0026[\n            Token::Map { len: Some(2) },\n            Token::Str(\"type\"),\n            Token::Str(\"Inner\"),\n            Token::Str(\"Newtype\"),\n            Token::U8(1),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Tuple(1, 1)),\n        \u0026[\n            Token::Map { len: Some(2) },\n            Token::Str(\"type\"),\n            Token::Str(\"Inner\"),\n            Token::Str(\"Tuple\"),\n            Token::TupleStruct {\n                name: \"Tuple\",\n                len: 2,\n            },\n            Token::U8(1),\n            Token::U8(1),\n            Token::TupleStructEnd,\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Struct { f: 1 }),\n        \u0026[\n            Token::Map { len: Some(2) },\n            Token::Str(\"type\"),\n            Token::Str(\"Inner\"),\n            Token::Str(\"Struct\"),\n            Token::Struct {\n                name: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"f\"),\n            Token::U8(1),\n            Token::StructEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_struct() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    pub struct Struct {\n        a: u8,\n    }\n\n    assert_tokens(\n        \u0026Struct { a: 1 },\n        \u0026[\n            Token::Struct {\n                name: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Struct\"),\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Struct { a: 1 },\n        \u0026[\n            Token::Struct {\n                name: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_braced_struct_with_zero_fields() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    struct S {}\n\n    assert_tokens(\n        \u0026S {},\n        \u0026[\n            Token::Struct { name: \"S\", len: 1 },\n            Token::Str(\"type\"),\n            Token::Str(\"S\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_struct_with_flattened_field() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"tag_struct\")]\n    pub struct Struct {\n        #[serde(flatten)]\n        pub flat: Enum,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"tag_enum\", content = \"content\")]\n    pub enum Enum {\n        A(u64),\n    }\n\n    assert_tokens(\n        \u0026Struct { flat: Enum::A(0) },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"tag_struct\"),\n            Token::Str(\"Struct\"),\n            Token::Str(\"tag_enum\"),\n            Token::Str(\"A\"),\n            Token::Str(\"content\"),\n            Token::U64(0),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Struct { flat: Enum::A(0) },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"tag_enum\"),\n            Token::Str(\"A\"),\n            Token::Str(\"content\"),\n            Token::U64(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_enum_with_flattened_integer_key() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    pub enum Untagged {\n        Variant {\n            #[serde(flatten)]\n            map: BTreeMap\u003cu64, String\u003e,\n        },\n    }\n\n    assert_tokens(\n        \u0026Untagged::Variant {\n            map: {\n                let mut map = BTreeMap::new();\n                map.insert(100, \"BTreeMap\".to_owned());\n                map\n            },\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::U64(100),\n            Token::Str(\"BTreeMap\"),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_enum_in_untagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum Outer {\n        Inner(Inner),\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    enum Inner {\n        Unit,\n        Newtype(u8),\n        Tuple(u8, u8),\n        Struct { f: u8 },\n    }\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Unit),\n        \u0026[Token::UnitVariant {\n            name: \"Inner\",\n            variant: \"Unit\",\n        }],\n    );\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Newtype(1)),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"Inner\",\n                variant: \"Newtype\",\n            },\n            Token::U8(1),\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Tuple(1, 1)),\n        \u0026[\n            Token::TupleVariant {\n                name: \"Inner\",\n                variant: \"Tuple\",\n                len: 2,\n            },\n            Token::U8(1),\n            Token::U8(1),\n            Token::TupleVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Struct { f: 1 }),\n        \u0026[\n            Token::StructVariant {\n                name: \"Inner\",\n                variant: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"f\"),\n            Token::U8(1),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_bytes() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    #[serde(untagged)]\n    enum Untagged {\n        String {\n            string: String,\n        },\n        Bytes {\n            #[serde(with = \"bytes\")]\n            bytes: Vec\u003cu8\u003e,\n        },\n    }\n\n    assert_de_tokens(\n        \u0026Untagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"string\"),\n            Token::Str(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"string\"),\n            Token::String(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"string\"),\n            Token::Bytes(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"string\"),\n            Token::ByteBuf(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::Str(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::String(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::Bytes(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::ByteBuf(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::Seq { len: Some(1) },\n            Token::U8(0),\n            Token::SeqEnd,\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_rename_all() {\n    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n    #[serde(rename_all = \"snake_case\")]\n    enum E {\n        #[serde(rename_all = \"camelCase\")]\n        Serialize {\n            serialize: bool,\n            serialize_seq: bool,\n        },\n        #[serde(rename_all = \"kebab-case\")]\n        SerializeSeq {\n            serialize: bool,\n            serialize_seq: bool,\n        },\n        #[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\n        SerializeMap {\n            serialize: bool,\n            serialize_seq: bool,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n    #[serde(rename_all = \"PascalCase\")]\n    struct S {\n        serialize: bool,\n        serialize_seq: bool,\n    }\n\n    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n    #[serde(rename_all = \"SCREAMING-KEBAB-CASE\")]\n    struct ScreamingKebab {\n        serialize: bool,\n        serialize_seq: bool,\n    }\n\n    assert_tokens(\n        \u0026E::Serialize {\n            serialize: true,\n            serialize_seq: true,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"E\",\n                variant: \"serialize\",\n                len: 2,\n            },\n            Token::Str(\"serialize\"),\n            Token::Bool(true),\n            Token::Str(\"serializeSeq\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026E::SerializeSeq {\n            serialize: true,\n            serialize_seq: true,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"E\",\n                variant: \"serialize_seq\",\n                len: 2,\n            },\n            Token::Str(\"serialize\"),\n            Token::Bool(true),\n            Token::Str(\"serialize-seq\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026E::SerializeMap {\n            serialize: true,\n            serialize_seq: true,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"E\",\n                variant: \"serialize_map\",\n                len: 2,\n            },\n            Token::Str(\"SERIALIZE\"),\n            Token::Bool(true),\n            Token::Str(\"SERIALIZE_SEQ\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026S {\n            serialize: true,\n            serialize_seq: true,\n        },\n        \u0026[\n            Token::Struct { name: \"S\", len: 2 },\n            Token::Str(\"Serialize\"),\n            Token::Bool(true),\n            Token::Str(\"SerializeSeq\"),\n            Token::Bool(true),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026ScreamingKebab {\n            serialize: true,\n            serialize_seq: true,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"ScreamingKebab\",\n                len: 2,\n            },\n            Token::Str(\"SERIALIZE\"),\n            Token::Bool(true),\n            Token::Str(\"SERIALIZE-SEQ\"),\n            Token::Bool(true),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_newtype_variant_containing_unit_struct_not_map() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Unit;\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum Message {\n        Unit(Unit),\n        Map(BTreeMap\u003cString, String\u003e),\n    }\n\n    assert_tokens(\n        \u0026Message::Map(BTreeMap::new()),\n        \u0026[Token::Map { len: Some(0) }, Token::MapEnd],\n    );\n}\n\n#[test]\nfn test_internally_tagged_newtype_variant_containing_unit_struct() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Info;\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"topic\")]\n    enum Message {\n        Info(Info),\n    }\n\n    assert_tokens(\n        \u0026Message::Info(Info),\n        \u0026[\n            Token::Map { len: Some(1) },\n            Token::Str(\"topic\"),\n            Token::Str(\"Info\"),\n            Token::MapEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_remote.rs"],"content":"#![allow(clippy::redundant_field_names)]\n\nuse serde::{Deserialize, Serialize};\n\nmod remote {\n    pub struct Unit;\n\n    pub struct PrimitivePriv(u8);\n\n    pub struct PrimitivePub(pub u8);\n\n    pub struct NewtypePriv(Unit);\n\n    pub struct NewtypePub(pub Unit);\n\n    pub struct TuplePriv(u8, Unit);\n\n    pub struct TuplePub(pub u8, pub Unit);\n\n    pub struct StructPriv {\n        a: u8,\n        b: Unit,\n    }\n\n    pub struct StructPub {\n        pub a: u8,\n        pub b: Unit,\n    }\n\n    impl PrimitivePriv {\n        pub fn new(a: u8) -\u003e Self {\n            PrimitivePriv(a)\n        }\n\n        pub fn get(\u0026self) -\u003e u8 {\n            self.0\n        }\n    }\n\n    impl NewtypePriv {\n        pub fn new(a: Unit) -\u003e Self {\n            NewtypePriv(a)\n        }\n\n        pub fn get(\u0026self) -\u003e \u0026Unit {\n            \u0026self.0\n        }\n    }\n\n    impl TuplePriv {\n        pub fn new(a: u8, b: Unit) -\u003e Self {\n            TuplePriv(a, b)\n        }\n\n        pub fn first(\u0026self) -\u003e u8 {\n            self.0\n        }\n\n        pub fn second(\u0026self) -\u003e \u0026Unit {\n            \u0026self.1\n        }\n    }\n\n    impl StructPriv {\n        pub fn new(a: u8, b: Unit) -\u003e Self {\n            StructPriv { a: a, b: b }\n        }\n\n        pub fn a(\u0026self) -\u003e u8 {\n            self.a\n        }\n\n        pub fn b(\u0026self) -\u003e \u0026Unit {\n            \u0026self.b\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize)]\nstruct Test {\n    #[serde(with = \"UnitDef\")]\n    unit: remote::Unit,\n\n    #[serde(with = \"PrimitivePrivDef\")]\n    primitive_priv: remote::PrimitivePriv,\n\n    #[serde(with = \"PrimitivePubDef\")]\n    primitive_pub: remote::PrimitivePub,\n\n    #[serde(with = \"NewtypePrivDef\")]\n    newtype_priv: remote::NewtypePriv,\n\n    #[serde(with = \"NewtypePubDef\")]\n    newtype_pub: remote::NewtypePub,\n\n    #[serde(with = \"TuplePrivDef\")]\n    tuple_priv: remote::TuplePriv,\n\n    #[serde(with = \"TuplePubDef\")]\n    tuple_pub: remote::TuplePub,\n\n    #[serde(with = \"StructPrivDef\")]\n    struct_priv: remote::StructPriv,\n\n    #[serde(with = \"StructPubDef\")]\n    struct_pub: remote::StructPub,\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::Unit\")]\nstruct UnitDef;\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::PrimitivePriv\")]\nstruct PrimitivePrivDef(#[serde(getter = \"remote::PrimitivePriv::get\")] u8);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::PrimitivePub\")]\nstruct PrimitivePubDef(u8);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::NewtypePriv\")]\nstruct NewtypePrivDef(#[serde(getter = \"remote::NewtypePriv::get\", with = \"UnitDef\")] remote::Unit);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::NewtypePub\")]\nstruct NewtypePubDef(#[serde(with = \"UnitDef\")] remote::Unit);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::TuplePriv\")]\nstruct TuplePrivDef(\n    #[serde(getter = \"remote::TuplePriv::first\")] u8,\n    #[serde(getter = \"remote::TuplePriv::second\", with = \"UnitDef\")] remote::Unit,\n);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::TuplePub\")]\nstruct TuplePubDef(u8, #[serde(with = \"UnitDef\")] remote::Unit);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::StructPriv\")]\nstruct StructPrivDef {\n    #[serde(getter = \"remote::StructPriv::a\")]\n    a: u8,\n\n    #[serde(getter = \"remote::StructPriv::b\")]\n    #[serde(with = \"UnitDef\")]\n    b: remote::Unit,\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::StructPub\")]\nstruct StructPubDef {\n    a: u8,\n\n    #[serde(with = \"UnitDef\")]\n    b: remote::Unit,\n}\n\nimpl From\u003cPrimitivePrivDef\u003e for remote::PrimitivePriv {\n    fn from(def: PrimitivePrivDef) -\u003e Self {\n        remote::PrimitivePriv::new(def.0)\n    }\n}\n\nimpl From\u003cNewtypePrivDef\u003e for remote::NewtypePriv {\n    fn from(def: NewtypePrivDef) -\u003e Self {\n        remote::NewtypePriv::new(def.0)\n    }\n}\n\nimpl From\u003cTuplePrivDef\u003e for remote::TuplePriv {\n    fn from(def: TuplePrivDef) -\u003e Self {\n        remote::TuplePriv::new(def.0, def.1)\n    }\n}\n\nimpl From\u003cStructPrivDef\u003e for remote::StructPriv {\n    fn from(def: StructPrivDef) -\u003e Self {\n        remote::StructPriv::new(def.a, def.b)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_roundtrip.rs"],"content":"use serde_test::{assert_tokens, Configure, Token};\n\nuse std::net;\n\n#[macro_use]\n#[allow(unused_macros)]\nmod macros;\n\n#[test]\nfn ip_addr_roundtrip() {\n    assert_tokens(\n        \u0026net::IpAddr::from(*b\"1234\").compact(),\n        \u0026seq![\n            Token::NewtypeVariant { name: \"IpAddr\", variant: \"V4\" },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n        ],\n    );\n}\n\n#[test]\nfn socket_addr_roundtrip() {\n    assert_tokens(\n        \u0026net::SocketAddr::from((*b\"1234567890123456\", 1234)).compact(),\n        \u0026seq![\n            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V6\" },\n\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_ser.rs"],"content":"#![allow(clippy::unreadable_literal)]\n#![cfg_attr(feature = \"unstable\", feature(never_type))]\n\nuse std::cell::RefCell;\nuse std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\nuse std::ffi::CString;\nuse std::mem;\nuse std::net;\nuse std::num::Wrapping;\nuse std::ops::Bound;\nuse std::path::{Path, PathBuf};\nuse std::rc::{Rc, Weak as RcWeak};\nuse std::sync::atomic::{\n    AtomicBool, AtomicI16, AtomicI32, AtomicI8, AtomicIsize, AtomicU16, AtomicU32, AtomicU8,\n    AtomicUsize,\n};\nuse std::sync::{Arc, Weak as ArcWeak};\nuse std::time::{Duration, UNIX_EPOCH};\n\n#[cfg(unix)]\nuse std::str;\n#[cfg(target_arch = \"x86_64\")]\nuse std::sync::atomic::{AtomicI64, AtomicU64};\n\nuse fnv::FnvHasher;\nuse serde::Serialize;\nuse serde_test::{assert_ser_tokens, assert_ser_tokens_error, Configure, Token};\n\n#[macro_use]\nmod macros;\n\n//////////////////////////////////////////////////////////////////////////\n\n#[derive(Serialize)]\nstruct UnitStruct;\n\n#[derive(Serialize)]\nstruct TupleStruct(i32, i32, i32);\n\n#[derive(Serialize)]\nstruct Struct {\n    a: i32,\n    b: i32,\n    c: i32,\n}\n\n#[derive(Serialize, PartialEq, Debug)]\nenum Enum {\n    Unit,\n    One(i32),\n    Seq(i32, i32),\n    Map {\n        a: i32,\n        b: i32,\n    },\n    #[serde(skip_serializing)]\n    SkippedUnit,\n    #[serde(skip_serializing)]\n    SkippedOne(i32),\n    #[serde(skip_serializing)]\n    SkippedSeq(i32, i32),\n    #[serde(skip_serializing)]\n    SkippedMap {\n        _a: i32,\n        _b: i32,\n    },\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nmacro_rules! declare_tests {\n    (\n        $readable:tt\n        $($name:ident { $($value:expr =\u003e $tokens:expr,)+ })+\n    ) =\u003e {\n        $(\n            #[test]\n            fn $name() {\n                $(\n                    assert_ser_tokens(\u0026$value.$readable(), $tokens);\n                )+\n            }\n        )+\n    };\n\n    ($($name:ident { $($value:expr =\u003e $tokens:expr,)+ })+) =\u003e {\n        $(\n            #[test]\n            fn $name() {\n                $(\n                    assert_ser_tokens(\u0026$value, $tokens);\n                )+\n            }\n        )+\n    }\n}\n\ndeclare_tests! {\n    test_unit {\n        () =\u003e \u0026[Token::Unit],\n    }\n    test_bool {\n        true =\u003e \u0026[Token::Bool(true)],\n        false =\u003e \u0026[Token::Bool(false)],\n    }\n    test_isizes {\n        0i8 =\u003e \u0026[Token::I8(0)],\n        0i16 =\u003e \u0026[Token::I16(0)],\n        0i32 =\u003e \u0026[Token::I32(0)],\n        0i64 =\u003e \u0026[Token::I64(0)],\n    }\n    test_usizes {\n        0u8 =\u003e \u0026[Token::U8(0)],\n        0u16 =\u003e \u0026[Token::U16(0)],\n        0u32 =\u003e \u0026[Token::U32(0)],\n        0u64 =\u003e \u0026[Token::U64(0)],\n    }\n    test_floats {\n        0f32 =\u003e \u0026[Token::F32(0.)],\n        0f64 =\u003e \u0026[Token::F64(0.)],\n    }\n    test_char {\n        'a' =\u003e \u0026[Token::Char('a')],\n    }\n    test_str {\n        \"abc\" =\u003e \u0026[Token::Str(\"abc\")],\n        \"abc\".to_owned() =\u003e \u0026[Token::Str(\"abc\")],\n    }\n    test_option {\n        None::\u003ci32\u003e =\u003e \u0026[Token::None],\n        Some(1) =\u003e \u0026[\n            Token::Some,\n            Token::I32(1),\n        ],\n    }\n    test_result {\n        Ok::\u003ci32, i32\u003e(0) =\u003e \u0026[\n            Token::NewtypeVariant { name: \"Result\", variant: \"Ok\" },\n            Token::I32(0),\n        ],\n        Err::\u003ci32, i32\u003e(1) =\u003e \u0026[\n            Token::NewtypeVariant { name: \"Result\", variant: \"Err\" },\n            Token::I32(1),\n        ],\n    }\n    test_slice {\n        \u0026[0][..0] =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        \u0026[1, 2, 3][..] =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n    }\n    test_array {\n        [0; 0] =\u003e \u0026[\n            Token::Tuple { len: 0 },\n            Token::TupleEnd,\n        ],\n        [1, 2, 3] =\u003e \u0026[\n            Token::Tuple { len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleEnd,\n        ],\n    }\n    test_vec {\n        Vec::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        vec![vec![], vec![1], vec![2, 3]] =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::Seq { len: Some(0) },\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(1) },\n                    Token::I32(1),\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(2) },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::SeqEnd,\n            Token::SeqEnd,\n        ],\n    }\n    test_btreeset {\n        BTreeSet::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        btreeset![1] =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n                Token::I32(1),\n            Token::SeqEnd,\n        ],\n    }\n    test_hashset {\n        HashSet::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        hashset![1] =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n                Token::I32(1),\n            Token::SeqEnd,\n        ],\n        hashset![FnvHasher @ 1] =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n                Token::I32(1),\n            Token::SeqEnd,\n        ],\n    }\n    test_tuple {\n        (1,) =\u003e \u0026[\n            Token::Tuple { len: 1 },\n                Token::I32(1),\n            Token::TupleEnd,\n        ],\n        (1, 2, 3) =\u003e \u0026[\n            Token::Tuple { len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleEnd,\n        ],\n    }\n    test_btreemap {\n        btreemap![1 =\u003e 2] =\u003e \u0026[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        btreemap![1 =\u003e 2, 3 =\u003e 4] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::I32(2),\n\n                Token::I32(3),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n        btreemap![1 =\u003e btreemap![], 2 =\u003e btreemap![3 =\u003e 4, 5 =\u003e 6]] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::Map { len: Some(0) },\n                Token::MapEnd,\n\n                Token::I32(2),\n                Token::Map { len: Some(2) },\n                    Token::I32(3),\n                    Token::I32(4),\n\n                    Token::I32(5),\n                    Token::I32(6),\n                Token::MapEnd,\n            Token::MapEnd,\n        ],\n    }\n    test_hashmap {\n        HashMap::\u003cisize, isize\u003e::new() =\u003e \u0026[\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n        ],\n        hashmap![1 =\u003e 2] =\u003e \u0026[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        hashmap![FnvHasher @ 1 =\u003e 2] =\u003e \u0026[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n    }\n    test_unit_struct {\n        UnitStruct =\u003e \u0026[Token::UnitStruct { name: \"UnitStruct\" }],\n    }\n    test_tuple_struct {\n        TupleStruct(1, 2, 3) =\u003e \u0026[\n            Token::TupleStruct { name: \"TupleStruct\", len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n    }\n    test_struct {\n        Struct { a: 1, b: 2, c: 3 } =\u003e \u0026[\n            Token::Struct { name: \"Struct\", len: 3 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n\n                Token::Str(\"c\"),\n                Token::I32(3),\n            Token::StructEnd,\n        ],\n    }\n    test_enum {\n        Enum::Unit =\u003e \u0026[Token::UnitVariant { name: \"Enum\", variant: \"Unit\" }],\n        Enum::One(42) =\u003e \u0026[Token::NewtypeVariant { name: \"Enum\", variant: \"One\" }, Token::I32(42)],\n        Enum::Seq(1, 2) =\u003e \u0026[\n            Token::TupleVariant { name: \"Enum\", variant: \"Seq\", len: 2 },\n                Token::I32(1),\n                Token::I32(2),\n            Token::TupleVariantEnd,\n        ],\n        Enum::Map { a: 1, b: 2 } =\u003e \u0026[\n            Token::StructVariant { name: \"Enum\", variant: \"Map\", len: 2 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n            Token::StructVariantEnd,\n        ],\n    }\n    test_box {\n        Box::new(0i32) =\u003e \u0026[Token::I32(0)],\n    }\n    test_boxed_slice {\n        Box::new([0, 1, 2]) =\u003e \u0026[\n            Token::Tuple { len: 3 },\n            Token::I32(0),\n            Token::I32(1),\n            Token::I32(2),\n            Token::TupleEnd,\n        ],\n    }\n    test_duration {\n        Duration::new(1, 2) =\u003e \u0026[\n            Token::Struct { name: \"Duration\", len: 2 },\n                Token::Str(\"secs\"),\n                Token::U64(1),\n\n                Token::Str(\"nanos\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n    }\n    test_system_time {\n        UNIX_EPOCH + Duration::new(1, 200) =\u003e \u0026[\n            Token::Struct { name: \"SystemTime\", len: 2 },\n                Token::Str(\"secs_since_epoch\"),\n                Token::U64(1),\n\n                Token::Str(\"nanos_since_epoch\"),\n                Token::U32(200),\n            Token::StructEnd,\n        ],\n    }\n    test_range {\n        1u32..2u32 =\u003e \u0026[\n            Token::Struct { name: \"Range\", len: 2 },\n                Token::Str(\"start\"),\n                Token::U32(1),\n\n                Token::Str(\"end\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n    }\n    test_range_inclusive {\n        1u32..=2u32 =\u003e \u0026[\n            Token::Struct { name: \"RangeInclusive\", len: 2 },\n                Token::Str(\"start\"),\n                Token::U32(1),\n\n                Token::Str(\"end\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n    }\n    test_bound {\n        Bound::Unbounded::\u003c()\u003e =\u003e \u0026[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Unbounded\"),\n            Token::Unit,\n        ],\n        Bound::Included(0u8) =\u003e \u0026[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Included\"),\n            Token::U8(0),\n        ],\n        Bound::Excluded(0u8) =\u003e \u0026[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Excluded\"),\n            Token::U8(0),\n        ],\n    }\n    test_path {\n        Path::new(\"/usr/local/lib\") =\u003e \u0026[\n            Token::Str(\"/usr/local/lib\"),\n        ],\n    }\n    test_path_buf {\n        PathBuf::from(\"/usr/local/lib\") =\u003e \u0026[\n            Token::Str(\"/usr/local/lib\"),\n        ],\n    }\n    test_cstring {\n        CString::new(\"abc\").unwrap() =\u003e \u0026[\n            Token::Bytes(b\"abc\"),\n        ],\n    }\n    test_cstr {\n        (\u0026*CString::new(\"abc\").unwrap()) =\u003e \u0026[\n            Token::Bytes(b\"abc\"),\n        ],\n    }\n    test_rc {\n        Rc::new(true) =\u003e \u0026[\n            Token::Bool(true),\n        ],\n    }\n    test_rc_weak_some {\n        {\n            let rc = Rc::new(true);\n            mem::forget(rc.clone());\n            Rc::downgrade(\u0026rc)\n        } =\u003e \u0026[\n            Token::Some,\n            Token::Bool(true),\n        ],\n    }\n    test_rc_weak_none {\n        RcWeak::\u003cbool\u003e::new() =\u003e \u0026[\n            Token::None,\n        ],\n    }\n    test_arc {\n        Arc::new(true) =\u003e \u0026[\n            Token::Bool(true),\n        ],\n    }\n    test_arc_weak_some {\n        {\n            let arc = Arc::new(true);\n            mem::forget(arc.clone());\n            Arc::downgrade(\u0026arc)\n        } =\u003e \u0026[\n            Token::Some,\n            Token::Bool(true),\n        ],\n    }\n    test_arc_weak_none {\n        ArcWeak::\u003cbool\u003e::new() =\u003e \u0026[\n            Token::None,\n        ],\n    }\n    test_wrapping {\n        Wrapping(1usize) =\u003e \u0026[\n            Token::U64(1),\n        ],\n    }\n    test_rc_dst {\n        Rc::\u003cstr\u003e::from(\"s\") =\u003e \u0026[\n            Token::Str(\"s\"),\n        ],\n        Rc::\u003c[bool]\u003e::from(\u0026[true][..]) =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n    }\n    test_arc_dst {\n        Arc::\u003cstr\u003e::from(\"s\") =\u003e \u0026[\n            Token::Str(\"s\"),\n        ],\n        Arc::\u003c[bool]\u003e::from(\u0026[true][..]) =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n    }\n    test_fmt_arguments {\n        format_args!(\"{}{}\", 1, 'a') =\u003e \u0026[\n            Token::Str(\"1a\"),\n        ],\n    }\n    test_atomic {\n        AtomicBool::new(false) =\u003e \u0026[Token::Bool(false)],\n        AtomicBool::new(true) =\u003e \u0026[Token::Bool(true)],\n        AtomicI8::new(63i8) =\u003e \u0026[Token::I8(63i8)],\n        AtomicI16::new(-318i16) =\u003e \u0026[Token::I16(-318i16)],\n        AtomicI32::new(65792i32) =\u003e \u0026[Token::I32(65792i32)],\n        AtomicIsize::new(-65792isize) =\u003e \u0026[Token::I64(-65792i64)],\n        AtomicU8::new(192u8) =\u003e \u0026[Token::U8(192u8)],\n        AtomicU16::new(510u16) =\u003e \u0026[Token::U16(510u16)],\n        AtomicU32::new(131072u32) =\u003e \u0026[Token::U32(131072u32)],\n        AtomicUsize::new(655360usize) =\u003e \u0026[Token::U64(655360u64)],\n    }\n}\n\n#[cfg(target_arch = \"x86_64\")]\ndeclare_tests! {\n    test_atomic64 {\n        AtomicI64::new(-4295032832i64) =\u003e \u0026[Token::I64(-4295032832i64)],\n        AtomicU64::new(12884901888u64) =\u003e \u0026[Token::U64(12884901888u64)],\n    }\n}\n\ndeclare_tests! {\n    readable\n\n    test_net_ipv4addr_readable {\n        \"1.2.3.4\".parse::\u003cnet::Ipv4Addr\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4\")],\n    }\n    test_net_ipv6addr_readable {\n        \"::1\".parse::\u003cnet::Ipv6Addr\u003e().unwrap() =\u003e \u0026[Token::Str(\"::1\")],\n    }\n    test_net_ipaddr_readable {\n        \"1.2.3.4\".parse::\u003cnet::IpAddr\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4\")],\n    }\n    test_net_socketaddr_readable {\n        \"1.2.3.4:1234\".parse::\u003cnet::SocketAddr\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4:1234\")],\n        \"1.2.3.4:1234\".parse::\u003cnet::SocketAddrV4\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4:1234\")],\n        \"[::1]:1234\".parse::\u003cnet::SocketAddrV6\u003e().unwrap() =\u003e \u0026[Token::Str(\"[::1]:1234\")],\n    }\n}\n\ndeclare_tests! {\n    compact\n\n    test_net_ipv4addr_compact {\n        net::Ipv4Addr::from(*b\"1234\") =\u003e \u0026seq![\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n        ],\n    }\n    test_net_ipv6addr_compact {\n        net::Ipv6Addr::from(*b\"1234567890123456\") =\u003e \u0026seq![\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n        ],\n    }\n    test_net_ipaddr_compact {\n        net::IpAddr::from(*b\"1234\") =\u003e \u0026seq![\n            Token::NewtypeVariant { name: \"IpAddr\", variant: \"V4\" },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n        ],\n    }\n    test_net_socketaddr_compact {\n        net::SocketAddr::from((*b\"1234567890123456\", 1234)) =\u003e \u0026seq![\n            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V6\" },\n\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd,\n        ],\n        net::SocketAddrV4::new(net::Ipv4Addr::from(*b\"1234\"), 1234) =\u003e \u0026seq![\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd,\n        ],\n        net::SocketAddrV6::new(net::Ipv6Addr::from(*b\"1234567890123456\"), 1234, 0, 0) =\u003e \u0026seq![\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd,\n        ],\n    }\n}\n\n#[cfg(feature = \"unstable\")]\ndeclare_tests! {\n    test_never_result {\n        Ok::\u003cu8, !\u003e(0) =\u003e \u0026[\n            Token::NewtypeVariant { name: \"Result\", variant: \"Ok\" },\n            Token::U8(0),\n        ],\n    }\n}\n\n#[test]\n#[cfg(unix)]\nfn test_cannot_serialize_paths() {\n    let path = unsafe { str::from_utf8_unchecked(b\"Hello \\xF0\\x90\\x80World\") };\n    assert_ser_tokens_error(\n        \u0026Path::new(path),\n        \u0026[],\n        \"path contains invalid UTF-8 characters\",\n    );\n\n    let mut path_buf = PathBuf::new();\n    path_buf.push(path);\n\n    assert_ser_tokens_error(\u0026path_buf, \u0026[], \"path contains invalid UTF-8 characters\");\n}\n\n#[test]\nfn test_cannot_serialize_mutably_borrowed_ref_cell() {\n    let ref_cell = RefCell::new(42);\n    let _reference = ref_cell.borrow_mut();\n    assert_ser_tokens_error(\u0026ref_cell, \u0026[], \"already mutably borrowed\");\n}\n\n#[test]\nfn test_enum_skipped() {\n    assert_ser_tokens_error(\n        \u0026Enum::SkippedUnit,\n        \u0026[],\n        \"the enum variant Enum::SkippedUnit cannot be serialized\",\n    );\n    assert_ser_tokens_error(\n        \u0026Enum::SkippedOne(42),\n        \u0026[],\n        \"the enum variant Enum::SkippedOne cannot be serialized\",\n    );\n    assert_ser_tokens_error(\n        \u0026Enum::SkippedSeq(1, 2),\n        \u0026[],\n        \"the enum variant Enum::SkippedSeq cannot be serialized\",\n    );\n    assert_ser_tokens_error(\n        \u0026Enum::SkippedMap { _a: 1, _b: 2 },\n        \u0026[],\n        \"the enum variant Enum::SkippedMap cannot be serialized\",\n    );\n}\n\n#[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n#[test]\nfn test_integer128() {\n    assert_ser_tokens_error(\u00261i128, \u0026[], \"i128 is not supported\");\n\n    assert_ser_tokens_error(\u00261u128, \u0026[], \"u128 is not supported\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_serde_path.rs"],"content":"#[test]\nfn test_gen_custom_serde() {\n    #[derive(serde::Serialize, serde::Deserialize)]\n    #[serde(crate = \"fake_serde\")]\n    struct Foo;\n\n    // Would be overlapping if serde::Serialize were implemented\n    impl AssertNotSerdeSerialize for Foo {}\n    // Would be overlapping if serde::Deserialize were implemented\n    impl\u003c'a\u003e AssertNotSerdeDeserialize\u003c'a\u003e for Foo {}\n\n    fake_serde::assert::\u003cFoo\u003e();\n}\n\nmod fake_serde {\n    pub use serde::*;\n\n    pub fn assert\u003cT\u003e()\n    where\n        T: Serialize,\n        T: for\u003c'a\u003e Deserialize\u003c'a\u003e,\n    {\n    }\n\n    pub trait Serialize {\n        fn serialize\u003cS: Serializer\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e;\n    }\n\n    pub trait Deserialize\u003c'a\u003e: Sized {\n        fn deserialize\u003cD: Deserializer\u003c'a\u003e\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e;\n    }\n}\n\ntrait AssertNotSerdeSerialize {}\n\nimpl\u003cT: serde::Serialize\u003e AssertNotSerdeSerialize for T {}\n\ntrait AssertNotSerdeDeserialize\u003c'a\u003e {}\n\nimpl\u003c'a, T: serde::Deserialize\u003c'a\u003e\u003e AssertNotSerdeDeserialize\u003c'a\u003e for T {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_unstable.rs"],"content":"#![deny(warnings)]\n\n// This test target is convoluted with the actual #[test] in a separate file to\n// get it so that the stable compiler does not need to parse the code of the\n// test. If the test were written with #[cfg(feature = \"unstable\")] #[test]\n// right here, the stable compiler would fail to parse those raw identifiers\n// even if the cfg were not enabled.\n#[cfg(feature = \"unstable\")]\nmod unstable;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_value.rs"],"content":"use serde::de::value::{self, MapAccessDeserializer};\nuse serde::de::{IntoDeserializer, MapAccess, Visitor};\nuse serde::{Deserialize, Deserializer};\nuse serde_test::{assert_de_tokens, Token};\nuse std::fmt;\n\n#[test]\nfn test_u32_to_enum() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    enum E {\n        A,\n        B,\n    }\n\n    let deserializer = IntoDeserializer::\u003cvalue::Error\u003e::into_deserializer(1u32);\n    let e: E = E::deserialize(deserializer).unwrap();\n    assert_eq!(E::B, e);\n}\n\n#[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n#[test]\nfn test_integer128() {\n    let de_u128 = IntoDeserializer::\u003cvalue::Error\u003e::into_deserializer(1u128);\n    let de_i128 = IntoDeserializer::\u003cvalue::Error\u003e::into_deserializer(1i128);\n\n    // u128 to u128\n    assert_eq!(1u128, u128::deserialize(de_u128).unwrap());\n\n    // u128 to i128\n    assert_eq!(1i128, i128::deserialize(de_u128).unwrap());\n\n    // i128 to u128\n    assert_eq!(1u128, u128::deserialize(de_i128).unwrap());\n\n    // i128 to i128\n    assert_eq!(1i128, i128::deserialize(de_i128).unwrap());\n}\n\n#[test]\nfn test_map_access_to_enum() {\n    #[derive(PartialEq, Debug)]\n    struct Potential(PotentialKind);\n\n    #[derive(PartialEq, Debug, Deserialize)]\n    enum PotentialKind {\n        Airebo(Airebo),\n    }\n\n    #[derive(PartialEq, Debug, Deserialize)]\n    struct Airebo {\n        lj_sigma: f64,\n    }\n\n    impl\u003c'de\u003e Deserialize\u003c'de\u003e for Potential {\n        fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            struct PotentialVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for PotentialVisitor {\n                type Value = Potential;\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    write!(formatter, \"a map\")\n                }\n\n                fn visit_map\u003cA\u003e(self, map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                where\n                    A: MapAccess\u003c'de\u003e,\n                {\n                    Deserialize::deserialize(MapAccessDeserializer::new(map)).map(Potential)\n                }\n            }\n\n            deserializer.deserialize_any(PotentialVisitor)\n        }\n    }\n\n    let expected = Potential(PotentialKind::Airebo(Airebo { lj_sigma: 14.0 }));\n\n    assert_de_tokens(\n        \u0026expected,\n        \u0026[\n            Token::Map { len: Some(1) },\n            Token::Str(\"Airebo\"),\n            Token::Map { len: Some(1) },\n            Token::Str(\"lj_sigma\"),\n            Token::F64(14.0),\n            Token::MapEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","bad_lifetimes.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test\u003c'a\u003e {\n    #[serde(borrow = \"zzz\")]\n    s: \u0026'a str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","duplicate_lifetime.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test\u003c'a\u003e {\n    #[serde(borrow = \"'a + 'a\")]\n    s: \u0026'a str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","duplicate_variant.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Str\u003c'a\u003e(\u0026'a str);\n\n#[derive(Deserialize)]\nenum Test\u003c'a\u003e {\n    #[serde(borrow)]\n    S(#[serde(borrow)] Str\u003c'a\u003e),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","empty_lifetimes.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test\u003c'a\u003e {\n    #[serde(borrow = \"\")]\n    s: \u0026'a str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","no_lifetimes.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test {\n    #[serde(borrow)]\n    s: String,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","struct_variant.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Str\u003c'a\u003e(\u0026'a str);\n\n#[derive(Deserialize)]\nenum Test\u003c'a\u003e {\n    #[serde(borrow)]\n    S { s: Str\u003c'a\u003e },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","wrong_lifetime.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test\u003c'a\u003e {\n    #[serde(borrow = \"'b\")]\n    s: \u0026'a str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","adjacent-tag.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"conflict\", content = \"conflict\")]\nenum E {\n    A,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","flatten-newtype-struct.rs"],"content":"use serde_derive::Serialize;\n\nuse std::collections::HashMap;\n\n#[derive(Serialize)]\nstruct Foo(#[serde(flatten)] HashMap\u003cString, String\u003e);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","flatten-tuple-struct.rs"],"content":"use serde_derive::Serialize;\n\nuse std::collections::HashMap;\n\n#[derive(Serialize)]\nstruct Foo(u32, #[serde(flatten)] HashMap\u003cString, String\u003e);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","from-try-from.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(from = \"u64\", try_from = \"u64\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","internal-tag-alias.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"conflict\")]\nenum E {\n    A {\n        #[serde(alias = \"conflict\")]\n        x: (),\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","internal-tag.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"conflict\")]\nenum E {\n    A {\n        #[serde(rename = \"conflict\")]\n        x: (),\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","default-attribute","enum.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default)]\nenum E {\n    S { f: u8 },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","default-attribute","enum_path.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default = \"default_e\")]\nenum E {\n    S { f: u8 },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","default-attribute","nameless_struct_fields.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default)]\nstruct T(u8, u8);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","default-attribute","nameless_struct_fields_path.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default = \"default_t\")]\nstruct T(u8, u8);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","rename-and-ser.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = \"x\", serialize = \"y\")]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","rename-ser-rename-ser.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(serialize = \"x\"), rename(serialize = \"y\"))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","rename-ser-rename.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(serialize = \"x\"))]\n    #[serde(rename = \"y\")]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","rename-ser-ser.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(serialize = \"x\", serialize = \"y\"))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","two-rename-ser.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(serialize = \"x\"))]\n    #[serde(rename(serialize = \"y\"))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","with-and-serialize-with.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(with = \"w\", serialize_with = \"s\")]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","content-no-tag.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(content = \"c\")]\nenum E {\n    A(u8),\n    B(String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","internal-tuple-variant.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"type\")]\nenum E {\n    Tuple(u8, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","untagged-and-adjacent.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(untagged)]\n#[serde(tag = \"t\", content = \"c\")]\nenum E {\n    A(u8),\n    B(String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","untagged-and-content.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(untagged)]\n#[serde(content = \"c\")]\nenum E {\n    A(u8),\n    B(String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","untagged-and-internal.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(untagged)]\n#[serde(tag = \"type\")]\nenum E {\n    A(u8),\n    B(String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","untagged-struct.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(untagged)]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","boolean.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = true)]\n    boolean: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","byte_character.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = b'a')]\n    byte_character: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","byte_string.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = b\"byte string\")]\n    byte_string: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","character.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = 'a')]\n    character: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","float.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = 3.14)]\n    float: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","integer.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = 100)]\n    integer: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","both.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier, variant_identifier)]\nenum F {\n    A,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","field_struct.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","field_tuple.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    B(u8, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","newtype_not_last.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    Other(String),\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","not_unit.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    #[serde(other)]\n    Other(u8, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","other_not_last.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    #[serde(other)]\n    Other,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","other_untagged.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(untagged)]\nenum F {\n    #[serde(other)]\n    Other,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","other_variant.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(variant_identifier)]\nenum F {\n    #[serde(other)]\n    Other,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","variant_struct.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(variant_identifier)]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","variant_tuple.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(variant_identifier)]\nenum F {\n    A,\n    B(u8, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","malformed","bound.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(bound(unknown))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","malformed","rename.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(unknown))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","precondition","deserialize_de_lifetime.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct S\u003c'de\u003e {\n    s: \u0026'de str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","precondition","deserialize_dst.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct S {\n    string: String,\n    slice: [u8],\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","precondition","serialize_field_identifier.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","precondition","serialize_variant_identifier.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(variant_identifier)]\nenum F {\n    A,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","bad_getter.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub struct S {\n        a: u8,\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    #[serde(getter = \"~~~\")]\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","bad_remote.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub struct S {\n        a: u8,\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"~~~\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","enum_getter.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub enum E {\n        A { a: u8 },\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::E\")]\npub enum E {\n    A {\n        #[serde(getter = \"get_a\")]\n        a: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","missing_field.rs"],"content":"use serde_derive::{Serialize, Deserialize};\n\nmod remote {\n    pub struct S {\n        pub a: u8,\n        pub b: u8,\n    }\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","nonremote_getter.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(getter = \"S::get\")]\n    a: u8,\n}\n\nimpl S {\n    fn get(\u0026self) -\u003e u8 {\n        self.a\n    }\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","unknown_field.rs"],"content":"use serde_derive::{Serialize, Deserialize};\n\nmod remote {\n    pub struct S {\n        pub a: u8,\n    }\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    b: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","wrong_de.rs"],"content":"use serde_derive::Deserialize;\n\nmod remote {\n    pub struct S(pub u16);\n}\n\n#[derive(Deserialize)]\n#[serde(remote = \"remote::S\")]\nstruct S(u8);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","wrong_getter.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub struct S {\n        a: u8,\n    }\n\n    impl S {\n        pub fn get(\u0026self) -\u003e u16 {\n            self.a as u16\n        }\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    #[serde(getter = \"remote::S::get\")]\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","wrong_ser.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub struct S {\n        pub a: u16,\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","rename","container_unknown_rename_rule.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(rename_all = \"abc\")]\nstruct S {\n    name: u8,\n    long_name: u8,\n    very_long_name: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","rename","variant_unknown_rename_rule.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum S {\n    #[serde(rename_all = \"abc\")]\n    V {\n        name: u8,\n        long_name: u8,\n        very_long_name: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","struct-representation","internally-tagged-tuple.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"type\")]\nstruct S(u8, u8);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","struct-representation","internally-tagged-unit.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"type\")]\nstruct U;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","at_most_one.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nstruct S {\n    a: u8,\n    b: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","de_at_least_one.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(transparent)]\nstruct S {\n    #[serde(skip)]\n    a: u8,\n    #[serde(default)]\n    b: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","enum.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nenum E {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","ser_at_least_one.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nstruct S {\n    #[serde(skip)]\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","unit_struct.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","with_from.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent, from = \"u64\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","with_into.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent, into = \"u64\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","with_try_from.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent, try_from = \"u64\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","type-attribute","from.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(from = \"Option\u003cT\")]\nenum TestOne {\n    Testing,\n    One,\n    Two,\n    Three,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","type-attribute","into.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(into = \"Option\u003cT\")]\nenum TestOne {\n    Testing,\n    One,\n    Two,\n    Three,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","type-attribute","try_from.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(try_from = \"Option\u003cT\")]\nenum TestOne {\n    Testing,\n    One,\n    Two,\n    Three,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unexpected-literal","container.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(\"literal\")]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unexpected-literal","field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(\"literal\")]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unexpected-literal","variant.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum E {\n    #[serde(\"literal\")]\n    V,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unknown-attribute","container.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(abc = \"xyz\")]\nstruct A {\n    x: u32,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unknown-attribute","field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct C {\n    #[serde(abc = \"xyz\")]\n    x: u32,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unknown-attribute","variant.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum E {\n    #[serde(abc = \"xyz\")]\n    V,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unsupported","union_de.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nunion Union {\n    x: u8,\n    y: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unsupported","union_ser.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nunion Union {\n    x: u8,\n    y: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_de_newtype_field.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nenum Enum {\n    #[serde(deserialize_with = \"deserialize_some_newtype_variant\")]\n    Newtype(#[serde(skip_deserializing)] String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_de_struct_field.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nenum Enum {\n    #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n    Struct {\n        #[serde(skip_deserializing)]\n        f1: String,\n        f2: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_de_tuple_field.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nenum Enum {\n    #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n    Tuple(#[serde(skip_deserializing)] String, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_de_whole_variant.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nenum Enum {\n    #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n    #[serde(skip_deserializing)]\n    Unit,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_newtype_field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n    Newtype(#[serde(skip_serializing)] String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_newtype_field_if.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n    Newtype(#[serde(skip_serializing_if = \"always\")] String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_struct_field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_other_variant\")]\n    Struct {\n        #[serde(skip_serializing)]\n        f1: String,\n        f2: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_struct_field_if.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n    Struct {\n        #[serde(skip_serializing_if = \"always\")]\n        f1: String,\n        f2: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_tuple_field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_other_variant\")]\n    Tuple(#[serde(skip_serializing)] String, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_tuple_field_if.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_other_variant\")]\n    Tuple(#[serde(skip_serializing_if = \"always\")] String, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_whole_variant.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_unit_variant\")]\n    #[serde(skip_serializing)]\n    Unit,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","unstable","mod.rs"],"content":"use serde::{Deserialize, Serialize};\nuse serde_test::{assert_tokens, Token};\n\n#[test]\nfn test_raw_identifiers() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[allow(non_camel_case_types)]\n    enum r#type {\n        r#type { r#type: () },\n    }\n\n    assert_tokens(\n        \u0026r#type::r#type { r#type: () },\n        \u0026[\n            Token::StructVariant {\n                name: \"type\",\n                variant: \"type\",\n                len: 1,\n            },\n            Token::Str(\"type\"),\n            Token::Unit,\n            Token::StructVariantEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","src","impls.rs"],"content":"use crate::{OpenapiSchema, OpenapiType};\n#[cfg(feature = \"chrono\")]\nuse chrono::{offset::TimeZone, Date, DateTime, NaiveDate, NaiveDateTime};\nuse indexmap::{IndexMap, IndexSet};\nuse openapiv3::{\n\tAdditionalProperties, ArrayType, IntegerType, NumberFormat, NumberType, ObjectType, ReferenceOr, SchemaKind,\n\tStringFormat, StringType, Type, VariantOrUnknownOrEmpty\n};\nuse serde_json::Value;\nuse std::{\n\tcollections::{BTreeMap, BTreeSet, HashMap, HashSet},\n\thash::BuildHasher,\n\tnum::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize}\n};\n#[cfg(feature = \"uuid\")]\nuse uuid::Uuid;\n\nmacro_rules! impl_openapi_type {\n\t($($ty:ident $(\u003c$($generic:ident : $bound:path),+\u003e)*),* =\u003e $schema:expr) =\u003e {\n\t\t$(\n\t\t\timpl $(\u003c$($generic : $bound),+\u003e)* OpenapiType for $ty $(\u003c$($generic),+\u003e)* {\n\t\t\t\tfn schema() -\u003e OpenapiSchema {\n\t\t\t\t\t$schema\n\t\t\t\t}\n\t\t\t}\n\t\t)*\n\t};\n}\n\ntype Unit = ();\nimpl_openapi_type!(Unit =\u003e {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Object(ObjectType {\n\t\tadditional_properties: Some(AdditionalProperties::Any(false)),\n\t\t..Default::default()\n\t})))\n});\n\nimpl_openapi_type!(Value =\u003e {\n\tOpenapiSchema {\n\t\tnullable: true,\n\t\tdescription: None,\n\t\tname: None,\n\t\tschema: SchemaKind::Any(Default::default()),\n\t\tdependencies: Default::default()\n\t}\n});\n\nimpl_openapi_type!(bool =\u003e OpenapiSchema::new(SchemaKind::Type(Type::Boolean {})));\n\n#[inline]\nfn int_schema(minimum: Option\u003ci64\u003e, bits: Option\u003ci64\u003e) -\u003e OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Integer(IntegerType {\n\t\tminimum,\n\t\tformat: bits\n\t\t\t.map(|bits| VariantOrUnknownOrEmpty::Unknown(format!(\"int{}\", bits)))\n\t\t\t.unwrap_or(VariantOrUnknownOrEmpty::Empty),\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(isize =\u003e int_schema(None, None));\nimpl_openapi_type!(i8 =\u003e int_schema(None, Some(8)));\nimpl_openapi_type!(i16 =\u003e int_schema(None, Some(16)));\nimpl_openapi_type!(i32 =\u003e int_schema(None, Some(32)));\nimpl_openapi_type!(i64 =\u003e int_schema(None, Some(64)));\nimpl_openapi_type!(i128 =\u003e int_schema(None, Some(128)));\n\nimpl_openapi_type!(usize =\u003e int_schema(Some(0), None));\nimpl_openapi_type!(u8 =\u003e int_schema(Some(0), Some(8)));\nimpl_openapi_type!(u16 =\u003e int_schema(Some(0), Some(16)));\nimpl_openapi_type!(u32 =\u003e int_schema(Some(0), Some(32)));\nimpl_openapi_type!(u64 =\u003e int_schema(Some(0), Some(64)));\nimpl_openapi_type!(u128 =\u003e int_schema(Some(0), Some(128)));\n\nimpl_openapi_type!(NonZeroUsize =\u003e int_schema(Some(1), None));\nimpl_openapi_type!(NonZeroU8 =\u003e int_schema(Some(1), Some(8)));\nimpl_openapi_type!(NonZeroU16 =\u003e int_schema(Some(1), Some(16)));\nimpl_openapi_type!(NonZeroU32 =\u003e int_schema(Some(1), Some(32)));\nimpl_openapi_type!(NonZeroU64 =\u003e int_schema(Some(1), Some(64)));\nimpl_openapi_type!(NonZeroU128 =\u003e int_schema(Some(1), Some(128)));\n\n#[inline]\nfn float_schema(format: NumberFormat) -\u003e OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Number(NumberType {\n\t\tformat: VariantOrUnknownOrEmpty::Item(format),\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(f32 =\u003e float_schema(NumberFormat::Float));\nimpl_openapi_type!(f64 =\u003e float_schema(NumberFormat::Double));\n\n#[inline]\nfn str_schema(format: VariantOrUnknownOrEmpty\u003cStringFormat\u003e) -\u003e OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::String(StringType {\n\t\tformat,\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(String, str =\u003e str_schema(VariantOrUnknownOrEmpty::Empty));\n\n#[cfg(feature = \"chrono\")]\nimpl_openapi_type!(Date\u003cT: TimeZone\u003e, NaiveDate =\u003e {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::Date))\n});\n\n#[cfg(feature = \"chrono\")]\nimpl_openapi_type!(DateTime\u003cT: TimeZone\u003e, NaiveDateTime =\u003e {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::DateTime))\n});\n\n#[cfg(feature = \"uuid\")]\nimpl_openapi_type!(Uuid =\u003e {\n\tstr_schema(VariantOrUnknownOrEmpty::Unknown(\"uuid\".to_owned()))\n});\n\nimpl_openapi_type!(Option\u003cT: OpenapiType\u003e =\u003e {\n\tlet schema = T::schema();\n\tlet mut dependencies = schema.dependencies.clone();\n\tlet schema = match schema.name.clone() {\n\t\tSome(name) =\u003e {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\tSchemaKind::AllOf { all_of: vec![reference] }\n\t\t},\n\t\tNone =\u003e schema.schema\n\t};\n\n\tOpenapiSchema {\n\t\tnullable: true,\n\t\tname: None,\n\t\tdescription: None,\n\t\tschema,\n\t\tdependencies\n\t}\n});\n\n#[inline]\nfn array_schema\u003cT: OpenapiType\u003e(unique_items: bool) -\u003e OpenapiSchema {\n\tlet schema = T::schema();\n\tlet mut dependencies = schema.dependencies.clone();\n\n\tlet items = match schema.name.clone() {\n\t\tSome(name) =\u003e {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\treference\n\t\t},\n\t\tNone =\u003e ReferenceOr::Item(Box::new(schema.into_schema()))\n\t};\n\n\tOpenapiSchema {\n\t\tnullable: false,\n\t\tname: None,\n\t\tdescription: None,\n\t\tschema: SchemaKind::Type(Type::Array(ArrayType {\n\t\t\titems,\n\t\t\tmin_items: None,\n\t\t\tmax_items: None,\n\t\t\tunique_items\n\t\t})),\n\t\tdependencies\n\t}\n}\n\nimpl_openapi_type!(Vec\u003cT: OpenapiType\u003e =\u003e array_schema::\u003cT\u003e(false));\nimpl_openapi_type!(BTreeSet\u003cT: OpenapiType\u003e, IndexSet\u003cT: OpenapiType\u003e, HashSet\u003cT: OpenapiType, S: BuildHasher\u003e =\u003e {\n\tarray_schema::\u003cT\u003e(true)\n});\n\n#[inline]\nfn map_schema\u003cK: OpenapiType, T: OpenapiType\u003e() -\u003e OpenapiSchema {\n\tlet key_schema = K::schema();\n\tlet mut dependencies = key_schema.dependencies.clone();\n\n\tlet keys = match key_schema.name.clone() {\n\t\tSome(name) =\u003e {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, key_schema);\n\t\t\treference\n\t\t},\n\t\tNone =\u003e ReferenceOr::Item(Box::new(key_schema.into_schema()))\n\t};\n\n\tlet schema = T::schema();\n\tdependencies.extend(schema.dependencies.iter().map(|(k, v)| (k.clone(), v.clone())));\n\n\tlet items = Box::new(match schema.name.clone() {\n\t\tSome(name) =\u003e {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\treference\n\t\t},\n\t\tNone =\u003e ReferenceOr::Item(schema.into_schema())\n\t});\n\n\tlet mut properties = IndexMap::new();\n\tproperties.insert(\"default\".to_owned(), keys);\n\n\tOpenapiSchema {\n\t\tnullable: false,\n\t\tname: None,\n\t\tdescription: None,\n\t\tschema: SchemaKind::Type(Type::Object(ObjectType {\n\t\t\tproperties,\n\t\t\trequired: vec![\"default\".to_owned()],\n\t\t\tadditional_properties: Some(AdditionalProperties::Schema(items)),\n\t\t\t..Default::default()\n\t\t})),\n\t\tdependencies\n\t}\n}\n\nimpl_openapi_type!(\n\tBTreeMap\u003cK: OpenapiType, T: OpenapiType\u003e,\n\tIndexMap\u003cK: OpenapiType, T: OpenapiType\u003e,\n\tHashMap\u003cK: OpenapiType, T: OpenapiType, S: BuildHasher\u003e\n\t=\u003e map_schema::\u003cK, T\u003e()\n);\n","traces":[{"line":22,"address":[305040,304944,305136,305232,304864,305328],"length":1,"stats":{"Line":44},"fn_name":"schema"},{"line":32,"address":[319766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[319706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[319751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[291551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[291450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[291459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[291481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[291544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[320202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[320311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[320375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[320455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[320535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[320615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[320695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[320775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[320855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[320951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[321047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[321143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[321239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[304871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[304951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[305047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[305143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[305239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[305335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[321335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[321383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[304599],"length":1,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[291959],"length":1,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[308615],"length":1,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[305486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[341722],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[341803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[341830,341928],"length":1,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[341857,341935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[342168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[341983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[342220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[342402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[341882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[342770],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[342651],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[342663],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[342675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[342723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[347610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[444244],"length":1,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[315816],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":82,"coverable":97},{"path":["/","home","runner","work","openapi_type","openapi_type","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms)]\n#![forbid(unsafe_code)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(clippy::tabs_in_doc_comments))]\n#![doc = r##\"\nThis crate gives static type information for primitives and commonly used types from the standard\nlibrary and a few other commonly used libraries like `chrono` and `uuid`. Also, it provides a\nderive macro for structs and enums to gain access to their static type information at runtime.\n\nThe core of this crate is the [`OpenapiType`] trait. It has one static function,\n[`schema`](OpenapiType::schema), which returns an [`OpenapiSchema`]. This assembles the static\ntype information in a way that is convenient to use for a generated OpenAPI specification, but\ncan also be utilized in other use cases as well.\n\n# Custom Types\nTo gain access to the static type information of your custom types at runtime, the easiest way\nis to use the derive macro:\n\n```rust\n# use openapi_type::OpenapiType;\n#[derive(OpenapiType)]\nstruct FooBar {\n\tfoo: String,\n\tbar: u64\n}\n# let schema = FooBar::schema().into_schema();\n# let schema_json = serde_json::to_value(\u0026schema).unwrap();\n# assert_eq!(schema_json, serde_json::json!({\n#   \"type\": \"object\",\n#   \"title\": \"FooBar\",\n#   \"properties\": {\n#     \"foo\": {\n#       \"type\": \"string\"\n#     },\n#     \"bar\": {\n#       \"type\": \"integer\",\n#       \"format\": \"int64\",\n#       \"minimum\": 0\n#     }\n#   },\n#   \"required\": [\"foo\", \"bar\"]\n# }));\n```\n\n# OpenAPI specification\nUsing above type, running `FooBar::schema().into_schema()` yields\n\n```yaml\ntype: object\ntitle: FooBar\nproperties:\n  foo:\n    type: string\n  bar:\n    type: integer\n    format: int64\n    minimum: 0\nrequired:\n  - foo\n  - bar\n```\n\nNote, however, that this is not sufficient for more complex types. If one of your structs fields\nis a type that has a name (that is, `Type::schema().name` is not `None`), above schema will contain\na reference to that schema. Therefore, always remember to put the\n[`dependencies`](OpenapiSchema::dependencies) into the specification alongside the type you are\ninterested in.\n\"##]\n\npub use indexmap;\npub use openapi_type_derive::OpenapiType;\npub use openapiv3 as openapi;\n\nmod impls;\n#[doc(hidden)]\npub mod private;\n\nuse indexmap::IndexMap;\nuse openapi::{Schema, SchemaData, SchemaKind};\n\n/// This struct is used to generate the OpenAPI specification for a particular type. It is already\n/// made available for all primitives and some other types from the rust standard library, and\n/// you can also make your own types provide one through the [OpenapiType] trait and derive macro.\n///\n/// Note that this struct is marked non-exhaustive. This means that new attributes might be added\n/// at any point in time without a breaking change. The only way to obtain a value is through the\n/// [OpenapiSchema::new] method.\n#[derive(Debug, Clone, PartialEq)]\n#[non_exhaustive]\npub struct OpenapiSchema {\n\t/// The name of this schema. If it is None, the schema will be inlined.\n\tpub name: Option\u003cString\u003e,\n\t/// The description of this schema. Optional and only makes sense when a [name] is set as well.\n\tpub description: Option\u003cString\u003e,\n\t/// Whether this particular schema is nullable. Note that there is no guarantee that this will\n\t/// make it into the final specification, it might just be interpreted as a hint to make it\n\t/// an optional parameter.\n\tpub nullable: bool,\n\t/// The actual OpenAPI schema.\n\tpub schema: SchemaKind,\n\t/// Other schemas that this schema depends on. They will be included in the final OpenAPI Spec\n\t/// along with this schema.\n\tpub dependencies: IndexMap\u003cString, OpenapiSchema\u003e\n}\n\nimpl OpenapiSchema {\n\t/// Create a new schema that has no name.\n\tpub fn new(schema: SchemaKind) -\u003e Self {\n\t\tSelf {\n\t\t\tname: None,\n\t\t\tdescription: None,\n\t\t\tnullable: false,\n\t\t\tschema,\n\t\t\tdependencies: IndexMap::new()\n\t\t}\n\t}\n\n\t/// Convert this schema to a [Schema] that can be serialized to the OpenAPI Spec.\n\tpub fn into_schema(self) -\u003e Schema {\n\t\tSchema {\n\t\t\tschema_data: SchemaData {\n\t\t\t\tnullable: self.nullable,\n\t\t\t\ttitle: self.name,\n\t\t\t\tdescription: self.description,\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tschema_kind: self.schema\n\t\t}\n\t}\n}\n\n/**\nThis trait needs to be implemented by every type that is being used in the OpenAPI Spec. It gives\naccess to the [OpenapiSchema] of this type. It is provided for primitive types, String and the\nlike. For use on your own types, there is a derive macro:\n\n```\n# #[macro_use] extern crate openapi_type_derive;\n#\n#[derive(OpenapiType)]\nstruct MyResponse {\n\tmessage: String\n}\n```\n*/\npub trait OpenapiType {\n\tfn schema() -\u003e OpenapiSchema;\n}\n\nimpl\u003c'a, T: ?Sized + OpenapiType\u003e OpenapiType for \u0026'a T {\n\tfn schema() -\u003e OpenapiSchema {\n\t\tT::schema()\n\t}\n}\n","traces":[{"line":107,"address":[1016355,1016096],"length":1,"stats":{"Line":3},"fn_name":"new"},{"line":113,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","runner","work","openapi_type","openapi_type","src","private.rs"],"content":"use crate::OpenapiSchema;\nuse indexmap::IndexMap;\n\npub type Dependencies = IndexMap\u003cString, OpenapiSchema\u003e;\n\npub fn add_dependencies(dependencies: \u0026mut Dependencies, other: \u0026mut Dependencies) {\n\twhile let Some((dep_name, dep_schema)) = other.pop() {\n\t\tif !dependencies.contains_key(\u0026dep_name) {\n\t\t\tdependencies.insert(dep_name, dep_schema);\n\t\t}\n\t}\n}\n","traces":[{"line":6,"address":[301712,302141],"length":1,"stats":{"Line":2},"fn_name":"add_dependencies"},{"line":7,"address":[302118,301745,301829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[302063,302080,301916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[301939,302073],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":4},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","custom_types.rs"],"content":"#![allow(dead_code)]\nuse openapi_type::OpenapiType;\n\nmacro_rules! test_type {\n\t($ty:ty = $json:tt) =\u003e {\n\t\tpaste::paste! {\n\t\t\t#[test]\n\t\t\tfn [\u003c $ty:lower \u003e]() {\n\t\t\t\tlet schema = \u003c$ty as OpenapiType\u003e::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(\u0026schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t}\n\t\t}\n\t};\n}\n\n#[derive(OpenapiType)]\nstruct UnitStruct;\ntest_type!(UnitStruct = {\n\t\"type\": \"object\",\n\t\"title\": \"UnitStruct\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\nstruct SimpleStruct {\n\tfoo: String,\n\tbar: isize\n}\ntest_type!(SimpleStruct = {\n\t\"type\": \"object\",\n\t\"title\": \"SimpleStruct\",\n\t\"properties\": {\n\t\t\"foo\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"bar\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"foo\", \"bar\"]\n});\n\n#[derive(OpenapiType)]\n#[openapi(rename = \"FooBar\")]\nstruct StructRename;\ntest_type!(StructRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FooBar\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\nenum EnumWithoutFields {\n\tSuccess,\n\tError\n}\ntest_type!(EnumWithoutFields = {\n\t\"type\": \"string\",\n\t\"title\": \"EnumWithoutFields\",\n\t\"enum\": [\n\t\t\"Success\",\n\t\t\"Error\"\n\t]\n});\n\n#[derive(OpenapiType)]\nenum EnumWithOneField {\n\tSuccess { value: isize }\n}\ntest_type!(EnumWithOneField = {\n\t\"type\": \"object\",\n\t\"title\": \"EnumWithOneField\",\n\t\"properties\": {\n\t\t\"Success\": {\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"value\": {\n\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"value\"]\n\t\t}\n\t},\n\t\"required\": [\"Success\"]\n});\n\n#[derive(OpenapiType)]\nenum EnumWithFields {\n\tSuccess { value: isize },\n\tError { msg: String }\n}\ntest_type!(EnumWithFields = {\n\t\"title\": \"EnumWithFields\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Success\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Success\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Error\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"msg\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"msg\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Error\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\nenum EnumExternallyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumExternallyTagged = {\n\t\"title\": \"EnumExternallyTagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Success\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Success\"]\n\t}, {\n\t\t\"type\": \"string\",\n\t\t\"enum\": [\"Empty\", \"Error\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\n#[openapi(tag = \"ty\")]\nenum EnumInternallyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumInternallyTagged = {\n\t\"title\": \"EnumInternallyTagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t},\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Success\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\", \"ty\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Empty\", \"Error\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\n#[openapi(tag = \"ty\", content = \"ct\")]\nenum EnumAdjacentlyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumAdjacentlyTagged = {\n\t\"title\": \"EnumAdjacentlyTagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Success\"]\n\t\t\t},\n\t\t\t\"ct\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\", \"ct\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Empty\", \"Error\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\n#[openapi(untagged)]\nenum EnumUntagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumUntagged = {\n\t\"title\": \"EnumUntagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"additionalProperties\": false\n\t}]\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","custom_types_attrs.rs"],"content":"#![allow(dead_code)]\nuse openapi_type::OpenapiType;\n\nmacro_rules! test_type {\n\t($ty:ty = $json:tt) =\u003e {\n\t\tpaste::paste! {\n\t\t\t#[test]\n\t\t\tfn [\u003c $ty:lower \u003e]() {\n\t\t\t\tlet schema = \u003c$ty as OpenapiType\u003e::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(\u0026schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t}\n\t\t}\n\t};\n}\n\n/// Very cool struct!\n#[derive(OpenapiType)]\nstruct ContainerDoc {\n\t/// Very important!\n\tfoo: String\n}\ntest_type!(ContainerDoc = {\n\t\"type\": \"object\",\n\t\"title\": \"ContainerDoc\",\n\t\"description\": \"Very cool struct!\",\n\t\"properties\": {\n\t\t\"foo\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"Very important!\"\n\t\t}\n\t},\n\t\"required\": [\"foo\"]\n});\n\n#[derive(OpenapiType)]\n#[openapi(rename = \"FooBar\")]\nstruct ContainerRename;\ntest_type!(ContainerRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FooBar\",\n\t\"additionalProperties\": false\n});\n\nmacro_rules! test_rename_all {\n\t(rename_all = $rename_all:literal, foo_bar = $foo_bar:literal) =\u003e {\n\t\tpaste::paste! {\n\t\t\t#[derive(OpenapiType, serde::Serialize)]\n\t\t\t#[openapi(rename = \"FooBar\")]\n\t\t\t#[serde(rename_all = $rename_all)]\n\t\t\t#[allow(non_camel_case_types, non_snake_case)]\n\t\t\tstruct [\u003c ContainerRenameAll_ $rename_all \u003e] {\n\t\t\t\tfoo_bar: Option\u003c\u0026'static str\u003e,\n\t\t\t}\n\t\t\ttest_type!([\u003c ContainerRenameAll_ $rename_all \u003e] = {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"title\": \"FooBar\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t$foo_bar: {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t});\n\t\t\t#[test]\n\t\t\tfn [\u003c containerrenameall_ $rename_all:lower _serde \u003e]() {\n\t\t\t\tlet value = [\u003c ContainerRenameAll_ $rename_all \u003e] {\n\t\t\t\t\tfoo_bar: Some(\"foo_bar\"),\n\t\t\t\t};\n\t\t\t\tlet json = serde_json::to_value(\u0026value).unwrap();\n\t\t\t\tlet expected = serde_json::json!({\n\t\t\t\t\t$foo_bar: \"foo_bar\",\n\t\t\t\t});\n\t\t\t\tpretty_assertions::assert_eq!(json, expected);\n\t\t\t}\n\t\t}\n\t};\n}\n\ntest_rename_all!(rename_all = \"lowercase\", foo_bar = \"foo_bar\");\ntest_rename_all!(rename_all = \"UPPERCASE\", foo_bar = \"FOO_BAR\");\ntest_rename_all!(rename_all = \"PascalCase\", foo_bar = \"FooBar\");\ntest_rename_all!(rename_all = \"camelCase\", foo_bar = \"fooBar\");\ntest_rename_all!(rename_all = \"snake_case\", foo_bar = \"foo_bar\");\ntest_rename_all!(rename_all = \"SCREAMING_SNAKE_CASE\", foo_bar = \"FOO_BAR\");\ntest_rename_all!(rename_all = \"kebab-case\", foo_bar = \"foo-bar\");\ntest_rename_all!(rename_all = \"SCREAMING-KEBAB-CASE\", foo_bar = \"FOO-BAR\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","enum_with_no_variants.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nenum Foo {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","not_openapitype.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo {\n\tbar: Bar\n}\n\nstruct Bar;\n\nfn main() {\n\tFoo::schema();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","not_openapitype_generics.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo\u003cT\u003e {\n\tbar: T\n}\n\nstruct Bar;\n\nfn main() {\n\t\u003cFoo\u003cBar\u003e\u003e::schema();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","tuple_struct.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo(i64, i64);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","tuple_variant.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nenum Foo {\n\tPair(i64, i64)\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","union.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nunion Foo {\n\tsigned: i64,\n\tunsigned: u64\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","unknown_attribute.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\n#[openapi(pizza)]\nstruct Foo;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","std_types.rs"],"content":"#[cfg(feature = \"chrono\")]\nuse chrono::{Date, DateTime, FixedOffset, NaiveDate, NaiveDateTime, Utc};\nuse indexmap::{IndexMap, IndexSet};\nuse openapi_type::OpenapiType;\nuse serde_json::Value;\nuse std::{\n\tcollections::{BTreeMap, BTreeSet, HashMap, HashSet},\n\tnum::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize}\n};\n#[cfg(feature = \"uuid\")]\nuse uuid::Uuid;\n\nmacro_rules! test_type {\n\t($($ty:ident $(\u003c$($generic:ident),+\u003e)*),* = $json:tt) =\u003e {\n\t\tpaste::paste! { $(\n\t\t\t#[test]\n\t\t\tfn [\u003c $ty:lower $($(_ $generic:lower)+)* \u003e]() {\n\t\t\t\tlet schema = \u003c$ty $(\u003c$($generic),+\u003e)* as OpenapiType\u003e::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(\u0026schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t}\n\t\t)* }\n\t};\n}\n\ntype Unit = ();\ntest_type!(Unit = {\n\t\"type\": \"object\",\n\t\"additionalProperties\": false\n});\n\ntest_type!(Value = {\n\t\"nullable\": true\n});\n\ntest_type!(bool = {\n\t\"type\": \"boolean\"\n});\n\n// ### integer types\n\ntest_type!(isize = {\n\t\"type\": \"integer\"\n});\n\ntest_type!(usize = {\n\t\"type\": \"integer\",\n\t\"minimum\": 0\n});\n\ntest_type!(i8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\"\n});\n\ntest_type!(u8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\",\n\t\"minimum\": 0\n});\n\ntest_type!(i16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\"\n});\n\ntest_type!(u16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\",\n\t\"minimum\": 0\n});\n\ntest_type!(i32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\"\n});\n\ntest_type!(u32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\",\n\t\"minimum\": 0\n});\n\ntest_type!(i64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\"\n});\n\ntest_type!(u64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\",\n\t\"minimum\": 0\n});\n\ntest_type!(i128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\"\n});\n\ntest_type!(u128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\",\n\t\"minimum\": 0\n});\n\n// ### non-zero integer types\n\ntest_type!(NonZeroUsize = {\n\t\"type\": \"integer\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\",\n\t\"minimum\": 1\n});\n\n// ### floats\n\ntest_type!(f32 = {\n\t\"type\": \"number\",\n\t\"format\": \"float\"\n});\n\ntest_type!(f64 = {\n\t\"type\": \"number\",\n\t\"format\": \"double\"\n});\n\n// ### string\n\ntest_type!(String = {\n\t\"type\": \"string\"\n});\n\n#[cfg(feature = \"uuid\")]\ntest_type!(Uuid = {\n\t\"type\": \"string\",\n\t\"format\": \"uuid\"\n});\n\n// ### date/time\n\n#[cfg(feature = \"chrono\")]\ntest_type!(Date\u003cFixedOffset\u003e, Date\u003cUtc\u003e, NaiveDate = {\n\t\"type\": \"string\",\n\t\"format\": \"date\"\n});\n\n#[cfg(feature = \"chrono\")]\ntest_type!(DateTime\u003cFixedOffset\u003e, DateTime\u003cUtc\u003e, NaiveDateTime = {\n\t\"type\": \"string\",\n\t\"format\": \"date-time\"\n});\n\n// ### some std types\n\ntest_type!(Option\u003cString\u003e = {\n\t\"type\": \"string\",\n\t\"nullable\": true\n});\n\ntest_type!(Vec\u003cString\u003e = {\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"string\"\n\t}\n});\n\ntest_type!(BTreeSet\u003cString\u003e, IndexSet\u003cString\u003e, HashSet\u003cString\u003e = {\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"string\"\n\t},\n\t\"uniqueItems\": true\n});\n\ntest_type!(BTreeMap\u003cisize, String\u003e, IndexMap\u003cisize, String\u003e, HashMap\u003cisize, String\u003e = {\n\t\"type\": \"object\",\n\t\"properties\": {\n\t\t\"default\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"default\"],\n\t\"additionalProperties\": {\n\t\t\"type\": \"string\"\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","trybuild.rs"],"content":"use trybuild::TestCases;\n\n#[test]\nfn trybuild() {\n\tlet t = TestCases::new();\n\tt.compile_fail(\"tests/fail/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","attrs.rs"],"content":"use crate::util::ExpectLit;\nuse syn::{punctuated::Punctuated, spanned::Spanned as _, Attribute, LitStr, Meta, Token};\n\npub(super) fn parse_doc_attr(input: \u0026Attribute) -\u003e syn::Result\u003cOption\u003cLitStr\u003e\u003e {\n\tinput.parse_meta().and_then(|meta| {\n\t\tOk(match meta {\n\t\t\tMeta::NameValue(kv) =\u003e Some(kv.lit.expect_str()?),\n\t\t\t_ =\u003e None\n\t\t})\n\t})\n}\n\n#[derive(Default)]\npub(super) struct ContainerAttributes {\n\tpub(super) rename: Option\u003cLitStr\u003e,\n\tpub(super) rename_all: Option\u003cLitStr\u003e,\n\tpub(super) tag: Option\u003cLitStr\u003e,\n\tpub(super) content: Option\u003cLitStr\u003e,\n\tpub(super) untagged: bool\n}\n\npub(super) fn parse_container_attrs(\n\tinput: \u0026Attribute,\n\tattrs: \u0026mut ContainerAttributes,\n\terror_on_unknown: bool\n) -\u003e syn::Result\u003c()\u003e {\n\tlet tokens: Punctuated\u003cMeta, Token![,]\u003e = input.parse_args_with(Punctuated::parse_terminated)?;\n\tfor token in tokens {\n\t\tmatch token {\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"rename\") =\u003e {\n\t\t\t\tattrs.rename = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"rename_all\") =\u003e {\n\t\t\t\tattrs.rename_all = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"tag\") =\u003e {\n\t\t\t\tattrs.tag = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::NameValue(kv) if kv.path.is_ident(\"content\") =\u003e {\n\t\t\t\tattrs.content = Some(kv.lit.expect_str()?);\n\t\t\t},\n\n\t\t\tMeta::Path(path) if path.is_ident(\"untagged\") =\u003e {\n\t\t\t\tattrs.untagged = true;\n\t\t\t},\n\n\t\t\tMeta::Path(path) if error_on_unknown =\u003e return Err(syn::Error::new(path.span(), \"Unexpected token\")),\n\t\t\tMeta::List(list) if error_on_unknown =\u003e return Err(syn::Error::new(list.span(), \"Unexpected token\")),\n\t\t\tMeta::NameValue(kv) if error_on_unknown =\u003e return Err(syn::Error::new(kv.path.span(), \"Unexpected token\")),\n\t\t\t_ =\u003e {}\n\t\t}\n\t}\n\tOk(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","codegen.rs"],"content":"use crate::parser::{ParseData, ParseDataField, TypeOrInline};\nuse proc_macro2::TokenStream;\nuse quote::quote;\nuse syn::LitStr;\n\npub(super) fn gen_doc_option(doc: \u0026[String]) -\u003e TokenStream {\n\tlet doc = doc.join(\"\\n\");\n\tlet doc = doc.trim();\n\tif doc.is_empty() {\n\t\tquote!(::core::option::Option::None)\n\t} else {\n\t\tquote!(::core::option::Option::Some(#doc))\n\t}\n}\n\nimpl ParseData {\n\tpub(super) fn gen_schema(\u0026self) -\u003e TokenStream {\n\t\tmatch self {\n\t\t\tSelf::Struct(fields) =\u003e gen_struct(fields),\n\t\t\tSelf::Enum(variants) =\u003e gen_enum(variants),\n\t\t\tSelf::Alternatives(alt) =\u003e gen_alt(alt),\n\t\t\tSelf::Unit =\u003e gen_unit()\n\t\t}\n\t}\n}\n\nfn gen_struct(fields: \u0026[ParseDataField]) -\u003e TokenStream {\n\tlet field_name = fields.iter().map(|f| \u0026f.name);\n\tlet field_doc = fields.iter().map(|f| gen_doc_option(\u0026f.doc));\n\tlet field_schema = fields.iter().map(|f| match \u0026f.ty {\n\t\tTypeOrInline::Type(ty) =\u003e {\n\t\t\tquote!(\u003c#ty as ::openapi_type::OpenapiType\u003e::schema())\n\t\t},\n\t\tTypeOrInline::Inline(data) =\u003e {\n\t\t\tlet code = data.gen_schema();\n\t\t\tquote!(::openapi_type::OpenapiSchema::new(#code))\n\t\t}\n\t});\n\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t{\n\t\t\tlet mut properties = \u003c::openapi_type::indexmap::IndexMap\u003c\n\t\t\t\t::std::string::String,\n\t\t\t\t#openapi::ReferenceOr\u003c::std::boxed::Box\u003c#openapi::Schema\u003e\u003e\n\t\t\t\u003e\u003e::new();\n\t\t\tlet mut required = \u003c::std::vec::Vec\u003c::std::string::String\u003e\u003e::new();\n\n\t\t\t#({\n\t\t\t\t\tconst FIELD_NAME: \u0026::core::primitive::str = #field_name;\n\t\t\t\t\tconst FIELD_DOC: ::core::option::Option\u003c\u0026'static ::core::primitive::str\u003e = #field_doc;\n\n\t\t\t\t\tlet mut field_schema = #field_schema;\n\t\t\t\t\t::openapi_type::private::add_dependencies(\n\t\t\t\t\t\t\u0026mut dependencies,\n\t\t\t\t\t\t\u0026mut field_schema.dependencies\n\t\t\t\t\t);\n\n\t\t\t\t\t// fields in OpenAPI are nullable by default\n\t\t\t\t\tmatch field_schema.nullable {\n\t\t\t\t\t\ttrue =\u003e field_schema.nullable = false,\n\t\t\t\t\t\tfalse =\u003e required.push(::std::string::String::from(FIELD_NAME))\n\t\t\t\t\t};\n\n\t\t\t\t\tmatch field_schema.name.as_ref() {\n\t\t\t\t\t\t// include the field schema as reference\n\t\t\t\t\t\t::std::option::Option::Some(schema_name) =\u003e {\n\t\t\t\t\t\t\tlet mut reference = ::std::string::String::from(\"#/components/schemas/\");\n\t\t\t\t\t\t\treference.push_str(schema_name);\n\t\t\t\t\t\t\tproperties.insert(\n\t\t\t\t\t\t\t\t::std::string::String::from(FIELD_NAME),\n\t\t\t\t\t\t\t\t#openapi::ReferenceOr::Reference { reference }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdependencies.insert(\n\t\t\t\t\t\t\t\t::std::string::String::from(schema_name),\n\t\t\t\t\t\t\t\tfield_schema\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// inline the field schema\n\t\t\t\t\t\t::std::option::Option::None =\u003e {\n\t\t\t\t\t\t\tlet mut schema = field_schema.into_schema();\n\t\t\t\t\t\t\tschema.schema_data.description = FIELD_DOC.map(|desc| {\n\t\t\t\t\t\t\t\t::std::string::String::from(desc)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tproperties.insert(\n\t\t\t\t\t\t\t\t::std::string::String::from(FIELD_NAME),\n\t\t\t\t\t\t\t\t#openapi::ReferenceOr::Item(\n\t\t\t\t\t\t\t\t\t::std::boxed::Box::new(schema)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t})*\n\n\t\t\t#openapi::SchemaKind::Type(\n\t\t\t\t#openapi::Type::Object(\n\t\t\t\t\t#openapi::ObjectType {\n\t\t\t\t\t\tproperties,\n\t\t\t\t\t\trequired,\n\t\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}\n}\n\nfn gen_enum(variants: \u0026[LitStr]) -\u003e TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t{\n\t\t\tlet mut enumeration = \u003c::std::vec::Vec\u003c::std::string::String\u003e\u003e::new();\n\t\t\t#(enumeration.push(::std::string::String::from(#variants));)*\n\t\t\t#openapi::SchemaKind::Type(\n\t\t\t\t#openapi::Type::String(\n\t\t\t\t\t#openapi::StringType {\n\t\t\t\t\t\tenumeration,\n\t\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}\n}\n\nfn gen_alt(alt: \u0026[ParseData]) -\u003e TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tlet schema = alt.iter().map(|data| data.gen_schema());\n\tquote! {\n\t\t{\n\t\t\tlet mut alternatives = \u003c::std::vec::Vec\u003c\n\t\t\t\t#openapi::ReferenceOr\u003c#openapi::Schema\u003e\n\t\t\t\u003e\u003e::new();\n\t\t\t#(alternatives.push(#openapi::ReferenceOr::Item(\n\t\t\t\t::openapi_type::OpenapiSchema::new(#schema).into_schema()\n\t\t\t));)*\n\t\t\t#openapi::SchemaKind::OneOf {\n\t\t\t\tone_of: alternatives\n\t\t\t}\n\t\t}\n\t}\n}\n\nfn gen_unit() -\u003e TokenStream {\n\tlet openapi = path!(::openapi_type::openapi);\n\tquote! {\n\t\t#openapi::SchemaKind::Type(\n\t\t\t#openapi::Type::Object(\n\t\t\t\t#openapi::ObjectType {\n\t\t\t\t\tadditional_properties: ::std::option::Option::Some(\n\t\t\t\t\t\t#openapi::AdditionalProperties::Any(false)\n\t\t\t\t\t),\n\t\t\t\t\t.. ::std::default::Default::default()\n\t\t\t\t}\n\t\t\t)\n\t\t)\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms)]\n#![deny(broken_intra_doc_links)]\n#![forbid(unsafe_code)]\n//! This crate defines the macros for `#[derive(OpenapiType)]`.\n\nuse proc_macro::TokenStream;\nuse proc_macro2::TokenStream as TokenStream2;\nuse quote::quote;\nuse syn::{parse_macro_input, Data, DeriveInput, LitStr, TraitBound, TraitBoundModifier, TypeParamBound};\n\n// unfortunately, the serde_derive_internals crate does not make\n// `case::RenameRule` available\nmod serde_derive_internals;\n\n#[macro_use]\nmod util;\n\nmod attrs;\nuse attrs::*;\nmod codegen;\nuse codegen::*;\nmod parser;\nuse parser::*;\n\n/// The derive macro for [OpenapiType](https://docs.rs/openapi_type/*/openapi_type/trait.OpenapiType.html).\n#[proc_macro_derive(OpenapiType, attributes(openapi))]\npub fn derive_openapi_type(input: TokenStream) -\u003e TokenStream {\n\tlet input = parse_macro_input!(input);\n\texpand_openapi_type(input).unwrap_or_else(|err| err.to_compile_error()).into()\n}\n\nfn expand_openapi_type(mut input: DeriveInput) -\u003e syn::Result\u003cTokenStream2\u003e {\n\t// parse #[serde] and #[openapi] attributes\n\tlet mut attrs = ContainerAttributes::default();\n\tfor attr in \u0026input.attrs {\n\t\tif attr.path.is_ident(\"serde\") {\n\t\t\tparse_container_attrs(attr, \u0026mut attrs, false)?;\n\t\t}\n\t}\n\tfor attr in \u0026input.attrs {\n\t\tif attr.path.is_ident(\"openapi\") {\n\t\t\tparse_container_attrs(attr, \u0026mut attrs, true)?;\n\t\t}\n\t}\n\n\t// parse #[doc] attributes\n\tlet mut doc: Vec\u003cString\u003e = Vec::new();\n\tfor attr in \u0026input.attrs {\n\t\tif attr.path.is_ident(\"doc\") {\n\t\t\tif let Some(lit) = parse_doc_attr(attr)? {\n\t\t\t\tdoc.push(lit.value());\n\t\t\t}\n\t\t}\n\t}\n\tlet doc = gen_doc_option(\u0026doc);\n\n\t// prepare impl block for codegen\n\tlet ident = \u0026input.ident;\n\tlet name = ident.to_string();\n\tlet mut name = LitStr::new(\u0026name, ident.span());\n\tif let Some(rename) = \u0026attrs.rename {\n\t\tname = rename.clone();\n\t}\n\n\t// prepare the generics - all impl generics will get `OpenapiType` requirement\n\tlet (impl_generics, ty_generics, where_clause) = {\n\t\tlet generics = \u0026mut input.generics;\n\t\tgenerics.type_params_mut().for_each(|param| {\n\t\t\tparam.colon_token.get_or_insert_with(Default::default);\n\t\t\tparam.bounds.push(TypeParamBound::Trait(TraitBound {\n\t\t\t\tparen_token: None,\n\t\t\t\tmodifier: TraitBoundModifier::None,\n\t\t\t\tlifetimes: None,\n\t\t\t\tpath: path!(::openapi_type::OpenapiType)\n\t\t\t}));\n\t\t});\n\t\tgenerics.split_for_impl()\n\t};\n\n\t// parse the input data\n\tlet parsed = match \u0026input.data {\n\t\tData::Struct(strukt) =\u003e parse_struct(strukt, \u0026attrs)?,\n\t\tData::Enum(inum) =\u003e parse_enum(inum, \u0026attrs)?,\n\t\tData::Union(union) =\u003e parse_union(union)?\n\t};\n\n\t// run the codegen\n\tlet schema_code = parsed.gen_schema();\n\n\t// put the code together\n\tOk(quote! {\n\t\t#[allow(unused_mut)]\n\t\timpl #impl_generics ::openapi_type::OpenapiType for #ident #ty_generics #where_clause {\n\t\t\tfn schema() -\u003e ::openapi_type::OpenapiSchema {\n\t\t\t\t// this will be used by the schema code\n\t\t\t\tlet mut dependencies = ::openapi_type::private::Dependencies::new();\n\n\t\t\t\tlet mut schema = ::openapi_type::OpenapiSchema::new(#schema_code);\n\t\t\t\tschema.nullable = false;\n\t\t\t\tschema.dependencies = dependencies;\n\n\t\t\t\tconst NAME: \u0026::core::primitive::str = #name;\n\t\t\t\tschema.name = ::std::option::Option::Some(::std::string::String::from(NAME));\n\n\t\t\t\tconst DESCRIPTION: ::core::option::Option\u003c\u0026'static core::primitive::str\u003e = #doc;\n\t\t\t\tschema.description = DESCRIPTION.map(|desc| ::std::string::String::from(desc));\n\n\t\t\t\tschema\n\t\t\t}\n\t\t}\n\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","parser.rs"],"content":"use crate::{\n\tattrs::{parse_doc_attr, ContainerAttributes},\n\tserde_derive_internals::case::RenameRule,\n\tutil::ToLitStr\n};\nuse proc_macro2::Span;\nuse syn::{spanned::Spanned as _, DataEnum, DataStruct, DataUnion, Fields, FieldsNamed, LitStr, Type};\n\npub(super) enum TypeOrInline {\n\tType(Type),\n\tInline(ParseData)\n}\n\npub(super) struct ParseDataField {\n\tpub(super) name: LitStr,\n\tpub(super) doc: Vec\u003cString\u003e,\n\tpub(super) ty: TypeOrInline\n}\n\n#[allow(dead_code)]\npub(super) enum ParseData {\n\tStruct(Vec\u003cParseDataField\u003e),\n\tEnum(Vec\u003cLitStr\u003e),\n\tAlternatives(Vec\u003cParseData\u003e),\n\tUnit\n}\n\nfn parse_named_fields(named_fields: \u0026FieldsNamed, rename_all: Option\u003c\u0026LitStr\u003e) -\u003e syn::Result\u003cParseData\u003e {\n\tlet mut fields: Vec\u003cParseDataField\u003e = Vec::new();\n\tfor f in \u0026named_fields.named {\n\t\tlet mut doc = Vec::new();\n\t\tfor attr in \u0026f.attrs {\n\t\t\tif attr.path.is_ident(\"doc\") {\n\t\t\t\tif let Some(lit) = parse_doc_attr(attr)? {\n\t\t\t\t\tdoc.push(lit.value());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet ident = f\n\t\t\t.ident\n\t\t\t.as_ref()\n\t\t\t.ok_or_else(|| syn::Error::new(f.span(), \"#[derive(OpenapiType)] does not support fields without an ident\"))?;\n\t\tlet mut name = ident.to_lit_str();\n\t\tif let Some(rename_all) = rename_all {\n\t\t\tlet rule: RenameRule = rename_all\n\t\t\t\t.value()\n\t\t\t\t.parse()\n\t\t\t\t.map_err(|_| syn::Error::new(rename_all.span(), \"Unknown rename_all rule\"))?;\n\t\t\tlet rename = rule.apply_to_field(\u0026name.value());\n\t\t\tname = LitStr::new(\u0026rename, name.span());\n\t\t}\n\t\tlet ty = f.ty.to_owned();\n\t\tfields.push(ParseDataField {\n\t\t\tname,\n\t\t\tdoc,\n\t\t\tty: TypeOrInline::Type(ty)\n\t\t});\n\t}\n\tOk(ParseData::Struct(fields))\n}\n\npub(super) fn parse_struct(strukt: \u0026DataStruct, attrs: \u0026ContainerAttributes) -\u003e syn::Result\u003cParseData\u003e {\n\tmatch \u0026strukt.fields {\n\t\tFields::Named(named_fields) =\u003e parse_named_fields(named_fields, attrs.rename_all.as_ref()),\n\t\tFields::Unnamed(unnamed_fields) =\u003e Err(syn::Error::new(\n\t\t\tunnamed_fields.span(),\n\t\t\t\"#[derive(OpenapiType)] does not support tuple structs\"\n\t\t)),\n\t\tFields::Unit =\u003e Ok(ParseData::Unit)\n\t}\n}\n\npub(super) fn parse_enum(inum: \u0026DataEnum, attrs: \u0026ContainerAttributes) -\u003e syn::Result\u003cParseData\u003e {\n\tlet mut strings: Vec\u003cLitStr\u003e = Vec::new();\n\tlet mut types: Vec\u003c(LitStr, ParseData)\u003e = Vec::new();\n\n\tfor v in \u0026inum.variants {\n\t\tlet name = v.ident.to_lit_str();\n\t\tmatch \u0026v.fields {\n\t\t\tFields::Named(named_fields) =\u003e {\n\t\t\t\ttypes.push((name, parse_named_fields(named_fields, attrs.rename_all.as_ref())?));\n\t\t\t},\n\t\t\tFields::Unnamed(unnamed_fields) =\u003e {\n\t\t\t\treturn Err(syn::Error::new(\n\t\t\t\t\tunnamed_fields.span(),\n\t\t\t\t\t\"#[derive(OpenapiType)] does not support tuple variants\"\n\t\t\t\t))\n\t\t\t},\n\t\t\tFields::Unit =\u003e strings.push(name)\n\t\t}\n\t}\n\n\tlet data_strings = if strings.is_empty() {\n\t\tNone\n\t} else {\n\t\tmatch (\u0026attrs.tag, \u0026attrs.content, attrs.untagged) {\n\t\t\t// externally tagged (default)\n\t\t\t(None, None, false) =\u003e Some(ParseData::Enum(strings)),\n\t\t\t// internally tagged or adjacently tagged\n\t\t\t(Some(tag), _, false) =\u003e Some(ParseData::Struct(vec![ParseDataField {\n\t\t\t\tname: tag.clone(),\n\t\t\t\tdoc: Vec::new(),\n\t\t\t\tty: TypeOrInline::Inline(ParseData::Enum(strings))\n\t\t\t}])),\n\t\t\t// untagged\n\t\t\t(None, None, true) =\u003e Some(ParseData::Unit),\n\t\t\t// unknown\n\t\t\t_ =\u003e return Err(syn::Error::new(Span::call_site(), \"Unknown enum representation\"))\n\t\t}\n\t};\n\n\tlet data_types =\n\t\tif types.is_empty() {\n\t\t\tNone\n\t\t} else {\n\t\t\tSome(ParseData::Alternatives(\n\t\t\t\ttypes\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|(name, mut data)| {\n\t\t\t\t\t\tOk(match (\u0026attrs.tag, \u0026attrs.content, attrs.untagged) {\n\t\t\t\t\t\t\t// externally tagged (default)\n\t\t\t\t\t\t\t(None, None, false) =\u003e ParseData::Struct(vec![ParseDataField {\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\t\t\t\tty: TypeOrInline::Inline(data)\n\t\t\t\t\t\t\t}]),\n\t\t\t\t\t\t\t// internally tagged\n\t\t\t\t\t\t\t(Some(tag), None, false) =\u003e {\n\t\t\t\t\t\t\t\tmatch \u0026mut data {\n\t\t\t\t\t\t\t\t\tParseData::Struct(fields) =\u003e fields.push(ParseDataField {\n\t\t\t\t\t\t\t\t\t\tname: tag.clone(),\n\t\t\t\t\t\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\t\t\t\t\t\tty: TypeOrInline::Inline(ParseData::Enum(vec![name]))\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t_ =\u003e return Err(syn::Error::new(\n\t\t\t\t\t\t\t\t\t\ttag.span(),\n\t\t\t\t\t\t\t\t\t\t\"#[derive(OpenapiType)] does not support tuple variants on internally tagged enums\"\n\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t// adjacently tagged\n\t\t\t\t\t\t\t(Some(tag), Some(content), false) =\u003e ParseData::Struct(vec![\n\t\t\t\t\t\t\t\tParseDataField {\n\t\t\t\t\t\t\t\t\tname: tag.clone(),\n\t\t\t\t\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\t\t\t\t\tty: TypeOrInline::Inline(ParseData::Enum(vec![name]))\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tParseDataField {\n\t\t\t\t\t\t\t\t\tname: content.clone(),\n\t\t\t\t\t\t\t\t\tdoc: Vec::new(),\n\t\t\t\t\t\t\t\t\tty: TypeOrInline::Inline(data)\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t// untagged\n\t\t\t\t\t\t\t(None, None, true) =\u003e data,\n\t\t\t\t\t\t\t// unknown\n\t\t\t\t\t\t\t_ =\u003e return Err(syn::Error::new(Span::call_site(), \"Unknown enum representation\"))\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t\t.collect::\u003csyn::Result\u003cVec\u003c_\u003e\u003e\u003e()?\n\t\t\t))\n\t\t};\n\n\tmatch (data_strings, data_types) {\n\t\t// only variants without fields\n\t\t(Some(data), None) =\u003e Ok(data),\n\t\t// only one variant with fields\n\t\t(None, Some(ParseData::Alternatives(mut alt))) if alt.len() == 1 =\u003e Ok(alt.remove(0)),\n\t\t// only variants with fields\n\t\t(None, Some(data)) =\u003e Ok(data),\n\t\t// variants with and without fields\n\t\t(Some(data), Some(ParseData::Alternatives(mut alt))) =\u003e {\n\t\t\talt.push(data);\n\t\t\tOk(ParseData::Alternatives(alt))\n\t\t},\n\t\t// no variants\n\t\t(None, None) =\u003e Err(syn::Error::new(\n\t\t\tinum.brace_token.span,\n\t\t\t\"#[derive(OpenapiType)] does not support enums with no variants\"\n\t\t)),\n\t\t// data_types always produces Alternatives\n\t\t_ =\u003e unreachable!()\n\t}\n}\n\npub(super) fn parse_union(union: \u0026DataUnion) -\u003e syn::Result\u003cParseData\u003e {\n\tErr(syn::Error::new(\n\t\tunion.union_token.span(),\n\t\t\"#[derive(OpenapiType)] cannot be used on unions\"\n\t))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","serde_derive_internals","case.rs"],"content":"//! Code to convert the Rust-styled field/variant (e.g. `my_field`, `MyType`) to the\n//! case of the source (e.g. `my-field`, `MY_FIELD`).\n\n// See https://users.rust-lang.org/t/psa-dealing-with-warning-unused-import-std-ascii-asciiext-in-today-s-nightly/13726\n#[allow(deprecated, unused_imports)]\nuse std::ascii::AsciiExt;\n\nuse std::str::FromStr;\n\nuse self::RenameRule::*;\n\n/// The different possible ways to change case of fields in a struct, or variants in an enum.\n#[derive(Copy, Clone, PartialEq)]\npub enum RenameRule {\n    /// Don't apply a default rename rule.\n    None,\n    /// Rename direct children to \"lowercase\" style.\n    LowerCase,\n    /// Rename direct children to \"UPPERCASE\" style.\n    UPPERCASE,\n    /// Rename direct children to \"PascalCase\" style, as typically used for\n    /// enum variants.\n    PascalCase,\n    /// Rename direct children to \"camelCase\" style.\n    CamelCase,\n    /// Rename direct children to \"snake_case\" style, as commonly used for\n    /// fields.\n    SnakeCase,\n    /// Rename direct children to \"SCREAMING_SNAKE_CASE\" style, as commonly\n    /// used for constants.\n    ScreamingSnakeCase,\n    /// Rename direct children to \"kebab-case\" style.\n    KebabCase,\n    /// Rename direct children to \"SCREAMING-KEBAB-CASE\" style.\n    ScreamingKebabCase,\n}\n\nimpl RenameRule {\n    /// Apply a renaming rule to an enum variant, returning the version expected in the source.\n    pub fn apply_to_variant(\u0026self, variant: \u0026str) -\u003e String {\n        match *self {\n            None | PascalCase =\u003e variant.to_owned(),\n            LowerCase =\u003e variant.to_ascii_lowercase(),\n            UPPERCASE =\u003e variant.to_ascii_uppercase(),\n            CamelCase =\u003e variant[..1].to_ascii_lowercase() + \u0026variant[1..],\n            SnakeCase =\u003e {\n                let mut snake = String::new();\n                for (i, ch) in variant.char_indices() {\n                    if i \u003e 0 \u0026\u0026 ch.is_uppercase() {\n                        snake.push('_');\n                    }\n                    snake.push(ch.to_ascii_lowercase());\n                }\n                snake\n            }\n            ScreamingSnakeCase =\u003e SnakeCase.apply_to_variant(variant).to_ascii_uppercase(),\n            KebabCase =\u003e SnakeCase.apply_to_variant(variant).replace('_', \"-\"),\n            ScreamingKebabCase =\u003e ScreamingSnakeCase\n                .apply_to_variant(variant)\n                .replace('_', \"-\"),\n        }\n    }\n\n    /// Apply a renaming rule to a struct field, returning the version expected in the source.\n    pub fn apply_to_field(\u0026self, field: \u0026str) -\u003e String {\n        match *self {\n            None | LowerCase | SnakeCase =\u003e field.to_owned(),\n            UPPERCASE =\u003e field.to_ascii_uppercase(),\n            PascalCase =\u003e {\n                let mut pascal = String::new();\n                let mut capitalize = true;\n                for ch in field.chars() {\n                    if ch == '_' {\n                        capitalize = true;\n                    } else if capitalize {\n                        pascal.push(ch.to_ascii_uppercase());\n                        capitalize = false;\n                    } else {\n                        pascal.push(ch);\n                    }\n                }\n                pascal\n            }\n            CamelCase =\u003e {\n                let pascal = PascalCase.apply_to_field(field);\n                pascal[..1].to_ascii_lowercase() + \u0026pascal[1..]\n            }\n            ScreamingSnakeCase =\u003e field.to_ascii_uppercase(),\n            KebabCase =\u003e field.replace('_', \"-\"),\n            ScreamingKebabCase =\u003e ScreamingSnakeCase.apply_to_field(field).replace('_', \"-\"),\n        }\n    }\n}\n\nimpl FromStr for RenameRule {\n    type Err = ();\n\n    fn from_str(rename_all_str: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match rename_all_str {\n            \"lowercase\" =\u003e Ok(LowerCase),\n            \"UPPERCASE\" =\u003e Ok(UPPERCASE),\n            \"PascalCase\" =\u003e Ok(PascalCase),\n            \"camelCase\" =\u003e Ok(CamelCase),\n            \"snake_case\" =\u003e Ok(SnakeCase),\n            \"SCREAMING_SNAKE_CASE\" =\u003e Ok(ScreamingSnakeCase),\n            \"kebab-case\" =\u003e Ok(KebabCase),\n            \"SCREAMING-KEBAB-CASE\" =\u003e Ok(ScreamingKebabCase),\n            _ =\u003e Err(()),\n        }\n    }\n}\n\n#[test]\nfn rename_variants() {\n    for \u0026(original, lower, upper, camel, snake, screaming, kebab, screaming_kebab) in \u0026[\n        (\n            \"Outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"OUTCOME\",\n        ),\n        (\n            \"VeryTasty\",\n            \"verytasty\",\n            \"VERYTASTY\",\n            \"veryTasty\",\n            \"very_tasty\",\n            \"VERY_TASTY\",\n            \"very-tasty\",\n            \"VERY-TASTY\",\n        ),\n        (\"A\", \"a\", \"A\", \"a\", \"a\", \"A\", \"a\", \"A\"),\n        (\"Z42\", \"z42\", \"Z42\", \"z42\", \"z42\", \"Z42\", \"z42\", \"Z42\"),\n    ] {\n        assert_eq!(None.apply_to_variant(original), original);\n        assert_eq!(LowerCase.apply_to_variant(original), lower);\n        assert_eq!(UPPERCASE.apply_to_variant(original), upper);\n        assert_eq!(PascalCase.apply_to_variant(original), original);\n        assert_eq!(CamelCase.apply_to_variant(original), camel);\n        assert_eq!(SnakeCase.apply_to_variant(original), snake);\n        assert_eq!(ScreamingSnakeCase.apply_to_variant(original), screaming);\n        assert_eq!(KebabCase.apply_to_variant(original), kebab);\n        assert_eq!(\n            ScreamingKebabCase.apply_to_variant(original),\n            screaming_kebab\n        );\n    }\n}\n\n#[test]\nfn rename_fields() {\n    for \u0026(original, upper, pascal, camel, screaming, kebab, screaming_kebab) in \u0026[\n        (\n            \"outcome\", \"OUTCOME\", \"Outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"OUTCOME\",\n        ),\n        (\n            \"very_tasty\",\n            \"VERY_TASTY\",\n            \"VeryTasty\",\n            \"veryTasty\",\n            \"VERY_TASTY\",\n            \"very-tasty\",\n            \"VERY-TASTY\",\n        ),\n        (\"a\", \"A\", \"A\", \"a\", \"A\", \"a\", \"A\"),\n        (\"z42\", \"Z42\", \"Z42\", \"z42\", \"Z42\", \"z42\", \"Z42\"),\n    ] {\n        assert_eq!(None.apply_to_field(original), original);\n        assert_eq!(UPPERCASE.apply_to_field(original), upper);\n        assert_eq!(PascalCase.apply_to_field(original), pascal);\n        assert_eq!(CamelCase.apply_to_field(original), camel);\n        assert_eq!(SnakeCase.apply_to_field(original), original);\n        assert_eq!(ScreamingSnakeCase.apply_to_field(original), screaming);\n        assert_eq!(KebabCase.apply_to_field(original), kebab);\n        assert_eq!(ScreamingKebabCase.apply_to_field(original), screaming_kebab);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","serde_derive_internals","mod.rs"],"content":"#[allow(clippy::upper_case_acronyms, dead_code)]\npub(super) mod case;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","derive","src","util.rs"],"content":"use proc_macro2::Ident;\nuse syn::{Lit, LitStr};\n\n/// Convert any literal path into a [syn::Path].\nmacro_rules! path {\n\t(:: $($segment:ident)::*) =\u003e {\n\t\tpath!(@private Some(Default::default()), $($segment),*)\n\t};\n\t($($segment:ident)::*) =\u003e {\n\t\tpath!(@private None, $($segment),*)\n\t};\n\t(@private $leading_colon:expr, $($segment:ident),*) =\u003e {\n\t\t{\n\t\t\t#[allow(unused_mut)]\n\t\t\tlet mut segments: ::syn::punctuated::Punctuated\u003c::syn::PathSegment, _\u003e = Default::default();\n\t\t\t$(\n\t\t\t\tsegments.push(::syn::PathSegment {\n\t\t\t\t\tident: ::proc_macro2::Ident::new(stringify!($segment), ::proc_macro2::Span::call_site()),\n\t\t\t\t\targuments: Default::default()\n\t\t\t\t});\n\t\t\t)*\n\t\t\t::syn::Path {\n\t\t\t\tleading_colon: $leading_colon,\n\t\t\t\tsegments\n\t\t\t}\n\t\t}\n\t};\n}\n\n/// Convert any [Ident] into a [LitStr]. Basically `stringify!`.\npub(super) trait ToLitStr {\n\tfn to_lit_str(\u0026self) -\u003e LitStr;\n}\nimpl ToLitStr for Ident {\n\tfn to_lit_str(\u0026self) -\u003e LitStr {\n\t\tLitStr::new(\u0026self.to_string(), self.span())\n\t}\n}\n\n/// Convert a [Lit] to one specific literal type.\npub(crate) trait ExpectLit {\n\tfn expect_str(self) -\u003e syn::Result\u003cLitStr\u003e;\n}\n\nimpl ExpectLit for Lit {\n\tfn expect_str(self) -\u003e syn::Result\u003cLitStr\u003e {\n\t\tmatch self {\n\t\t\tSelf::Str(str) =\u003e Ok(str),\n\t\t\t_ =\u003e Err(syn::Error::new(self.span(), \"Expected string literal\"))\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","build.rs"],"content":"use std::env;\nuse std::process::Command;\nuse std::str::{self, FromStr};\n\n// The rustc-cfg strings below are *not* public API. Please let us know by\n// opening a GitHub issue if your build environment requires some way to enable\n// these cfgs other than by executing our build script.\nfn main() {\n    let minor = match rustc_minor_version() {\n        Some(minor) =\u003e minor,\n        None =\u003e return,\n    };\n\n    let target = env::var(\"TARGET\").unwrap();\n    let emscripten = target == \"asmjs-unknown-emscripten\" || target == \"wasm32-unknown-emscripten\";\n\n    // std::collections::Bound was stabilized in Rust 1.17\n    // but it was moved to core::ops later in Rust 1.26:\n    // https://doc.rust-lang.org/core/ops/enum.Bound.html\n    if minor \u003e= 26 {\n        println!(\"cargo:rustc-cfg=ops_bound\");\n    } else if minor \u003e= 17 \u0026\u0026 cfg!(feature = \"std\") {\n        println!(\"cargo:rustc-cfg=collections_bound\");\n    }\n\n    // core::cmp::Reverse stabilized in Rust 1.19:\n    // https://doc.rust-lang.org/stable/core/cmp/struct.Reverse.html\n    if minor \u003e= 19 {\n        println!(\"cargo:rustc-cfg=core_reverse\");\n    }\n\n    // CString::into_boxed_c_str stabilized in Rust 1.20:\n    // https://doc.rust-lang.org/std/ffi/struct.CString.html#method.into_boxed_c_str\n    if minor \u003e= 20 {\n        println!(\"cargo:rustc-cfg=de_boxed_c_str\");\n    }\n\n    // From\u003cBox\u003cT\u003e\u003e for Rc\u003cT\u003e / Arc\u003cT\u003e stabilized in Rust 1.21:\n    // https://doc.rust-lang.org/std/rc/struct.Rc.html#impl-From\u003cBox\u003cT\u003e\u003e\n    // https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-From\u003cBox\u003cT\u003e\u003e\n    if minor \u003e= 21 {\n        println!(\"cargo:rustc-cfg=de_rc_dst\");\n    }\n\n    // Duration available in core since Rust 1.25:\n    // https://blog.rust-lang.org/2018/03/29/Rust-1.25.html#library-stabilizations\n    if minor \u003e= 25 {\n        println!(\"cargo:rustc-cfg=core_duration\");\n    }\n\n    // 128-bit integers stabilized in Rust 1.26:\n    // https://blog.rust-lang.org/2018/05/10/Rust-1.26.html\n    //\n    // Disabled on Emscripten targets as Emscripten doesn't\n    // currently support integers larger than 64 bits.\n    if minor \u003e= 26 \u0026\u0026 !emscripten {\n        println!(\"cargo:rustc-cfg=integer128\");\n    }\n\n    // Inclusive ranges methods stabilized in Rust 1.27:\n    // https://github.com/rust-lang/rust/pull/50758\n    if minor \u003e= 27 {\n        println!(\"cargo:rustc-cfg=range_inclusive\");\n    }\n\n    // Non-zero integers stabilized in Rust 1.28:\n    // https://github.com/rust-lang/rust/pull/50808\n    if minor \u003e= 28 {\n        println!(\"cargo:rustc-cfg=num_nonzero\");\n    }\n\n    // TryFrom, Atomic types, and non-zero signed integers stabilized in Rust 1.34:\n    // https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#tryfrom-and-tryinto\n    // https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#library-stabilizations\n    if minor \u003e= 34 {\n        println!(\"cargo:rustc-cfg=core_try_from\");\n        println!(\"cargo:rustc-cfg=num_nonzero_signed\");\n\n        // Whitelist of archs that support std::sync::atomic module. Ideally we\n        // would use #[cfg(target_has_atomic = \"...\")] but it is not stable yet.\n        // Instead this is based on rustc's src/librustc_target/spec/*.rs.\n        let has_atomic64 = target.starts_with(\"x86_64\")\n            || target.starts_with(\"i686\")\n            || target.starts_with(\"aarch64\")\n            || target.starts_with(\"powerpc64\")\n            || target.starts_with(\"sparc64\")\n            || target.starts_with(\"mips64el\");\n        let has_atomic32 = has_atomic64 || emscripten;\n        if has_atomic64 {\n            println!(\"cargo:rustc-cfg=std_atomic64\");\n        }\n        if has_atomic32 {\n            println!(\"cargo:rustc-cfg=std_atomic\");\n        }\n    }\n}\n\nfn rustc_minor_version() -\u003e Option\u003cu32\u003e {\n    let rustc = match env::var_os(\"RUSTC\") {\n        Some(rustc) =\u003e rustc,\n        None =\u003e return None,\n    };\n\n    let output = match Command::new(rustc).arg(\"--version\").output() {\n        Ok(output) =\u003e output,\n        Err(_) =\u003e return None,\n    };\n\n    let version = match str::from_utf8(\u0026output.stdout) {\n        Ok(version) =\u003e version,\n        Err(_) =\u003e return None,\n    };\n\n    let mut pieces = version.split('.');\n    if pieces.next() != Some(\"rustc 1\") {\n        return None;\n    }\n\n    let next = match pieces.next() {\n        Some(next) =\u003e next,\n        None =\u003e return None,\n    };\n\n    u32::from_str(next).ok()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","from_primitive.rs"],"content":"use lib::*;\n\nmacro_rules! int_to_int {\n    ($dst:ident, $n:ident) =\u003e {\n        if $dst::min_value() as i64 \u003c= $n as i64 \u0026\u0026 $n as i64 \u003c= $dst::max_value() as i64 {\n            Some($n as $dst)\n        } else {\n            None\n        }\n    };\n}\n\nmacro_rules! int_to_uint {\n    ($dst:ident, $n:ident) =\u003e {\n        if 0 \u003c= $n \u0026\u0026 $n as u64 \u003c= $dst::max_value() as u64 {\n            Some($n as $dst)\n        } else {\n            None\n        }\n    };\n}\n\nmacro_rules! uint_to {\n    ($dst:ident, $n:ident) =\u003e {\n        if $n as u64 \u003c= $dst::max_value() as u64 {\n            Some($n as $dst)\n        } else {\n            None\n        }\n    };\n}\n\npub trait FromPrimitive: Sized {\n    fn from_i8(n: i8) -\u003e Option\u003cSelf\u003e;\n    fn from_i16(n: i16) -\u003e Option\u003cSelf\u003e;\n    fn from_i32(n: i32) -\u003e Option\u003cSelf\u003e;\n    fn from_i64(n: i64) -\u003e Option\u003cSelf\u003e;\n    fn from_u8(n: u8) -\u003e Option\u003cSelf\u003e;\n    fn from_u16(n: u16) -\u003e Option\u003cSelf\u003e;\n    fn from_u32(n: u32) -\u003e Option\u003cSelf\u003e;\n    fn from_u64(n: u64) -\u003e Option\u003cSelf\u003e;\n}\n\nmacro_rules! impl_from_primitive_for_int {\n    ($t:ident) =\u003e {\n        impl FromPrimitive for $t {\n            #[inline]\n            fn from_i8(n: i8) -\u003e Option\u003cSelf\u003e {\n                int_to_int!($t, n)\n            }\n            #[inline]\n            fn from_i16(n: i16) -\u003e Option\u003cSelf\u003e {\n                int_to_int!($t, n)\n            }\n            #[inline]\n            fn from_i32(n: i32) -\u003e Option\u003cSelf\u003e {\n                int_to_int!($t, n)\n            }\n            #[inline]\n            fn from_i64(n: i64) -\u003e Option\u003cSelf\u003e {\n                int_to_int!($t, n)\n            }\n            #[inline]\n            fn from_u8(n: u8) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u16(n: u16) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u32(n: u32) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u64(n: u64) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n        }\n    };\n}\n\nmacro_rules! impl_from_primitive_for_uint {\n    ($t:ident) =\u003e {\n        impl FromPrimitive for $t {\n            #[inline]\n            fn from_i8(n: i8) -\u003e Option\u003cSelf\u003e {\n                int_to_uint!($t, n)\n            }\n            #[inline]\n            fn from_i16(n: i16) -\u003e Option\u003cSelf\u003e {\n                int_to_uint!($t, n)\n            }\n            #[inline]\n            fn from_i32(n: i32) -\u003e Option\u003cSelf\u003e {\n                int_to_uint!($t, n)\n            }\n            #[inline]\n            fn from_i64(n: i64) -\u003e Option\u003cSelf\u003e {\n                int_to_uint!($t, n)\n            }\n            #[inline]\n            fn from_u8(n: u8) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u16(n: u16) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u32(n: u32) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n            #[inline]\n            fn from_u64(n: u64) -\u003e Option\u003cSelf\u003e {\n                uint_to!($t, n)\n            }\n        }\n    };\n}\n\nmacro_rules! impl_from_primitive_for_float {\n    ($t:ident) =\u003e {\n        impl FromPrimitive for $t {\n            #[inline]\n            fn from_i8(n: i8) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_i16(n: i16) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_i32(n: i32) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_i64(n: i64) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_u8(n: u8) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_u16(n: u16) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_u32(n: u32) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n            #[inline]\n            fn from_u64(n: u64) -\u003e Option\u003cSelf\u003e {\n                Some(n as Self)\n            }\n        }\n    };\n}\n\nimpl_from_primitive_for_int!(isize);\nimpl_from_primitive_for_int!(i8);\nimpl_from_primitive_for_int!(i16);\nimpl_from_primitive_for_int!(i32);\nimpl_from_primitive_for_int!(i64);\nimpl_from_primitive_for_uint!(usize);\nimpl_from_primitive_for_uint!(u8);\nimpl_from_primitive_for_uint!(u16);\nimpl_from_primitive_for_uint!(u32);\nimpl_from_primitive_for_uint!(u64);\nimpl_from_primitive_for_float!(f32);\nimpl_from_primitive_for_float!(f64);\n\nserde_if_integer128! {\n    impl FromPrimitive for i128 {\n        #[inline]\n        fn from_i8(n: i8) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_i16(n: i16) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_i32(n: i32) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_i64(n: i64) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_u8(n: u8) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_u16(n: u16) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_u32(n: u32) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n        #[inline]\n        fn from_u64(n: u64) -\u003e Option\u003cSelf\u003e {\n            Some(n as i128)\n        }\n    }\n\n    impl FromPrimitive for u128 {\n        #[inline]\n        fn from_i8(n: i8) -\u003e Option\u003cSelf\u003e {\n            if n \u003e= 0 {\n                Some(n as u128)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn from_i16(n: i16) -\u003e Option\u003cSelf\u003e {\n            if n \u003e= 0 {\n                Some(n as u128)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn from_i32(n: i32) -\u003e Option\u003cSelf\u003e {\n            if n \u003e= 0 {\n                Some(n as u128)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn from_i64(n: i64) -\u003e Option\u003cSelf\u003e {\n            if n \u003e= 0 {\n                Some(n as u128)\n            } else {\n                None\n            }\n        }\n        #[inline]\n        fn from_u8(n: u8) -\u003e Option\u003cSelf\u003e {\n            Some(n as u128)\n        }\n        #[inline]\n        fn from_u16(n: u16) -\u003e Option\u003cSelf\u003e {\n            Some(n as u128)\n        }\n        #[inline]\n        fn from_u32(n: u32) -\u003e Option\u003cSelf\u003e {\n            Some(n as u128)\n        }\n        #[inline]\n        fn from_u64(n: u64) -\u003e Option\u003cSelf\u003e {\n            Some(n as u128)\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","ignored_any.rs"],"content":"use lib::*;\n\nuse de::{\n    Deserialize, Deserializer, EnumAccess, Error, MapAccess, SeqAccess, VariantAccess, Visitor,\n};\n\n/// An efficient way of discarding data from a deserializer.\n///\n/// Think of this like `serde_json::Value` in that it can be deserialized from\n/// any type, except that it does not store any information about the data that\n/// gets deserialized.\n///\n/// ```edition2018\n/// use std::fmt;\n/// use std::marker::PhantomData;\n///\n/// use serde::de::{\n///     self, Deserialize, DeserializeSeed, Deserializer, IgnoredAny, SeqAccess, Visitor,\n/// };\n///\n/// /// A seed that can be used to deserialize only the `n`th element of a sequence\n/// /// while efficiently discarding elements of any type before or after index `n`.\n/// ///\n/// /// For example to deserialize only the element at index 3:\n/// ///\n/// /// ```\n/// /// NthElement::new(3).deserialize(deserializer)\n/// /// ```\n/// pub struct NthElement\u003cT\u003e {\n///     n: usize,\n///     marker: PhantomData\u003cT\u003e,\n/// }\n///\n/// impl\u003cT\u003e NthElement\u003cT\u003e {\n///     pub fn new(n: usize) -\u003e Self {\n///         NthElement {\n///             n: n,\n///             marker: PhantomData,\n///         }\n///     }\n/// }\n///\n/// impl\u003c'de, T\u003e Visitor\u003c'de\u003e for NthElement\u003cT\u003e\n/// where\n///     T: Deserialize\u003c'de\u003e,\n/// {\n///     type Value = T;\n///\n///     fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n///         write!(\n///             formatter,\n///             \"a sequence in which we care about element {}\",\n///             self.n\n///         )\n///     }\n///\n///     fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n///     where\n///         A: SeqAccess\u003c'de\u003e,\n///     {\n///         // Skip over the first `n` elements.\n///         for i in 0..self.n {\n///             // It is an error if the sequence ends before we get to element `n`.\n///             if seq.next_element::\u003cIgnoredAny\u003e()?.is_none() {\n///                 return Err(de::Error::invalid_length(i, \u0026self));\n///             }\n///         }\n///\n///         // Deserialize the one we care about.\n///         let nth = match seq.next_element()? {\n///             Some(nth) =\u003e nth,\n///             None =\u003e {\n///                 return Err(de::Error::invalid_length(self.n, \u0026self));\n///             }\n///         };\n///\n///         // Skip over any remaining elements in the sequence after `n`.\n///         while let Some(IgnoredAny) = seq.next_element()? {\n///             // ignore\n///         }\n///\n///         Ok(nth)\n///     }\n/// }\n///\n/// impl\u003c'de, T\u003e DeserializeSeed\u003c'de\u003e for NthElement\u003cT\u003e\n/// where\n///     T: Deserialize\u003c'de\u003e,\n/// {\n///     type Value = T;\n///\n///     fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n///     where\n///         D: Deserializer\u003c'de\u003e,\n///     {\n///         deserializer.deserialize_seq(self)\n///     }\n/// }\n///\n/// # fn example\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003c(), D::Error\u003e\n/// # where\n/// #     D: Deserializer\u003c'de\u003e,\n/// # {\n/// // Deserialize only the sequence element at index 3 from this deserializer.\n/// // The element at index 3 is required to be a string. Elements before and\n/// // after index 3 are allowed to be of any type.\n/// let s: String = NthElement::new(3).deserialize(deserializer)?;\n/// #     Ok(())\n/// # }\n/// ```\n#[derive(Copy, Clone, Debug, Default)]\npub struct IgnoredAny;\n\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for IgnoredAny {\n    type Value = IgnoredAny;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"anything at all\")\n    }\n\n    #[inline]\n    fn visit_bool\u003cE\u003e(self, x: bool) -\u003e Result\u003cSelf::Value, E\u003e {\n        let _ = x;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_i64\u003cE\u003e(self, x: i64) -\u003e Result\u003cSelf::Value, E\u003e {\n        let _ = x;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_u64\u003cE\u003e(self, x: u64) -\u003e Result\u003cSelf::Value, E\u003e {\n        let _ = x;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_f64\u003cE\u003e(self, x: f64) -\u003e Result\u003cSelf::Value, E\u003e {\n        let _ = x;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_str\u003cE\u003e(self, s: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        let _ = s;\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_none\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e {\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        IgnoredAny::deserialize(deserializer)\n    }\n\n    #[inline]\n    fn visit_newtype_struct\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        IgnoredAny::deserialize(deserializer)\n    }\n\n    #[inline]\n    fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e {\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: SeqAccess\u003c'de\u003e,\n    {\n        while let Some(IgnoredAny) = try!(seq.next_element()) {\n            // Gobble\n        }\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_map\u003cA\u003e(self, mut map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: MapAccess\u003c'de\u003e,\n    {\n        while let Some((IgnoredAny, IgnoredAny)) = try!(map.next_entry()) {\n            // Gobble\n        }\n        Ok(IgnoredAny)\n    }\n\n    #[inline]\n    fn visit_bytes\u003cE\u003e(self, bytes: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        let _ = bytes;\n        Ok(IgnoredAny)\n    }\n\n    fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: EnumAccess\u003c'de\u003e,\n    {\n        data.variant::\u003cIgnoredAny\u003e()?.1.newtype_variant()\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for IgnoredAny {\n    #[inline]\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cIgnoredAny, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_ignored_any(IgnoredAny)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","impls.rs"],"content":"use lib::*;\n\nuse de::{\n    Deserialize, Deserializer, EnumAccess, Error, SeqAccess, Unexpected, VariantAccess, Visitor,\n};\n\n#[cfg(any(core_duration, feature = \"std\", feature = \"alloc\"))]\nuse de::MapAccess;\n\nuse de::from_primitive::FromPrimitive;\nuse private::de::InPlaceSeed;\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse private::de::size_hint;\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct UnitVisitor;\n\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for UnitVisitor {\n    type Value = ();\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"unit\")\n    }\n\n    fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(())\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for () {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_unit(UnitVisitor)\n    }\n}\n\n#[cfg(feature = \"unstable\")]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for ! {\n    fn deserialize\u003cD\u003e(_deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Err(Error::custom(\"cannot deserialize `!`\"))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct BoolVisitor;\n\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for BoolVisitor {\n    type Value = bool;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a boolean\")\n    }\n\n    fn visit_bool\u003cE\u003e(self, v: bool) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for bool {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_bool(BoolVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! visit_integer_method {\n    ($src_ty:ident, $method:ident, $from_method:ident, $group:ident, $group_ty:ident) =\u003e {\n        #[inline]\n        fn $method\u003cE\u003e(self, v: $src_ty) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            match FromPrimitive::$from_method(v) {\n                Some(v) =\u003e Ok(v),\n                None =\u003e Err(Error::invalid_value(Unexpected::$group(v as $group_ty), \u0026self)),\n            }\n        }\n    }\n}\n\nmacro_rules! visit_float_method {\n    ($src_ty:ident, $method:ident) =\u003e {\n        #[inline]\n        fn $method\u003cE\u003e(self, v: $src_ty) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(v as Self::Value)\n        }\n    }\n}\n\nmacro_rules! impl_deserialize_num {\n    ($ty:ident, $method:ident, $($visit:ident),*) =\u003e {\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for $ty {\n            #[inline]\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct PrimitiveVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for PrimitiveVisitor {\n                    type Value = $ty;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(stringify!($ty))\n                    }\n\n                    $(\n                        impl_deserialize_num!($visit $ty);\n                    )*\n                }\n\n                deserializer.$method(PrimitiveVisitor)\n            }\n        }\n    };\n\n    (integer $ty:ident) =\u003e {\n        visit_integer_method!(i8, visit_i8, from_i8, Signed, i64);\n        visit_integer_method!(i16, visit_i16, from_i16, Signed, i64);\n        visit_integer_method!(i32, visit_i32, from_i32, Signed, i64);\n        visit_integer_method!(i64, visit_i64, from_i64, Signed, i64);\n\n        visit_integer_method!(u8, visit_u8, from_u8, Unsigned, u64);\n        visit_integer_method!(u16, visit_u16, from_u16, Unsigned, u64);\n        visit_integer_method!(u32, visit_u32, from_u32, Unsigned, u64);\n        visit_integer_method!(u64, visit_u64, from_u64, Unsigned, u64);\n    };\n\n    (float $ty:ident) =\u003e {\n        visit_float_method!(f32, visit_f32);\n        visit_float_method!(f64, visit_f64);\n    };\n}\n\nimpl_deserialize_num!(i8, deserialize_i8, integer);\nimpl_deserialize_num!(i16, deserialize_i16, integer);\nimpl_deserialize_num!(i32, deserialize_i32, integer);\nimpl_deserialize_num!(i64, deserialize_i64, integer);\nimpl_deserialize_num!(isize, deserialize_i64, integer);\n\nimpl_deserialize_num!(u8, deserialize_u8, integer);\nimpl_deserialize_num!(u16, deserialize_u16, integer);\nimpl_deserialize_num!(u32, deserialize_u32, integer);\nimpl_deserialize_num!(u64, deserialize_u64, integer);\nimpl_deserialize_num!(usize, deserialize_u64, integer);\n\nimpl_deserialize_num!(f32, deserialize_f32, integer, float);\nimpl_deserialize_num!(f64, deserialize_f64, integer, float);\n\nserde_if_integer128! {\n    impl\u003c'de\u003e Deserialize\u003c'de\u003e for i128 {\n        #[inline]\n        fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            struct PrimitiveVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for PrimitiveVisitor {\n                type Value = i128;\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(\"i128\")\n                }\n\n                impl_deserialize_num!(integer i128);\n\n                #[inline]\n                fn visit_i128\u003cE\u003e(self, v: i128) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    Ok(v)\n                }\n\n                #[inline]\n                fn visit_u128\u003cE\u003e(self, v: u128) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    if v \u003c= i128::max_value() as u128 {\n                        Ok(v as i128)\n                    } else {\n                        Err(Error::invalid_value(Unexpected::Other(\"u128\"), \u0026self))\n                    }\n                }\n            }\n\n            deserializer.deserialize_i128(PrimitiveVisitor)\n        }\n    }\n\n    impl\u003c'de\u003e Deserialize\u003c'de\u003e for u128 {\n        #[inline]\n        fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            struct PrimitiveVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for PrimitiveVisitor {\n                type Value = u128;\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(\"u128\")\n                }\n\n                impl_deserialize_num!(integer u128);\n\n                #[inline]\n                fn visit_i128\u003cE\u003e(self, v: i128) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    if v \u003e= 0 {\n                        Ok(v as u128)\n                    } else {\n                        Err(Error::invalid_value(Unexpected::Other(\"i128\"), \u0026self))\n                    }\n                }\n\n                #[inline]\n                fn visit_u128\u003cE\u003e(self, v: u128) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    Ok(v)\n                }\n            }\n\n            deserializer.deserialize_u128(PrimitiveVisitor)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct CharVisitor;\n\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for CharVisitor {\n    type Value = char;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a character\")\n    }\n\n    #[inline]\n    fn visit_char\u003cE\u003e(self, v: char) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    #[inline]\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        let mut iter = v.chars();\n        match (iter.next(), iter.next()) {\n            (Some(c), None) =\u003e Ok(c),\n            _ =\u003e Err(Error::invalid_value(Unexpected::Str(v), \u0026self)),\n        }\n    }\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for char {\n    #[inline]\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_char(CharVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nstruct StringVisitor;\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nstruct StringInPlaceVisitor\u003c'a\u003e(\u0026'a mut String);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for StringVisitor {\n    type Value = String;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a string\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v.to_owned())\n    }\n\n    fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        match str::from_utf8(v) {\n            Ok(s) =\u003e Ok(s.to_owned()),\n            Err(_) =\u003e Err(Error::invalid_value(Unexpected::Bytes(v), \u0026self)),\n        }\n    }\n\n    fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        match String::from_utf8(v) {\n            Ok(s) =\u003e Ok(s),\n            Err(e) =\u003e Err(Error::invalid_value(\n                Unexpected::Bytes(\u0026e.into_bytes()),\n                \u0026self,\n            )),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de\u003e Visitor\u003c'de\u003e for StringInPlaceVisitor\u003c'a\u003e {\n    type Value = ();\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a string\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.0.clear();\n        self.0.push_str(v);\n        Ok(())\n    }\n\n    fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        *self.0 = v;\n        Ok(())\n    }\n\n    fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        match str::from_utf8(v) {\n            Ok(s) =\u003e {\n                self.0.clear();\n                self.0.push_str(s);\n                Ok(())\n            }\n            Err(_) =\u003e Err(Error::invalid_value(Unexpected::Bytes(v), \u0026self)),\n        }\n    }\n\n    fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        match String::from_utf8(v) {\n            Ok(s) =\u003e {\n                *self.0 = s;\n                Ok(())\n            }\n            Err(e) =\u003e Err(Error::invalid_value(\n                Unexpected::Bytes(\u0026e.into_bytes()),\n                \u0026self,\n            )),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for String {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_string(StringVisitor)\n    }\n\n    fn deserialize_in_place\u003cD\u003e(deserializer: D, place: \u0026mut Self) -\u003e Result\u003c(), D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_string(StringInPlaceVisitor(place))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct StrVisitor;\n\nimpl\u003c'a\u003e Visitor\u003c'a\u003e for StrVisitor {\n    type Value = \u0026'a str;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a borrowed string\")\n    }\n\n    fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'a str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v) // so easy\n    }\n\n    fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'a [u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        str::from_utf8(v).map_err(|_| Error::invalid_value(Unexpected::Bytes(v), \u0026self))\n    }\n}\n\nimpl\u003c'de: 'a, 'a\u003e Deserialize\u003c'de\u003e for \u0026'a str {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(StrVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct BytesVisitor;\n\nimpl\u003c'a\u003e Visitor\u003c'a\u003e for BytesVisitor {\n    type Value = \u0026'a [u8];\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a borrowed byte array\")\n    }\n\n    fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'a [u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'a str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v.as_bytes())\n    }\n}\n\nimpl\u003c'de: 'a, 'a\u003e Deserialize\u003c'de\u003e for \u0026'a [u8] {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_bytes(BytesVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nstruct CStringVisitor;\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for CStringVisitor {\n    type Value = CString;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"byte array\")\n    }\n\n    fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: SeqAccess\u003c'de\u003e,\n    {\n        let len = size_hint::cautious(seq.size_hint());\n        let mut values = Vec::with_capacity(len);\n\n        while let Some(value) = try!(seq.next_element()) {\n            values.push(value);\n        }\n\n        CString::new(values).map_err(Error::custom)\n    }\n\n    fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n\n    fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n\n    fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for CString {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_byte_buf(CStringVisitor)\n    }\n}\n\nmacro_rules! forwarded_impl {\n    (\n        $(#[doc = $doc:tt])*\n        ( $($id: ident),* ), $ty: ty, $func: expr\n    ) =\u003e {\n        $(#[doc = $doc])*\n        impl\u003c'de $(, $id : Deserialize\u003c'de\u003e,)*\u003e Deserialize\u003c'de\u003e for $ty {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                Deserialize::deserialize(deserializer).map($func)\n            }\n        }\n    }\n}\n\n#[cfg(all(feature = \"std\", de_boxed_c_str))]\nforwarded_impl!((), Box\u003cCStr\u003e, CString::into_boxed_c_str);\n\n#[cfg(core_reverse)]\nforwarded_impl!((T), Reverse\u003cT\u003e, Reverse);\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct OptionVisitor\u003cT\u003e {\n    marker: PhantomData\u003cT\u003e,\n}\n\nimpl\u003c'de, T\u003e Visitor\u003c'de\u003e for OptionVisitor\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    type Value = Option\u003cT\u003e;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"option\")\n    }\n\n    #[inline]\n    fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(None)\n    }\n\n    #[inline]\n    fn visit_none\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(None)\n    }\n\n    #[inline]\n    fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(deserializer).map(Some)\n    }\n\n    #[doc(hidden)]\n    fn __private_visit_untagged_option\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, ()\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Ok(T::deserialize(deserializer).ok())\n    }\n}\n\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Option\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_option(OptionVisitor {\n            marker: PhantomData,\n        })\n    }\n\n    // The Some variant's repr is opaque, so we can't play cute tricks with its\n    // tag to have deserialize_in_place build the content in place unconditionally.\n    //\n    // FIXME: investigate whether branching on the old value being Some to\n    // deserialize_in_place the value is profitable (probably data-dependent?)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct PhantomDataVisitor\u003cT: ?Sized\u003e {\n    marker: PhantomData\u003cT\u003e,\n}\n\nimpl\u003c'de, T: ?Sized\u003e Visitor\u003c'de\u003e for PhantomDataVisitor\u003cT\u003e {\n    type Value = PhantomData\u003cT\u003e;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"unit\")\n    }\n\n    #[inline]\n    fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(PhantomData)\n    }\n}\n\nimpl\u003c'de, T: ?Sized\u003e Deserialize\u003c'de\u003e for PhantomData\u003cT\u003e {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let visitor = PhantomDataVisitor {\n            marker: PhantomData,\n        };\n        deserializer.deserialize_unit_struct(\"PhantomData\", visitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! seq_impl {\n    (\n        $ty:ident \u003c T $(: $tbound1:ident $(+ $tbound2:ident)*)* $(, $typaram:ident : $bound1:ident $(+ $bound2:ident)*)* \u003e,\n        $access:ident,\n        $clear:expr,\n        $with_capacity:expr,\n        $reserve:expr,\n        $insert:expr\n    ) =\u003e {\n        impl\u003c'de, T $(, $typaram)*\u003e Deserialize\u003c'de\u003e for $ty\u003cT $(, $typaram)*\u003e\n        where\n            T: Deserialize\u003c'de\u003e $(+ $tbound1 $(+ $tbound2)*)*,\n            $($typaram: $bound1 $(+ $bound2)*,)*\n        {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct SeqVisitor\u003cT $(, $typaram)*\u003e {\n                    marker: PhantomData\u003c$ty\u003cT $(, $typaram)*\u003e\u003e,\n                }\n\n                impl\u003c'de, T $(, $typaram)*\u003e Visitor\u003c'de\u003e for SeqVisitor\u003cT $(, $typaram)*\u003e\n                where\n                    T: Deserialize\u003c'de\u003e $(+ $tbound1 $(+ $tbound2)*)*,\n                    $($typaram: $bound1 $(+ $bound2)*,)*\n                {\n                    type Value = $ty\u003cT $(, $typaram)*\u003e;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"a sequence\")\n                    }\n\n                    #[inline]\n                    fn visit_seq\u003cA\u003e(self, mut $access: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                    where\n                        A: SeqAccess\u003c'de\u003e,\n                    {\n                        let mut values = $with_capacity;\n\n                        while let Some(value) = try!($access.next_element()) {\n                            $insert(\u0026mut values, value);\n                        }\n\n                        Ok(values)\n                    }\n                }\n\n                let visitor = SeqVisitor { marker: PhantomData };\n                deserializer.deserialize_seq(visitor)\n            }\n\n            fn deserialize_in_place\u003cD\u003e(deserializer: D, place: \u0026mut Self) -\u003e Result\u003c(), D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct SeqInPlaceVisitor\u003c'a, T: 'a $(, $typaram: 'a)*\u003e(\u0026'a mut $ty\u003cT $(, $typaram)*\u003e);\n\n                impl\u003c'a, 'de, T $(, $typaram)*\u003e Visitor\u003c'de\u003e for SeqInPlaceVisitor\u003c'a, T $(, $typaram)*\u003e\n                where\n                    T: Deserialize\u003c'de\u003e $(+ $tbound1 $(+ $tbound2)*)*,\n                    $($typaram: $bound1 $(+ $bound2)*,)*\n                {\n                    type Value = ();\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"a sequence\")\n                    }\n\n                    #[inline]\n                    fn visit_seq\u003cA\u003e(mut self, mut $access: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                    where\n                        A: SeqAccess\u003c'de\u003e,\n                    {\n                        $clear(\u0026mut self.0);\n                        $reserve(\u0026mut self.0, size_hint::cautious($access.size_hint()));\n\n                        // FIXME: try to overwrite old values here? (Vec, VecDeque, LinkedList)\n                        while let Some(value) = try!($access.next_element()) {\n                            $insert(\u0026mut self.0, value);\n                        }\n\n                        Ok(())\n                    }\n                }\n\n                deserializer.deserialize_seq(SeqInPlaceVisitor(place))\n            }\n        }\n    }\n}\n\n// Dummy impl of reserve\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nfn nop_reserve\u003cT\u003e(_seq: T, _n: usize) {}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(\n    BinaryHeap\u003cT: Ord\u003e,\n    seq,\n    BinaryHeap::clear,\n    BinaryHeap::with_capacity(size_hint::cautious(seq.size_hint())),\n    BinaryHeap::reserve,\n    BinaryHeap::push\n);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(\n    BTreeSet\u003cT: Eq + Ord\u003e,\n    seq,\n    BTreeSet::clear,\n    BTreeSet::new(),\n    nop_reserve,\n    BTreeSet::insert\n);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(\n    LinkedList\u003cT\u003e,\n    seq,\n    LinkedList::clear,\n    LinkedList::new(),\n    nop_reserve,\n    LinkedList::push_back\n);\n\n#[cfg(feature = \"std\")]\nseq_impl!(\n    HashSet\u003cT: Eq + Hash, S: BuildHasher + Default\u003e,\n    seq,\n    HashSet::clear,\n    HashSet::with_capacity_and_hasher(size_hint::cautious(seq.size_hint()), S::default()),\n    HashSet::reserve,\n    HashSet::insert);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(\n    VecDeque\u003cT\u003e,\n    seq,\n    VecDeque::clear,\n    VecDeque::with_capacity(size_hint::cautious(seq.size_hint())),\n    VecDeque::reserve,\n    VecDeque::push_back\n);\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Vec\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        struct VecVisitor\u003cT\u003e {\n            marker: PhantomData\u003cT\u003e,\n        }\n\n        impl\u003c'de, T\u003e Visitor\u003c'de\u003e for VecVisitor\u003cT\u003e\n        where\n            T: Deserialize\u003c'de\u003e,\n        {\n            type Value = Vec\u003cT\u003e;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"a sequence\")\n            }\n\n            fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: SeqAccess\u003c'de\u003e,\n            {\n                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));\n\n                while let Some(value) = try!(seq.next_element()) {\n                    values.push(value);\n                }\n\n                Ok(values)\n            }\n        }\n\n        let visitor = VecVisitor {\n            marker: PhantomData,\n        };\n        deserializer.deserialize_seq(visitor)\n    }\n\n    fn deserialize_in_place\u003cD\u003e(deserializer: D, place: \u0026mut Self) -\u003e Result\u003c(), D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        struct VecInPlaceVisitor\u003c'a, T: 'a\u003e(\u0026'a mut Vec\u003cT\u003e);\n\n        impl\u003c'a, 'de, T\u003e Visitor\u003c'de\u003e for VecInPlaceVisitor\u003c'a, T\u003e\n        where\n            T: Deserialize\u003c'de\u003e,\n        {\n            type Value = ();\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"a sequence\")\n            }\n\n            fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: SeqAccess\u003c'de\u003e,\n            {\n                let hint = size_hint::cautious(seq.size_hint());\n                if let Some(additional) = hint.checked_sub(self.0.len()) {\n                    self.0.reserve(additional);\n                }\n\n                for i in 0..self.0.len() {\n                    let next = {\n                        let next_place = InPlaceSeed(\u0026mut self.0[i]);\n                        try!(seq.next_element_seed(next_place))\n                    };\n                    if next.is_none() {\n                        self.0.truncate(i);\n                        return Ok(());\n                    }\n                }\n\n                while let Some(value) = try!(seq.next_element()) {\n                    self.0.push(value);\n                }\n\n                Ok(())\n            }\n        }\n\n        deserializer.deserialize_seq(VecInPlaceVisitor(place))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct ArrayVisitor\u003cA\u003e {\n    marker: PhantomData\u003cA\u003e,\n}\nstruct ArrayInPlaceVisitor\u003c'a, A: 'a\u003e(\u0026'a mut A);\n\nimpl\u003cA\u003e ArrayVisitor\u003cA\u003e {\n    fn new() -\u003e Self {\n        ArrayVisitor {\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, T\u003e Visitor\u003c'de\u003e for ArrayVisitor\u003c[T; 0]\u003e {\n    type Value = [T; 0];\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"an empty array\")\n    }\n\n    #[inline]\n    fn visit_seq\u003cA\u003e(self, _: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: SeqAccess\u003c'de\u003e,\n    {\n        Ok([])\n    }\n}\n\n// Does not require T: Deserialize\u003c'de\u003e.\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for [T; 0] {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_tuple(0, ArrayVisitor::\u003c[T; 0]\u003e::new())\n    }\n}\n\nmacro_rules! array_impls {\n    ($($len:expr =\u003e ($($n:tt)+))+) =\u003e {\n        $(\n            impl\u003c'de, T\u003e Visitor\u003c'de\u003e for ArrayVisitor\u003c[T; $len]\u003e\n            where\n                T: Deserialize\u003c'de\u003e,\n            {\n                type Value = [T; $len];\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(concat!(\"an array of length \", $len))\n                }\n\n                #[inline]\n                fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                where\n                    A: SeqAccess\u003c'de\u003e,\n                {\n                    Ok([$(\n                        match try!(seq.next_element()) {\n                            Some(val) =\u003e val,\n                            None =\u003e return Err(Error::invalid_length($n, \u0026self)),\n                        }\n                    ),+])\n                }\n            }\n\n            impl\u003c'a, 'de, T\u003e Visitor\u003c'de\u003e for ArrayInPlaceVisitor\u003c'a, [T; $len]\u003e\n            where\n                T: Deserialize\u003c'de\u003e,\n            {\n                type Value = ();\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(concat!(\"an array of length \", $len))\n                }\n\n                #[inline]\n                fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                where\n                    A: SeqAccess\u003c'de\u003e,\n                {\n                    let mut fail_idx = None;\n                    for (idx, dest) in self.0[..].iter_mut().enumerate() {\n                        if try!(seq.next_element_seed(InPlaceSeed(dest))).is_none() {\n                            fail_idx = Some(idx);\n                            break;\n                        }\n                    }\n                    if let Some(idx) = fail_idx {\n                        return Err(Error::invalid_length(idx, \u0026self));\n                    }\n                    Ok(())\n                }\n            }\n\n            impl\u003c'de, T\u003e Deserialize\u003c'de\u003e for [T; $len]\n            where\n                T: Deserialize\u003c'de\u003e,\n            {\n                fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n                where\n                    D: Deserializer\u003c'de\u003e,\n                {\n                    deserializer.deserialize_tuple($len, ArrayVisitor::\u003c[T; $len]\u003e::new())\n                }\n\n                fn deserialize_in_place\u003cD\u003e(deserializer: D, place: \u0026mut Self) -\u003e Result\u003c(), D::Error\u003e\n                where\n                    D: Deserializer\u003c'de\u003e,\n                {\n                    deserializer.deserialize_tuple($len, ArrayInPlaceVisitor(place))\n                }\n            }\n        )+\n    }\n}\n\narray_impls! {\n    1 =\u003e (0)\n    2 =\u003e (0 1)\n    3 =\u003e (0 1 2)\n    4 =\u003e (0 1 2 3)\n    5 =\u003e (0 1 2 3 4)\n    6 =\u003e (0 1 2 3 4 5)\n    7 =\u003e (0 1 2 3 4 5 6)\n    8 =\u003e (0 1 2 3 4 5 6 7)\n    9 =\u003e (0 1 2 3 4 5 6 7 8)\n    10 =\u003e (0 1 2 3 4 5 6 7 8 9)\n    11 =\u003e (0 1 2 3 4 5 6 7 8 9 10)\n    12 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11)\n    13 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12)\n    14 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13)\n    15 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14)\n    16 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)\n    17 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16)\n    18 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17)\n    19 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18)\n    20 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19)\n    21 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)\n    22 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21)\n    23 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22)\n    24 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23)\n    25 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24)\n    26 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25)\n    27 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26)\n    28 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27)\n    29 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28)\n    30 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29)\n    31 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)\n    32 =\u003e (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! tuple_impls {\n    ($($len:tt =\u003e ($($n:tt $name:ident)+))+) =\u003e {\n        $(\n            impl\u003c'de, $($name: Deserialize\u003c'de\u003e),+\u003e Deserialize\u003c'de\u003e for ($($name,)+) {\n                #[inline]\n                fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n                where\n                    D: Deserializer\u003c'de\u003e,\n                {\n                    struct TupleVisitor\u003c$($name,)+\u003e {\n                        marker: PhantomData\u003c($($name,)+)\u003e,\n                    }\n\n                    impl\u003c'de, $($name: Deserialize\u003c'de\u003e),+\u003e Visitor\u003c'de\u003e for TupleVisitor\u003c$($name,)+\u003e {\n                        type Value = ($($name,)+);\n\n                        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                            formatter.write_str(concat!(\"a tuple of size \", $len))\n                        }\n\n                        #[inline]\n                        #[allow(non_snake_case)]\n                        fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                        where\n                            A: SeqAccess\u003c'de\u003e,\n                        {\n                            $(\n                                let $name = match try!(seq.next_element()) {\n                                    Some(value) =\u003e value,\n                                    None =\u003e return Err(Error::invalid_length($n, \u0026self)),\n                                };\n                            )+\n\n                            Ok(($($name,)+))\n                        }\n                    }\n\n                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })\n                }\n\n                #[inline]\n                fn deserialize_in_place\u003cD\u003e(deserializer: D, place: \u0026mut Self) -\u003e Result\u003c(), D::Error\u003e\n                where\n                    D: Deserializer\u003c'de\u003e,\n                {\n                    struct TupleInPlaceVisitor\u003c'a, $($name: 'a,)+\u003e(\u0026'a mut ($($name,)+));\n\n                    impl\u003c'a, 'de, $($name: Deserialize\u003c'de\u003e),+\u003e Visitor\u003c'de\u003e for TupleInPlaceVisitor\u003c'a, $($name,)+\u003e {\n                        type Value = ();\n\n                        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                            formatter.write_str(concat!(\"a tuple of size \", $len))\n                        }\n\n                        #[inline]\n                        #[allow(non_snake_case)]\n                        fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                        where\n                            A: SeqAccess\u003c'de\u003e,\n                        {\n                            $(\n                                if try!(seq.next_element_seed(InPlaceSeed(\u0026mut (self.0).$n))).is_none() {\n                                    return Err(Error::invalid_length($n, \u0026self));\n                                }\n                            )+\n\n                            Ok(())\n                        }\n                    }\n\n                    deserializer.deserialize_tuple($len, TupleInPlaceVisitor(place))\n                }\n            }\n        )+\n    }\n}\n\ntuple_impls! {\n    1  =\u003e (0 T0)\n    2  =\u003e (0 T0 1 T1)\n    3  =\u003e (0 T0 1 T1 2 T2)\n    4  =\u003e (0 T0 1 T1 2 T2 3 T3)\n    5  =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4)\n    6  =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5)\n    7  =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6)\n    8  =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7)\n    9  =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8)\n    10 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9)\n    11 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10)\n    12 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11)\n    13 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12)\n    14 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13)\n    15 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14)\n    16 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! map_impl {\n    (\n        $ty:ident \u003c K $(: $kbound1:ident $(+ $kbound2:ident)*)*, V $(, $typaram:ident : $bound1:ident $(+ $bound2:ident)*)* \u003e,\n        $access:ident,\n        $with_capacity:expr\n    ) =\u003e {\n        impl\u003c'de, K, V $(, $typaram)*\u003e Deserialize\u003c'de\u003e for $ty\u003cK, V $(, $typaram)*\u003e\n        where\n            K: Deserialize\u003c'de\u003e $(+ $kbound1 $(+ $kbound2)*)*,\n            V: Deserialize\u003c'de\u003e,\n            $($typaram: $bound1 $(+ $bound2)*),*\n        {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct MapVisitor\u003cK, V $(, $typaram)*\u003e {\n                    marker: PhantomData\u003c$ty\u003cK, V $(, $typaram)*\u003e\u003e,\n                }\n\n                impl\u003c'de, K, V $(, $typaram)*\u003e Visitor\u003c'de\u003e for MapVisitor\u003cK, V $(, $typaram)*\u003e\n                where\n                    K: Deserialize\u003c'de\u003e $(+ $kbound1 $(+ $kbound2)*)*,\n                    V: Deserialize\u003c'de\u003e,\n                    $($typaram: $bound1 $(+ $bound2)*),*\n                {\n                    type Value = $ty\u003cK, V $(, $typaram)*\u003e;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"a map\")\n                    }\n\n                    #[inline]\n                    fn visit_map\u003cA\u003e(self, mut $access: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                    where\n                        A: MapAccess\u003c'de\u003e,\n                    {\n                        let mut values = $with_capacity;\n\n                        while let Some((key, value)) = try!($access.next_entry()) {\n                            values.insert(key, value);\n                        }\n\n                        Ok(values)\n                    }\n                }\n\n                let visitor = MapVisitor { marker: PhantomData };\n                deserializer.deserialize_map(visitor)\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmap_impl!(\n    BTreeMap\u003cK: Ord, V\u003e,\n    map,\n    BTreeMap::new());\n\n#[cfg(feature = \"std\")]\nmap_impl!(\n    HashMap\u003cK: Eq + Hash, V, S: BuildHasher + Default\u003e,\n    map,\n    HashMap::with_capacity_and_hasher(size_hint::cautious(map.size_hint()), S::default()));\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nmacro_rules! parse_ip_impl {\n    ($expecting:tt $ty:ty; $size:tt) =\u003e {\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for $ty {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                if deserializer.is_human_readable() {\n                    struct IpAddrVisitor;\n\n                    impl\u003c'de\u003e Visitor\u003c'de\u003e for IpAddrVisitor {\n                        type Value = $ty;\n\n                        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                            formatter.write_str($expecting)\n                        }\n\n                        fn visit_str\u003cE\u003e(self, s: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                        where\n                            E: Error,\n                        {\n                            s.parse().map_err(Error::custom)\n                        }\n                    }\n\n                    deserializer.deserialize_str(IpAddrVisitor)\n                } else {\n                    \u003c[u8; $size]\u003e::deserialize(deserializer).map(\u003c$ty\u003e::from)\n                }\n            }\n        }\n    };\n}\n\n#[cfg(feature = \"std\")]\nmacro_rules! variant_identifier {\n    (\n        $name_kind: ident ( $($variant: ident; $bytes: expr; $index: expr),* )\n        $expecting_message: expr,\n        $variants_name: ident\n    ) =\u003e {\n        enum $name_kind {\n            $( $variant ),*\n        }\n\n        static $variants_name: \u0026'static [\u0026'static str] = \u0026[ $( stringify!($variant) ),*];\n\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for $name_kind {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct KindVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for KindVisitor {\n                    type Value = $name_kind;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str($expecting_message)\n                    }\n\n                    fn visit_u32\u003cE\u003e(self, value: u32) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            $(\n                                $index =\u003e Ok($name_kind :: $variant),\n                            )*\n                            _ =\u003e Err(Error::invalid_value(Unexpected::Unsigned(value as u64), \u0026self),),\n                        }\n                    }\n\n                    fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            $(\n                                stringify!($variant) =\u003e Ok($name_kind :: $variant),\n                            )*\n                            _ =\u003e Err(Error::unknown_variant(value, $variants_name)),\n                        }\n                    }\n\n                    fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            $(\n                                $bytes =\u003e Ok($name_kind :: $variant),\n                            )*\n                            _ =\u003e {\n                                match str::from_utf8(value) {\n                                    Ok(value) =\u003e Err(Error::unknown_variant(value, $variants_name)),\n                                    Err(_) =\u003e Err(Error::invalid_value(Unexpected::Bytes(value), \u0026self)),\n                                }\n                            }\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(KindVisitor)\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nmacro_rules! deserialize_enum {\n    (\n        $name: ident $name_kind: ident ( $($variant: ident; $bytes: expr; $index: expr),* )\n        $expecting_message: expr,\n        $deserializer: expr\n    ) =\u003e {\n        variant_identifier!{\n            $name_kind ( $($variant; $bytes; $index),* )\n            $expecting_message,\n            VARIANTS\n        }\n\n        struct EnumVisitor;\n        impl\u003c'de\u003e Visitor\u003c'de\u003e for EnumVisitor {\n            type Value = $name;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(concat!(\"a \", stringify!($name)))\n            }\n\n\n            fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: EnumAccess\u003c'de\u003e,\n            {\n                match try!(data.variant()) {\n                    $(\n                        ($name_kind :: $variant, v) =\u003e v.newtype_variant().map($name :: $variant),\n                    )*\n                }\n            }\n        }\n        $deserializer.deserialize_enum(stringify!($name), VARIANTS, EnumVisitor)\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for net::IpAddr {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        if deserializer.is_human_readable() {\n            struct IpAddrVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for IpAddrVisitor {\n                type Value = net::IpAddr;\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(\"IP address\")\n                }\n\n                fn visit_str\u003cE\u003e(self, s: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    s.parse().map_err(Error::custom)\n                }\n            }\n\n            deserializer.deserialize_str(IpAddrVisitor)\n        } else {\n            use lib::net::IpAddr;\n            deserialize_enum! {\n                IpAddr IpAddrKind (V4; b\"V4\"; 0, V6; b\"V6\"; 1)\n                \"`V4` or `V6`\",\n                deserializer\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nparse_ip_impl!(\"IPv4 address\" net::Ipv4Addr; 4);\n\n#[cfg(feature = \"std\")]\nparse_ip_impl!(\"IPv6 address\" net::Ipv6Addr; 16);\n\n#[cfg(feature = \"std\")]\nmacro_rules! parse_socket_impl {\n    ($expecting:tt $ty:ty, $new:expr) =\u003e {\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for $ty {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                if deserializer.is_human_readable() {\n                    struct SocketAddrVisitor;\n\n                    impl\u003c'de\u003e Visitor\u003c'de\u003e for SocketAddrVisitor {\n                        type Value = $ty;\n\n                        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                            formatter.write_str($expecting)\n                        }\n\n                        fn visit_str\u003cE\u003e(self, s: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                        where\n                            E: Error,\n                        {\n                            s.parse().map_err(Error::custom)\n                        }\n                    }\n\n                    deserializer.deserialize_str(SocketAddrVisitor)\n                } else {\n                    \u003c(_, u16)\u003e::deserialize(deserializer).map(|(ip, port)| $new(ip, port))\n                }\n            }\n        }\n    };\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for net::SocketAddr {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        if deserializer.is_human_readable() {\n            struct SocketAddrVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for SocketAddrVisitor {\n                type Value = net::SocketAddr;\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(\"socket address\")\n                }\n\n                fn visit_str\u003cE\u003e(self, s: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    s.parse().map_err(Error::custom)\n                }\n            }\n\n            deserializer.deserialize_str(SocketAddrVisitor)\n        } else {\n            use lib::net::SocketAddr;\n            deserialize_enum! {\n                SocketAddr SocketAddrKind (V4; b\"V4\"; 0, V6; b\"V6\"; 1)\n                \"`V4` or `V6`\",\n                deserializer\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nparse_socket_impl!(\"IPv4 socket address\" net::SocketAddrV4, net::SocketAddrV4::new);\n\n#[cfg(feature = \"std\")]\nparse_socket_impl!(\"IPv6 socket address\" net::SocketAddrV6, |ip, port| net::SocketAddrV6::new(\n    ip, port, 0, 0\n));\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nstruct PathVisitor;\n\n#[cfg(feature = \"std\")]\nimpl\u003c'a\u003e Visitor\u003c'a\u003e for PathVisitor {\n    type Value = \u0026'a Path;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"a borrowed path\")\n    }\n\n    fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'a str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v.as_ref())\n    }\n\n    fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'a [u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        str::from_utf8(v)\n            .map(AsRef::as_ref)\n            .map_err(|_| Error::invalid_value(Unexpected::Bytes(v), \u0026self))\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de: 'a, 'a\u003e Deserialize\u003c'de\u003e for \u0026'a Path {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(PathVisitor)\n    }\n}\n\n#[cfg(feature = \"std\")]\nstruct PathBufVisitor;\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for PathBufVisitor {\n    type Value = PathBuf;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"path string\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(From::from(v))\n    }\n\n    fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(From::from(v))\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for PathBuf {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_string(PathBufVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// If this were outside of the serde crate, it would just use:\n//\n//    #[derive(Deserialize)]\n//    #[serde(variant_identifier)]\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nvariant_identifier! {\n    OsStringKind (Unix; b\"Unix\"; 0, Windows; b\"Windows\"; 1)\n    \"`Unix` or `Windows`\",\n    OSSTR_VARIANTS\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nstruct OsStringVisitor;\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for OsStringVisitor {\n    type Value = OsString;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"os string\")\n    }\n\n    #[cfg(unix)]\n    fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: EnumAccess\u003c'de\u003e,\n    {\n        use std::os::unix::ffi::OsStringExt;\n\n        match try!(data.variant()) {\n            (OsStringKind::Unix, v) =\u003e v.newtype_variant().map(OsString::from_vec),\n            (OsStringKind::Windows, _) =\u003e Err(Error::custom(\n                \"cannot deserialize Windows OS string on Unix\",\n            )),\n        }\n    }\n\n    #[cfg(windows)]\n    fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: EnumAccess\u003c'de\u003e,\n    {\n        use std::os::windows::ffi::OsStringExt;\n\n        match try!(data.variant()) {\n            (OsStringKind::Windows, v) =\u003e v\n                .newtype_variant::\u003cVec\u003cu16\u003e\u003e()\n                .map(|vec| OsString::from_wide(\u0026vec)),\n            (OsStringKind::Unix, _) =\u003e Err(Error::custom(\n                \"cannot deserialize Unix OS string on Windows\",\n            )),\n        }\n    }\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for OsString {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_enum(\"OsString\", OSSTR_VARIANTS, OsStringVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nforwarded_impl!((T), Box\u003cT\u003e, Box::new);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nforwarded_impl!((T), Box\u003c[T]\u003e, Vec::into_boxed_slice);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nforwarded_impl!((), Box\u003cstr\u003e, String::into_boxed_str);\n\n#[cfg(all(\n    not(de_rc_dst),\n    feature = \"rc\",\n    any(feature = \"std\", feature = \"alloc\")\n))]\nforwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Arc` will not attempt to\n    /// deduplicate `Arc` references to the same data. Every deserialized `Arc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    (T), Arc\u003cT\u003e, Arc::new\n}\n\n#[cfg(all(\n    not(de_rc_dst),\n    feature = \"rc\",\n    any(feature = \"std\", feature = \"alloc\")\n))]\nforwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Rc` will not attempt to\n    /// deduplicate `Rc` references to the same data. Every deserialized `Rc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    (T), Rc\u003cT\u003e, Rc::new\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, 'a, T: ?Sized\u003e Deserialize\u003c'de\u003e for Cow\u003c'a, T\u003e\nwhere\n    T: ToOwned,\n    T::Owned: Deserialize\u003c'de\u003e,\n{\n    #[inline]\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::Owned::deserialize(deserializer).map(Cow::Owned)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde. The resulting\n/// `Weak\u003cT\u003e` has a reference count of 0 and cannot be upgraded.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nimpl\u003c'de, T: ?Sized\u003e Deserialize\u003c'de\u003e for RcWeak\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        try!(Option::\u003cT\u003e::deserialize(deserializer));\n        Ok(RcWeak::new())\n    }\n}\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde. The resulting\n/// `Weak\u003cT\u003e` has a reference count of 0 and cannot be upgraded.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nimpl\u003c'de, T: ?Sized\u003e Deserialize\u003c'de\u003e for ArcWeak\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        try!(Option::\u003cT\u003e::deserialize(deserializer));\n        Ok(ArcWeak::new())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(all(de_rc_dst, feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nmacro_rules! box_forwarded_impl {\n    (\n        $(#[doc = $doc:tt])*\n        $t:ident\n    ) =\u003e {\n        $(#[doc = $doc])*\n        impl\u003c'de, T: ?Sized\u003e Deserialize\u003c'de\u003e for $t\u003cT\u003e\n        where\n            Box\u003cT\u003e: Deserialize\u003c'de\u003e,\n        {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                Box::deserialize(deserializer).map(Into::into)\n            }\n        }\n    };\n}\n\n#[cfg(all(de_rc_dst, feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nbox_forwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Rc` will not attempt to\n    /// deduplicate `Rc` references to the same data. Every deserialized `Rc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    Rc\n}\n\n#[cfg(all(de_rc_dst, feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nbox_forwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Arc` will not attempt to\n    /// deduplicate `Arc` references to the same data. Every deserialized `Arc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    Arc\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Cell\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e + Copy,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(deserializer).map(Cell::new)\n    }\n}\n\nforwarded_impl!((T), RefCell\u003cT\u003e, RefCell::new);\n\n#[cfg(feature = \"std\")]\nforwarded_impl!((T), Mutex\u003cT\u003e, Mutex::new);\n\n#[cfg(feature = \"std\")]\nforwarded_impl!((T), RwLock\u003cT\u003e, RwLock::new);\n\n////////////////////////////////////////////////////////////////////////////////\n\n// This is a cleaned-up version of the impl generated by:\n//\n//     #[derive(Deserialize)]\n//     #[serde(deny_unknown_fields)]\n//     struct Duration {\n//         secs: u64,\n//         nanos: u32,\n//     }\n#[cfg(any(core_duration, feature = \"std\"))]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Duration {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        // If this were outside of the serde crate, it would just use:\n        //\n        //    #[derive(Deserialize)]\n        //    #[serde(field_identifier, rename_all = \"lowercase\")]\n        enum Field {\n            Secs,\n            Nanos,\n        };\n\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for Field {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct FieldVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"`secs` or `nanos`\")\n                    }\n\n                    fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"secs\" =\u003e Ok(Field::Secs),\n                            \"nanos\" =\u003e Ok(Field::Nanos),\n                            _ =\u003e Err(Error::unknown_field(value, FIELDS)),\n                        }\n                    }\n\n                    fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"secs\" =\u003e Ok(Field::Secs),\n                            b\"nanos\" =\u003e Ok(Field::Nanos),\n                            _ =\u003e {\n                                let value = ::export::from_utf8_lossy(value);\n                                Err(Error::unknown_field(\u0026value, FIELDS))\n                            }\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct DurationVisitor;\n\n        impl\u003c'de\u003e Visitor\u003c'de\u003e for DurationVisitor {\n            type Value = Duration;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"struct Duration\")\n            }\n\n            fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: SeqAccess\u003c'de\u003e,\n            {\n                let secs: u64 = match try!(seq.next_element()) {\n                    Some(value) =\u003e value,\n                    None =\u003e {\n                        return Err(Error::invalid_length(0, \u0026self));\n                    }\n                };\n                let nanos: u32 = match try!(seq.next_element()) {\n                    Some(value) =\u003e value,\n                    None =\u003e {\n                        return Err(Error::invalid_length(1, \u0026self));\n                    }\n                };\n                Ok(Duration::new(secs, nanos))\n            }\n\n            fn visit_map\u003cA\u003e(self, mut map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: MapAccess\u003c'de\u003e,\n            {\n                let mut secs: Option\u003cu64\u003e = None;\n                let mut nanos: Option\u003cu32\u003e = None;\n                while let Some(key) = try!(map.next_key()) {\n                    match key {\n                        Field::Secs =\u003e {\n                            if secs.is_some() {\n                                return Err(\u003cA::Error as Error\u003e::duplicate_field(\"secs\"));\n                            }\n                            secs = Some(try!(map.next_value()));\n                        }\n                        Field::Nanos =\u003e {\n                            if nanos.is_some() {\n                                return Err(\u003cA::Error as Error\u003e::duplicate_field(\"nanos\"));\n                            }\n                            nanos = Some(try!(map.next_value()));\n                        }\n                    }\n                }\n                let secs = match secs {\n                    Some(secs) =\u003e secs,\n                    None =\u003e return Err(\u003cA::Error as Error\u003e::missing_field(\"secs\")),\n                };\n                let nanos = match nanos {\n                    Some(nanos) =\u003e nanos,\n                    None =\u003e return Err(\u003cA::Error as Error\u003e::missing_field(\"nanos\")),\n                };\n                Ok(Duration::new(secs, nanos))\n            }\n        }\n\n        const FIELDS: \u0026'static [\u0026'static str] = \u0026[\"secs\", \"nanos\"];\n        deserializer.deserialize_struct(\"Duration\", FIELDS, DurationVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for SystemTime {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        // Reuse duration\n        enum Field {\n            Secs,\n            Nanos,\n        };\n\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for Field {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct FieldVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"`secs_since_epoch` or `nanos_since_epoch`\")\n                    }\n\n                    fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"secs_since_epoch\" =\u003e Ok(Field::Secs),\n                            \"nanos_since_epoch\" =\u003e Ok(Field::Nanos),\n                            _ =\u003e Err(Error::unknown_field(value, FIELDS)),\n                        }\n                    }\n\n                    fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"secs_since_epoch\" =\u003e Ok(Field::Secs),\n                            b\"nanos_since_epoch\" =\u003e Ok(Field::Nanos),\n                            _ =\u003e {\n                                let value = String::from_utf8_lossy(value);\n                                Err(Error::unknown_field(\u0026value, FIELDS))\n                            }\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct DurationVisitor;\n\n        impl\u003c'de\u003e Visitor\u003c'de\u003e for DurationVisitor {\n            type Value = Duration;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"struct SystemTime\")\n            }\n\n            fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: SeqAccess\u003c'de\u003e,\n            {\n                let secs: u64 = match try!(seq.next_element()) {\n                    Some(value) =\u003e value,\n                    None =\u003e {\n                        return Err(Error::invalid_length(0, \u0026self));\n                    }\n                };\n                let nanos: u32 = match try!(seq.next_element()) {\n                    Some(value) =\u003e value,\n                    None =\u003e {\n                        return Err(Error::invalid_length(1, \u0026self));\n                    }\n                };\n                Ok(Duration::new(secs, nanos))\n            }\n\n            fn visit_map\u003cA\u003e(self, mut map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: MapAccess\u003c'de\u003e,\n            {\n                let mut secs: Option\u003cu64\u003e = None;\n                let mut nanos: Option\u003cu32\u003e = None;\n                while let Some(key) = try!(map.next_key()) {\n                    match key {\n                        Field::Secs =\u003e {\n                            if secs.is_some() {\n                                return Err(\u003cA::Error as Error\u003e::duplicate_field(\n                                    \"secs_since_epoch\",\n                                ));\n                            }\n                            secs = Some(try!(map.next_value()));\n                        }\n                        Field::Nanos =\u003e {\n                            if nanos.is_some() {\n                                return Err(\u003cA::Error as Error\u003e::duplicate_field(\n                                    \"nanos_since_epoch\",\n                                ));\n                            }\n                            nanos = Some(try!(map.next_value()));\n                        }\n                    }\n                }\n                let secs = match secs {\n                    Some(secs) =\u003e secs,\n                    None =\u003e return Err(\u003cA::Error as Error\u003e::missing_field(\"secs_since_epoch\")),\n                };\n                let nanos = match nanos {\n                    Some(nanos) =\u003e nanos,\n                    None =\u003e return Err(\u003cA::Error as Error\u003e::missing_field(\"nanos_since_epoch\")),\n                };\n                Ok(Duration::new(secs, nanos))\n            }\n        }\n\n        const FIELDS: \u0026'static [\u0026'static str] = \u0026[\"secs_since_epoch\", \"nanos_since_epoch\"];\n        let duration = try!(deserializer.deserialize_struct(\"SystemTime\", FIELDS, DurationVisitor));\n        Ok(UNIX_EPOCH + duration)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Similar to:\n//\n//     #[derive(Deserialize)]\n//     #[serde(deny_unknown_fields)]\n//     struct Range {\n//         start: u64,\n//         end: u32,\n//     }\nimpl\u003c'de, Idx\u003e Deserialize\u003c'de\u003e for Range\u003cIdx\u003e\nwhere\n    Idx: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let (start, end) = deserializer.deserialize_struct(\n            \"Range\",\n            range::FIELDS,\n            range::RangeVisitor {\n                expecting: \"struct Range\",\n                phantom: PhantomData,\n            },\n        )?;\n        Ok(start..end)\n    }\n}\n\n#[cfg(range_inclusive)]\nimpl\u003c'de, Idx\u003e Deserialize\u003c'de\u003e for RangeInclusive\u003cIdx\u003e\nwhere\n    Idx: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let (start, end) = deserializer.deserialize_struct(\n            \"RangeInclusive\",\n            range::FIELDS,\n            range::RangeVisitor {\n                expecting: \"struct RangeInclusive\",\n                phantom: PhantomData,\n            },\n        )?;\n        Ok(RangeInclusive::new(start, end))\n    }\n}\n\nmod range {\n    use lib::*;\n\n    use de::{Deserialize, Deserializer, Error, MapAccess, SeqAccess, Visitor};\n\n    pub const FIELDS: \u0026'static [\u0026'static str] = \u0026[\"start\", \"end\"];\n\n    // If this were outside of the serde crate, it would just use:\n    //\n    //    #[derive(Deserialize)]\n    //    #[serde(field_identifier, rename_all = \"lowercase\")]\n    enum Field {\n        Start,\n        End,\n    }\n\n    impl\u003c'de\u003e Deserialize\u003c'de\u003e for Field {\n        fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            struct FieldVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for FieldVisitor {\n                type Value = Field;\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    formatter.write_str(\"`start` or `end`\")\n                }\n\n                fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    match value {\n                        \"start\" =\u003e Ok(Field::Start),\n                        \"end\" =\u003e Ok(Field::End),\n                        _ =\u003e Err(Error::unknown_field(value, FIELDS)),\n                    }\n                }\n\n                fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n                where\n                    E: Error,\n                {\n                    match value {\n                        b\"start\" =\u003e Ok(Field::Start),\n                        b\"end\" =\u003e Ok(Field::End),\n                        _ =\u003e {\n                            let value = ::export::from_utf8_lossy(value);\n                            Err(Error::unknown_field(\u0026value, FIELDS))\n                        }\n                    }\n                }\n            }\n\n            deserializer.deserialize_identifier(FieldVisitor)\n        }\n    }\n\n    pub struct RangeVisitor\u003cIdx\u003e {\n        pub expecting: \u0026'static str,\n        pub phantom: PhantomData\u003cIdx\u003e,\n    }\n\n    impl\u003c'de, Idx\u003e Visitor\u003c'de\u003e for RangeVisitor\u003cIdx\u003e\n    where\n        Idx: Deserialize\u003c'de\u003e,\n    {\n        type Value = (Idx, Idx);\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            formatter.write_str(self.expecting)\n        }\n\n        fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n        where\n            A: SeqAccess\u003c'de\u003e,\n        {\n            let start: Idx = match try!(seq.next_element()) {\n                Some(value) =\u003e value,\n                None =\u003e {\n                    return Err(Error::invalid_length(0, \u0026self));\n                }\n            };\n            let end: Idx = match try!(seq.next_element()) {\n                Some(value) =\u003e value,\n                None =\u003e {\n                    return Err(Error::invalid_length(1, \u0026self));\n                }\n            };\n            Ok((start, end))\n        }\n\n        fn visit_map\u003cA\u003e(self, mut map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n        where\n            A: MapAccess\u003c'de\u003e,\n        {\n            let mut start: Option\u003cIdx\u003e = None;\n            let mut end: Option\u003cIdx\u003e = None;\n            while let Some(key) = try!(map.next_key()) {\n                match key {\n                    Field::Start =\u003e {\n                        if start.is_some() {\n                            return Err(\u003cA::Error as Error\u003e::duplicate_field(\"start\"));\n                        }\n                        start = Some(try!(map.next_value()));\n                    }\n                    Field::End =\u003e {\n                        if end.is_some() {\n                            return Err(\u003cA::Error as Error\u003e::duplicate_field(\"end\"));\n                        }\n                        end = Some(try!(map.next_value()));\n                    }\n                }\n            }\n            let start = match start {\n                Some(start) =\u003e start,\n                None =\u003e return Err(\u003cA::Error as Error\u003e::missing_field(\"start\")),\n            };\n            let end = match end {\n                Some(end) =\u003e end,\n                None =\u003e return Err(\u003cA::Error as Error\u003e::missing_field(\"end\")),\n            };\n            Ok((start, end))\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(ops_bound, collections_bound))]\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Bound\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        enum Field {\n            Unbounded,\n            Included,\n            Excluded,\n        }\n\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for Field {\n            #[inline]\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct FieldVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"`Unbounded`, `Included` or `Excluded`\")\n                    }\n\n                    fn visit_u32\u003cE\u003e(self, value: u32) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            0 =\u003e Ok(Field::Unbounded),\n                            1 =\u003e Ok(Field::Included),\n                            2 =\u003e Ok(Field::Excluded),\n                            _ =\u003e Err(Error::invalid_value(\n                                Unexpected::Unsigned(value as u64),\n                                \u0026self,\n                            )),\n                        }\n                    }\n\n                    fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"Unbounded\" =\u003e Ok(Field::Unbounded),\n                            \"Included\" =\u003e Ok(Field::Included),\n                            \"Excluded\" =\u003e Ok(Field::Excluded),\n                            _ =\u003e Err(Error::unknown_variant(value, VARIANTS)),\n                        }\n                    }\n\n                    fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"Unbounded\" =\u003e Ok(Field::Unbounded),\n                            b\"Included\" =\u003e Ok(Field::Included),\n                            b\"Excluded\" =\u003e Ok(Field::Excluded),\n                            _ =\u003e match str::from_utf8(value) {\n                                Ok(value) =\u003e Err(Error::unknown_variant(value, VARIANTS)),\n                                Err(_) =\u003e {\n                                    Err(Error::invalid_value(Unexpected::Bytes(value), \u0026self))\n                                }\n                            },\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct BoundVisitor\u003cT\u003e(PhantomData\u003cBound\u003cT\u003e\u003e);\n\n        impl\u003c'de, T\u003e Visitor\u003c'de\u003e for BoundVisitor\u003cT\u003e\n        where\n            T: Deserialize\u003c'de\u003e,\n        {\n            type Value = Bound\u003cT\u003e;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"enum Bound\")\n            }\n\n            fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: EnumAccess\u003c'de\u003e,\n            {\n                match try!(data.variant()) {\n                    (Field::Unbounded, v) =\u003e v.unit_variant().map(|()| Bound::Unbounded),\n                    (Field::Included, v) =\u003e v.newtype_variant().map(Bound::Included),\n                    (Field::Excluded, v) =\u003e v.newtype_variant().map(Bound::Excluded),\n                }\n            }\n        }\n\n        const VARIANTS: \u0026'static [\u0026'static str] = \u0026[\"Unbounded\", \"Included\", \"Excluded\"];\n\n        deserializer.deserialize_enum(\"Bound\", VARIANTS, BoundVisitor(PhantomData))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! nonzero_integers {\n    ( $( $T: ident, )+ ) =\u003e {\n        $(\n            #[cfg(num_nonzero)]\n            impl\u003c'de\u003e Deserialize\u003c'de\u003e for num::$T {\n                fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n                where\n                    D: Deserializer\u003c'de\u003e,\n                {\n                    let value = try!(Deserialize::deserialize(deserializer));\n                    match \u003cnum::$T\u003e::new(value) {\n                        Some(nonzero) =\u003e Ok(nonzero),\n                        None =\u003e Err(Error::custom(\"expected a non-zero value\")),\n                    }\n                }\n            }\n        )+\n    };\n}\n\nnonzero_integers! {\n    NonZeroU8,\n    NonZeroU16,\n    NonZeroU32,\n    NonZeroU64,\n    NonZeroUsize,\n}\n\n#[cfg(num_nonzero_signed)]\nnonzero_integers! {\n    NonZeroI8,\n    NonZeroI16,\n    NonZeroI32,\n    NonZeroI64,\n    NonZeroIsize,\n}\n\n// Currently 128-bit integers do not work on Emscripten targets so we need an\n// additional `#[cfg]`\nserde_if_integer128! {\n    nonzero_integers! {\n        NonZeroU128,\n    }\n\n    #[cfg(num_nonzero_signed)]\n    nonzero_integers! {\n        NonZeroI128,\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003c'de, T, E\u003e Deserialize\u003c'de\u003e for Result\u003cT, E\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n    E: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        // If this were outside of the serde crate, it would just use:\n        //\n        //    #[derive(Deserialize)]\n        //    #[serde(variant_identifier)]\n        enum Field {\n            Ok,\n            Err,\n        }\n\n        impl\u003c'de\u003e Deserialize\u003c'de\u003e for Field {\n            #[inline]\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: Deserializer\u003c'de\u003e,\n            {\n                struct FieldVisitor;\n\n                impl\u003c'de\u003e Visitor\u003c'de\u003e for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                        formatter.write_str(\"`Ok` or `Err`\")\n                    }\n\n                    fn visit_u32\u003cE\u003e(self, value: u32) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            0 =\u003e Ok(Field::Ok),\n                            1 =\u003e Ok(Field::Err),\n                            _ =\u003e Err(Error::invalid_value(\n                                Unexpected::Unsigned(value as u64),\n                                \u0026self,\n                            )),\n                        }\n                    }\n\n                    fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"Ok\" =\u003e Ok(Field::Ok),\n                            \"Err\" =\u003e Ok(Field::Err),\n                            _ =\u003e Err(Error::unknown_variant(value, VARIANTS)),\n                        }\n                    }\n\n                    fn visit_bytes\u003cE\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"Ok\" =\u003e Ok(Field::Ok),\n                            b\"Err\" =\u003e Ok(Field::Err),\n                            _ =\u003e match str::from_utf8(value) {\n                                Ok(value) =\u003e Err(Error::unknown_variant(value, VARIANTS)),\n                                Err(_) =\u003e {\n                                    Err(Error::invalid_value(Unexpected::Bytes(value), \u0026self))\n                                }\n                            },\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct ResultVisitor\u003cT, E\u003e(PhantomData\u003cResult\u003cT, E\u003e\u003e);\n\n        impl\u003c'de, T, E\u003e Visitor\u003c'de\u003e for ResultVisitor\u003cT, E\u003e\n        where\n            T: Deserialize\u003c'de\u003e,\n            E: Deserialize\u003c'de\u003e,\n        {\n            type Value = Result\u003cT, E\u003e;\n\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                formatter.write_str(\"enum Result\")\n            }\n\n            fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n            where\n                A: EnumAccess\u003c'de\u003e,\n            {\n                match try!(data.variant()) {\n                    (Field::Ok, v) =\u003e v.newtype_variant().map(Ok),\n                    (Field::Err, v) =\u003e v.newtype_variant().map(Err),\n                }\n            }\n        }\n\n        const VARIANTS: \u0026'static [\u0026'static str] = \u0026[\"Ok\", \"Err\"];\n\n        deserializer.deserialize_enum(\"Result\", VARIANTS, ResultVisitor(PhantomData))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Wrapping\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Deserialize::deserialize(deserializer).map(Wrapping)\n    }\n}\n\n#[cfg(all(feature = \"std\", std_atomic))]\nmacro_rules! atomic_impl {\n    ($($ty:ident)*) =\u003e {\n        $(\n            impl\u003c'de\u003e Deserialize\u003c'de\u003e for $ty {\n                fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n                where\n                    D: Deserializer\u003c'de\u003e,\n                {\n                    Deserialize::deserialize(deserializer).map(Self::new)\n                }\n            }\n        )*\n    };\n}\n\n#[cfg(all(feature = \"std\", std_atomic))]\natomic_impl! {\n    AtomicBool\n    AtomicI8 AtomicI16 AtomicI32 AtomicIsize\n    AtomicU8 AtomicU16 AtomicU32 AtomicUsize\n}\n\n#[cfg(all(feature = \"std\", std_atomic64))]\natomic_impl! {\n    AtomicI64 AtomicU64\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","mod.rs"],"content":"//! Generic data structure deserialization framework.\n//!\n//! The two most important traits in this module are [`Deserialize`] and\n//! [`Deserializer`].\n//!\n//!  - **A type that implements `Deserialize` is a data structure** that can be\n//!    deserialized from any data format supported by Serde, and conversely\n//!  - **A type that implements `Deserializer` is a data format** that can\n//!    deserialize any data structure supported by Serde.\n//!\n//! # The Deserialize trait\n//!\n//! Serde provides [`Deserialize`] implementations for many Rust primitive and\n//! standard library types. The complete list is below. All of these can be\n//! deserialized using Serde out of the box.\n//!\n//! Additionally, Serde provides a procedural macro called [`serde_derive`] to\n//! automatically generate [`Deserialize`] implementations for structs and enums\n//! in your program. See the [derive section of the manual] for how to use this.\n//!\n//! In rare cases it may be necessary to implement [`Deserialize`] manually for\n//! some type in your program. See the [Implementing `Deserialize`] section of\n//! the manual for more about this.\n//!\n//! Third-party crates may provide [`Deserialize`] implementations for types\n//! that they expose. For example the [`linked-hash-map`] crate provides a\n//! [`LinkedHashMap\u003cK, V\u003e`] type that is deserializable by Serde because the\n//! crate provides an implementation of [`Deserialize`] for it.\n//!\n//! # The Deserializer trait\n//!\n//! [`Deserializer`] implementations are provided by third-party crates, for\n//! example [`serde_json`], [`serde_yaml`] and [`bincode`].\n//!\n//! A partial list of well-maintained formats is given on the [Serde\n//! website][data formats].\n//!\n//! # Implementations of Deserialize provided by Serde\n//!\n//! This is a slightly different set of types than what is supported for\n//! serialization. Some types can be serialized by Serde but not deserialized.\n//! One example is `OsStr`.\n//!\n//!  - **Primitive types**:\n//!    - bool\n//!    - i8, i16, i32, i64, i128, isize\n//!    - u8, u16, u32, u64, u128, usize\n//!    - f32, f64\n//!    - char\n//!  - **Compound types**:\n//!    - \\[T; 0\\] through \\[T; 32\\]\n//!    - tuples up to size 16\n//!  - **Common standard library types**:\n//!    - String\n//!    - Option\\\u003cT\\\u003e\n//!    - Result\\\u003cT, E\\\u003e\n//!    - PhantomData\\\u003cT\\\u003e\n//!  - **Wrapper types**:\n//!    - Box\\\u003cT\\\u003e\n//!    - Box\\\u003c\\[T\\]\\\u003e\n//!    - Box\\\u003cstr\\\u003e\n//!    - Cow\\\u003c'a, T\\\u003e\n//!    - Cell\\\u003cT\\\u003e\n//!    - RefCell\\\u003cT\\\u003e\n//!    - Mutex\\\u003cT\\\u003e\n//!    - RwLock\\\u003cT\\\u003e\n//!    - Rc\\\u003cT\\\u003e\u0026emsp;*(if* features = [\"rc\"] *is enabled)*\n//!    - Arc\\\u003cT\\\u003e\u0026emsp;*(if* features = [\"rc\"] *is enabled)*\n//!  - **Collection types**:\n//!    - BTreeMap\\\u003cK, V\\\u003e\n//!    - BTreeSet\\\u003cT\\\u003e\n//!    - BinaryHeap\\\u003cT\\\u003e\n//!    - HashMap\\\u003cK, V, H\\\u003e\n//!    - HashSet\\\u003cT, H\\\u003e\n//!    - LinkedList\\\u003cT\\\u003e\n//!    - VecDeque\\\u003cT\\\u003e\n//!    - Vec\\\u003cT\\\u003e\n//!  - **Zero-copy types**:\n//!    - \u0026str\n//!    - \u0026\\[u8\\]\n//!  - **FFI types**:\n//!    - CString\n//!    - Box\\\u003cCStr\\\u003e\n//!    - OsString\n//!  - **Miscellaneous standard library types**:\n//!    - Duration\n//!    - SystemTime\n//!    - Path\n//!    - PathBuf\n//!    - Range\\\u003cT\\\u003e\n//!    - RangeInclusive\\\u003cT\\\u003e\n//!    - Bound\\\u003cT\\\u003e\n//!    - num::NonZero*\n//!    - `!` *(unstable)*\n//!  - **Net types**:\n//!    - IpAddr\n//!    - Ipv4Addr\n//!    - Ipv6Addr\n//!    - SocketAddr\n//!    - SocketAddrV4\n//!    - SocketAddrV6\n//!\n//! [Implementing `Deserialize`]: https://serde.rs/impl-deserialize.html\n//! [`Deserialize`]: ../trait.Deserialize.html\n//! [`Deserializer`]: ../trait.Deserializer.html\n//! [`LinkedHashMap\u003cK, V\u003e`]: https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html\n//! [`bincode`]: https://github.com/TyOverby/bincode\n//! [`linked-hash-map`]: https://crates.io/crates/linked-hash-map\n//! [`serde_derive`]: https://crates.io/crates/serde_derive\n//! [`serde_json`]: https://github.com/serde-rs/json\n//! [`serde_yaml`]: https://github.com/dtolnay/serde-yaml\n//! [derive section of the manual]: https://serde.rs/derive.html\n//! [data formats]: https://serde.rs/#data-formats\n\nuse lib::*;\n\n////////////////////////////////////////////////////////////////////////////////\n\npub mod value;\n\nmod from_primitive;\nmod ignored_any;\nmod impls;\nmod utf8;\n\npub use self::ignored_any::IgnoredAny;\n\n#[cfg(feature = \"std\")]\n#[doc(no_inline)]\npub use std::error::Error as StdError;\n#[cfg(not(feature = \"std\"))]\n#[doc(no_inline)]\npub use std_error::Error as StdError;\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! declare_error_trait {\n    (Error: Sized $(+ $($supertrait:ident)::+)*) =\u003e {\n        /// The `Error` trait allows `Deserialize` implementations to create descriptive\n        /// error messages belonging to the `Deserializer` against which they are\n        /// currently running.\n        ///\n        /// Every `Deserializer` declares an `Error` type that encompasses both\n        /// general-purpose deserialization errors as well as errors specific to the\n        /// particular deserialization format. For example the `Error` type of\n        /// `serde_json` can represent errors like an invalid JSON escape sequence or an\n        /// unterminated string literal, in addition to the error cases that are part of\n        /// this trait.\n        ///\n        /// Most deserializers should only need to provide the `Error::custom` method\n        /// and inherit the default behavior for the other methods.\n        ///\n        /// # Example implementation\n        ///\n        /// The [example data format] presented on the website shows an error\n        /// type appropriate for a basic JSON data format.\n        ///\n        /// [example data format]: https://serde.rs/data-format.html\n        pub trait Error: Sized $(+ $($supertrait)::+)* {\n            /// Raised when there is general error when deserializing a type.\n            ///\n            /// The message should not be capitalized and should not end with a period.\n            ///\n            /// ```edition2018\n            /// # use std::str::FromStr;\n            /// #\n            /// # struct IpAddr;\n            /// #\n            /// # impl FromStr for IpAddr {\n            /// #     type Err = String;\n            /// #\n            /// #     fn from_str(_: \u0026str) -\u003e Result\u003cSelf, String\u003e {\n            /// #         unimplemented!()\n            /// #     }\n            /// # }\n            /// #\n            /// use serde::de::{self, Deserialize, Deserializer};\n            ///\n            /// impl\u003c'de\u003e Deserialize\u003c'de\u003e for IpAddr {\n            ///     fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            ///     where\n            ///         D: Deserializer\u003c'de\u003e,\n            ///     {\n            ///         let s = String::deserialize(deserializer)?;\n            ///         s.parse().map_err(de::Error::custom)\n            ///     }\n            /// }\n            /// ```\n            fn custom\u003cT\u003e(msg: T) -\u003e Self\n            where\n                T: Display;\n\n            /// Raised when a `Deserialize` receives a type different from what it was\n            /// expecting.\n            ///\n            /// The `unexp` argument provides information about what type was received.\n            /// This is the type that was present in the input file or other source data\n            /// of the Deserializer.\n            ///\n            /// The `exp` argument provides information about what type was being\n            /// expected. This is the type that is written in the program.\n            ///\n            /// For example if we try to deserialize a String out of a JSON file\n            /// containing an integer, the unexpected type is the integer and the\n            /// expected type is the string.\n            #[cold]\n            fn invalid_type(unexp: Unexpected, exp: \u0026Expected) -\u003e Self {\n                Error::custom(format_args!(\"invalid type: {}, expected {}\", unexp, exp))\n            }\n\n            /// Raised when a `Deserialize` receives a value of the right type but that\n            /// is wrong for some other reason.\n            ///\n            /// The `unexp` argument provides information about what value was received.\n            /// This is the value that was present in the input file or other source\n            /// data of the Deserializer.\n            ///\n            /// The `exp` argument provides information about what value was being\n            /// expected. This is the type that is written in the program.\n            ///\n            /// For example if we try to deserialize a String out of some binary data\n            /// that is not valid UTF-8, the unexpected value is the bytes and the\n            /// expected value is a string.\n            #[cold]\n            fn invalid_value(unexp: Unexpected, exp: \u0026Expected) -\u003e Self {\n                Error::custom(format_args!(\"invalid value: {}, expected {}\", unexp, exp))\n            }\n\n            /// Raised when deserializing a sequence or map and the input data contains\n            /// too many or too few elements.\n            ///\n            /// The `len` argument is the number of elements encountered. The sequence\n            /// or map may have expected more arguments or fewer arguments.\n            ///\n            /// The `exp` argument provides information about what data was being\n            /// expected. For example `exp` might say that a tuple of size 6 was\n            /// expected.\n            #[cold]\n            fn invalid_length(len: usize, exp: \u0026Expected) -\u003e Self {\n                Error::custom(format_args!(\"invalid length {}, expected {}\", len, exp))\n            }\n\n            /// Raised when a `Deserialize` enum type received a variant with an\n            /// unrecognized name.\n            #[cold]\n            fn unknown_variant(variant: \u0026str, expected: \u0026'static [\u0026'static str]) -\u003e Self {\n                if expected.is_empty() {\n                    Error::custom(format_args!(\n                        \"unknown variant `{}`, there are no variants\",\n                        variant\n                    ))\n                } else {\n                    Error::custom(format_args!(\n                        \"unknown variant `{}`, expected {}\",\n                        variant,\n                        OneOf { names: expected }\n                    ))\n                }\n            }\n\n            /// Raised when a `Deserialize` struct type received a field with an\n            /// unrecognized name.\n            #[cold]\n            fn unknown_field(field: \u0026str, expected: \u0026'static [\u0026'static str]) -\u003e Self {\n                if expected.is_empty() {\n                    Error::custom(format_args!(\n                        \"unknown field `{}`, there are no fields\",\n                        field\n                    ))\n                } else {\n                    Error::custom(format_args!(\n                        \"unknown field `{}`, expected {}\",\n                        field,\n                        OneOf { names: expected }\n                    ))\n                }\n            }\n\n            /// Raised when a `Deserialize` struct type expected to receive a required\n            /// field with a particular name but that field was not present in the\n            /// input.\n            #[cold]\n            fn missing_field(field: \u0026'static str) -\u003e Self {\n                Error::custom(format_args!(\"missing field `{}`\", field))\n            }\n\n            /// Raised when a `Deserialize` struct type received more than one of the\n            /// same field.\n            #[cold]\n            fn duplicate_field(field: \u0026'static str) -\u003e Self {\n                Error::custom(format_args!(\"duplicate field `{}`\", field))\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\ndeclare_error_trait!(Error: Sized + StdError);\n\n#[cfg(not(feature = \"std\"))]\ndeclare_error_trait!(Error: Sized + Debug + Display);\n\n/// `Unexpected` represents an unexpected invocation of any one of the `Visitor`\n/// trait methods.\n///\n/// This is used as an argument to the `invalid_type`, `invalid_value`, and\n/// `invalid_length` methods of the `Error` trait to build error messages.\n///\n/// ```edition2018\n/// # use std::fmt;\n/// #\n/// # use serde::de::{self, Unexpected, Visitor};\n/// #\n/// # struct Example;\n/// #\n/// # impl\u003c'de\u003e Visitor\u003c'de\u003e for Example {\n/// #     type Value = ();\n/// #\n/// #     fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n/// #         write!(formatter, \"definitely not a boolean\")\n/// #     }\n/// #\n/// fn visit_bool\u003cE\u003e(self, v: bool) -\u003e Result\u003cSelf::Value, E\u003e\n/// where\n///     E: de::Error,\n/// {\n///     Err(de::Error::invalid_type(Unexpected::Bool(v), \u0026self))\n/// }\n/// # }\n/// ```\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum Unexpected\u003c'a\u003e {\n    /// The input contained a boolean value that was not expected.\n    Bool(bool),\n\n    /// The input contained an unsigned integer `u8`, `u16`, `u32` or `u64` that\n    /// was not expected.\n    Unsigned(u64),\n\n    /// The input contained a signed integer `i8`, `i16`, `i32` or `i64` that\n    /// was not expected.\n    Signed(i64),\n\n    /// The input contained a floating point `f32` or `f64` that was not\n    /// expected.\n    Float(f64),\n\n    /// The input contained a `char` that was not expected.\n    Char(char),\n\n    /// The input contained a `\u0026str` or `String` that was not expected.\n    Str(\u0026'a str),\n\n    /// The input contained a `\u0026[u8]` or `Vec\u003cu8\u003e` that was not expected.\n    Bytes(\u0026'a [u8]),\n\n    /// The input contained a unit `()` that was not expected.\n    Unit,\n\n    /// The input contained an `Option\u003cT\u003e` that was not expected.\n    Option,\n\n    /// The input contained a newtype struct that was not expected.\n    NewtypeStruct,\n\n    /// The input contained a sequence that was not expected.\n    Seq,\n\n    /// The input contained a map that was not expected.\n    Map,\n\n    /// The input contained an enum that was not expected.\n    Enum,\n\n    /// The input contained a unit variant that was not expected.\n    UnitVariant,\n\n    /// The input contained a newtype variant that was not expected.\n    NewtypeVariant,\n\n    /// The input contained a tuple variant that was not expected.\n    TupleVariant,\n\n    /// The input contained a struct variant that was not expected.\n    StructVariant,\n\n    /// A message stating what uncategorized thing the input contained that was\n    /// not expected.\n    ///\n    /// The message should be a noun or noun phrase, not capitalized and without\n    /// a period. An example message is \"unoriginal superhero\".\n    Other(\u0026'a str),\n}\n\nimpl\u003c'a\u003e fmt::Display for Unexpected\u003c'a\u003e {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e Result\u003c(), fmt::Error\u003e {\n        use self::Unexpected::*;\n        match *self {\n            Bool(b) =\u003e write!(formatter, \"boolean `{}`\", b),\n            Unsigned(i) =\u003e write!(formatter, \"integer `{}`\", i),\n            Signed(i) =\u003e write!(formatter, \"integer `{}`\", i),\n            Float(f) =\u003e write!(formatter, \"floating point `{}`\", f),\n            Char(c) =\u003e write!(formatter, \"character `{}`\", c),\n            Str(s) =\u003e write!(formatter, \"string {:?}\", s),\n            Bytes(_) =\u003e write!(formatter, \"byte array\"),\n            Unit =\u003e write!(formatter, \"unit value\"),\n            Option =\u003e write!(formatter, \"Option value\"),\n            NewtypeStruct =\u003e write!(formatter, \"newtype struct\"),\n            Seq =\u003e write!(formatter, \"sequence\"),\n            Map =\u003e write!(formatter, \"map\"),\n            Enum =\u003e write!(formatter, \"enum\"),\n            UnitVariant =\u003e write!(formatter, \"unit variant\"),\n            NewtypeVariant =\u003e write!(formatter, \"newtype variant\"),\n            TupleVariant =\u003e write!(formatter, \"tuple variant\"),\n            StructVariant =\u003e write!(formatter, \"struct variant\"),\n            Other(other) =\u003e formatter.write_str(other),\n        }\n    }\n}\n\n/// `Expected` represents an explanation of what data a `Visitor` was expecting\n/// to receive.\n///\n/// This is used as an argument to the `invalid_type`, `invalid_value`, and\n/// `invalid_length` methods of the `Error` trait to build error messages. The\n/// message should be a noun or noun phrase that completes the sentence \"This\n/// Visitor expects to receive ...\", for example the message could be \"an\n/// integer between 0 and 64\". The message should not be capitalized and should\n/// not end with a period.\n///\n/// Within the context of a `Visitor` implementation, the `Visitor` itself\n/// (`\u0026self`) is an implementation of this trait.\n///\n/// ```edition2018\n/// # use std::fmt;\n/// #\n/// # use serde::de::{self, Unexpected, Visitor};\n/// #\n/// # struct Example;\n/// #\n/// # impl\u003c'de\u003e Visitor\u003c'de\u003e for Example {\n/// #     type Value = ();\n/// #\n/// #     fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n/// #         write!(formatter, \"definitely not a boolean\")\n/// #     }\n/// #\n/// fn visit_bool\u003cE\u003e(self, v: bool) -\u003e Result\u003cSelf::Value, E\u003e\n/// where\n///     E: de::Error,\n/// {\n///     Err(de::Error::invalid_type(Unexpected::Bool(v), \u0026self))\n/// }\n/// # }\n/// ```\n///\n/// Outside of a `Visitor`, `\u0026\"...\"` can be used.\n///\n/// ```edition2018\n/// # use serde::de::{self, Unexpected};\n/// #\n/// # fn example\u003cE\u003e() -\u003e Result\u003c(), E\u003e\n/// # where\n/// #     E: de::Error,\n/// # {\n/// #     let v = true;\n/// return Err(de::Error::invalid_type(Unexpected::Bool(v), \u0026\"a negative integer\"));\n/// # }\n/// ```\npub trait Expected {\n    /// Format an explanation of what data was being expected. Same signature as\n    /// the `Display` and `Debug` traits.\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result;\n}\n\nimpl\u003c'de, T\u003e Expected for T\nwhere\n    T: Visitor\u003c'de\u003e,\n{\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        self.expecting(formatter)\n    }\n}\n\nimpl\u003c'a\u003e Expected for \u0026'a str {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(self)\n    }\n}\n\nimpl\u003c'a\u003e Display for Expected + 'a {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        Expected::fmt(self, formatter)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A **data structure** that can be deserialized from any data format supported\n/// by Serde.\n///\n/// Serde provides `Deserialize` implementations for many Rust primitive and\n/// standard library types. The complete list is [here][de]. All of these can\n/// be deserialized using Serde out of the box.\n///\n/// Additionally, Serde provides a procedural macro called `serde_derive` to\n/// automatically generate `Deserialize` implementations for structs and enums\n/// in your program. See the [derive section of the manual][derive] for how to\n/// use this.\n///\n/// In rare cases it may be necessary to implement `Deserialize` manually for\n/// some type in your program. See the [Implementing\n/// `Deserialize`][impl-deserialize] section of the manual for more about this.\n///\n/// Third-party crates may provide `Deserialize` implementations for types that\n/// they expose. For example the `linked-hash-map` crate provides a\n/// `LinkedHashMap\u003cK, V\u003e` type that is deserializable by Serde because the crate\n/// provides an implementation of `Deserialize` for it.\n///\n/// [de]: https://docs.serde.rs/serde/de/index.html\n/// [derive]: https://serde.rs/derive.html\n/// [impl-deserialize]: https://serde.rs/impl-deserialize.html\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by `Self` when deserialized. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\npub trait Deserialize\u003c'de\u003e: Sized {\n    /// Deserialize this value from the given Serde deserializer.\n    ///\n    /// See the [Implementing `Deserialize`][impl-deserialize] section of the\n    /// manual for more information about how to implement this method.\n    ///\n    /// [impl-deserialize]: https://serde.rs/impl-deserialize.html\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e;\n\n    /// Deserializes a value into `self` from the given Deserializer.\n    ///\n    /// The purpose of this method is to allow the deserializer to reuse\n    /// resources and avoid copies. As such, if this method returns an error,\n    /// `self` will be in an indeterminate state where some parts of the struct\n    /// have been overwritten. Although whatever state that is will be\n    /// memory-safe.\n    ///\n    /// This is generally useful when repeatedly deserializing values that\n    /// are processed one at a time, where the value of `self` doesn't matter\n    /// when the next deserialization occurs.\n    ///\n    /// If you manually implement this, your recursive deserializations should\n    /// use `deserialize_in_place`.\n    ///\n    /// This method is stable and an official public API, but hidden from the\n    /// documentation because it is almost never what newbies are looking for.\n    /// Showing it in rustdoc would cause it to be featured more prominently\n    /// than it deserves.\n    #[doc(hidden)]\n    fn deserialize_in_place\u003cD\u003e(deserializer: D, place: \u0026mut Self) -\u003e Result\u003c(), D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        // Default implementation just delegates to `deserialize` impl.\n        *place = Deserialize::deserialize(deserializer)?;\n        Ok(())\n    }\n}\n\n/// A data structure that can be deserialized without borrowing any data from\n/// the deserializer.\n///\n/// This is primarily useful for trait bounds on functions. For example a\n/// `from_str` function may be able to deserialize a data structure that borrows\n/// from the input string, but a `from_reader` function may only deserialize\n/// owned data.\n///\n/// ```edition2018\n/// # use serde::de::{Deserialize, DeserializeOwned};\n/// # use std::io::{Read, Result};\n/// #\n/// # trait Ignore {\n/// fn from_str\u003c'a, T\u003e(s: \u0026'a str) -\u003e Result\u003cT\u003e\n/// where\n///     T: Deserialize\u003c'a\u003e;\n///\n/// fn from_reader\u003cR, T\u003e(rdr: R) -\u003e Result\u003cT\u003e\n/// where\n///     R: Read,\n///     T: DeserializeOwned;\n/// # }\n/// ```\n///\n/// # Lifetime\n///\n/// The relationship between `Deserialize` and `DeserializeOwned` in trait\n/// bounds is explained in more detail on the page [Understanding deserializer\n/// lifetimes].\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\npub trait DeserializeOwned: for\u003c'de\u003e Deserialize\u003c'de\u003e {}\nimpl\u003cT\u003e DeserializeOwned for T where T: for\u003c'de\u003e Deserialize\u003c'de\u003e {}\n\n/// `DeserializeSeed` is the stateful form of the `Deserialize` trait. If you\n/// ever find yourself looking for a way to pass data into a `Deserialize` impl,\n/// this trait is the way to do it.\n///\n/// As one example of stateful deserialization consider deserializing a JSON\n/// array into an existing buffer. Using the `Deserialize` trait we could\n/// deserialize a JSON array into a `Vec\u003cT\u003e` but it would be a freshly allocated\n/// `Vec\u003cT\u003e`; there is no way for `Deserialize` to reuse a previously allocated\n/// buffer. Using `DeserializeSeed` instead makes this possible as in the\n/// example code below.\n///\n/// The canonical API for stateless deserialization looks like this:\n///\n/// ```edition2018\n/// # use serde::Deserialize;\n/// #\n/// # enum Error {}\n/// #\n/// fn func\u003c'de, T: Deserialize\u003c'de\u003e\u003e() -\u003e Result\u003cT, Error\u003e\n/// # {\n/// #     unimplemented!()\n/// # }\n/// ```\n///\n/// Adjusting an API like this to support stateful deserialization is a matter\n/// of accepting a seed as input:\n///\n/// ```edition2018\n/// # use serde::de::DeserializeSeed;\n/// #\n/// # enum Error {}\n/// #\n/// fn func_seed\u003c'de, T: DeserializeSeed\u003c'de\u003e\u003e(seed: T) -\u003e Result\u003cT::Value, Error\u003e\n/// # {\n/// #     let _ = seed;\n/// #     unimplemented!()\n/// # }\n/// ```\n///\n/// In practice the majority of deserialization is stateless. An API expecting a\n/// seed can be appeased by passing `std::marker::PhantomData` as a seed in the\n/// case of stateless deserialization.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by `Self::Value` when deserialized. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example\n///\n/// Suppose we have JSON that looks like `[[1, 2], [3, 4, 5], [6]]` and we need\n/// to deserialize it into a flat representation like `vec![1, 2, 3, 4, 5, 6]`.\n/// Allocating a brand new `Vec\u003cT\u003e` for each subarray would be slow. Instead we\n/// would like to allocate a single `Vec\u003cT\u003e` and then deserialize each subarray\n/// into it. This requires stateful deserialization using the `DeserializeSeed`\n/// trait.\n///\n/// ```edition2018\n/// use std::fmt;\n/// use std::marker::PhantomData;\n///\n/// use serde::de::{Deserialize, DeserializeSeed, Deserializer, SeqAccess, Visitor};\n///\n/// // A DeserializeSeed implementation that uses stateful deserialization to\n/// // append array elements onto the end of an existing vector. The preexisting\n/// // state (\"seed\") in this case is the Vec\u003cT\u003e. The `deserialize` method of\n/// // `ExtendVec` will be traversing the inner arrays of the JSON input and\n/// // appending each integer into the existing Vec.\n/// struct ExtendVec\u003c'a, T: 'a\u003e(\u0026'a mut Vec\u003cT\u003e);\n///\n/// impl\u003c'de, 'a, T\u003e DeserializeSeed\u003c'de\u003e for ExtendVec\u003c'a, T\u003e\n/// where\n///     T: Deserialize\u003c'de\u003e,\n/// {\n///     // The return type of the `deserialize` method. This implementation\n///     // appends onto an existing vector but does not create any new data\n///     // structure, so the return type is ().\n///     type Value = ();\n///\n///     fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n///     where\n///         D: Deserializer\u003c'de\u003e,\n///     {\n///         // Visitor implementation that will walk an inner array of the JSON\n///         // input.\n///         struct ExtendVecVisitor\u003c'a, T: 'a\u003e(\u0026'a mut Vec\u003cT\u003e);\n///\n///         impl\u003c'de, 'a, T\u003e Visitor\u003c'de\u003e for ExtendVecVisitor\u003c'a, T\u003e\n///         where\n///             T: Deserialize\u003c'de\u003e,\n///         {\n///             type Value = ();\n///\n///             fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n///                 write!(formatter, \"an array of integers\")\n///             }\n///\n///             fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003c(), A::Error\u003e\n///             where\n///                 A: SeqAccess\u003c'de\u003e,\n///             {\n///                 // Visit each element in the inner array and push it onto\n///                 // the existing vector.\n///                 while let Some(elem) = seq.next_element()? {\n///                     self.0.push(elem);\n///                 }\n///                 Ok(())\n///             }\n///         }\n///\n///         deserializer.deserialize_seq(ExtendVecVisitor(self.0))\n///     }\n/// }\n///\n/// // Visitor implementation that will walk the outer array of the JSON input.\n/// struct FlattenedVecVisitor\u003cT\u003e(PhantomData\u003cT\u003e);\n///\n/// impl\u003c'de, T\u003e Visitor\u003c'de\u003e for FlattenedVecVisitor\u003cT\u003e\n/// where\n///     T: Deserialize\u003c'de\u003e,\n/// {\n///     // This Visitor constructs a single Vec\u003cT\u003e to hold the flattened\n///     // contents of the inner arrays.\n///     type Value = Vec\u003cT\u003e;\n///\n///     fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n///         write!(formatter, \"an array of arrays\")\n///     }\n///\n///     fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cVec\u003cT\u003e, A::Error\u003e\n///     where\n///         A: SeqAccess\u003c'de\u003e,\n///     {\n///         // Create a single Vec to hold the flattened contents.\n///         let mut vec = Vec::new();\n///\n///         // Each iteration through this loop is one inner array.\n///         while let Some(()) = seq.next_element_seed(ExtendVec(\u0026mut vec))? {\n///             // Nothing to do; inner array has been appended into `vec`.\n///         }\n///\n///         // Return the finished vec.\n///         Ok(vec)\n///     }\n/// }\n///\n/// # fn example\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003c(), D::Error\u003e\n/// # where\n/// #     D: Deserializer\u003c'de\u003e,\n/// # {\n/// let visitor = FlattenedVecVisitor(PhantomData);\n/// let flattened: Vec\u003cu64\u003e = deserializer.deserialize_seq(visitor)?;\n/// #     Ok(())\n/// # }\n/// ```\npub trait DeserializeSeed\u003c'de\u003e: Sized {\n    /// The type produced by using this seed.\n    type Value;\n\n    /// Equivalent to the more common `Deserialize::deserialize` method, except\n    /// with some initial piece of data (the seed) passed in.\n    fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e;\n}\n\nimpl\u003c'de, T\u003e DeserializeSeed\u003c'de\u003e for PhantomData\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    type Value = T;\n\n    #[inline]\n    fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cT, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(deserializer)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A **data format** that can deserialize any data structure supported by\n/// Serde.\n///\n/// The role of this trait is to define the deserialization half of the [Serde\n/// data model], which is a way to categorize every Rust data type into one of\n/// 29 possible types. Each method of the `Deserializer` trait corresponds to one\n/// of the types of the data model.\n///\n/// Implementations of `Deserialize` map themselves into this data model by\n/// passing to the `Deserializer` a `Visitor` implementation that can receive\n/// these various types.\n///\n/// The types that make up the Serde data model are:\n///\n///  - **14 primitive types**\n///    - bool\n///    - i8, i16, i32, i64, i128\n///    - u8, u16, u32, u64, u128\n///    - f32, f64\n///    - char\n///  - **string**\n///    - UTF-8 bytes with a length and no null terminator.\n///    - When serializing, all strings are handled equally. When deserializing,\n///      there are three flavors of strings: transient, owned, and borrowed.\n///  - **byte array** - \\[u8\\]\n///    - Similar to strings, during deserialization byte arrays can be\n///      transient, owned, or borrowed.\n///  - **option**\n///    - Either none or some value.\n///  - **unit**\n///    - The type of `()` in Rust. It represents an anonymous value containing\n///      no data.\n///  - **unit_struct**\n///    - For example `struct Unit` or `PhantomData\u003cT\u003e`. It represents a named\n///      value containing no data.\n///  - **unit_variant**\n///    - For example the `E::A` and `E::B` in `enum E { A, B }`.\n///  - **newtype_struct**\n///    - For example `struct Millimeters(u8)`.\n///  - **newtype_variant**\n///    - For example the `E::N` in `enum E { N(u8) }`.\n///  - **seq**\n///    - A variably sized heterogeneous sequence of values, for example `Vec\u003cT\u003e`\n///      or `HashSet\u003cT\u003e`. When serializing, the length may or may not be known\n///      before iterating through all the data. When deserializing, the length\n///      is determined by looking at the serialized data.\n///  - **tuple**\n///    - A statically sized heterogeneous sequence of values for which the\n///      length will be known at deserialization time without looking at the\n///      serialized data, for example `(u8,)` or `(String, u64, Vec\u003cT\u003e)` or\n///      `[u64; 10]`.\n///  - **tuple_struct**\n///    - A named tuple, for example `struct Rgb(u8, u8, u8)`.\n///  - **tuple_variant**\n///    - For example the `E::T` in `enum E { T(u8, u8) }`.\n///  - **map**\n///    - A heterogeneous key-value pairing, for example `BTreeMap\u003cK, V\u003e`.\n///  - **struct**\n///    - A heterogeneous key-value pairing in which the keys are strings and\n///      will be known at deserialization time without looking at the serialized\n///      data, for example `struct S { r: u8, g: u8, b: u8 }`.\n///  - **struct_variant**\n///    - For example the `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`.\n///\n/// The `Deserializer` trait supports two entry point styles which enables\n/// different kinds of deserialization.\n///\n/// 1. The `deserialize` method. Self-describing data formats like JSON are able\n///    to look at the serialized data and tell what it represents. For example\n///    the JSON deserializer may see an opening curly brace (`{`) and know that\n///    it is seeing a map. If the data format supports\n///    `Deserializer::deserialize_any`, it will drive the Visitor using whatever\n///    type it sees in the input. JSON uses this approach when deserializing\n///    `serde_json::Value` which is an enum that can represent any JSON\n///    document. Without knowing what is in a JSON document, we can deserialize\n///    it to `serde_json::Value` by going through\n///    `Deserializer::deserialize_any`.\n///\n/// 2. The various `deserialize_*` methods. Non-self-describing formats like\n///    Bincode need to be told what is in the input in order to deserialize it.\n///    The `deserialize_*` methods are hints to the deserializer for how to\n///    interpret the next piece of input. Non-self-describing formats are not\n///    able to deserialize something like `serde_json::Value` which relies on\n///    `Deserializer::deserialize_any`.\n///\n/// When implementing `Deserialize`, you should avoid relying on\n/// `Deserializer::deserialize_any` unless you need to be told by the\n/// Deserializer what type is in the input. Know that relying on\n/// `Deserializer::deserialize_any` means your data type will be able to\n/// deserialize from self-describing formats only, ruling out Bincode and many\n/// others.\n///\n/// [Serde data model]: https://serde.rs/data-model.html\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed from the input when deserializing. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website contains example code for\n/// a basic JSON `Deserializer`.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait Deserializer\u003c'de\u003e: Sized {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization.\n    type Error: Error;\n\n    /// Require the `Deserializer` to figure out how to drive the visitor based\n    /// on what data type is in the input.\n    ///\n    /// When implementing `Deserialize`, you should avoid relying on\n    /// `Deserializer::deserialize_any` unless you need to be told by the\n    /// Deserializer what type is in the input. Know that relying on\n    /// `Deserializer::deserialize_any` means your data type will be able to\n    /// deserialize from self-describing formats only, ruling out Bincode and\n    /// many others.\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a `bool` value.\n    fn deserialize_bool\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting an `i8` value.\n    fn deserialize_i8\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting an `i16` value.\n    fn deserialize_i16\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting an `i32` value.\n    fn deserialize_i32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting an `i64` value.\n    fn deserialize_i64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    serde_if_integer128! {\n        /// Hint that the `Deserialize` type is expecting an `i128` value.\n        ///\n        /// This method is available only on Rust compiler versions \u003e=1.26. The\n        /// default behavior unconditionally returns an error.\n        fn deserialize_i128\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e\n        {\n            let _ = visitor;\n            Err(Error::custom(\"i128 is not supported\"))\n        }\n    }\n\n    /// Hint that the `Deserialize` type is expecting a `u8` value.\n    fn deserialize_u8\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a `u16` value.\n    fn deserialize_u16\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a `u32` value.\n    fn deserialize_u32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a `u64` value.\n    fn deserialize_u64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    serde_if_integer128! {\n        /// Hint that the `Deserialize` type is expecting an `u128` value.\n        ///\n        /// This method is available only on Rust compiler versions \u003e=1.26. The\n        /// default behavior unconditionally returns an error.\n        fn deserialize_u128\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e\n        {\n            let _ = visitor;\n            Err(Error::custom(\"u128 is not supported\"))\n        }\n    }\n\n    /// Hint that the `Deserialize` type is expecting a `f32` value.\n    fn deserialize_f32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a `f64` value.\n    fn deserialize_f64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a `char` value.\n    fn deserialize_char\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a string value and does\n    /// not benefit from taking ownership of buffered data owned by the\n    /// `Deserializer`.\n    ///\n    /// If the `Visitor` would benefit from taking ownership of `String` data,\n    /// indiciate this to the `Deserializer` by using `deserialize_string`\n    /// instead.\n    fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a string value and would\n    /// benefit from taking ownership of buffered data owned by the\n    /// `Deserializer`.\n    ///\n    /// If the `Visitor` would not benefit from taking ownership of `String`\n    /// data, indicate that to the `Deserializer` by using `deserialize_str`\n    /// instead.\n    fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a byte array and does not\n    /// benefit from taking ownership of buffered data owned by the\n    /// `Deserializer`.\n    ///\n    /// If the `Visitor` would benefit from taking ownership of `Vec\u003cu8\u003e` data,\n    /// indicate this to the `Deserializer` by using `deserialize_byte_buf`\n    /// instead.\n    fn deserialize_bytes\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a byte array and would\n    /// benefit from taking ownership of buffered data owned by the\n    /// `Deserializer`.\n    ///\n    /// If the `Visitor` would not benefit from taking ownership of `Vec\u003cu8\u003e`\n    /// data, indicate that to the `Deserializer` by using `deserialize_bytes`\n    /// instead.\n    fn deserialize_byte_buf\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting an optional value.\n    ///\n    /// This allows deserializers that encode an optional value as a nullable\n    /// value to convert the null value into `None` and a regular value into\n    /// `Some(value)`.\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a unit value.\n    fn deserialize_unit\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a unit struct with a\n    /// particular name.\n    fn deserialize_unit_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a newtype struct with a\n    /// particular name.\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a sequence of values.\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a sequence of values and\n    /// knows how many values there are without looking at the serialized data.\n    fn deserialize_tuple\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a tuple struct with a\n    /// particular name and number of fields.\n    fn deserialize_tuple_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        len: usize,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a map of key-value pairs.\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting a struct with a particular\n    /// name and fields.\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting an enum value with a\n    /// particular name and possible variants.\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type is expecting the name of a struct\n    /// field or the discriminant of an enum variant.\n    fn deserialize_identifier\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Hint that the `Deserialize` type needs to deserialize a value whose type\n    /// doesn't matter because it is ignored.\n    ///\n    /// Deserializers for non-self-describing formats may not support this mode.\n    fn deserialize_ignored_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Determine whether `Deserialize` implementations should expect to\n    /// deserialize their human-readable form.\n    ///\n    /// Some types have a human-readable form that may be somewhat expensive to\n    /// construct, as well as a binary form that is compact and efficient.\n    /// Generally text-based formats like JSON and YAML will prefer to use the\n    /// human-readable one and binary formats like Bincode will prefer the\n    /// compact one.\n    ///\n    /// ```edition2018\n    /// # use std::ops::Add;\n    /// # use std::str::FromStr;\n    /// #\n    /// # struct Timestamp;\n    /// #\n    /// # impl Timestamp {\n    /// #     const EPOCH: Timestamp = Timestamp;\n    /// # }\n    /// #\n    /// # impl FromStr for Timestamp {\n    /// #     type Err = String;\n    /// #     fn from_str(_: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// # struct Duration;\n    /// #\n    /// # impl Duration {\n    /// #     fn seconds(_: u64) -\u003e Self { unimplemented!() }\n    /// # }\n    /// #\n    /// # impl Add\u003cDuration\u003e for Timestamp {\n    /// #     type Output = Timestamp;\n    /// #     fn add(self, _: Duration) -\u003e Self::Output {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// use serde::de::{self, Deserialize, Deserializer};\n    ///\n    /// impl\u003c'de\u003e Deserialize\u003c'de\u003e for Timestamp {\n    ///     fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    ///     where\n    ///         D: Deserializer\u003c'de\u003e,\n    ///     {\n    ///         if deserializer.is_human_readable() {\n    ///             // Deserialize from a human-readable string like \"2015-05-15T17:01:00Z\".\n    ///             let s = String::deserialize(deserializer)?;\n    ///             Timestamp::from_str(\u0026s).map_err(de::Error::custom)\n    ///         } else {\n    ///             // Deserialize from a compact binary representation, seconds since\n    ///             // the Unix epoch.\n    ///             let n = u64::deserialize(deserializer)?;\n    ///             Ok(Timestamp::EPOCH + Duration::seconds(n))\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// The default implementation of this method returns `true`. Data formats\n    /// may override this to `false` to request a compact form for types that\n    /// support one. Note that modifying this method to change a format from\n    /// human-readable to compact or vice versa should be regarded as a breaking\n    /// change, as a value serialized in human-readable mode is not required to\n    /// deserialize from the same data in compact mode.\n    #[inline]\n    fn is_human_readable(\u0026self) -\u003e bool {\n        true\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// This trait represents a visitor that walks through a deserializer.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the requirement for lifetime of data\n/// that may be borrowed by `Self::Value`. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example\n///\n/// ```edition2018\n/// # use std::fmt;\n/// #\n/// # use serde::de::{self, Unexpected, Visitor};\n/// #\n/// /// A visitor that deserializes a long string - a string containing at least\n/// /// some minimum number of bytes.\n/// struct LongString {\n///     min: usize,\n/// }\n///\n/// impl\u003c'de\u003e Visitor\u003c'de\u003e for LongString {\n///     type Value = String;\n///\n///     fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n///         write!(formatter, \"a string containing at least {} bytes\", self.min)\n///     }\n///\n///     fn visit_str\u003cE\u003e(self, s: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n///     where\n///         E: de::Error,\n///     {\n///         if s.len() \u003e= self.min {\n///             Ok(s.to_owned())\n///         } else {\n///             Err(de::Error::invalid_value(Unexpected::Str(s), \u0026self))\n///         }\n///     }\n/// }\n/// ```\npub trait Visitor\u003c'de\u003e: Sized {\n    /// The value produced by this visitor.\n    type Value;\n\n    /// Format a message stating what data this Visitor expects to receive.\n    ///\n    /// This is used in error messages. The message should complete the sentence\n    /// \"This Visitor expects to receive ...\", for example the message could be\n    /// \"an integer between 0 and 64\". The message should not be capitalized and\n    /// should not end with a period.\n    ///\n    /// ```edition2018\n    /// # use std::fmt;\n    /// #\n    /// # struct S {\n    /// #     max: usize,\n    /// # }\n    /// #\n    /// # impl\u003c'de\u003e serde::de::Visitor\u003c'de\u003e for S {\n    /// #     type Value = ();\n    /// #\n    /// fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    ///     write!(formatter, \"an integer between 0 and {}\", self.max)\n    /// }\n    /// # }\n    /// ```\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result;\n\n    /// The input contains a boolean.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_bool\u003cE\u003e(self, v: bool) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Bool(v), \u0026self))\n    }\n\n    /// The input contains an `i8`.\n    ///\n    /// The default implementation forwards to [`visit_i64`].\n    ///\n    /// [`visit_i64`]: #method.visit_i64\n    fn visit_i8\u003cE\u003e(self, v: i8) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n\n    /// The input contains an `i16`.\n    ///\n    /// The default implementation forwards to [`visit_i64`].\n    ///\n    /// [`visit_i64`]: #method.visit_i64\n    fn visit_i16\u003cE\u003e(self, v: i16) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n\n    /// The input contains an `i32`.\n    ///\n    /// The default implementation forwards to [`visit_i64`].\n    ///\n    /// [`visit_i64`]: #method.visit_i64\n    fn visit_i32\u003cE\u003e(self, v: i32) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_i64(v as i64)\n    }\n\n    /// The input contains an `i64`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_i64\u003cE\u003e(self, v: i64) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Signed(v), \u0026self))\n    }\n\n    serde_if_integer128! {\n        /// The input contains a `i128`.\n        ///\n        /// This method is available only on Rust compiler versions \u003e=1.26. The\n        /// default implementation fails with a type error.\n        fn visit_i128\u003cE\u003e(self, v: i128) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            let _ = v;\n            Err(Error::invalid_type(Unexpected::Other(\"i128\"), \u0026self))\n        }\n    }\n\n    /// The input contains a `u8`.\n    ///\n    /// The default implementation forwards to [`visit_u64`].\n    ///\n    /// [`visit_u64`]: #method.visit_u64\n    fn visit_u8\u003cE\u003e(self, v: u8) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n\n    /// The input contains a `u16`.\n    ///\n    /// The default implementation forwards to [`visit_u64`].\n    ///\n    /// [`visit_u64`]: #method.visit_u64\n    fn visit_u16\u003cE\u003e(self, v: u16) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n\n    /// The input contains a `u32`.\n    ///\n    /// The default implementation forwards to [`visit_u64`].\n    ///\n    /// [`visit_u64`]: #method.visit_u64\n    fn visit_u32\u003cE\u003e(self, v: u32) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_u64(v as u64)\n    }\n\n    /// The input contains a `u64`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_u64\u003cE\u003e(self, v: u64) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Unsigned(v), \u0026self))\n    }\n\n    serde_if_integer128! {\n        /// The input contains a `u128`.\n        ///\n        /// This method is available only on Rust compiler versions \u003e=1.26. The\n        /// default implementation fails with a type error.\n        fn visit_u128\u003cE\u003e(self, v: u128) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            let _ = v;\n            Err(Error::invalid_type(Unexpected::Other(\"u128\"), \u0026self))\n        }\n    }\n\n    /// The input contains an `f32`.\n    ///\n    /// The default implementation forwards to [`visit_f64`].\n    ///\n    /// [`visit_f64`]: #method.visit_f64\n    fn visit_f32\u003cE\u003e(self, v: f32) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_f64(v as f64)\n    }\n\n    /// The input contains an `f64`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_f64\u003cE\u003e(self, v: f64) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Float(v), \u0026self))\n    }\n\n    /// The input contains a `char`.\n    ///\n    /// The default implementation forwards to [`visit_str`] as a one-character\n    /// string.\n    ///\n    /// [`visit_str`]: #method.visit_str\n    #[inline]\n    fn visit_char\u003cE\u003e(self, v: char) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_str(utf8::encode(v).as_str())\n    }\n\n    /// The input contains a string. The lifetime of the string is ephemeral and\n    /// it may be destroyed after this method returns.\n    ///\n    /// This method allows the `Deserializer` to avoid a copy by retaining\n    /// ownership of any buffered data. `Deserialize` implementations that do\n    /// not benefit from taking ownership of `String` data should indicate that\n    /// to the deserializer by using `Deserializer::deserialize_str` rather than\n    /// `Deserializer::deserialize_string`.\n    ///\n    /// It is never correct to implement `visit_string` without implementing\n    /// `visit_str`. Implement neither, both, or just `visit_str`.\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Str(v), \u0026self))\n    }\n\n    /// The input contains a string that lives at least as long as the\n    /// `Deserializer`.\n    ///\n    /// This enables zero-copy deserialization of strings in some formats. For\n    /// example JSON input containing the JSON string `\"borrowed\"` can be\n    /// deserialized with zero copying into a `\u0026'a str` as long as the input\n    /// data outlives `'a`.\n    ///\n    /// The default implementation forwards to `visit_str`.\n    #[inline]\n    fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'de str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_str(v)\n    }\n\n    /// The input contains a string and ownership of the string is being given\n    /// to the `Visitor`.\n    ///\n    /// This method allows the `Visitor` to avoid a copy by taking ownership of\n    /// a string created by the `Deserializer`. `Deserialize` implementations\n    /// that benefit from taking ownership of `String` data should indicate that\n    /// to the deserializer by using `Deserializer::deserialize_string` rather\n    /// than `Deserializer::deserialize_str`, although not every deserializer\n    /// will honor such a request.\n    ///\n    /// It is never correct to implement `visit_string` without implementing\n    /// `visit_str`. Implement neither, both, or just `visit_str`.\n    ///\n    /// The default implementation forwards to `visit_str` and then drops the\n    /// `String`.\n    #[inline]\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_str(\u0026v)\n    }\n\n    /// The input contains a byte array. The lifetime of the byte array is\n    /// ephemeral and it may be destroyed after this method returns.\n    ///\n    /// This method allows the `Deserializer` to avoid a copy by retaining\n    /// ownership of any buffered data. `Deserialize` implementations that do\n    /// not benefit from taking ownership of `Vec\u003cu8\u003e` data should indicate that\n    /// to the deserializer by using `Deserializer::deserialize_bytes` rather\n    /// than `Deserializer::deserialize_byte_buf`.\n    ///\n    /// It is never correct to implement `visit_byte_buf` without implementing\n    /// `visit_bytes`. Implement neither, both, or just `visit_bytes`.\n    fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        let _ = v;\n        Err(Error::invalid_type(Unexpected::Bytes(v), \u0026self))\n    }\n\n    /// The input contains a byte array that lives at least as long as the\n    /// `Deserializer`.\n    ///\n    /// This enables zero-copy deserialization of bytes in some formats. For\n    /// example Bincode data containing bytes can be deserialized with zero\n    /// copying into a `\u0026'a [u8]` as long as the input data outlives `'a`.\n    ///\n    /// The default implementation forwards to `visit_bytes`.\n    #[inline]\n    fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'de [u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_bytes(v)\n    }\n\n    /// The input contains a byte array and ownership of the byte array is being\n    /// given to the `Visitor`.\n    ///\n    /// This method allows the `Visitor` to avoid a copy by taking ownership of\n    /// a byte buffer created by the `Deserializer`. `Deserialize`\n    /// implementations that benefit from taking ownership of `Vec\u003cu8\u003e` data\n    /// should indicate that to the deserializer by using\n    /// `Deserializer::deserialize_byte_buf` rather than\n    /// `Deserializer::deserialize_bytes`, although not every deserializer will\n    /// honor such a request.\n    ///\n    /// It is never correct to implement `visit_byte_buf` without implementing\n    /// `visit_bytes`. Implement neither, both, or just `visit_bytes`.\n    ///\n    /// The default implementation forwards to `visit_bytes` and then drops the\n    /// `Vec\u003cu8\u003e`.\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        self.visit_bytes(\u0026v)\n    }\n\n    /// The input contains an optional that is absent.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_none\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Option, \u0026self))\n    }\n\n    /// The input contains an optional that is present.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let _ = deserializer;\n        Err(Error::invalid_type(Unexpected::Option, \u0026self))\n    }\n\n    /// The input contains a unit `()`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Err(Error::invalid_type(Unexpected::Unit, \u0026self))\n    }\n\n    /// The input contains a newtype struct.\n    ///\n    /// The content of the newtype struct may be read from the given\n    /// `Deserializer`.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_newtype_struct\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let _ = deserializer;\n        Err(Error::invalid_type(Unexpected::NewtypeStruct, \u0026self))\n    }\n\n    /// The input contains a sequence of elements.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_seq\u003cA\u003e(self, seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: SeqAccess\u003c'de\u003e,\n    {\n        let _ = seq;\n        Err(Error::invalid_type(Unexpected::Seq, \u0026self))\n    }\n\n    /// The input contains a key-value map.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_map\u003cA\u003e(self, map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: MapAccess\u003c'de\u003e,\n    {\n        let _ = map;\n        Err(Error::invalid_type(Unexpected::Map, \u0026self))\n    }\n\n    /// The input contains an enum.\n    ///\n    /// The default implementation fails with a type error.\n    fn visit_enum\u003cA\u003e(self, data: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n    where\n        A: EnumAccess\u003c'de\u003e,\n    {\n        let _ = data;\n        Err(Error::invalid_type(Unexpected::Enum, \u0026self))\n    }\n\n    // Used when deserializing a flattened Option field. Not public API.\n    #[doc(hidden)]\n    fn __private_visit_untagged_option\u003cD\u003e(self, _: D) -\u003e Result\u003cSelf::Value, ()\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Err(())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Provides a `Visitor` access to each element of a sequence in the input.\n///\n/// This is a trait that a `Deserializer` passes to a `Visitor` implementation,\n/// which deserializes each item in a sequence.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by deserialized sequence elements. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SeqAccess` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SeqAccess\u003c'de\u003e {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization.\n    type Error: Error;\n\n    /// This returns `Ok(Some(value))` for the next value in the sequence, or\n    /// `Ok(None)` if there are no more remaining items.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `SeqAccess::next_element` instead.\n    fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e;\n\n    /// This returns `Ok(Some(value))` for the next value in the sequence, or\n    /// `Ok(None)` if there are no more remaining items.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `SeqAccess` implementations should not override the default behavior.\n    #[inline]\n    fn next_element\u003cT\u003e(\u0026mut self) -\u003e Result\u003cOption\u003cT\u003e, Self::Error\u003e\n    where\n        T: Deserialize\u003c'de\u003e,\n    {\n        self.next_element_seed(PhantomData)\n    }\n\n    /// Returns the number of elements remaining in the sequence, if known.\n    #[inline]\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        None\n    }\n}\n\nimpl\u003c'de, 'a, A\u003e SeqAccess\u003c'de\u003e for \u0026'a mut A\nwhere\n    A: SeqAccess\u003c'de\u003e,\n{\n    type Error = A::Error;\n\n    #[inline]\n    fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        (**self).next_element_seed(seed)\n    }\n\n    #[inline]\n    fn next_element\u003cT\u003e(\u0026mut self) -\u003e Result\u003cOption\u003cT\u003e, Self::Error\u003e\n    where\n        T: Deserialize\u003c'de\u003e,\n    {\n        (**self).next_element()\n    }\n\n    #[inline]\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        (**self).size_hint()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Provides a `Visitor` access to each entry of a map in the input.\n///\n/// This is a trait that a `Deserializer` passes to a `Visitor` implementation.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by deserialized map entries. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `MapAccess` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait MapAccess\u003c'de\u003e {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization.\n    type Error: Error;\n\n    /// This returns `Ok(Some(key))` for the next key in the map, or `Ok(None)`\n    /// if there are no more remaining entries.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `MapAccess::next_key` or `MapAccess::next_entry` instead.\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e;\n\n    /// This returns a `Ok(value)` for the next value in the map.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `MapAccess::next_value` instead.\n    ///\n    /// # Panics\n    ///\n    /// Calling `next_value_seed` before `next_key_seed` is incorrect and is\n    /// allowed to panic or return bogus results.\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e;\n\n    /// This returns `Ok(Some((key, value)))` for the next (key-value) pair in\n    /// the map, or `Ok(None)` if there are no more remaining items.\n    ///\n    /// `MapAccess` implementations should override the default behavior if a\n    /// more efficient implementation is possible.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `MapAccess::next_entry` instead.\n    #[inline]\n    fn next_entry_seed\u003cK, V\u003e(\n        \u0026mut self,\n        kseed: K,\n        vseed: V,\n    ) -\u003e Result\u003cOption\u003c(K::Value, V::Value)\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        match try!(self.next_key_seed(kseed)) {\n            Some(key) =\u003e {\n                let value = try!(self.next_value_seed(vseed));\n                Ok(Some((key, value)))\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    /// This returns `Ok(Some(key))` for the next key in the map, or `Ok(None)`\n    /// if there are no more remaining entries.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `MapAccess` implementations should not override the default behavior.\n    #[inline]\n    fn next_key\u003cK\u003e(\u0026mut self) -\u003e Result\u003cOption\u003cK\u003e, Self::Error\u003e\n    where\n        K: Deserialize\u003c'de\u003e,\n    {\n        self.next_key_seed(PhantomData)\n    }\n\n    /// This returns a `Ok(value)` for the next value in the map.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `MapAccess` implementations should not override the default behavior.\n    ///\n    /// # Panics\n    ///\n    /// Calling `next_value` before `next_key` is incorrect and is allowed to\n    /// panic or return bogus results.\n    #[inline]\n    fn next_value\u003cV\u003e(\u0026mut self) -\u003e Result\u003cV, Self::Error\u003e\n    where\n        V: Deserialize\u003c'de\u003e,\n    {\n        self.next_value_seed(PhantomData)\n    }\n\n    /// This returns `Ok(Some((key, value)))` for the next (key-value) pair in\n    /// the map, or `Ok(None)` if there are no more remaining items.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `MapAccess` implementations should not override the default behavior.\n    #[inline]\n    fn next_entry\u003cK, V\u003e(\u0026mut self) -\u003e Result\u003cOption\u003c(K, V)\u003e, Self::Error\u003e\n    where\n        K: Deserialize\u003c'de\u003e,\n        V: Deserialize\u003c'de\u003e,\n    {\n        self.next_entry_seed(PhantomData, PhantomData)\n    }\n\n    /// Returns the number of entries remaining in the map, if known.\n    #[inline]\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        None\n    }\n}\n\nimpl\u003c'de, 'a, A\u003e MapAccess\u003c'de\u003e for \u0026'a mut A\nwhere\n    A: MapAccess\u003c'de\u003e,\n{\n    type Error = A::Error;\n\n    #[inline]\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n    {\n        (**self).next_key_seed(seed)\n    }\n\n    #[inline]\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        (**self).next_value_seed(seed)\n    }\n\n    #[inline]\n    fn next_entry_seed\u003cK, V\u003e(\n        \u0026mut self,\n        kseed: K,\n        vseed: V,\n    ) -\u003e Result\u003cOption\u003c(K::Value, V::Value)\u003e, Self::Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        (**self).next_entry_seed(kseed, vseed)\n    }\n\n    #[inline]\n    fn next_entry\u003cK, V\u003e(\u0026mut self) -\u003e Result\u003cOption\u003c(K, V)\u003e, Self::Error\u003e\n    where\n        K: Deserialize\u003c'de\u003e,\n        V: Deserialize\u003c'de\u003e,\n    {\n        (**self).next_entry()\n    }\n\n    #[inline]\n    fn next_key\u003cK\u003e(\u0026mut self) -\u003e Result\u003cOption\u003cK\u003e, Self::Error\u003e\n    where\n        K: Deserialize\u003c'de\u003e,\n    {\n        (**self).next_key()\n    }\n\n    #[inline]\n    fn next_value\u003cV\u003e(\u0026mut self) -\u003e Result\u003cV, Self::Error\u003e\n    where\n        V: Deserialize\u003c'de\u003e,\n    {\n        (**self).next_value()\n    }\n\n    #[inline]\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        (**self).size_hint()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Provides a `Visitor` access to the data of an enum in the input.\n///\n/// `EnumAccess` is created by the `Deserializer` and passed to the\n/// `Visitor` in order to identify which variant of an enum to deserialize.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by the deserialized enum variant. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `EnumAccess` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait EnumAccess\u003c'de\u003e: Sized {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization.\n    type Error: Error;\n    /// The `Visitor` that will be used to deserialize the content of the enum\n    /// variant.\n    type Variant: VariantAccess\u003c'de, Error = Self::Error\u003e;\n\n    /// `variant` is called to identify which variant to deserialize.\n    ///\n    /// `Deserialize` implementations should typically use `EnumAccess::variant`\n    /// instead.\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e;\n\n    /// `variant` is called to identify which variant to deserialize.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `EnumAccess` implementations should not override the default behavior.\n    #[inline]\n    fn variant\u003cV\u003e(self) -\u003e Result\u003c(V, Self::Variant), Self::Error\u003e\n    where\n        V: Deserialize\u003c'de\u003e,\n    {\n        self.variant_seed(PhantomData)\n    }\n}\n\n/// `VariantAccess` is a visitor that is created by the `Deserializer` and\n/// passed to the `Deserialize` to deserialize the content of a particular enum\n/// variant.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed by the deserialized enum variant. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `VariantAccess` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait VariantAccess\u003c'de\u003e: Sized {\n    /// The error type that can be returned if some error occurs during\n    /// deserialization. Must match the error type of our `EnumAccess`.\n    type Error: Error;\n\n    /// Called when deserializing a variant with no values.\n    ///\n    /// If the data contains a different type of variant, the following\n    /// `invalid_type` error should be constructed:\n    ///\n    /// ```edition2018\n    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n    /// #\n    /// # struct X;\n    /// #\n    /// # impl\u003c'de\u003e VariantAccess\u003c'de\u003e for X {\n    /// #     type Error = value::Error;\n    /// #\n    /// fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n    ///     // What the data actually contained; suppose it is a tuple variant.\n    ///     let unexp = Unexpected::TupleVariant;\n    ///     Err(de::Error::invalid_type(unexp, \u0026\"unit variant\"))\n    /// }\n    /// #\n    /// #     fn newtype_variant_seed\u003cT\u003e(self, _: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    /// #     where\n    /// #         T: DeserializeSeed\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// #\n    /// #     fn tuple_variant\u003cV\u003e(self, _: usize, _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// #     where\n    /// #         V: Visitor\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// #\n    /// #     fn struct_variant\u003cV\u003e(self, _: \u0026[\u0026str], _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// #     where\n    /// #         V: Visitor\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// # }\n    /// ```\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e;\n\n    /// Called when deserializing a variant with a single value.\n    ///\n    /// `Deserialize` implementations should typically use\n    /// `VariantAccess::newtype_variant` instead.\n    ///\n    /// If the data contains a different type of variant, the following\n    /// `invalid_type` error should be constructed:\n    ///\n    /// ```edition2018\n    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n    /// #\n    /// # struct X;\n    /// #\n    /// # impl\u003c'de\u003e VariantAccess\u003c'de\u003e for X {\n    /// #     type Error = value::Error;\n    /// #\n    /// #     fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n    /// #         unimplemented!()\n    /// #     }\n    /// #\n    /// fn newtype_variant_seed\u003cT\u003e(self, _seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    /// where\n    ///     T: DeserializeSeed\u003c'de\u003e,\n    /// {\n    ///     // What the data actually contained; suppose it is a unit variant.\n    ///     let unexp = Unexpected::UnitVariant;\n    ///     Err(de::Error::invalid_type(unexp, \u0026\"newtype variant\"))\n    /// }\n    /// #\n    /// #     fn tuple_variant\u003cV\u003e(self, _: usize, _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// #     where\n    /// #         V: Visitor\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// #\n    /// #     fn struct_variant\u003cV\u003e(self, _: \u0026[\u0026str], _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// #     where\n    /// #         V: Visitor\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// # }\n    /// ```\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e;\n\n    /// Called when deserializing a variant with a single value.\n    ///\n    /// This method exists as a convenience for `Deserialize` implementations.\n    /// `VariantAccess` implementations should not override the default\n    /// behavior.\n    #[inline]\n    fn newtype_variant\u003cT\u003e(self) -\u003e Result\u003cT, Self::Error\u003e\n    where\n        T: Deserialize\u003c'de\u003e,\n    {\n        self.newtype_variant_seed(PhantomData)\n    }\n\n    /// Called when deserializing a tuple-like variant.\n    ///\n    /// The `len` is the number of fields expected in the tuple variant.\n    ///\n    /// If the data contains a different type of variant, the following\n    /// `invalid_type` error should be constructed:\n    ///\n    /// ```edition2018\n    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n    /// #\n    /// # struct X;\n    /// #\n    /// # impl\u003c'de\u003e VariantAccess\u003c'de\u003e for X {\n    /// #     type Error = value::Error;\n    /// #\n    /// #     fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n    /// #         unimplemented!()\n    /// #     }\n    /// #\n    /// #     fn newtype_variant_seed\u003cT\u003e(self, _: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    /// #     where\n    /// #         T: DeserializeSeed\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// #\n    /// fn tuple_variant\u003cV\u003e(\n    ///     self,\n    ///     _len: usize,\n    ///     _visitor: V,\n    /// ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// where\n    ///     V: Visitor\u003c'de\u003e,\n    /// {\n    ///     // What the data actually contained; suppose it is a unit variant.\n    ///     let unexp = Unexpected::UnitVariant;\n    ///     Err(de::Error::invalid_type(unexp, \u0026\"tuple variant\"))\n    /// }\n    /// #\n    /// #     fn struct_variant\u003cV\u003e(self, _: \u0026[\u0026str], _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// #     where\n    /// #         V: Visitor\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// # }\n    /// ```\n    fn tuple_variant\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n\n    /// Called when deserializing a struct-like variant.\n    ///\n    /// The `fields` are the names of the fields of the struct variant.\n    ///\n    /// If the data contains a different type of variant, the following\n    /// `invalid_type` error should be constructed:\n    ///\n    /// ```edition2018\n    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n    /// #\n    /// # struct X;\n    /// #\n    /// # impl\u003c'de\u003e VariantAccess\u003c'de\u003e for X {\n    /// #     type Error = value::Error;\n    /// #\n    /// #     fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n    /// #         unimplemented!()\n    /// #     }\n    /// #\n    /// #     fn newtype_variant_seed\u003cT\u003e(self, _: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    /// #     where\n    /// #         T: DeserializeSeed\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// #\n    /// #     fn tuple_variant\u003cV\u003e(self, _: usize, _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// #     where\n    /// #         V: Visitor\u003c'de\u003e,\n    /// #     { unimplemented!() }\n    /// #\n    /// fn struct_variant\u003cV\u003e(\n    ///     self,\n    ///     _fields: \u0026'static [\u0026'static str],\n    ///     _visitor: V,\n    /// ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    /// where\n    ///     V: Visitor\u003c'de\u003e,\n    /// {\n    ///     // What the data actually contained; suppose it is a unit variant.\n    ///     let unexp = Unexpected::UnitVariant;\n    ///     Err(de::Error::invalid_type(unexp, \u0026\"struct variant\"))\n    /// }\n    /// # }\n    /// ```\n    fn struct_variant\u003cV\u003e(\n        self,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Converts an existing value into a `Deserializer` from which other values can\n/// be deserialized.\n///\n/// # Lifetime\n///\n/// The `'de` lifetime of this trait is the lifetime of data that may be\n/// borrowed from the resulting `Deserializer`. See the page [Understanding\n/// deserializer lifetimes] for a more detailed explanation of these lifetimes.\n///\n/// [Understanding deserializer lifetimes]: https://serde.rs/lifetimes.html\n///\n/// # Example\n///\n/// ```edition2018\n/// use std::str::FromStr;\n/// use serde::Deserialize;\n/// use serde::de::{value, IntoDeserializer};\n///\n/// #[derive(Deserialize)]\n/// enum Setting {\n///     On,\n///     Off,\n/// }\n///\n/// impl FromStr for Setting {\n///     type Err = value::Error;\n///\n///     fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n///         Self::deserialize(s.into_deserializer())\n///     }\n/// }\n/// ```\npub trait IntoDeserializer\u003c'de, E: Error = value::Error\u003e {\n    /// The type of the deserializer being converted into.\n    type Deserializer: Deserializer\u003c'de, Error = E\u003e;\n\n    /// Convert this value into a deserializer.\n    fn into_deserializer(self) -\u003e Self::Deserializer;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Used in error messages.\n///\n/// - expected `a`\n/// - expected `a` or `b`\n/// - expected one of `a`, `b`, `c`\n///\n/// The slice of names must not be empty.\nstruct OneOf {\n    names: \u0026'static [\u0026'static str],\n}\n\nimpl Display for OneOf {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self.names.len() {\n            0 =\u003e panic!(), // special case elsewhere\n            1 =\u003e write!(formatter, \"`{}`\", self.names[0]),\n            2 =\u003e write!(formatter, \"`{}` or `{}`\", self.names[0], self.names[1]),\n            _ =\u003e {\n                try!(write!(formatter, \"one of \"));\n                for (i, alt) in self.names.iter().enumerate() {\n                    if i \u003e 0 {\n                        try!(write!(formatter, \", \"));\n                    }\n                    try!(write!(formatter, \"`{}`\", alt));\n                }\n                Ok(())\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","utf8.rs"],"content":"use lib::*;\n\nconst TAG_CONT: u8 = 0b1000_0000;\nconst TAG_TWO_B: u8 = 0b1100_0000;\nconst TAG_THREE_B: u8 = 0b1110_0000;\nconst TAG_FOUR_B: u8 = 0b1111_0000;\nconst MAX_ONE_B: u32 = 0x80;\nconst MAX_TWO_B: u32 = 0x800;\nconst MAX_THREE_B: u32 = 0x10000;\n\n#[inline]\npub fn encode(c: char) -\u003e Encode {\n    let code = c as u32;\n    let mut buf = [0; 4];\n    let pos = if code \u003c MAX_ONE_B {\n        buf[3] = code as u8;\n        3\n    } else if code \u003c MAX_TWO_B {\n        buf[2] = (code \u003e\u003e 6 \u0026 0x1F) as u8 | TAG_TWO_B;\n        buf[3] = (code \u0026 0x3F) as u8 | TAG_CONT;\n        2\n    } else if code \u003c MAX_THREE_B {\n        buf[1] = (code \u003e\u003e 12 \u0026 0x0F) as u8 | TAG_THREE_B;\n        buf[2] = (code \u003e\u003e 6 \u0026 0x3F) as u8 | TAG_CONT;\n        buf[3] = (code \u0026 0x3F) as u8 | TAG_CONT;\n        1\n    } else {\n        buf[0] = (code \u003e\u003e 18 \u0026 0x07) as u8 | TAG_FOUR_B;\n        buf[1] = (code \u003e\u003e 12 \u0026 0x3F) as u8 | TAG_CONT;\n        buf[2] = (code \u003e\u003e 6 \u0026 0x3F) as u8 | TAG_CONT;\n        buf[3] = (code \u0026 0x3F) as u8 | TAG_CONT;\n        0\n    };\n    Encode { buf: buf, pos: pos }\n}\n\npub struct Encode {\n    buf: [u8; 4],\n    pos: usize,\n}\n\nimpl Encode {\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        str::from_utf8(\u0026self.buf[self.pos..]).unwrap()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","de","value.rs"],"content":"//! Building blocks for deserializing basic values using the `IntoDeserializer`\n//! trait.\n//!\n//! ```edition2018\n//! use std::str::FromStr;\n//! use serde::Deserialize;\n//! use serde::de::{value, IntoDeserializer};\n//!\n//! #[derive(Deserialize)]\n//! enum Setting {\n//!     On,\n//!     Off,\n//! }\n//!\n//! impl FromStr for Setting {\n//!     type Err = value::Error;\n//!\n//!     fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n//!         Self::deserialize(s.into_deserializer())\n//!     }\n//! }\n//! ```\n\nuse lib::*;\n\nuse self::private::{First, Second};\nuse de::{self, Expected, IntoDeserializer, SeqAccess};\nuse private::de::size_hint;\nuse ser;\n\n////////////////////////////////////////////////////////////////////////////////\n\n// For structs that contain a PhantomData. We do not want the trait\n// bound `E: Clone` inferred by derive(Clone).\nmacro_rules! impl_copy_clone {\n    ($ty:ident $(\u003c$lifetime:tt\u003e)*) =\u003e {\n        impl\u003c$($lifetime,)* E\u003e Copy for $ty\u003c$($lifetime,)* E\u003e {}\n\n        impl\u003c$($lifetime,)* E\u003e Clone for $ty\u003c$($lifetime,)* E\u003e {\n            fn clone(\u0026self) -\u003e Self {\n                *self\n            }\n        }\n    };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A minimal representation of all possible errors that can occur using the\n/// `IntoDeserializer` trait.\n#[derive(Clone, Debug, PartialEq)]\npub struct Error {\n    err: ErrorImpl,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\ntype ErrorImpl = Box\u003cstr\u003e;\n#[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\ntype ErrorImpl = ();\n\nimpl de::Error for Error {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cold]\n    fn custom\u003cT\u003e(msg: T) -\u003e Self\n    where\n        T: Display,\n    {\n        Error {\n            err: msg.to_string().into_boxed_str(),\n        }\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    #[cold]\n    fn custom\u003cT\u003e(msg: T) -\u003e Self\n    where\n        T: Display,\n    {\n        let _ = msg;\n        Error { err: () }\n    }\n}\n\nimpl ser::Error for Error {\n    #[cold]\n    fn custom\u003cT\u003e(msg: T) -\u003e Self\n    where\n        T: Display,\n    {\n        de::Error::custom(msg)\n    }\n}\n\nimpl Display for Error {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e Result\u003c(), fmt::Error\u003e {\n        formatter.write_str(\u0026self.err)\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e Result\u003c(), fmt::Error\u003e {\n        formatter.write_str(\"Serde deserialization error\")\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl error::Error for Error {\n    fn description(\u0026self) -\u003e \u0026str {\n        \u0026self.err\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003c'de, E\u003e IntoDeserializer\u003c'de, E\u003e for ()\nwhere\n    E: de::Error,\n{\n    type Deserializer = UnitDeserializer\u003cE\u003e;\n\n    fn into_deserializer(self) -\u003e UnitDeserializer\u003cE\u003e {\n        UnitDeserializer {\n            marker: PhantomData,\n        }\n    }\n}\n\n/// A deserializer holding a `()`.\n#[derive(Debug)]\npub struct UnitDeserializer\u003cE\u003e {\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl_copy_clone!(UnitDeserializer);\n\nimpl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for UnitDeserializer\u003cE\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf unit unit_struct newtype_struct seq tuple tuple_struct\n        map struct enum identifier ignored_any\n    }\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_unit()\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_none()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer that cannot be instantiated.\n#[cfg(feature = \"unstable\")]\npub struct NeverDeserializer\u003cE\u003e {\n    never: !,\n    marker: PhantomData\u003cE\u003e,\n}\n\n#[cfg(feature = \"unstable\")]\nimpl\u003c'de, E\u003e IntoDeserializer\u003c'de, E\u003e for !\nwhere\n    E: de::Error,\n{\n    type Deserializer = NeverDeserializer\u003cE\u003e;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        self\n    }\n}\n\n#[cfg(feature = \"unstable\")]\nimpl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for NeverDeserializer\u003cE\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        self.never\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! primitive_deserializer {\n    ($ty:ty, $doc:tt, $name:ident, $method:ident $($cast:tt)*) =\u003e {\n        #[doc = \"A deserializer holding\"]\n        #[doc = $doc]\n        #[derive(Debug)]\n        pub struct $name\u003cE\u003e {\n            value: $ty,\n            marker: PhantomData\u003cE\u003e\n        }\n\n        impl_copy_clone!($name);\n\n        impl\u003c'de, E\u003e IntoDeserializer\u003c'de, E\u003e for $ty\n        where\n            E: de::Error,\n        {\n            type Deserializer = $name\u003cE\u003e;\n\n            fn into_deserializer(self) -\u003e $name\u003cE\u003e {\n                $name {\n                    value: self,\n                    marker: PhantomData,\n                }\n            }\n        }\n\n        impl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for $name\u003cE\u003e\n        where\n            E: de::Error,\n        {\n            type Error = E;\n\n            forward_to_deserialize_any! {\n                bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str\n                string bytes byte_buf option unit unit_struct newtype_struct seq\n                tuple tuple_struct map struct enum identifier ignored_any\n            }\n\n            fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n            where\n                V: de::Visitor\u003c'de\u003e,\n            {\n                visitor.$method(self.value $($cast)*)\n            }\n        }\n    }\n}\n\nprimitive_deserializer!(bool, \"a `bool`.\", BoolDeserializer, visit_bool);\nprimitive_deserializer!(i8, \"an `i8`.\", I8Deserializer, visit_i8);\nprimitive_deserializer!(i16, \"an `i16`.\", I16Deserializer, visit_i16);\nprimitive_deserializer!(i32, \"an `i32`.\", I32Deserializer, visit_i32);\nprimitive_deserializer!(i64, \"an `i64`.\", I64Deserializer, visit_i64);\nprimitive_deserializer!(isize, \"an `isize`.\", IsizeDeserializer, visit_i64 as i64);\nprimitive_deserializer!(u8, \"a `u8`.\", U8Deserializer, visit_u8);\nprimitive_deserializer!(u16, \"a `u16`.\", U16Deserializer, visit_u16);\nprimitive_deserializer!(u64, \"a `u64`.\", U64Deserializer, visit_u64);\nprimitive_deserializer!(usize, \"a `usize`.\", UsizeDeserializer, visit_u64 as u64);\nprimitive_deserializer!(f32, \"an `f32`.\", F32Deserializer, visit_f32);\nprimitive_deserializer!(f64, \"an `f64`.\", F64Deserializer, visit_f64);\nprimitive_deserializer!(char, \"a `char`.\", CharDeserializer, visit_char);\n\nserde_if_integer128! {\n    primitive_deserializer!(i128, \"an `i128`.\", I128Deserializer, visit_i128);\n    primitive_deserializer!(u128, \"a `u128`.\", U128Deserializer, visit_u128);\n}\n\n/// A deserializer holding a `u32`.\n#[derive(Debug)]\npub struct U32Deserializer\u003cE\u003e {\n    value: u32,\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl_copy_clone!(U32Deserializer);\n\nimpl\u003c'de, E\u003e IntoDeserializer\u003c'de, E\u003e for u32\nwhere\n    E: de::Error,\n{\n    type Deserializer = U32Deserializer\u003cE\u003e;\n\n    fn into_deserializer(self) -\u003e U32Deserializer\u003cE\u003e {\n        U32Deserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for U32Deserializer\u003cE\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_u32(self.value)\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n}\n\nimpl\u003c'de, E\u003e de::EnumAccess\u003c'de\u003e for U32Deserializer\u003cE\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly\u003cE\u003e;\n\n    fn variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003c(T::Value, Self::Variant), Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `\u0026str`.\n#[derive(Debug)]\npub struct StrDeserializer\u003c'a, E\u003e {\n    value: \u0026'a str,\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl_copy_clone!(StrDeserializer\u003c'de\u003e);\n\nimpl\u003c'de, 'a, E\u003e IntoDeserializer\u003c'de, E\u003e for \u0026'a str\nwhere\n    E: de::Error,\n{\n    type Deserializer = StrDeserializer\u003c'a, E\u003e;\n\n    fn into_deserializer(self) -\u003e StrDeserializer\u003c'a, E\u003e {\n        StrDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, 'a, E\u003e de::Deserializer\u003c'de\u003e for StrDeserializer\u003c'a, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_str(self.value)\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\nimpl\u003c'de, 'a, E\u003e de::EnumAccess\u003c'de\u003e for StrDeserializer\u003c'a, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly\u003cE\u003e;\n\n    fn variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003c(T::Value, Self::Variant), Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `\u0026str` with a lifetime tied to another\n/// deserializer.\n#[derive(Debug)]\npub struct BorrowedStrDeserializer\u003c'de, E\u003e {\n    value: \u0026'de str,\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl_copy_clone!(BorrowedStrDeserializer\u003c'de\u003e);\n\nimpl\u003c'de, E\u003e BorrowedStrDeserializer\u003c'de, E\u003e {\n    /// Create a new borrowed deserializer from the given string.\n    pub fn new(value: \u0026'de str) -\u003e BorrowedStrDeserializer\u003c'de, E\u003e {\n        BorrowedStrDeserializer {\n            value: value,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for BorrowedStrDeserializer\u003c'de, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_borrowed_str(self.value)\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\nimpl\u003c'de, E\u003e de::EnumAccess\u003c'de\u003e for BorrowedStrDeserializer\u003c'de, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly\u003cE\u003e;\n\n    fn variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003c(T::Value, Self::Variant), Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `String`.\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[derive(Debug)]\npub struct StringDeserializer\u003cE\u003e {\n    value: String,\n    marker: PhantomData\u003cE\u003e,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003cE\u003e Clone for StringDeserializer\u003cE\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        StringDeserializer {\n            value: self.value.clone(),\n            marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, E\u003e IntoDeserializer\u003c'de, E\u003e for String\nwhere\n    E: de::Error,\n{\n    type Deserializer = StringDeserializer\u003cE\u003e;\n\n    fn into_deserializer(self) -\u003e StringDeserializer\u003cE\u003e {\n        StringDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for StringDeserializer\u003cE\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_string(self.value)\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, 'a, E\u003e de::EnumAccess\u003c'de\u003e for StringDeserializer\u003cE\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly\u003cE\u003e;\n\n    fn variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003c(T::Value, Self::Variant), Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `Cow\u003cstr\u003e`.\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[derive(Debug)]\npub struct CowStrDeserializer\u003c'a, E\u003e {\n    value: Cow\u003c'a, str\u003e,\n    marker: PhantomData\u003cE\u003e,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, E\u003e Clone for CowStrDeserializer\u003c'a, E\u003e {\n    fn clone(\u0026self) -\u003e Self {\n        CowStrDeserializer {\n            value: self.value.clone(),\n            marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, 'a, E\u003e IntoDeserializer\u003c'de, E\u003e for Cow\u003c'a, str\u003e\nwhere\n    E: de::Error,\n{\n    type Deserializer = CowStrDeserializer\u003c'a, E\u003e;\n\n    fn into_deserializer(self) -\u003e CowStrDeserializer\u003c'a, E\u003e {\n        CowStrDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, 'a, E\u003e de::Deserializer\u003c'de\u003e for CowStrDeserializer\u003c'a, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        match self.value {\n            Cow::Borrowed(string) =\u003e visitor.visit_str(string),\n            Cow::Owned(string) =\u003e visitor.visit_string(string),\n        }\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let _ = name;\n        let _ = variants;\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, 'a, E\u003e de::EnumAccess\u003c'de\u003e for CowStrDeserializer\u003c'a, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    type Variant = private::UnitOnly\u003cE\u003e;\n\n    fn variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003c(T::Value, Self::Variant), Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(self).map(private::unit_only)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `\u0026[u8]` with a lifetime tied to another\n/// deserializer.\n#[derive(Debug)]\npub struct BorrowedBytesDeserializer\u003c'de, E\u003e {\n    value: \u0026'de [u8],\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl_copy_clone!(BorrowedBytesDeserializer\u003c'de\u003e);\n\nimpl\u003c'de, E\u003e BorrowedBytesDeserializer\u003c'de, E\u003e {\n    /// Create a new borrowed deserializer from the given byte slice.\n    pub fn new(value: \u0026'de [u8]) -\u003e BorrowedBytesDeserializer\u003c'de, E\u003e {\n        BorrowedBytesDeserializer {\n            value: value,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for BorrowedBytesDeserializer\u003c'de, E\u003e\nwhere\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_borrowed_bytes(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any enum\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer that iterates over a sequence.\n#[derive(Clone, Debug)]\npub struct SeqDeserializer\u003cI, E\u003e {\n    iter: iter::Fuse\u003cI\u003e,\n    count: usize,\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl\u003cI, E\u003e SeqDeserializer\u003cI, E\u003e\nwhere\n    I: Iterator,\n{\n    /// Construct a new `SeqDeserializer\u003cI, E\u003e`.\n    pub fn new(iter: I) -\u003e Self {\n        SeqDeserializer {\n            iter: iter.fuse(),\n            count: 0,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003cI, E\u003e SeqDeserializer\u003cI, E\u003e\nwhere\n    I: Iterator,\n    E: de::Error,\n{\n    /// Check for remaining elements after passing a `SeqDeserializer` to\n    /// `Visitor::visit_seq`.\n    pub fn end(self) -\u003e Result\u003c(), E\u003e {\n        let remaining = self.iter.count();\n        if remaining == 0 {\n            Ok(())\n        } else {\n            // First argument is the number of elements in the data, second\n            // argument is the number of elements expected by the Deserialize.\n            Err(de::Error::invalid_length(\n                self.count + remaining,\n                \u0026ExpectedInSeq(self.count),\n            ))\n        }\n    }\n}\n\nimpl\u003c'de, I, T, E\u003e de::Deserializer\u003c'de\u003e for SeqDeserializer\u003cI, E\u003e\nwhere\n    I: Iterator\u003cItem = T\u003e,\n    T: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let v = try!(visitor.visit_seq(\u0026mut self));\n        try!(self.end());\n        Ok(v)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\nimpl\u003c'de, I, T, E\u003e de::SeqAccess\u003c'de\u003e for SeqDeserializer\u003cI, E\u003e\nwhere\n    I: Iterator\u003cItem = T\u003e,\n    T: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn next_element_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cOption\u003cV::Value\u003e, Self::Error\u003e\n    where\n        V: de::DeserializeSeed\u003c'de\u003e,\n    {\n        match self.iter.next() {\n            Some(value) =\u003e {\n                self.count += 1;\n                seed.deserialize(value.into_deserializer()).map(Some)\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        size_hint::from_bounds(\u0026self.iter)\n    }\n}\n\nstruct ExpectedInSeq(usize);\n\nimpl Expected for ExpectedInSeq {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        if self.0 == 1 {\n            write!(formatter, \"1 element in sequence\")\n        } else {\n            write!(formatter, \"{} elements in sequence\", self.0)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, T, E\u003e IntoDeserializer\u003c'de, E\u003e for Vec\u003cT\u003e\nwhere\n    T: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Deserializer = SeqDeserializer\u003c\u003cSelf as IntoIterator\u003e::IntoIter, E\u003e;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        SeqDeserializer::new(self.into_iter())\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, T, E\u003e IntoDeserializer\u003c'de, E\u003e for BTreeSet\u003cT\u003e\nwhere\n    T: IntoDeserializer\u003c'de, E\u003e + Eq + Ord,\n    E: de::Error,\n{\n    type Deserializer = SeqDeserializer\u003c\u003cSelf as IntoIterator\u003e::IntoIter, E\u003e;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        SeqDeserializer::new(self.into_iter())\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de, T, S, E\u003e IntoDeserializer\u003c'de, E\u003e for HashSet\u003cT, S\u003e\nwhere\n    T: IntoDeserializer\u003c'de, E\u003e + Eq + Hash,\n    S: BuildHasher,\n    E: de::Error,\n{\n    type Deserializer = SeqDeserializer\u003c\u003cSelf as IntoIterator\u003e::IntoIter, E\u003e;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        SeqDeserializer::new(self.into_iter())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `SeqAccess`.\n#[derive(Clone, Debug)]\npub struct SeqAccessDeserializer\u003cA\u003e {\n    seq: A,\n}\n\nimpl\u003cA\u003e SeqAccessDeserializer\u003cA\u003e {\n    /// Construct a new `SeqAccessDeserializer\u003cA\u003e`.\n    pub fn new(seq: A) -\u003e Self {\n        SeqAccessDeserializer { seq: seq }\n    }\n}\n\nimpl\u003c'de, A\u003e de::Deserializer\u003c'de\u003e for SeqAccessDeserializer\u003cA\u003e\nwhere\n    A: de::SeqAccess\u003c'de\u003e,\n{\n    type Error = A::Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_seq(self.seq)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer that iterates over a map.\npub struct MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n{\n    iter: iter::Fuse\u003cI\u003e,\n    value: Option\u003cSecond\u003cI::Item\u003e\u003e,\n    count: usize,\n    lifetime: PhantomData\u003c\u0026'de ()\u003e,\n    error: PhantomData\u003cE\u003e,\n}\n\nimpl\u003c'de, I, E\u003e MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n{\n    /// Construct a new `MapDeserializer\u003cI, E\u003e`.\n    pub fn new(iter: I) -\u003e Self {\n        MapDeserializer {\n            iter: iter.fuse(),\n            value: None,\n            count: 0,\n            lifetime: PhantomData,\n            error: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, I, E\u003e MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n    E: de::Error,\n{\n    /// Check for remaining elements after passing a `MapDeserializer` to\n    /// `Visitor::visit_map`.\n    pub fn end(self) -\u003e Result\u003c(), E\u003e {\n        let remaining = self.iter.count();\n        if remaining == 0 {\n            Ok(())\n        } else {\n            // First argument is the number of elements in the data, second\n            // argument is the number of elements expected by the Deserialize.\n            Err(de::Error::invalid_length(\n                self.count + remaining,\n                \u0026ExpectedInMap(self.count),\n            ))\n        }\n    }\n}\n\nimpl\u003c'de, I, E\u003e MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n{\n    fn next_pair(\u0026mut self) -\u003e Option\u003c(First\u003cI::Item\u003e, Second\u003cI::Item\u003e)\u003e {\n        match self.iter.next() {\n            Some(kv) =\u003e {\n                self.count += 1;\n                Some(private::Pair::split(kv))\n            }\n            None =\u003e None,\n        }\n    }\n}\n\nimpl\u003c'de, I, E\u003e de::Deserializer\u003c'de\u003e for MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n    First\u003cI::Item\u003e: IntoDeserializer\u003c'de, E\u003e,\n    Second\u003cI::Item\u003e: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let value = try!(visitor.visit_map(\u0026mut self));\n        try!(self.end());\n        Ok(value)\n    }\n\n    fn deserialize_seq\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let value = try!(visitor.visit_seq(\u0026mut self));\n        try!(self.end());\n        Ok(value)\n    }\n\n    fn deserialize_tuple\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let _ = len;\n        self.deserialize_seq(visitor)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct tuple_struct map\n        struct enum identifier ignored_any\n    }\n}\n\nimpl\u003c'de, I, E\u003e de::MapAccess\u003c'de\u003e for MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n    First\u003cI::Item\u003e: IntoDeserializer\u003c'de, E\u003e,\n    Second\u003cI::Item\u003e: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn next_key_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        match self.next_pair() {\n            Some((key, value)) =\u003e {\n                self.value = Some(value);\n                seed.deserialize(key.into_deserializer()).map(Some)\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn next_value_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        let value = self.value.take();\n        // Panic because this indicates a bug in the program rather than an\n        // expected failure.\n        let value = value.expect(\"MapAccess::visit_value called before visit_key\");\n        seed.deserialize(value.into_deserializer())\n    }\n\n    fn next_entry_seed\u003cTK, TV\u003e(\n        \u0026mut self,\n        kseed: TK,\n        vseed: TV,\n    ) -\u003e Result\u003cOption\u003c(TK::Value, TV::Value)\u003e, Self::Error\u003e\n    where\n        TK: de::DeserializeSeed\u003c'de\u003e,\n        TV: de::DeserializeSeed\u003c'de\u003e,\n    {\n        match self.next_pair() {\n            Some((key, value)) =\u003e {\n                let key = try!(kseed.deserialize(key.into_deserializer()));\n                let value = try!(vseed.deserialize(value.into_deserializer()));\n                Ok(Some((key, value)))\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        size_hint::from_bounds(\u0026self.iter)\n    }\n}\n\nimpl\u003c'de, I, E\u003e de::SeqAccess\u003c'de\u003e for MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator,\n    I::Item: private::Pair,\n    First\u003cI::Item\u003e: IntoDeserializer\u003c'de, E\u003e,\n    Second\u003cI::Item\u003e: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        match self.next_pair() {\n            Some((k, v)) =\u003e {\n                let de = PairDeserializer(k, v, PhantomData);\n                seed.deserialize(de).map(Some)\n            }\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        size_hint::from_bounds(\u0026self.iter)\n    }\n}\n\n// Cannot #[derive(Clone)] because of the bound `Second\u003cI::Item\u003e: Clone`.\nimpl\u003c'de, I, E\u003e Clone for MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator + Clone,\n    I::Item: private::Pair,\n    Second\u003cI::Item\u003e: Clone,\n{\n    fn clone(\u0026self) -\u003e Self {\n        MapDeserializer {\n            iter: self.iter.clone(),\n            value: self.value.clone(),\n            count: self.count,\n            lifetime: self.lifetime,\n            error: self.error,\n        }\n    }\n}\n\n// Cannot #[derive(Debug)] because of the bound `Second\u003cI::Item\u003e: Debug`.\nimpl\u003c'de, I, E\u003e Debug for MapDeserializer\u003c'de, I, E\u003e\nwhere\n    I: Iterator + Debug,\n    I::Item: private::Pair,\n    Second\u003cI::Item\u003e: Debug,\n{\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter\n            .debug_struct(\"MapDeserializer\")\n            .field(\"iter\", \u0026self.iter)\n            .field(\"value\", \u0026self.value)\n            .field(\"count\", \u0026self.count)\n            .field(\"lifetime\", \u0026self.lifetime)\n            .field(\"error\", \u0026self.error)\n            .finish()\n    }\n}\n\n// Used in the `impl SeqAccess for MapDeserializer` to visit the map as a\n// sequence of pairs.\nstruct PairDeserializer\u003cA, B, E\u003e(A, B, PhantomData\u003cE\u003e);\n\nimpl\u003c'de, A, B, E\u003e de::Deserializer\u003c'de\u003e for PairDeserializer\u003cA, B, E\u003e\nwhere\n    A: IntoDeserializer\u003c'de, E\u003e,\n    B: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct tuple_struct map\n        struct enum identifier ignored_any\n    }\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        self.deserialize_seq(visitor)\n    }\n\n    fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        let mut pair_visitor = PairVisitor(Some(self.0), Some(self.1), PhantomData);\n        let pair = try!(visitor.visit_seq(\u0026mut pair_visitor));\n        if pair_visitor.1.is_none() {\n            Ok(pair)\n        } else {\n            let remaining = pair_visitor.size_hint().unwrap();\n            // First argument is the number of elements in the data, second\n            // argument is the number of elements expected by the Deserialize.\n            Err(de::Error::invalid_length(2, \u0026ExpectedInSeq(2 - remaining)))\n        }\n    }\n\n    fn deserialize_tuple\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        if len == 2 {\n            self.deserialize_seq(visitor)\n        } else {\n            // First argument is the number of elements in the data, second\n            // argument is the number of elements expected by the Deserialize.\n            Err(de::Error::invalid_length(2, \u0026ExpectedInSeq(len)))\n        }\n    }\n}\n\nstruct PairVisitor\u003cA, B, E\u003e(Option\u003cA\u003e, Option\u003cB\u003e, PhantomData\u003cE\u003e);\n\nimpl\u003c'de, A, B, E\u003e de::SeqAccess\u003c'de\u003e for PairVisitor\u003cA, B, E\u003e\nwhere\n    A: IntoDeserializer\u003c'de, E\u003e,\n    B: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Error = E;\n\n    fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        if let Some(k) = self.0.take() {\n            seed.deserialize(k.into_deserializer()).map(Some)\n        } else if let Some(v) = self.1.take() {\n            seed.deserialize(v.into_deserializer()).map(Some)\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        if self.0.is_some() {\n            Some(2)\n        } else if self.1.is_some() {\n            Some(1)\n        } else {\n            Some(0)\n        }\n    }\n}\n\nstruct ExpectedInMap(usize);\n\nimpl Expected for ExpectedInMap {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        if self.0 == 1 {\n            write!(formatter, \"1 element in map\")\n        } else {\n            write!(formatter, \"{} elements in map\", self.0)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'de, K, V, E\u003e IntoDeserializer\u003c'de, E\u003e for BTreeMap\u003cK, V\u003e\nwhere\n    K: IntoDeserializer\u003c'de, E\u003e + Eq + Ord,\n    V: IntoDeserializer\u003c'de, E\u003e,\n    E: de::Error,\n{\n    type Deserializer = MapDeserializer\u003c'de, \u003cSelf as IntoIterator\u003e::IntoIter, E\u003e;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        MapDeserializer::new(self.into_iter())\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003c'de, K, V, S, E\u003e IntoDeserializer\u003c'de, E\u003e for HashMap\u003cK, V, S\u003e\nwhere\n    K: IntoDeserializer\u003c'de, E\u003e + Eq + Hash,\n    V: IntoDeserializer\u003c'de, E\u003e,\n    S: BuildHasher,\n    E: de::Error,\n{\n    type Deserializer = MapDeserializer\u003c'de, \u003cSelf as IntoIterator\u003e::IntoIter, E\u003e;\n\n    fn into_deserializer(self) -\u003e Self::Deserializer {\n        MapDeserializer::new(self.into_iter())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A deserializer holding a `MapAccess`.\n#[derive(Clone, Debug)]\npub struct MapAccessDeserializer\u003cA\u003e {\n    map: A,\n}\n\nimpl\u003cA\u003e MapAccessDeserializer\u003cA\u003e {\n    /// Construct a new `MapAccessDeserializer\u003cA\u003e`.\n    pub fn new(map: A) -\u003e Self {\n        MapAccessDeserializer { map: map }\n    }\n}\n\nimpl\u003c'de, A\u003e de::Deserializer\u003c'de\u003e for MapAccessDeserializer\u003cA\u003e\nwhere\n    A: de::MapAccess\u003c'de\u003e,\n{\n    type Error = A::Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_map(self.map)\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        _name: \u0026str,\n        _variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct identifier ignored_any\n    }\n}\n\nimpl\u003c'de, A\u003e de::EnumAccess\u003c'de\u003e for MapAccessDeserializer\u003cA\u003e\nwhere\n    A: de::MapAccess\u003c'de\u003e,\n{\n    type Error = A::Error;\n    type Variant = private::MapAsEnum\u003cA\u003e;\n\n    fn variant_seed\u003cT\u003e(mut self, seed: T) -\u003e Result\u003c(T::Value, Self::Variant), Self::Error\u003e\n    where\n        T: de::DeserializeSeed\u003c'de\u003e,\n    {\n        match self.map.next_key_seed(seed)? {\n            Some(key) =\u003e Ok((key, private::map_as_enum(self.map))),\n            None =\u003e Err(de::Error::invalid_type(de::Unexpected::Map, \u0026\"enum\")),\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmod private {\n    use lib::*;\n\n    use de::{self, DeserializeSeed, Deserializer, MapAccess, Unexpected, VariantAccess, Visitor};\n\n    #[derive(Clone, Debug)]\n    pub struct UnitOnly\u003cE\u003e {\n        marker: PhantomData\u003cE\u003e,\n    }\n\n    pub fn unit_only\u003cT, E\u003e(t: T) -\u003e (T, UnitOnly\u003cE\u003e) {\n        (\n            t,\n            UnitOnly {\n                marker: PhantomData,\n            },\n        )\n    }\n\n    impl\u003c'de, E\u003e de::VariantAccess\u003c'de\u003e for UnitOnly\u003cE\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n            Ok(())\n        }\n\n        fn newtype_variant_seed\u003cT\u003e(self, _seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            Err(de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                \u0026\"newtype variant\",\n            ))\n        }\n\n        fn tuple_variant\u003cV\u003e(self, _len: usize, _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            Err(de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                \u0026\"tuple variant\",\n            ))\n        }\n\n        fn struct_variant\u003cV\u003e(\n            self,\n            _fields: \u0026'static [\u0026'static str],\n            _visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            Err(de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                \u0026\"struct variant\",\n            ))\n        }\n    }\n\n    #[derive(Clone, Debug)]\n    pub struct MapAsEnum\u003cA\u003e {\n        map: A,\n    }\n\n    pub fn map_as_enum\u003cA\u003e(map: A) -\u003e MapAsEnum\u003cA\u003e {\n        MapAsEnum { map: map }\n    }\n\n    impl\u003c'de, A\u003e VariantAccess\u003c'de\u003e for MapAsEnum\u003cA\u003e\n    where\n        A: MapAccess\u003c'de\u003e,\n    {\n        type Error = A::Error;\n\n        fn unit_variant(mut self) -\u003e Result\u003c(), Self::Error\u003e {\n            self.map.next_value()\n        }\n\n        fn newtype_variant_seed\u003cT\u003e(mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n        where\n            T: DeserializeSeed\u003c'de\u003e,\n        {\n            self.map.next_value_seed(seed)\n        }\n\n        fn tuple_variant\u003cV\u003e(mut self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.map.next_value_seed(SeedTupleVariant {\n                len: len,\n                visitor: visitor,\n            })\n        }\n\n        fn struct_variant\u003cV\u003e(\n            mut self,\n            _fields: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.map\n                .next_value_seed(SeedStructVariant { visitor: visitor })\n        }\n    }\n\n    struct SeedTupleVariant\u003cV\u003e {\n        len: usize,\n        visitor: V,\n    }\n\n    impl\u003c'de, V\u003e DeserializeSeed\u003c'de\u003e for SeedTupleVariant\u003cV\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        type Value = V::Value;\n\n        fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            deserializer.deserialize_tuple(self.len, self.visitor)\n        }\n    }\n\n    struct SeedStructVariant\u003cV\u003e {\n        visitor: V,\n    }\n\n    impl\u003c'de, V\u003e DeserializeSeed\u003c'de\u003e for SeedStructVariant\u003cV\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        type Value = V::Value;\n\n        fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            deserializer.deserialize_map(self.visitor)\n        }\n    }\n\n    /// Avoid having to restate the generic types on `MapDeserializer`. The\n    /// `Iterator::Item` contains enough information to figure out K and V.\n    pub trait Pair {\n        type First;\n        type Second;\n        fn split(self) -\u003e (Self::First, Self::Second);\n    }\n\n    impl\u003cA, B\u003e Pair for (A, B) {\n        type First = A;\n        type Second = B;\n        fn split(self) -\u003e (A, B) {\n            self\n        }\n    }\n\n    pub type First\u003cT\u003e = \u003cT as Pair\u003e::First;\n    pub type Second\u003cT\u003e = \u003cT as Pair\u003e::Second;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","export.rs"],"content":"pub use lib::clone::Clone;\npub use lib::convert::{From, Into};\npub use lib::default::Default;\npub use lib::fmt::{self, Formatter};\npub use lib::marker::PhantomData;\npub use lib::option::Option::{self, None, Some};\npub use lib::result::Result::{self, Err, Ok};\n\npub use self::string::from_utf8_lossy;\n\n#[cfg(any(feature = \"alloc\", feature = \"std\"))]\npub use lib::{ToString, Vec};\n\n#[cfg(core_try_from)]\npub use lib::convert::TryFrom;\n\nmod string {\n    use lib::*;\n\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    pub fn from_utf8_lossy(bytes: \u0026[u8]) -\u003e Cow\u003cstr\u003e {\n        String::from_utf8_lossy(bytes)\n    }\n\n    // The generated code calls this like:\n    //\n    //     let value = \u0026_serde::export::from_utf8_lossy(bytes);\n    //     Err(_serde::de::Error::unknown_variant(value, VARIANTS))\n    //\n    // so it is okay for the return type to be different from the std case as long\n    // as the above works.\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    pub fn from_utf8_lossy(bytes: \u0026[u8]) -\u003e \u0026str {\n        // Three unicode replacement characters if it fails. They look like a\n        // white-on-black question mark. The user will recognize it as invalid\n        // UTF-8.\n        str::from_utf8(bytes).unwrap_or(\"\\u{fffd}\\u{fffd}\\u{fffd}\")\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","integer128.rs"],"content":"/// Conditional compilation depending on whether Serde is built with support for\n/// 128-bit integers.\n///\n/// Data formats that wish to support Rust compiler versions older than 1.26\n/// (or targets that lack 128-bit integers) may place the i128 / u128 methods\n/// of their Serializer and Deserializer behind this macro.\n///\n/// Data formats that require a minimum Rust compiler version of at least 1.26,\n/// or do not target platforms that lack 128-bit integers, do not need to\n/// bother with this macro and may assume support for 128-bit integers.\n///\n/// ```edition2018\n/// # use serde::private::ser::Error;\n/// #\n/// # struct MySerializer;\n/// #\n/// use serde::{serde_if_integer128, Serializer};\n///\n/// impl Serializer for MySerializer {\n///     type Ok = ();\n///     type Error = Error;\n///\n///     fn serialize_i64(self, v: i64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n///         /* ... */\n/// #         unimplemented!()\n///     }\n///\n///     /* ... */\n///\n///     serde_if_integer128! {\n///         fn serialize_i128(self, v: i128) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n///             /* ... */\n/// #             unimplemented!()\n///         }\n///\n///         fn serialize_u128(self, v: u128) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n///             /* ... */\n/// #             unimplemented!()\n///         }\n///     }\n/// #\n/// #     serde::__serialize_unimplemented! {\n/// #         bool i8 i16 i32 u8 u16 u32 u64 f32 f64 char str bytes none some\n/// #         unit unit_struct unit_variant newtype_struct newtype_variant seq\n/// #         tuple tuple_struct tuple_variant map struct struct_variant\n/// #     }\n/// }\n/// ```\n///\n/// When Serde is built with support for 128-bit integers, this macro expands\n/// transparently into just the input tokens.\n///\n/// ```edition2018\n/// macro_rules! serde_if_integer128 {\n///     ($($tt:tt)*) =\u003e {\n///         $($tt)*\n///     };\n/// }\n/// ```\n///\n/// When built without support for 128-bit integers, this macro expands to\n/// nothing.\n///\n/// ```edition2018\n/// macro_rules! serde_if_integer128 {\n///     ($($tt:tt)*) =\u003e {};\n/// }\n/// ```\n#[cfg(integer128)]\n#[macro_export]\nmacro_rules! serde_if_integer128 {\n    ($($tt:tt)*) =\u003e {\n        $($tt)*\n    };\n}\n\n#[cfg(not(integer128))]\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! serde_if_integer128 {\n    ($($tt:tt)*) =\u003e {};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","lib.rs"],"content":"//! # Serde\n//!\n//! Serde is a framework for ***ser***ializing and ***de***serializing Rust data\n//! structures efficiently and generically.\n//!\n//! The Serde ecosystem consists of data structures that know how to serialize\n//! and deserialize themselves along with data formats that know how to\n//! serialize and deserialize other things. Serde provides the layer by which\n//! these two groups interact with each other, allowing any supported data\n//! structure to be serialized and deserialized using any supported data format.\n//!\n//! See the Serde website [https://serde.rs/] for additional documentation and\n//! usage examples.\n//!\n//! [https://serde.rs/]: https://serde.rs/\n//!\n//! ## Design\n//!\n//! Where many other languages rely on runtime reflection for serializing data,\n//! Serde is instead built on Rust's powerful trait system. A data structure\n//! that knows how to serialize and deserialize itself is one that implements\n//! Serde's `Serialize` and `Deserialize` traits (or uses Serde's derive\n//! attribute to automatically generate implementations at compile time). This\n//! avoids any overhead of reflection or runtime type information. In fact in\n//! many situations the interaction between data structure and data format can\n//! be completely optimized away by the Rust compiler, leaving Serde\n//! serialization to perform the same speed as a handwritten serializer for the\n//! specific selection of data structure and data format.\n//!\n//! ## Data formats\n//!\n//! The following is a partial list of data formats that have been implemented\n//! for Serde by the community.\n//!\n//! - [JSON], the ubiquitous JavaScript Object Notation used by many HTTP APIs.\n//! - [Bincode], a compact binary format\n//!   used for IPC within the Servo rendering engine.\n//! - [CBOR], a Concise Binary Object Representation designed for small message\n//!   size without the need for version negotiation.\n//! - [YAML], a popular human-friendly configuration language that ain't markup\n//!   language.\n//! - [MessagePack], an efficient binary format that resembles a compact JSON.\n//! - [TOML], a minimal configuration format used by [Cargo].\n//! - [Pickle], a format common in the Python world.\n//! - [RON], a Rusty Object Notation.\n//! - [BSON], the data storage and network transfer format used by MongoDB.\n//! - [Avro], a binary format used within Apache Hadoop, with support for schema\n//!   definition.\n//! - [JSON5], A superset of JSON including some productions from ES5.\n//! - [Postcard], a no\\_std and embedded-systems friendly compact binary format.\n//! - [URL], the x-www-form-urlencoded format.\n//! - [Envy], a way to deserialize environment variables into Rust structs.\n//!   *(deserialization only)*\n//! - [Envy Store], a way to deserialize [AWS Parameter Store] parameters into\n//!   Rust structs. *(deserialization only)*\n//!\n//! [JSON]: https://github.com/serde-rs/json\n//! [Bincode]: https://github.com/TyOverby/bincode\n//! [CBOR]: https://github.com/pyfisch/cbor\n//! [YAML]: https://github.com/dtolnay/serde-yaml\n//! [MessagePack]: https://github.com/3Hren/msgpack-rust\n//! [TOML]: https://github.com/alexcrichton/toml-rs\n//! [Pickle]: https://github.com/birkenfeld/serde-pickle\n//! [RON]: https://github.com/ron-rs/ron\n//! [BSON]: https://github.com/zonyitoo/bson-rs\n//! [Avro]: https://github.com/flavray/avro-rs\n//! [JSON5]: https://github.com/callum-oakley/json5-rs\n//! [Postcard]: https://github.com/jamesmunns/postcard\n//! [URL]: https://github.com/nox/serde_urlencoded\n//! [Envy]: https://github.com/softprops/envy\n//! [Envy Store]: https://github.com/softprops/envy-store\n//! [Cargo]: http://doc.crates.io/manifest.html\n//! [AWS Parameter Store]: https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-paramstore.html\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Serde types in rustdoc of other crates get linked to here.\n#![doc(html_root_url = \"https://docs.rs/serde/1.0.100\")]\n// Support using Serde without the standard library!\n#![cfg_attr(not(feature = \"std\"), no_std)]\n// Unstable functionality only if the user asks for it. For tracking and\n// discussion of these features please refer to this issue:\n//\n//    https://github.com/serde-rs/serde/issues/812\n#![cfg_attr(feature = \"unstable\", feature(specialization, never_type))]\n#![allow(unknown_lints, bare_trait_objects, deprecated)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(renamed_and_removed_lints))]\n#![cfg_attr(feature = \"cargo-clippy\", deny(clippy, clippy_pedantic))]\n// Ignored clippy and clippy_pedantic lints\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        // not available in our oldest supported compiler\n        checked_conversions,\n        empty_enum,\n        redundant_field_names,\n        redundant_static_lifetimes,\n        // integer and float ser/de requires these sorts of casts\n        cast_possible_truncation,\n        cast_possible_wrap,\n        cast_sign_loss,\n        // things are often more readable this way\n        cast_lossless,\n        module_name_repetitions,\n        single_match_else,\n        type_complexity,\n        use_self,\n        zero_prefixed_literal,\n        // not practical\n        needless_pass_by_value,\n        similar_names,\n        // preference\n        doc_markdown,\n    )\n)]\n// Rustc lints.\n#![deny(missing_docs, unused_imports)]\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"alloc\")]\nextern crate alloc;\n\n/// A facade around all the types we need from the `std`, `core`, and `alloc`\n/// crates. This avoids elaborate import wrangling having to happen in every\n/// module.\nmod lib {\n    mod core {\n        #[cfg(not(feature = \"std\"))]\n        pub use core::*;\n        #[cfg(feature = \"std\")]\n        pub use std::*;\n    }\n\n    pub use self::core::{cmp, iter, mem, num, slice, str};\n    pub use self::core::{f32, f64};\n    pub use self::core::{i16, i32, i64, i8, isize};\n    pub use self::core::{u16, u32, u64, u8, usize};\n\n    pub use self::core::cell::{Cell, RefCell};\n    pub use self::core::clone::{self, Clone};\n    pub use self::core::convert::{self, From, Into};\n    pub use self::core::default::{self, Default};\n    pub use self::core::fmt::{self, Debug, Display};\n    pub use self::core::marker::{self, PhantomData};\n    pub use self::core::ops::Range;\n    pub use self::core::option::{self, Option};\n    pub use self::core::result::{self, Result};\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::borrow::{Cow, ToOwned};\n    #[cfg(feature = \"std\")]\n    pub use std::borrow::{Cow, ToOwned};\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::string::{String, ToString};\n    #[cfg(feature = \"std\")]\n    pub use std::string::{String, ToString};\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::vec::Vec;\n    #[cfg(feature = \"std\")]\n    pub use std::vec::Vec;\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::boxed::Box;\n    #[cfg(feature = \"std\")]\n    pub use std::boxed::Box;\n\n    #[cfg(all(feature = \"rc\", feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::rc::{Rc, Weak as RcWeak};\n    #[cfg(all(feature = \"rc\", feature = \"std\"))]\n    pub use std::rc::{Rc, Weak as RcWeak};\n\n    #[cfg(all(feature = \"rc\", feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::sync::{Arc, Weak as ArcWeak};\n    #[cfg(all(feature = \"rc\", feature = \"std\"))]\n    pub use std::sync::{Arc, Weak as ArcWeak};\n\n    #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n    pub use alloc::collections::{BTreeMap, BTreeSet, BinaryHeap, LinkedList, VecDeque};\n    #[cfg(feature = \"std\")]\n    pub use std::collections::{BTreeMap, BTreeSet, BinaryHeap, LinkedList, VecDeque};\n\n    #[cfg(feature = \"std\")]\n    pub use std::{error, net};\n\n    #[cfg(feature = \"std\")]\n    pub use std::collections::{HashMap, HashSet};\n    #[cfg(feature = \"std\")]\n    pub use std::ffi::{CStr, CString, OsStr, OsString};\n    #[cfg(feature = \"std\")]\n    pub use std::hash::{BuildHasher, Hash};\n    #[cfg(feature = \"std\")]\n    pub use std::io::Write;\n    #[cfg(feature = \"std\")]\n    pub use std::num::Wrapping;\n    #[cfg(feature = \"std\")]\n    pub use std::path::{Path, PathBuf};\n    #[cfg(feature = \"std\")]\n    pub use std::sync::{Mutex, RwLock};\n    #[cfg(feature = \"std\")]\n    pub use std::time::{SystemTime, UNIX_EPOCH};\n\n    #[cfg(all(feature = \"std\", collections_bound))]\n    pub use std::collections::Bound;\n\n    #[cfg(core_reverse)]\n    pub use self::core::cmp::Reverse;\n\n    #[cfg(ops_bound)]\n    pub use self::core::ops::Bound;\n\n    #[cfg(range_inclusive)]\n    pub use self::core::ops::RangeInclusive;\n\n    #[cfg(all(feature = \"std\", std_atomic))]\n    pub use std::sync::atomic::{\n        AtomicBool, AtomicI16, AtomicI32, AtomicI8, AtomicIsize, AtomicU16, AtomicU32, AtomicU8,\n        AtomicUsize, Ordering,\n    };\n    #[cfg(all(feature = \"std\", std_atomic64))]\n    pub use std::sync::atomic::{AtomicI64, AtomicU64};\n\n    #[cfg(any(core_duration, feature = \"std\"))]\n    pub use self::core::time::Duration;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[macro_use]\nmod macros;\n\n#[macro_use]\nmod integer128;\n\npub mod de;\npub mod ser;\n\n#[doc(inline)]\npub use de::{Deserialize, Deserializer};\n#[doc(inline)]\npub use ser::{Serialize, Serializer};\n\n// Generated code uses these to support no_std. Not public API.\n#[doc(hidden)]\npub mod export;\n\n// Helpers used by generated code and doc tests. Not public API.\n#[doc(hidden)]\npub mod private;\n\n#[cfg(not(feature = \"std\"))]\nmod std_error;\n\n// Re-export #[derive(Serialize, Deserialize)].\n//\n// The reason re-exporting is not enabled by default is that disabling it would\n// be annoying for crates that provide handwritten impls or data formats. They\n// would need to disable default features and then explicitly re-enable std.\n#[cfg(feature = \"serde_derive\")]\n#[allow(unused_imports)]\n#[macro_use]\nextern crate serde_derive;\n#[cfg(feature = \"serde_derive\")]\n#[doc(hidden)]\npub use serde_derive::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","macros.rs"],"content":"// Super explicit first paragraph because this shows up at the top level and\n// trips up people who are just looking for basic Serialize / Deserialize\n// documentation.\n//\n/// Helper macro when implementing the `Deserializer` part of a new data format\n/// for Serde.\n///\n/// Some [`Deserializer`] implementations for self-describing formats do not\n/// care what hint the [`Visitor`] gives them, they just want to blindly call\n/// the [`Visitor`] method corresponding to the data they can tell is in the\n/// input. This requires repetitive implementations of all the [`Deserializer`]\n/// trait methods.\n///\n/// ```edition2018\n/// # use serde::forward_to_deserialize_any;\n/// # use serde::de::{value, Deserializer, Visitor};\n/// #\n/// # struct MyDeserializer;\n/// #\n/// # impl\u003c'de\u003e Deserializer\u003c'de\u003e for MyDeserializer {\n/// #     type Error = value::Error;\n/// #\n/// #     fn deserialize_any\u003cV\u003e(self, _: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n/// #     where\n/// #         V: Visitor\u003c'de\u003e,\n/// #     {\n/// #         unimplemented!()\n/// #     }\n/// #\n/// #[inline]\n/// fn deserialize_bool\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n/// where\n///     V: Visitor\u003c'de\u003e,\n/// {\n///     self.deserialize_any(visitor)\n/// }\n/// #\n/// #     forward_to_deserialize_any! {\n/// #         i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n/// #         bytes byte_buf option unit unit_struct newtype_struct seq tuple\n/// #         tuple_struct map struct enum identifier ignored_any\n/// #     }\n/// # }\n/// ```\n///\n/// The `forward_to_deserialize_any!` macro implements these simple forwarding\n/// methods so that they forward directly to [`Deserializer::deserialize_any`].\n/// You can choose which methods to forward.\n///\n/// ```edition2018\n/// # use serde::forward_to_deserialize_any;\n/// # use serde::de::{value, Deserializer, Visitor};\n/// #\n/// # struct MyDeserializer;\n/// #\n/// impl\u003c'de\u003e Deserializer\u003c'de\u003e for MyDeserializer {\n/// #   type Error = value::Error;\n/// #\n///     fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n///     where\n///         V: Visitor\u003c'de\u003e,\n///     {\n///         /* ... */\n/// #       let _ = visitor;\n/// #       unimplemented!()\n///     }\n///\n///     forward_to_deserialize_any! {\n///         bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n///         bytes byte_buf option unit unit_struct newtype_struct seq tuple\n///         tuple_struct map struct enum identifier ignored_any\n///     }\n/// }\n/// ```\n///\n/// The macro assumes the convention that your `Deserializer` lifetime parameter\n/// is called `'de` and that the `Visitor` type parameters on each method are\n/// called `V`. A different type parameter and a different lifetime can be\n/// specified explicitly if necessary.\n///\n/// ```edition2018\n/// # use std::marker::PhantomData;\n/// #\n/// # use serde::forward_to_deserialize_any;\n/// # use serde::de::{value, Deserializer, Visitor};\n/// #\n/// # struct MyDeserializer\u003cV\u003e(PhantomData\u003cV\u003e);\n/// #\n/// # impl\u003c'q, V\u003e Deserializer\u003c'q\u003e for MyDeserializer\u003cV\u003e {\n/// #     type Error = value::Error;\n/// #\n/// #     fn deserialize_any\u003cW\u003e(self, visitor: W) -\u003e Result\u003cW::Value, Self::Error\u003e\n/// #     where\n/// #         W: Visitor\u003c'q\u003e,\n/// #     {\n/// #         unimplemented!()\n/// #     }\n/// #\n/// forward_to_deserialize_any! {\n///     \u003cW: Visitor\u003c'q\u003e\u003e\n///     bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n///     bytes byte_buf option unit unit_struct newtype_struct seq tuple\n///     tuple_struct map struct enum identifier ignored_any\n/// }\n/// # }\n/// ```\n///\n/// [`Deserializer`]: trait.Deserializer.html\n/// [`Visitor`]: de/trait.Visitor.html\n/// [`Deserializer::deserialize_any`]: trait.Deserializer.html#tymethod.deserialize_any\n#[macro_export(local_inner_macros)]\nmacro_rules! forward_to_deserialize_any {\n    (\u003c$visitor:ident: Visitor\u003c$lifetime:tt\u003e\u003e $($func:ident)*) =\u003e {\n        $(forward_to_deserialize_any_helper!{$func\u003c$lifetime, $visitor\u003e})*\n    };\n    // This case must be after the previous one.\n    ($($func:ident)*) =\u003e {\n        $(forward_to_deserialize_any_helper!{$func\u003c'de, V\u003e})*\n    };\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! forward_to_deserialize_any_method {\n    ($func:ident\u003c$l:tt, $v:ident\u003e($($arg:ident : $ty:ty),*)) =\u003e {\n        #[inline]\n        fn $func\u003c$v\u003e(self, $($arg: $ty,)* visitor: $v) -\u003e $crate::export::Result\u003c$v::Value, Self::Error\u003e\n        where\n            $v: $crate::de::Visitor\u003c$l\u003e,\n        {\n            $(\n                let _ = $arg;\n            )*\n            self.deserialize_any(visitor)\n        }\n    };\n}\n\n#[doc(hidden)]\n#[macro_export(local_inner_macros)]\nmacro_rules! forward_to_deserialize_any_helper {\n    (bool\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_bool\u003c$l, $v\u003e()}\n    };\n    (i8\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_i8\u003c$l, $v\u003e()}\n    };\n    (i16\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_i16\u003c$l, $v\u003e()}\n    };\n    (i32\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_i32\u003c$l, $v\u003e()}\n    };\n    (i64\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_i64\u003c$l, $v\u003e()}\n    };\n    (i128\u003c$l:tt, $v:ident\u003e) =\u003e {\n        serde_if_integer128! {\n            forward_to_deserialize_any_method!{deserialize_i128\u003c$l, $v\u003e()}\n        }\n    };\n    (u8\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_u8\u003c$l, $v\u003e()}\n    };\n    (u16\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_u16\u003c$l, $v\u003e()}\n    };\n    (u32\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_u32\u003c$l, $v\u003e()}\n    };\n    (u64\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_u64\u003c$l, $v\u003e()}\n    };\n    (u128\u003c$l:tt, $v:ident\u003e) =\u003e {\n        serde_if_integer128! {\n            forward_to_deserialize_any_method!{deserialize_u128\u003c$l, $v\u003e()}\n        }\n    };\n    (f32\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_f32\u003c$l, $v\u003e()}\n    };\n    (f64\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_f64\u003c$l, $v\u003e()}\n    };\n    (char\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_char\u003c$l, $v\u003e()}\n    };\n    (str\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_str\u003c$l, $v\u003e()}\n    };\n    (string\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_string\u003c$l, $v\u003e()}\n    };\n    (bytes\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_bytes\u003c$l, $v\u003e()}\n    };\n    (byte_buf\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_byte_buf\u003c$l, $v\u003e()}\n    };\n    (option\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_option\u003c$l, $v\u003e()}\n    };\n    (unit\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_unit\u003c$l, $v\u003e()}\n    };\n    (unit_struct\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_unit_struct\u003c$l, $v\u003e(name: \u0026'static str)}\n    };\n    (newtype_struct\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_newtype_struct\u003c$l, $v\u003e(name: \u0026'static str)}\n    };\n    (seq\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_seq\u003c$l, $v\u003e()}\n    };\n    (tuple\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_tuple\u003c$l, $v\u003e(len: usize)}\n    };\n    (tuple_struct\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_tuple_struct\u003c$l, $v\u003e(name: \u0026'static str, len: usize)}\n    };\n    (map\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_map\u003c$l, $v\u003e()}\n    };\n    (struct\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_struct\u003c$l, $v\u003e(name: \u0026'static str, fields: \u0026'static [\u0026'static str])}\n    };\n    (enum\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_enum\u003c$l, $v\u003e(name: \u0026'static str, variants: \u0026'static [\u0026'static str])}\n    };\n    (identifier\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_identifier\u003c$l, $v\u003e()}\n    };\n    (ignored_any\u003c$l:tt, $v:ident\u003e) =\u003e {\n        forward_to_deserialize_any_method!{deserialize_ignored_any\u003c$l, $v\u003e()}\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","private","de.rs"],"content":"use lib::*;\n\nuse de::{Deserialize, DeserializeSeed, Deserializer, Error, IntoDeserializer, Visitor};\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse de::{MapAccess, Unexpected};\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub use self::content::{\n    Content, ContentDeserializer, ContentRefDeserializer, EnumDeserializer,\n    InternallyTaggedUnitVisitor, TagContentOtherField, TagContentOtherFieldVisitor,\n    TagOrContentField, TagOrContentFieldVisitor, TaggedContentVisitor, UntaggedUnitVisitor,\n};\n\n/// If the missing field is of type `Option\u003cT\u003e` then treat is as `None`,\n/// otherwise it is an error.\npub fn missing_field\u003c'de, V, E\u003e(field: \u0026'static str) -\u003e Result\u003cV, E\u003e\nwhere\n    V: Deserialize\u003c'de\u003e,\n    E: Error,\n{\n    struct MissingFieldDeserializer\u003cE\u003e(\u0026'static str, PhantomData\u003cE\u003e);\n\n    impl\u003c'de, E\u003e Deserializer\u003c'de\u003e for MissingFieldDeserializer\u003cE\u003e\n    where\n        E: Error,\n    {\n        type Error = E;\n\n        fn deserialize_any\u003cV\u003e(self, _visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            Err(Error::missing_field(self.0))\n        }\n\n        fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            visitor.visit_none()\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    let deserializer = MissingFieldDeserializer(field, PhantomData);\n    Deserialize::deserialize(deserializer)\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub fn borrow_cow_str\u003c'de: 'a, 'a, D\u003e(deserializer: D) -\u003e Result\u003cCow\u003c'a, str\u003e, D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    struct CowStrVisitor;\n\n    impl\u003c'a\u003e Visitor\u003c'a\u003e for CowStrVisitor {\n        type Value = Cow\u003c'a, str\u003e;\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            formatter.write_str(\"a string\")\n        }\n\n        fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v.to_owned()))\n        }\n\n        fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'a str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Borrowed(v))\n        }\n\n        fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v))\n        }\n\n        fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            match str::from_utf8(v) {\n                Ok(s) =\u003e Ok(Cow::Owned(s.to_owned())),\n                Err(_) =\u003e Err(Error::invalid_value(Unexpected::Bytes(v), \u0026self)),\n            }\n        }\n\n        fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'a [u8]) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            match str::from_utf8(v) {\n                Ok(s) =\u003e Ok(Cow::Borrowed(s)),\n                Err(_) =\u003e Err(Error::invalid_value(Unexpected::Bytes(v), \u0026self)),\n            }\n        }\n\n        fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            match String::from_utf8(v) {\n                Ok(s) =\u003e Ok(Cow::Owned(s)),\n                Err(e) =\u003e Err(Error::invalid_value(\n                    Unexpected::Bytes(\u0026e.into_bytes()),\n                    \u0026self,\n                )),\n            }\n        }\n    }\n\n    deserializer.deserialize_str(CowStrVisitor)\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub fn borrow_cow_bytes\u003c'de: 'a, 'a, D\u003e(deserializer: D) -\u003e Result\u003cCow\u003c'a, [u8]\u003e, D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    struct CowBytesVisitor;\n\n    impl\u003c'a\u003e Visitor\u003c'a\u003e for CowBytesVisitor {\n        type Value = Cow\u003c'a, [u8]\u003e;\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            formatter.write_str(\"a byte array\")\n        }\n\n        fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v.as_bytes().to_vec()))\n        }\n\n        fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'a str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Borrowed(v.as_bytes()))\n        }\n\n        fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v.into_bytes()))\n        }\n\n        fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v.to_vec()))\n        }\n\n        fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'a [u8]) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Borrowed(v))\n        }\n\n        fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: Error,\n        {\n            Ok(Cow::Owned(v))\n        }\n    }\n\n    deserializer.deserialize_bytes(CowBytesVisitor)\n}\n\npub mod size_hint {\n    use lib::*;\n\n    pub fn from_bounds\u003cI\u003e(iter: \u0026I) -\u003e Option\u003cusize\u003e\n    where\n        I: Iterator,\n    {\n        helper(iter.size_hint())\n    }\n\n    #[inline]\n    pub fn cautious(hint: Option\u003cusize\u003e) -\u003e usize {\n        cmp::min(hint.unwrap_or(0), 4096)\n    }\n\n    fn helper(bounds: (usize, Option\u003cusize\u003e)) -\u003e Option\u003cusize\u003e {\n        match bounds {\n            (lower, Some(upper)) if lower == upper =\u003e Some(upper),\n            _ =\u003e None,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmod content {\n    // This module is private and nothing here should be used outside of\n    // generated code.\n    //\n    // We will iterate on the implementation for a few releases and only have to\n    // worry about backward compatibility for the `untagged` and `tag` attributes\n    // rather than for this entire mechanism.\n    //\n    // This issue is tracking making some of this stuff public:\n    // https://github.com/serde-rs/serde/issues/741\n\n    use lib::*;\n\n    use super::size_hint;\n    use de::{\n        self, Deserialize, DeserializeSeed, Deserializer, EnumAccess, Expected, IgnoredAny,\n        MapAccess, SeqAccess, Unexpected, Visitor,\n    };\n\n    /// Used from generated code to buffer the contents of the Deserializer when\n    /// deserializing untagged enums and internally tagged enums.\n    ///\n    /// Not public API. Use serde-value instead.\n    #[derive(Debug)]\n    pub enum Content\u003c'de\u003e {\n        Bool(bool),\n\n        U8(u8),\n        U16(u16),\n        U32(u32),\n        U64(u64),\n\n        I8(i8),\n        I16(i16),\n        I32(i32),\n        I64(i64),\n\n        F32(f32),\n        F64(f64),\n\n        Char(char),\n        String(String),\n        Str(\u0026'de str),\n        ByteBuf(Vec\u003cu8\u003e),\n        Bytes(\u0026'de [u8]),\n\n        None,\n        Some(Box\u003cContent\u003c'de\u003e\u003e),\n\n        Unit,\n        Newtype(Box\u003cContent\u003c'de\u003e\u003e),\n        Seq(Vec\u003cContent\u003c'de\u003e\u003e),\n        Map(Vec\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e),\n    }\n\n    impl\u003c'de\u003e Content\u003c'de\u003e {\n        pub fn as_str(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n            match *self {\n                Content::Str(x) =\u003e Some(x),\n                Content::String(ref x) =\u003e Some(x),\n                Content::Bytes(x) =\u003e str::from_utf8(x).ok(),\n                Content::ByteBuf(ref x) =\u003e str::from_utf8(x).ok(),\n                _ =\u003e None,\n            }\n        }\n\n        #[cold]\n        fn unexpected(\u0026self) -\u003e Unexpected {\n            match *self {\n                Content::Bool(b) =\u003e Unexpected::Bool(b),\n                Content::U8(n) =\u003e Unexpected::Unsigned(n as u64),\n                Content::U16(n) =\u003e Unexpected::Unsigned(n as u64),\n                Content::U32(n) =\u003e Unexpected::Unsigned(n as u64),\n                Content::U64(n) =\u003e Unexpected::Unsigned(n),\n                Content::I8(n) =\u003e Unexpected::Signed(n as i64),\n                Content::I16(n) =\u003e Unexpected::Signed(n as i64),\n                Content::I32(n) =\u003e Unexpected::Signed(n as i64),\n                Content::I64(n) =\u003e Unexpected::Signed(n),\n                Content::F32(f) =\u003e Unexpected::Float(f as f64),\n                Content::F64(f) =\u003e Unexpected::Float(f),\n                Content::Char(c) =\u003e Unexpected::Char(c),\n                Content::String(ref s) =\u003e Unexpected::Str(s),\n                Content::Str(s) =\u003e Unexpected::Str(s),\n                Content::ByteBuf(ref b) =\u003e Unexpected::Bytes(b),\n                Content::Bytes(b) =\u003e Unexpected::Bytes(b),\n                Content::None | Content::Some(_) =\u003e Unexpected::Option,\n                Content::Unit =\u003e Unexpected::Unit,\n                Content::Newtype(_) =\u003e Unexpected::NewtypeStruct,\n                Content::Seq(_) =\u003e Unexpected::Seq,\n                Content::Map(_) =\u003e Unexpected::Map,\n            }\n        }\n    }\n\n    impl\u003c'de\u003e Deserialize\u003c'de\u003e for Content\u003c'de\u003e {\n        fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            // Untagged and internally tagged enums are only supported in\n            // self-describing formats.\n            let visitor = ContentVisitor { value: PhantomData };\n            deserializer.deserialize_any(visitor)\n        }\n    }\n\n    struct ContentVisitor\u003c'de\u003e {\n        value: PhantomData\u003cContent\u003c'de\u003e\u003e,\n    }\n\n    impl\u003c'de\u003e ContentVisitor\u003c'de\u003e {\n        fn new() -\u003e Self {\n            ContentVisitor { value: PhantomData }\n        }\n    }\n\n    impl\u003c'de\u003e Visitor\u003c'de\u003e for ContentVisitor\u003c'de\u003e {\n        type Value = Content\u003c'de\u003e;\n\n        fn expecting(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            fmt.write_str(\"any value\")\n        }\n\n        fn visit_bool\u003cF\u003e(self, value: bool) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::Bool(value))\n        }\n\n        fn visit_i8\u003cF\u003e(self, value: i8) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::I8(value))\n        }\n\n        fn visit_i16\u003cF\u003e(self, value: i16) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::I16(value))\n        }\n\n        fn visit_i32\u003cF\u003e(self, value: i32) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::I32(value))\n        }\n\n        fn visit_i64\u003cF\u003e(self, value: i64) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::I64(value))\n        }\n\n        fn visit_u8\u003cF\u003e(self, value: u8) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::U8(value))\n        }\n\n        fn visit_u16\u003cF\u003e(self, value: u16) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::U16(value))\n        }\n\n        fn visit_u32\u003cF\u003e(self, value: u32) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::U32(value))\n        }\n\n        fn visit_u64\u003cF\u003e(self, value: u64) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::U64(value))\n        }\n\n        fn visit_f32\u003cF\u003e(self, value: f32) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::F32(value))\n        }\n\n        fn visit_f64\u003cF\u003e(self, value: f64) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::F64(value))\n        }\n\n        fn visit_char\u003cF\u003e(self, value: char) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::Char(value))\n        }\n\n        fn visit_str\u003cF\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::String(value.into()))\n        }\n\n        fn visit_borrowed_str\u003cF\u003e(self, value: \u0026'de str) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::Str(value))\n        }\n\n        fn visit_string\u003cF\u003e(self, value: String) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::String(value))\n        }\n\n        fn visit_bytes\u003cF\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::ByteBuf(value.into()))\n        }\n\n        fn visit_borrowed_bytes\u003cF\u003e(self, value: \u0026'de [u8]) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::Bytes(value))\n        }\n\n        fn visit_byte_buf\u003cF\u003e(self, value: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::ByteBuf(value))\n        }\n\n        fn visit_unit\u003cF\u003e(self) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::Unit)\n        }\n\n        fn visit_none\u003cF\u003e(self) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            Ok(Content::None)\n        }\n\n        fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            Deserialize::deserialize(deserializer).map(|v| Content::Some(Box::new(v)))\n        }\n\n        fn visit_newtype_struct\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            Deserialize::deserialize(deserializer).map(|v| Content::Newtype(Box::new(v)))\n        }\n\n        fn visit_seq\u003cV\u003e(self, mut visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n        where\n            V: SeqAccess\u003c'de\u003e,\n        {\n            let mut vec = Vec::with_capacity(size_hint::cautious(visitor.size_hint()));\n            while let Some(e) = try!(visitor.next_element()) {\n                vec.push(e);\n            }\n            Ok(Content::Seq(vec))\n        }\n\n        fn visit_map\u003cV\u003e(self, mut visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n        where\n            V: MapAccess\u003c'de\u003e,\n        {\n            let mut vec = Vec::with_capacity(size_hint::cautious(visitor.size_hint()));\n            while let Some(kv) = try!(visitor.next_entry()) {\n                vec.push(kv);\n            }\n            Ok(Content::Map(vec))\n        }\n\n        fn visit_enum\u003cV\u003e(self, _visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n        where\n            V: EnumAccess\u003c'de\u003e,\n        {\n            Err(de::Error::custom(\n                \"untagged and internally tagged enums do not support enum input\",\n            ))\n        }\n    }\n\n    /// This is the type of the map keys in an internally tagged enum.\n    ///\n    /// Not public API.\n    pub enum TagOrContent\u003c'de\u003e {\n        Tag,\n        Content(Content\u003c'de\u003e),\n    }\n\n    struct TagOrContentVisitor\u003c'de\u003e {\n        name: \u0026'static str,\n        value: PhantomData\u003cTagOrContent\u003c'de\u003e\u003e,\n    }\n\n    impl\u003c'de\u003e TagOrContentVisitor\u003c'de\u003e {\n        fn new(name: \u0026'static str) -\u003e Self {\n            TagOrContentVisitor {\n                name: name,\n                value: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de\u003e DeserializeSeed\u003c'de\u003e for TagOrContentVisitor\u003c'de\u003e {\n        type Value = TagOrContent\u003c'de\u003e;\n\n        fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            // Internally tagged enums are only supported in self-describing\n            // formats.\n            deserializer.deserialize_any(self)\n        }\n    }\n\n    impl\u003c'de\u003e Visitor\u003c'de\u003e for TagOrContentVisitor\u003c'de\u003e {\n        type Value = TagOrContent\u003c'de\u003e;\n\n        fn expecting(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(fmt, \"a type tag `{}` or any other value\", self.name)\n        }\n\n        fn visit_bool\u003cF\u003e(self, value: bool) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_bool(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_i8\u003cF\u003e(self, value: i8) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_i8(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_i16\u003cF\u003e(self, value: i16) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_i16(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_i32\u003cF\u003e(self, value: i32) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_i32(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_i64\u003cF\u003e(self, value: i64) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_i64(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_u8\u003cF\u003e(self, value: u8) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_u8(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_u16\u003cF\u003e(self, value: u16) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_u16(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_u32\u003cF\u003e(self, value: u32) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_u32(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_u64\u003cF\u003e(self, value: u64) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_u64(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_f32\u003cF\u003e(self, value: f32) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_f32(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_f64\u003cF\u003e(self, value: f64) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_f64(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_char\u003cF\u003e(self, value: char) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_char(value)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_str\u003cF\u003e(self, value: \u0026str) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            if value == self.name {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_str(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_borrowed_str\u003cF\u003e(self, value: \u0026'de str) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            if value == self.name {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_borrowed_str(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_string\u003cF\u003e(self, value: String) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            if value == self.name {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_string(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_bytes\u003cF\u003e(self, value: \u0026[u8]) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            if value == self.name.as_bytes() {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_bytes(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_borrowed_bytes\u003cF\u003e(self, value: \u0026'de [u8]) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            if value == self.name.as_bytes() {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_borrowed_bytes(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_byte_buf\u003cF\u003e(self, value: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            if value == self.name.as_bytes() {\n                Ok(TagOrContent::Tag)\n            } else {\n                ContentVisitor::new()\n                    .visit_byte_buf(value)\n                    .map(TagOrContent::Content)\n            }\n        }\n\n        fn visit_unit\u003cF\u003e(self) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_unit()\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_none\u003cF\u003e(self) -\u003e Result\u003cSelf::Value, F\u003e\n        where\n            F: de::Error,\n        {\n            ContentVisitor::new()\n                .visit_none()\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_some\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            ContentVisitor::new()\n                .visit_some(deserializer)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_newtype_struct\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            ContentVisitor::new()\n                .visit_newtype_struct(deserializer)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n        where\n            V: SeqAccess\u003c'de\u003e,\n        {\n            ContentVisitor::new()\n                .visit_seq(visitor)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n        where\n            V: MapAccess\u003c'de\u003e,\n        {\n            ContentVisitor::new()\n                .visit_map(visitor)\n                .map(TagOrContent::Content)\n        }\n\n        fn visit_enum\u003cV\u003e(self, visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n        where\n            V: EnumAccess\u003c'de\u003e,\n        {\n            ContentVisitor::new()\n                .visit_enum(visitor)\n                .map(TagOrContent::Content)\n        }\n    }\n\n    /// Used by generated code to deserialize an internally tagged enum.\n    ///\n    /// Not public API.\n    pub struct TaggedContent\u003c'de, T\u003e {\n        pub tag: T,\n        pub content: Content\u003c'de\u003e,\n    }\n\n    /// Not public API.\n    pub struct TaggedContentVisitor\u003c'de, T\u003e {\n        tag_name: \u0026'static str,\n        value: PhantomData\u003cTaggedContent\u003c'de, T\u003e\u003e,\n    }\n\n    impl\u003c'de, T\u003e TaggedContentVisitor\u003c'de, T\u003e {\n        /// Visitor for the content of an internally tagged enum with the given\n        /// tag name.\n        pub fn new(name: \u0026'static str) -\u003e Self {\n            TaggedContentVisitor {\n                tag_name: name,\n                value: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de, T\u003e DeserializeSeed\u003c'de\u003e for TaggedContentVisitor\u003c'de, T\u003e\n    where\n        T: Deserialize\u003c'de\u003e,\n    {\n        type Value = TaggedContent\u003c'de, T\u003e;\n\n        fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            // Internally tagged enums are only supported in self-describing\n            // formats.\n            deserializer.deserialize_any(self)\n        }\n    }\n\n    impl\u003c'de, T\u003e Visitor\u003c'de\u003e for TaggedContentVisitor\u003c'de, T\u003e\n    where\n        T: Deserialize\u003c'de\u003e,\n    {\n        type Value = TaggedContent\u003c'de, T\u003e;\n\n        fn expecting(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            fmt.write_str(\"internally tagged enum\")\n        }\n\n        fn visit_seq\u003cS\u003e(self, mut seq: S) -\u003e Result\u003cSelf::Value, S::Error\u003e\n        where\n            S: SeqAccess\u003c'de\u003e,\n        {\n            let tag = match try!(seq.next_element()) {\n                Some(tag) =\u003e tag,\n                None =\u003e {\n                    return Err(de::Error::missing_field(self.tag_name));\n                }\n            };\n            let rest = de::value::SeqAccessDeserializer::new(seq);\n            Ok(TaggedContent {\n                tag: tag,\n                content: try!(Content::deserialize(rest)),\n            })\n        }\n\n        fn visit_map\u003cM\u003e(self, mut map: M) -\u003e Result\u003cSelf::Value, M::Error\u003e\n        where\n            M: MapAccess\u003c'de\u003e,\n        {\n            let mut tag = None;\n            let mut vec = Vec::with_capacity(size_hint::cautious(map.size_hint()));\n            while let Some(k) = try!(map.next_key_seed(TagOrContentVisitor::new(self.tag_name))) {\n                match k {\n                    TagOrContent::Tag =\u003e {\n                        if tag.is_some() {\n                            return Err(de::Error::duplicate_field(self.tag_name));\n                        }\n                        tag = Some(try!(map.next_value()));\n                    }\n                    TagOrContent::Content(k) =\u003e {\n                        let v = try!(map.next_value());\n                        vec.push((k, v));\n                    }\n                }\n            }\n            match tag {\n                None =\u003e Err(de::Error::missing_field(self.tag_name)),\n                Some(tag) =\u003e Ok(TaggedContent {\n                    tag: tag,\n                    content: Content::Map(vec),\n                }),\n            }\n        }\n    }\n\n    /// Used by generated code to deserialize an adjacently tagged enum.\n    ///\n    /// Not public API.\n    pub enum TagOrContentField {\n        Tag,\n        Content,\n    }\n\n    /// Not public API.\n    pub struct TagOrContentFieldVisitor {\n        pub tag: \u0026'static str,\n        pub content: \u0026'static str,\n    }\n\n    impl\u003c'de\u003e DeserializeSeed\u003c'de\u003e for TagOrContentFieldVisitor {\n        type Value = TagOrContentField;\n\n        fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            deserializer.deserialize_str(self)\n        }\n    }\n\n    impl\u003c'de\u003e Visitor\u003c'de\u003e for TagOrContentFieldVisitor {\n        type Value = TagOrContentField;\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(formatter, \"{:?} or {:?}\", self.tag, self.content)\n        }\n\n        fn visit_str\u003cE\u003e(self, field: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: de::Error,\n        {\n            if field == self.tag {\n                Ok(TagOrContentField::Tag)\n            } else if field == self.content {\n                Ok(TagOrContentField::Content)\n            } else {\n                Err(de::Error::invalid_value(Unexpected::Str(field), \u0026self))\n            }\n        }\n    }\n\n    /// Used by generated code to deserialize an adjacently tagged enum when\n    /// ignoring unrelated fields is allowed.\n    ///\n    /// Not public API.\n    pub enum TagContentOtherField {\n        Tag,\n        Content,\n        Other,\n    }\n\n    /// Not public API.\n    pub struct TagContentOtherFieldVisitor {\n        pub tag: \u0026'static str,\n        pub content: \u0026'static str,\n    }\n\n    impl\u003c'de\u003e DeserializeSeed\u003c'de\u003e for TagContentOtherFieldVisitor {\n        type Value = TagContentOtherField;\n\n        fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            deserializer.deserialize_str(self)\n        }\n    }\n\n    impl\u003c'de\u003e Visitor\u003c'de\u003e for TagContentOtherFieldVisitor {\n        type Value = TagContentOtherField;\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(\n                formatter,\n                \"{:?}, {:?}, or other ignored fields\",\n                self.tag, self.content\n            )\n        }\n\n        fn visit_str\u003cE\u003e(self, field: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n        where\n            E: de::Error,\n        {\n            if field == self.tag {\n                Ok(TagContentOtherField::Tag)\n            } else if field == self.content {\n                Ok(TagContentOtherField::Content)\n            } else {\n                Ok(TagContentOtherField::Other)\n            }\n        }\n    }\n\n    /// Not public API\n    pub struct ContentDeserializer\u003c'de, E\u003e {\n        content: Content\u003c'de\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, E\u003e ContentDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        #[cold]\n        fn invalid_type(self, exp: \u0026Expected) -\u003e E {\n            de::Error::invalid_type(self.content.unexpected(), exp)\n        }\n\n        fn deserialize_integer\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::U8(v) =\u003e visitor.visit_u8(v),\n                Content::U16(v) =\u003e visitor.visit_u16(v),\n                Content::U32(v) =\u003e visitor.visit_u32(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I8(v) =\u003e visitor.visit_i8(v),\n                Content::I16(v) =\u003e visitor.visit_i16(v),\n                Content::I32(v) =\u003e visitor.visit_i32(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n    }\n\n    fn visit_content_seq\u003c'de, V, E\u003e(content: Vec\u003cContent\u003c'de\u003e\u003e, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n        E: de::Error,\n    {\n        let seq = content.into_iter().map(ContentDeserializer::new);\n        let mut seq_visitor = de::value::SeqDeserializer::new(seq);\n        let value = try!(visitor.visit_seq(\u0026mut seq_visitor));\n        try!(seq_visitor.end());\n        Ok(value)\n    }\n\n    fn visit_content_map\u003c'de, V, E\u003e(\n        content: Vec\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, E\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n        E: de::Error,\n    {\n        let map = content\n            .into_iter()\n            .map(|(k, v)| (ContentDeserializer::new(k), ContentDeserializer::new(v)));\n        let mut map_visitor = de::value::MapDeserializer::new(map);\n        let value = try!(visitor.visit_map(\u0026mut map_visitor));\n        try!(map_visitor.end());\n        Ok(value)\n    }\n\n    /// Used when deserializing an internally tagged enum because the content\n    /// will be used exactly once.\n    impl\u003c'de, E\u003e Deserializer\u003c'de\u003e for ContentDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Bool(v) =\u003e visitor.visit_bool(v),\n                Content::U8(v) =\u003e visitor.visit_u8(v),\n                Content::U16(v) =\u003e visitor.visit_u16(v),\n                Content::U32(v) =\u003e visitor.visit_u32(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I8(v) =\u003e visitor.visit_i8(v),\n                Content::I16(v) =\u003e visitor.visit_i16(v),\n                Content::I32(v) =\u003e visitor.visit_i32(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                Content::F32(v) =\u003e visitor.visit_f32(v),\n                Content::F64(v) =\u003e visitor.visit_f64(v),\n                Content::Char(v) =\u003e visitor.visit_char(v),\n                Content::String(v) =\u003e visitor.visit_string(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(v) =\u003e visitor.visit_byte_buf(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                Content::Unit =\u003e visitor.visit_unit(),\n                Content::None =\u003e visitor.visit_none(),\n                Content::Some(v) =\u003e visitor.visit_some(ContentDeserializer::new(*v)),\n                Content::Newtype(v) =\u003e visitor.visit_newtype_struct(ContentDeserializer::new(*v)),\n                Content::Seq(v) =\u003e visit_content_seq(v, visitor),\n                Content::Map(v) =\u003e visit_content_map(v, visitor),\n            }\n        }\n\n        fn deserialize_bool\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Bool(v) =\u003e visitor.visit_bool(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_i8\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i16\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u8\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u16\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_f32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::F32(v) =\u003e visitor.visit_f32(v),\n                Content::F64(v) =\u003e visitor.visit_f64(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_f64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::F64(v) =\u003e visitor.visit_f64(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_char\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Char(v) =\u003e visitor.visit_char(v),\n                Content::String(v) =\u003e visitor.visit_string(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_string(visitor)\n        }\n\n        fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::String(v) =\u003e visitor.visit_string(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(v) =\u003e visitor.visit_byte_buf(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_bytes\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_byte_buf(visitor)\n        }\n\n        fn deserialize_byte_buf\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::String(v) =\u003e visitor.visit_string(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(v) =\u003e visitor.visit_byte_buf(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                Content::Seq(v) =\u003e visit_content_seq(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::None =\u003e visitor.visit_none(),\n                Content::Some(v) =\u003e visitor.visit_some(ContentDeserializer::new(*v)),\n                Content::Unit =\u003e visitor.visit_unit(),\n                _ =\u003e visitor.visit_some(self),\n            }\n        }\n\n        fn deserialize_unit\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Unit =\u003e visitor.visit_unit(),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_unit_struct\u003cV\u003e(\n            self,\n            _name: \u0026'static str,\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                // As a special case, allow deserializing untagged newtype\n                // variant containing unit struct.\n                //\n                //     #[derive(Deserialize)]\n                //     struct Info;\n                //\n                //     #[derive(Deserialize)]\n                //     #[serde(tag = \"topic\")]\n                //     enum Message {\n                //         Info(Info),\n                //     }\n                //\n                // We want {\"topic\":\"Info\"} to deserialize even though\n                // ordinarily unit structs do not deserialize from empty map.\n                Content::Map(ref v) if v.is_empty() =\u003e visitor.visit_unit(),\n                _ =\u003e self.deserialize_any(visitor),\n            }\n        }\n\n        fn deserialize_newtype_struct\u003cV\u003e(\n            self,\n            _name: \u0026str,\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Newtype(v) =\u003e visitor.visit_newtype_struct(ContentDeserializer::new(*v)),\n                _ =\u003e visitor.visit_newtype_struct(self),\n            }\n        }\n\n        fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Seq(v) =\u003e visit_content_seq(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_tuple\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_seq(visitor)\n        }\n\n        fn deserialize_tuple_struct\u003cV\u003e(\n            self,\n            _name: \u0026'static str,\n            _len: usize,\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_seq(visitor)\n        }\n\n        fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Map(v) =\u003e visit_content_map(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_struct\u003cV\u003e(\n            self,\n            _name: \u0026'static str,\n            _fields: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::Seq(v) =\u003e visit_content_seq(v, visitor),\n                Content::Map(v) =\u003e visit_content_map(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_enum\u003cV\u003e(\n            self,\n            _name: \u0026str,\n            _variants: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            let (variant, value) = match self.content {\n                Content::Map(value) =\u003e {\n                    let mut iter = value.into_iter();\n                    let (variant, value) = match iter.next() {\n                        Some(v) =\u003e v,\n                        None =\u003e {\n                            return Err(de::Error::invalid_value(\n                                de::Unexpected::Map,\n                                \u0026\"map with a single key\",\n                            ));\n                        }\n                    };\n                    // enums are encoded in json as maps with a single key:value pair\n                    if iter.next().is_some() {\n                        return Err(de::Error::invalid_value(\n                            de::Unexpected::Map,\n                            \u0026\"map with a single key\",\n                        ));\n                    }\n                    (variant, Some(value))\n                }\n                s @ Content::String(_) | s @ Content::Str(_) =\u003e (s, None),\n                other =\u003e {\n                    return Err(de::Error::invalid_type(\n                        other.unexpected(),\n                        \u0026\"string or map\",\n                    ));\n                }\n            };\n\n            visitor.visit_enum(EnumDeserializer::new(variant, value))\n        }\n\n        fn deserialize_identifier\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match self.content {\n                Content::String(v) =\u003e visitor.visit_string(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(v) =\u003e visitor.visit_byte_buf(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                Content::U8(v) =\u003e visitor.visit_u8(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_ignored_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            drop(self);\n            visitor.visit_unit()\n        }\n    }\n\n    impl\u003c'de, E\u003e ContentDeserializer\u003c'de, E\u003e {\n        /// private API, don't use\n        pub fn new(content: Content\u003c'de\u003e) -\u003e Self {\n            ContentDeserializer {\n                content: content,\n                err: PhantomData,\n            }\n        }\n    }\n\n    pub struct EnumDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        variant: Content\u003c'de\u003e,\n        value: Option\u003cContent\u003c'de\u003e\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, E\u003e EnumDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        pub fn new(variant: Content\u003c'de\u003e, value: Option\u003cContent\u003c'de\u003e\u003e) -\u003e EnumDeserializer\u003c'de, E\u003e {\n            EnumDeserializer {\n                variant: variant,\n                value: value,\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de, E\u003e de::EnumAccess\u003c'de\u003e for EnumDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n        type Variant = VariantDeserializer\u003c'de, Self::Error\u003e;\n\n        fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), E\u003e\n        where\n            V: de::DeserializeSeed\u003c'de\u003e,\n        {\n            let visitor = VariantDeserializer {\n                value: self.value,\n                err: PhantomData,\n            };\n            seed.deserialize(ContentDeserializer::new(self.variant))\n                .map(|v| (v, visitor))\n        }\n    }\n\n    pub struct VariantDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        value: Option\u003cContent\u003c'de\u003e\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, E\u003e de::VariantAccess\u003c'de\u003e for VariantDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn unit_variant(self) -\u003e Result\u003c(), E\u003e {\n            match self.value {\n                Some(value) =\u003e de::Deserialize::deserialize(ContentDeserializer::new(value)),\n                None =\u003e Ok(()),\n            }\n        }\n\n        fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, E\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.value {\n                Some(value) =\u003e seed.deserialize(ContentDeserializer::new(value)),\n                None =\u003e Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    \u0026\"newtype variant\",\n                )),\n            }\n        }\n\n        fn tuple_variant\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            match self.value {\n                Some(Content::Seq(v)) =\u003e {\n                    de::Deserializer::deserialize_any(SeqDeserializer::new(v), visitor)\n                }\n                Some(other) =\u003e Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    \u0026\"tuple variant\",\n                )),\n                None =\u003e Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    \u0026\"tuple variant\",\n                )),\n            }\n        }\n\n        fn struct_variant\u003cV\u003e(\n            self,\n            _fields: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            match self.value {\n                Some(Content::Map(v)) =\u003e {\n                    de::Deserializer::deserialize_any(MapDeserializer::new(v), visitor)\n                }\n                Some(Content::Seq(v)) =\u003e {\n                    de::Deserializer::deserialize_any(SeqDeserializer::new(v), visitor)\n                }\n                Some(other) =\u003e Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    \u0026\"struct variant\",\n                )),\n                _ =\u003e Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    \u0026\"struct variant\",\n                )),\n            }\n        }\n    }\n\n    struct SeqDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        iter: \u003cVec\u003cContent\u003c'de\u003e\u003e as IntoIterator\u003e::IntoIter,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, E\u003e SeqDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        fn new(vec: Vec\u003cContent\u003c'de\u003e\u003e) -\u003e Self {\n            SeqDeserializer {\n                iter: vec.into_iter(),\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for SeqDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        #[inline]\n        fn deserialize_any\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            let len = self.iter.len();\n            if len == 0 {\n                visitor.visit_unit()\n            } else {\n                let ret = try!(visitor.visit_seq(\u0026mut self));\n                let remaining = self.iter.len();\n                if remaining == 0 {\n                    Ok(ret)\n                } else {\n                    Err(de::Error::invalid_length(len, \u0026\"fewer elements in array\"))\n                }\n            }\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf option unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    impl\u003c'de, E\u003e de::SeqAccess\u003c'de\u003e for SeqDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.iter.next() {\n                Some(value) =\u003e seed.deserialize(ContentDeserializer::new(value)).map(Some),\n                None =\u003e Ok(None),\n            }\n        }\n\n        fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n            size_hint::from_bounds(\u0026self.iter)\n        }\n    }\n\n    struct MapDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        iter: \u003cVec\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e as IntoIterator\u003e::IntoIter,\n        value: Option\u003cContent\u003c'de\u003e\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, E\u003e MapDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        fn new(map: Vec\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e) -\u003e Self {\n            MapDeserializer {\n                iter: map.into_iter(),\n                value: None,\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de, E\u003e de::MapAccess\u003c'de\u003e for MapDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn next_key_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.iter.next() {\n                Some((key, value)) =\u003e {\n                    self.value = Some(value);\n                    seed.deserialize(ContentDeserializer::new(key)).map(Some)\n                }\n                None =\u003e Ok(None),\n            }\n        }\n\n        fn next_value_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.value.take() {\n                Some(value) =\u003e seed.deserialize(ContentDeserializer::new(value)),\n                None =\u003e Err(de::Error::custom(\"value is missing\")),\n            }\n        }\n\n        fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n            size_hint::from_bounds(\u0026self.iter)\n        }\n    }\n\n    impl\u003c'de, E\u003e de::Deserializer\u003c'de\u003e for MapDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        #[inline]\n        fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            visitor.visit_map(self)\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf option unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    /// Not public API.\n    pub struct ContentRefDeserializer\u003c'a, 'de: 'a, E\u003e {\n        content: \u0026'a Content\u003c'de\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'a, 'de, E\u003e ContentRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        #[cold]\n        fn invalid_type(self, exp: \u0026Expected) -\u003e E {\n            de::Error::invalid_type(self.content.unexpected(), exp)\n        }\n\n        fn deserialize_integer\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::U8(v) =\u003e visitor.visit_u8(v),\n                Content::U16(v) =\u003e visitor.visit_u16(v),\n                Content::U32(v) =\u003e visitor.visit_u32(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I8(v) =\u003e visitor.visit_i8(v),\n                Content::I16(v) =\u003e visitor.visit_i16(v),\n                Content::I32(v) =\u003e visitor.visit_i32(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n    }\n\n    fn visit_content_seq_ref\u003c'a, 'de, V, E\u003e(\n        content: \u0026'a [Content\u003c'de\u003e],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, E\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n        E: de::Error,\n    {\n        let seq = content.iter().map(ContentRefDeserializer::new);\n        let mut seq_visitor = de::value::SeqDeserializer::new(seq);\n        let value = try!(visitor.visit_seq(\u0026mut seq_visitor));\n        try!(seq_visitor.end());\n        Ok(value)\n    }\n\n    fn visit_content_map_ref\u003c'a, 'de, V, E\u003e(\n        content: \u0026'a [(Content\u003c'de\u003e, Content\u003c'de\u003e)],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, E\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n        E: de::Error,\n    {\n        let map = content.iter().map(|\u0026(ref k, ref v)| {\n            (\n                ContentRefDeserializer::new(k),\n                ContentRefDeserializer::new(v),\n            )\n        });\n        let mut map_visitor = de::value::MapDeserializer::new(map);\n        let value = try!(visitor.visit_map(\u0026mut map_visitor));\n        try!(map_visitor.end());\n        Ok(value)\n    }\n\n    /// Used when deserializing an untagged enum because the content may need\n    /// to be used more than once.\n    impl\u003c'de, 'a, E\u003e Deserializer\u003c'de\u003e for ContentRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Bool(v) =\u003e visitor.visit_bool(v),\n                Content::U8(v) =\u003e visitor.visit_u8(v),\n                Content::U16(v) =\u003e visitor.visit_u16(v),\n                Content::U32(v) =\u003e visitor.visit_u32(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I8(v) =\u003e visitor.visit_i8(v),\n                Content::I16(v) =\u003e visitor.visit_i16(v),\n                Content::I32(v) =\u003e visitor.visit_i32(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                Content::F32(v) =\u003e visitor.visit_f32(v),\n                Content::F64(v) =\u003e visitor.visit_f64(v),\n                Content::Char(v) =\u003e visitor.visit_char(v),\n                Content::String(ref v) =\u003e visitor.visit_str(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(ref v) =\u003e visitor.visit_bytes(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                Content::Unit =\u003e visitor.visit_unit(),\n                Content::None =\u003e visitor.visit_none(),\n                Content::Some(ref v) =\u003e visitor.visit_some(ContentRefDeserializer::new(v)),\n                Content::Newtype(ref v) =\u003e {\n                    visitor.visit_newtype_struct(ContentRefDeserializer::new(v))\n                }\n                Content::Seq(ref v) =\u003e visit_content_seq_ref(v, visitor),\n                Content::Map(ref v) =\u003e visit_content_map_ref(v, visitor),\n            }\n        }\n\n        fn deserialize_bool\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Bool(v) =\u003e visitor.visit_bool(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_i8\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i16\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_i64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u8\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u16\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_u64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_integer(visitor)\n        }\n\n        fn deserialize_f32\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::F32(v) =\u003e visitor.visit_f32(v),\n                Content::F64(v) =\u003e visitor.visit_f64(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_f64\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::F64(v) =\u003e visitor.visit_f64(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                Content::I64(v) =\u003e visitor.visit_i64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_char\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Char(v) =\u003e visitor.visit_char(v),\n                Content::String(ref v) =\u003e visitor.visit_str(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_str\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::String(ref v) =\u003e visitor.visit_str(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(ref v) =\u003e visitor.visit_bytes(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_string\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_str(visitor)\n        }\n\n        fn deserialize_bytes\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::String(ref v) =\u003e visitor.visit_str(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(ref v) =\u003e visitor.visit_bytes(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                Content::Seq(ref v) =\u003e visit_content_seq_ref(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_byte_buf\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_bytes(visitor)\n        }\n\n        fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::None =\u003e visitor.visit_none(),\n                Content::Some(ref v) =\u003e visitor.visit_some(ContentRefDeserializer::new(v)),\n                Content::Unit =\u003e visitor.visit_unit(),\n                _ =\u003e visitor.visit_some(self),\n            }\n        }\n\n        fn deserialize_unit\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Unit =\u003e visitor.visit_unit(),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_unit_struct\u003cV\u003e(\n            self,\n            _name: \u0026'static str,\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_unit(visitor)\n        }\n\n        fn deserialize_newtype_struct\u003cV\u003e(self, _name: \u0026str, visitor: V) -\u003e Result\u003cV::Value, E\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Newtype(ref v) =\u003e {\n                    visitor.visit_newtype_struct(ContentRefDeserializer::new(v))\n                }\n                _ =\u003e visitor.visit_newtype_struct(self),\n            }\n        }\n\n        fn deserialize_seq\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Seq(ref v) =\u003e visit_content_seq_ref(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_tuple\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_seq(visitor)\n        }\n\n        fn deserialize_tuple_struct\u003cV\u003e(\n            self,\n            _name: \u0026'static str,\n            _len: usize,\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            self.deserialize_seq(visitor)\n        }\n\n        fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Map(ref v) =\u003e visit_content_map_ref(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_struct\u003cV\u003e(\n            self,\n            _name: \u0026'static str,\n            _fields: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::Seq(ref v) =\u003e visit_content_seq_ref(v, visitor),\n                Content::Map(ref v) =\u003e visit_content_map_ref(v, visitor),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_enum\u003cV\u003e(\n            self,\n            _name: \u0026str,\n            _variants: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            let (variant, value) = match *self.content {\n                Content::Map(ref value) =\u003e {\n                    let mut iter = value.iter();\n                    let \u0026(ref variant, ref value) = match iter.next() {\n                        Some(v) =\u003e v,\n                        None =\u003e {\n                            return Err(de::Error::invalid_value(\n                                de::Unexpected::Map,\n                                \u0026\"map with a single key\",\n                            ));\n                        }\n                    };\n                    // enums are encoded in json as maps with a single key:value pair\n                    if iter.next().is_some() {\n                        return Err(de::Error::invalid_value(\n                            de::Unexpected::Map,\n                            \u0026\"map with a single key\",\n                        ));\n                    }\n                    (variant, Some(value))\n                }\n                ref s @ Content::String(_) | ref s @ Content::Str(_) =\u003e (s, None),\n                ref other =\u003e {\n                    return Err(de::Error::invalid_type(\n                        other.unexpected(),\n                        \u0026\"string or map\",\n                    ));\n                }\n            };\n\n            visitor.visit_enum(EnumRefDeserializer {\n                variant: variant,\n                value: value,\n                err: PhantomData,\n            })\n        }\n\n        fn deserialize_identifier\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            match *self.content {\n                Content::String(ref v) =\u003e visitor.visit_str(v),\n                Content::Str(v) =\u003e visitor.visit_borrowed_str(v),\n                Content::ByteBuf(ref v) =\u003e visitor.visit_bytes(v),\n                Content::Bytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n                Content::U8(v) =\u003e visitor.visit_u8(v),\n                Content::U64(v) =\u003e visitor.visit_u64(v),\n                _ =\u003e Err(self.invalid_type(\u0026visitor)),\n            }\n        }\n\n        fn deserialize_ignored_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: Visitor\u003c'de\u003e,\n        {\n            visitor.visit_unit()\n        }\n    }\n\n    impl\u003c'a, 'de, E\u003e ContentRefDeserializer\u003c'a, 'de, E\u003e {\n        /// private API, don't use\n        pub fn new(content: \u0026'a Content\u003c'de\u003e) -\u003e Self {\n            ContentRefDeserializer {\n                content: content,\n                err: PhantomData,\n            }\n        }\n    }\n\n    struct EnumRefDeserializer\u003c'a, 'de: 'a, E\u003e\n    where\n        E: de::Error,\n    {\n        variant: \u0026'a Content\u003c'de\u003e,\n        value: Option\u003c\u0026'a Content\u003c'de\u003e\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, 'a, E\u003e de::EnumAccess\u003c'de\u003e for EnumRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n        type Variant = VariantRefDeserializer\u003c'a, 'de, Self::Error\u003e;\n\n        fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n        where\n            V: de::DeserializeSeed\u003c'de\u003e,\n        {\n            let visitor = VariantRefDeserializer {\n                value: self.value,\n                err: PhantomData,\n            };\n            seed.deserialize(ContentRefDeserializer::new(self.variant))\n                .map(|v| (v, visitor))\n        }\n    }\n\n    struct VariantRefDeserializer\u003c'a, 'de: 'a, E\u003e\n    where\n        E: de::Error,\n    {\n        value: Option\u003c\u0026'a Content\u003c'de\u003e\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'de, 'a, E\u003e de::VariantAccess\u003c'de\u003e for VariantRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn unit_variant(self) -\u003e Result\u003c(), E\u003e {\n            match self.value {\n                Some(value) =\u003e de::Deserialize::deserialize(ContentRefDeserializer::new(value)),\n                None =\u003e Ok(()),\n            }\n        }\n\n        fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, E\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.value {\n                Some(value) =\u003e seed.deserialize(ContentRefDeserializer::new(value)),\n                None =\u003e Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    \u0026\"newtype variant\",\n                )),\n            }\n        }\n\n        fn tuple_variant\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            match self.value {\n                Some(\u0026Content::Seq(ref v)) =\u003e {\n                    de::Deserializer::deserialize_any(SeqRefDeserializer::new(v), visitor)\n                }\n                Some(other) =\u003e Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    \u0026\"tuple variant\",\n                )),\n                None =\u003e Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    \u0026\"tuple variant\",\n                )),\n            }\n        }\n\n        fn struct_variant\u003cV\u003e(\n            self,\n            _fields: \u0026'static [\u0026'static str],\n            visitor: V,\n        ) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            match self.value {\n                Some(\u0026Content::Map(ref v)) =\u003e {\n                    de::Deserializer::deserialize_any(MapRefDeserializer::new(v), visitor)\n                }\n                Some(\u0026Content::Seq(ref v)) =\u003e {\n                    de::Deserializer::deserialize_any(SeqRefDeserializer::new(v), visitor)\n                }\n                Some(other) =\u003e Err(de::Error::invalid_type(\n                    other.unexpected(),\n                    \u0026\"struct variant\",\n                )),\n                _ =\u003e Err(de::Error::invalid_type(\n                    de::Unexpected::UnitVariant,\n                    \u0026\"struct variant\",\n                )),\n            }\n        }\n    }\n\n    struct SeqRefDeserializer\u003c'a, 'de: 'a, E\u003e\n    where\n        E: de::Error,\n    {\n        iter: \u003c\u0026'a [Content\u003c'de\u003e] as IntoIterator\u003e::IntoIter,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'a, 'de, E\u003e SeqRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        fn new(slice: \u0026'a [Content\u003c'de\u003e]) -\u003e Self {\n            SeqRefDeserializer {\n                iter: slice.iter(),\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de, 'a, E\u003e de::Deserializer\u003c'de\u003e for SeqRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        #[inline]\n        fn deserialize_any\u003cV\u003e(mut self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            let len = self.iter.len();\n            if len == 0 {\n                visitor.visit_unit()\n            } else {\n                let ret = try!(visitor.visit_seq(\u0026mut self));\n                let remaining = self.iter.len();\n                if remaining == 0 {\n                    Ok(ret)\n                } else {\n                    Err(de::Error::invalid_length(len, \u0026\"fewer elements in array\"))\n                }\n            }\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf option unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    impl\u003c'de, 'a, E\u003e de::SeqAccess\u003c'de\u003e for SeqRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.iter.next() {\n                Some(value) =\u003e seed\n                    .deserialize(ContentRefDeserializer::new(value))\n                    .map(Some),\n                None =\u003e Ok(None),\n            }\n        }\n\n        fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n            size_hint::from_bounds(\u0026self.iter)\n        }\n    }\n\n    struct MapRefDeserializer\u003c'a, 'de: 'a, E\u003e\n    where\n        E: de::Error,\n    {\n        iter: \u003c\u0026'a [(Content\u003c'de\u003e, Content\u003c'de\u003e)] as IntoIterator\u003e::IntoIter,\n        value: Option\u003c\u0026'a Content\u003c'de\u003e\u003e,\n        err: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003c'a, 'de, E\u003e MapRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        fn new(map: \u0026'a [(Content\u003c'de\u003e, Content\u003c'de\u003e)]) -\u003e Self {\n            MapRefDeserializer {\n                iter: map.iter(),\n                value: None,\n                err: PhantomData,\n            }\n        }\n    }\n\n    impl\u003c'de, 'a, E\u003e de::MapAccess\u003c'de\u003e for MapRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        fn next_key_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.iter.next() {\n                Some(\u0026(ref key, ref value)) =\u003e {\n                    self.value = Some(value);\n                    seed.deserialize(ContentRefDeserializer::new(key)).map(Some)\n                }\n                None =\u003e Ok(None),\n            }\n        }\n\n        fn next_value_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n        where\n            T: de::DeserializeSeed\u003c'de\u003e,\n        {\n            match self.value.take() {\n                Some(value) =\u003e seed.deserialize(ContentRefDeserializer::new(value)),\n                None =\u003e Err(de::Error::custom(\"value is missing\")),\n            }\n        }\n\n        fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n            size_hint::from_bounds(\u0026self.iter)\n        }\n    }\n\n    impl\u003c'de, 'a, E\u003e de::Deserializer\u003c'de\u003e for MapRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Error = E;\n\n        #[inline]\n        fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n        where\n            V: de::Visitor\u003c'de\u003e,\n        {\n            visitor.visit_map(self)\n        }\n\n        forward_to_deserialize_any! {\n            bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n            bytes byte_buf option unit unit_struct newtype_struct seq tuple\n            tuple_struct map struct enum identifier ignored_any\n        }\n    }\n\n    impl\u003c'de, E\u003e de::IntoDeserializer\u003c'de, E\u003e for ContentDeserializer\u003c'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Deserializer = Self;\n\n        fn into_deserializer(self) -\u003e Self {\n            self\n        }\n    }\n\n    impl\u003c'de, 'a, E\u003e de::IntoDeserializer\u003c'de, E\u003e for ContentRefDeserializer\u003c'a, 'de, E\u003e\n    where\n        E: de::Error,\n    {\n        type Deserializer = Self;\n\n        fn into_deserializer(self) -\u003e Self {\n            self\n        }\n    }\n\n    /// Visitor for deserializing an internally tagged unit variant.\n    ///\n    /// Not public API.\n    pub struct InternallyTaggedUnitVisitor\u003c'a\u003e {\n        type_name: \u0026'a str,\n        variant_name: \u0026'a str,\n    }\n\n    impl\u003c'a\u003e InternallyTaggedUnitVisitor\u003c'a\u003e {\n        /// Not public API.\n        pub fn new(type_name: \u0026'a str, variant_name: \u0026'a str) -\u003e Self {\n            InternallyTaggedUnitVisitor {\n                type_name: type_name,\n                variant_name: variant_name,\n            }\n        }\n    }\n\n    impl\u003c'de, 'a\u003e Visitor\u003c'de\u003e for InternallyTaggedUnitVisitor\u003c'a\u003e {\n        type Value = ();\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(\n                formatter,\n                \"unit variant {}::{}\",\n                self.type_name, self.variant_name\n            )\n        }\n\n        fn visit_seq\u003cS\u003e(self, _: S) -\u003e Result\u003c(), S::Error\u003e\n        where\n            S: SeqAccess\u003c'de\u003e,\n        {\n            Ok(())\n        }\n\n        fn visit_map\u003cM\u003e(self, mut access: M) -\u003e Result\u003c(), M::Error\u003e\n        where\n            M: MapAccess\u003c'de\u003e,\n        {\n            while let Some(_) = try!(access.next_entry::\u003cIgnoredAny, IgnoredAny\u003e()) {}\n            Ok(())\n        }\n    }\n\n    /// Visitor for deserializing an untagged unit variant.\n    ///\n    /// Not public API.\n    pub struct UntaggedUnitVisitor\u003c'a\u003e {\n        type_name: \u0026'a str,\n        variant_name: \u0026'a str,\n    }\n\n    impl\u003c'a\u003e UntaggedUnitVisitor\u003c'a\u003e {\n        /// Not public API.\n        pub fn new(type_name: \u0026'a str, variant_name: \u0026'a str) -\u003e Self {\n            UntaggedUnitVisitor {\n                type_name: type_name,\n                variant_name: variant_name,\n            }\n        }\n    }\n\n    impl\u003c'de, 'a\u003e Visitor\u003c'de\u003e for UntaggedUnitVisitor\u003c'a\u003e {\n        type Value = ();\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(\n                formatter,\n                \"unit variant {}::{}\",\n                self.type_name, self.variant_name\n            )\n        }\n\n        fn visit_unit\u003cE\u003e(self) -\u003e Result\u003c(), E\u003e\n        where\n            E: de::Error,\n        {\n            Ok(())\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Like `IntoDeserializer` but also implemented for `\u0026[u8]`. This is used for\n// the newtype fallthrough case of `field_identifier`.\n//\n//    #[derive(Deserialize)]\n//    #[serde(field_identifier)]\n//    enum F {\n//        A,\n//        B,\n//        Other(String), // deserialized using IdentifierDeserializer\n//    }\npub trait IdentifierDeserializer\u003c'de, E: Error\u003e {\n    type Deserializer: Deserializer\u003c'de, Error = E\u003e;\n\n    fn from(self) -\u003e Self::Deserializer;\n}\n\nimpl\u003c'de, E\u003e IdentifierDeserializer\u003c'de, E\u003e for u32\nwhere\n    E: Error,\n{\n    type Deserializer = \u003cu32 as IntoDeserializer\u003c'de, E\u003e\u003e::Deserializer;\n\n    fn from(self) -\u003e Self::Deserializer {\n        self.into_deserializer()\n    }\n}\n\npub struct StrDeserializer\u003c'a, E\u003e {\n    value: \u0026'a str,\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl\u003c'a, E\u003e IdentifierDeserializer\u003c'a, E\u003e for \u0026'a str\nwhere\n    E: Error,\n{\n    type Deserializer = StrDeserializer\u003c'a, E\u003e;\n\n    fn from(self) -\u003e Self::Deserializer {\n        StrDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, 'a, E\u003e Deserializer\u003c'de\u003e for StrDeserializer\u003c'a, E\u003e\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_str(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\npub struct BytesDeserializer\u003c'a, E\u003e {\n    value: \u0026'a [u8],\n    marker: PhantomData\u003cE\u003e,\n}\n\nimpl\u003c'a, E\u003e IdentifierDeserializer\u003c'a, E\u003e for \u0026'a [u8]\nwhere\n    E: Error,\n{\n    type Deserializer = BytesDeserializer\u003c'a, E\u003e;\n\n    fn from(self) -\u003e Self::Deserializer {\n        BytesDeserializer {\n            value: self,\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl\u003c'de, 'a, E\u003e Deserializer\u003c'de\u003e for BytesDeserializer\u003c'a, E\u003e\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_bytes(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\n/// A DeserializeSeed helper for implementing deserialize_in_place Visitors.\n///\n/// Wraps a mutable reference and calls deserialize_in_place on it.\npub struct InPlaceSeed\u003c'a, T: 'a\u003e(pub \u0026'a mut T);\n\nimpl\u003c'a, 'de, T\u003e DeserializeSeed\u003c'de\u003e for InPlaceSeed\u003c'a, T\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    type Value = ();\n    fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize_in_place(deserializer, self.0)\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapDeserializer\u003c'a, 'de: 'a, E\u003e(\n    pub \u0026'a mut Vec\u003cOption\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e\u003e,\n    pub PhantomData\u003cE\u003e,\n);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e FlatMapDeserializer\u003c'a, 'de, E\u003e\nwhere\n    E: Error,\n{\n    fn deserialize_other\u003cV\u003e() -\u003e Result\u003cV, E\u003e {\n        Err(Error::custom(\"can only flatten structs and maps\"))\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! forward_to_deserialize_other {\n    ($($func:ident ( $($arg:ty),* ))*) =\u003e {\n        $(\n            fn $func\u003cV\u003e(self, $(_: $arg,)* _visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                Self::deserialize_other()\n            }\n        )*\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e Deserializer\u003c'de\u003e for FlatMapDeserializer\u003c'a, 'de, E\u003e\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_map(FlatInternallyTaggedAccess {\n            iter: self.0.iter_mut(),\n            pending: None,\n            _marker: PhantomData,\n        })\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        for item in self.0.iter_mut() {\n            // items in the vector are nulled out when used.  So we can only use\n            // an item if it's still filled in and if the field is one we care\n            // about.\n            let use_item = match *item {\n                None =\u003e false,\n                Some((ref c, _)) =\u003e c.as_str().map_or(false, |x| variants.contains(\u0026x)),\n            };\n\n            if use_item {\n                let (key, value) = item.take().unwrap();\n                return visitor.visit_enum(EnumDeserializer::new(key, Some(value)));\n            }\n        }\n\n        Err(Error::custom(format_args!(\n            \"no variant of enum {} found in flattened data\",\n            name\n        )))\n    }\n\n    fn deserialize_map\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_map(FlatMapAccess::new(self.0.iter()))\n    }\n\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        _: \u0026'static str,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_map(FlatStructAccess::new(self.0.iter_mut(), fields))\n    }\n\n    fn deserialize_newtype_struct\u003cV\u003e(self, _name: \u0026str, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_newtype_struct(self)\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match visitor.__private_visit_untagged_option(self) {\n            Ok(value) =\u003e Ok(value),\n            Err(()) =\u003e Self::deserialize_other(),\n        }\n    }\n\n    forward_to_deserialize_other! {\n        deserialize_bool()\n        deserialize_i8()\n        deserialize_i16()\n        deserialize_i32()\n        deserialize_i64()\n        deserialize_u8()\n        deserialize_u16()\n        deserialize_u32()\n        deserialize_u64()\n        deserialize_f32()\n        deserialize_f64()\n        deserialize_char()\n        deserialize_str()\n        deserialize_string()\n        deserialize_bytes()\n        deserialize_byte_buf()\n        deserialize_unit()\n        deserialize_unit_struct(\u0026'static str)\n        deserialize_seq()\n        deserialize_tuple(usize)\n        deserialize_tuple_struct(\u0026'static str, usize)\n        deserialize_identifier()\n        deserialize_ignored_any()\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapAccess\u003c'a, 'de: 'a, E\u003e {\n    iter: slice::Iter\u003c'a, Option\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e\u003e,\n    pending_content: Option\u003c\u0026'a Content\u003c'de\u003e\u003e,\n    _marker: PhantomData\u003cE\u003e,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e FlatMapAccess\u003c'a, 'de, E\u003e {\n    fn new(\n        iter: slice::Iter\u003c'a, Option\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e\u003e,\n    ) -\u003e FlatMapAccess\u003c'a, 'de, E\u003e {\n        FlatMapAccess {\n            iter: iter,\n            pending_content: None,\n            _marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e MapAccess\u003c'de\u003e for FlatMapAccess\u003c'a, 'de, E\u003e\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn next_key_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        while let Some(item) = self.iter.next() {\n            // Items in the vector are nulled out when used by a struct.\n            if let Some((ref key, ref content)) = *item {\n                self.pending_content = Some(content);\n                return seed.deserialize(ContentRefDeserializer::new(key)).map(Some);\n            }\n        }\n        Ok(None)\n    }\n\n    fn next_value_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.pending_content.take() {\n            Some(value) =\u003e seed.deserialize(ContentRefDeserializer::new(value)),\n            None =\u003e Err(Error::custom(\"value is missing\")),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatStructAccess\u003c'a, 'de: 'a, E\u003e {\n    iter: slice::IterMut\u003c'a, Option\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e\u003e,\n    pending_content: Option\u003cContent\u003c'de\u003e\u003e,\n    fields: \u0026'static [\u0026'static str],\n    _marker: PhantomData\u003cE\u003e,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e FlatStructAccess\u003c'a, 'de, E\u003e {\n    fn new(\n        iter: slice::IterMut\u003c'a, Option\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e\u003e,\n        fields: \u0026'static [\u0026'static str],\n    ) -\u003e FlatStructAccess\u003c'a, 'de, E\u003e {\n        FlatStructAccess {\n            iter: iter,\n            pending_content: None,\n            fields: fields,\n            _marker: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e MapAccess\u003c'de\u003e for FlatStructAccess\u003c'a, 'de, E\u003e\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn next_key_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        while let Some(item) = self.iter.next() {\n            // items in the vector are nulled out when used.  So we can only use\n            // an item if it's still filled in and if the field is one we care\n            // about.  In case we do not know which fields we want, we take them all.\n            let use_item = match *item {\n                None =\u003e false,\n                Some((ref c, _)) =\u003e c.as_str().map_or(false, |key| self.fields.contains(\u0026key)),\n            };\n\n            if use_item {\n                let (key, content) = item.take().unwrap();\n                self.pending_content = Some(content);\n                return seed.deserialize(ContentDeserializer::new(key)).map(Some);\n            }\n        }\n        Ok(None)\n    }\n\n    fn next_value_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.pending_content.take() {\n            Some(value) =\u003e seed.deserialize(ContentDeserializer::new(value)),\n            None =\u003e Err(Error::custom(\"value is missing\")),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatInternallyTaggedAccess\u003c'a, 'de: 'a, E\u003e {\n    iter: slice::IterMut\u003c'a, Option\u003c(Content\u003c'de\u003e, Content\u003c'de\u003e)\u003e\u003e,\n    pending: Option\u003c\u0026'a Content\u003c'de\u003e\u003e,\n    _marker: PhantomData\u003cE\u003e,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, 'de, E\u003e MapAccess\u003c'de\u003e for FlatInternallyTaggedAccess\u003c'a, 'de, E\u003e\nwhere\n    E: Error,\n{\n    type Error = E;\n\n    fn next_key_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        while let Some(item) = self.iter.next() {\n            if let Some((ref key, ref content)) = *item {\n                // Do not take(), instead borrow this entry. The internally tagged\n                // enum does its own buffering so we can't tell whether this entry\n                // is going to be consumed. Borrowing here leaves the entry\n                // available for later flattened fields.\n                self.pending = Some(content);\n                return seed.deserialize(ContentRefDeserializer::new(key)).map(Some);\n            }\n        }\n        Ok(None)\n    }\n\n    fn next_value_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.pending.take() {\n            Some(value) =\u003e seed.deserialize(ContentRefDeserializer::new(value)),\n            None =\u003e panic!(\"value is missing\"),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","private","macros.rs"],"content":"#[doc(hidden)]\n#[macro_export]\nmacro_rules! __private_serialize {\n    () =\u003e {\n        trait Serialize {\n            fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                S: $crate::Serializer;\n        }\n    };\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! __private_deserialize {\n    () =\u003e {\n        trait Deserialize\u003c'de\u003e: Sized {\n            fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n            where\n                D: $crate::Deserializer\u003c'de\u003e;\n        }\n    };\n}\n\n/// Used only by Serde doc tests. Not public API.\n#[doc(hidden)]\n#[macro_export(local_inner_macros)]\nmacro_rules! __serialize_unimplemented {\n    ($($func:ident)*) =\u003e {\n        $(\n            __serialize_unimplemented_helper!($func);\n        )*\n    };\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! __serialize_unimplemented_method {\n    ($func:ident $(\u003c$t:ident\u003e)* ($($arg:ty),*) -\u003e $ret:ident) =\u003e {\n        fn $func $(\u003c$t: ?Sized + $crate::Serialize\u003e)* (self $(, _: $arg)*) -\u003e $crate::export::Result\u003cSelf::$ret, Self::Error\u003e {\n            unimplemented!()\n        }\n    };\n}\n\n#[doc(hidden)]\n#[macro_export(local_inner_macros)]\nmacro_rules! __serialize_unimplemented_helper {\n    (bool) =\u003e {\n        __serialize_unimplemented_method!(serialize_bool(bool) -\u003e Ok);\n    };\n    (i8) =\u003e {\n        __serialize_unimplemented_method!(serialize_i8(i8) -\u003e Ok);\n    };\n    (i16) =\u003e {\n        __serialize_unimplemented_method!(serialize_i16(i16) -\u003e Ok);\n    };\n    (i32) =\u003e {\n        __serialize_unimplemented_method!(serialize_i32(i32) -\u003e Ok);\n    };\n    (i64) =\u003e {\n        __serialize_unimplemented_method!(serialize_i64(i64) -\u003e Ok);\n    };\n    (u8) =\u003e {\n        __serialize_unimplemented_method!(serialize_u8(u8) -\u003e Ok);\n    };\n    (u16) =\u003e {\n        __serialize_unimplemented_method!(serialize_u16(u16) -\u003e Ok);\n    };\n    (u32) =\u003e {\n        __serialize_unimplemented_method!(serialize_u32(u32) -\u003e Ok);\n    };\n    (u64) =\u003e {\n        __serialize_unimplemented_method!(serialize_u64(u64) -\u003e Ok);\n    };\n    (f32) =\u003e {\n        __serialize_unimplemented_method!(serialize_f32(f32) -\u003e Ok);\n    };\n    (f64) =\u003e {\n        __serialize_unimplemented_method!(serialize_f64(f64) -\u003e Ok);\n    };\n    (char) =\u003e {\n        __serialize_unimplemented_method!(serialize_char(char) -\u003e Ok);\n    };\n    (str) =\u003e {\n        __serialize_unimplemented_method!(serialize_str(\u0026str) -\u003e Ok);\n    };\n    (bytes) =\u003e {\n        __serialize_unimplemented_method!(serialize_bytes(\u0026[u8]) -\u003e Ok);\n    };\n    (none) =\u003e {\n        __serialize_unimplemented_method!(serialize_none() -\u003e Ok);\n    };\n    (some) =\u003e {\n        __serialize_unimplemented_method!(serialize_some\u003cT\u003e(\u0026T) -\u003e Ok);\n    };\n    (unit) =\u003e {\n        __serialize_unimplemented_method!(serialize_unit() -\u003e Ok);\n    };\n    (unit_struct) =\u003e {\n        __serialize_unimplemented_method!(serialize_unit_struct(\u0026str) -\u003e Ok);\n    };\n    (unit_variant) =\u003e {\n        __serialize_unimplemented_method!(serialize_unit_variant(\u0026str, u32, \u0026str) -\u003e Ok);\n    };\n    (newtype_struct) =\u003e {\n        __serialize_unimplemented_method!(serialize_newtype_struct\u003cT\u003e(\u0026str, \u0026T) -\u003e Ok);\n    };\n    (newtype_variant) =\u003e {\n        __serialize_unimplemented_method!(serialize_newtype_variant\u003cT\u003e(\u0026str, u32, \u0026str, \u0026T) -\u003e Ok);\n    };\n    (seq) =\u003e {\n        type SerializeSeq = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_seq(Option\u003cusize\u003e) -\u003e SerializeSeq);\n    };\n    (tuple) =\u003e {\n        type SerializeTuple = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_tuple(usize) -\u003e SerializeTuple);\n    };\n    (tuple_struct) =\u003e {\n        type SerializeTupleStruct = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_tuple_struct(\u0026str, usize) -\u003e SerializeTupleStruct);\n    };\n    (tuple_variant) =\u003e {\n        type SerializeTupleVariant = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_tuple_variant(\u0026str, u32, \u0026str, usize) -\u003e SerializeTupleVariant);\n    };\n    (map) =\u003e {\n        type SerializeMap = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_map(Option\u003cusize\u003e) -\u003e SerializeMap);\n    };\n    (struct) =\u003e {\n        type SerializeStruct = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_struct(\u0026str, usize) -\u003e SerializeStruct);\n    };\n    (struct_variant) =\u003e {\n        type SerializeStructVariant = $crate::ser::Impossible\u003cSelf::Ok, Self::Error\u003e;\n        __serialize_unimplemented_method!(serialize_struct_variant(\u0026str, u32, \u0026str, usize) -\u003e SerializeStructVariant);\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","private","mod.rs"],"content":"mod macros;\n\npub mod de;\npub mod ser;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","private","ser.rs"],"content":"use lib::*;\n\nuse ser::{self, Impossible, Serialize, SerializeMap, SerializeStruct, Serializer};\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse self::content::{\n    Content, ContentSerializer, SerializeStructVariantAsMapValue, SerializeTupleVariantAsMapValue,\n};\n\n/// Used to check that serde(getter) attributes return the expected type.\n/// Not public API.\npub fn constrain\u003cT: ?Sized\u003e(t: \u0026T) -\u003e \u0026T {\n    t\n}\n\n/// Not public API.\npub fn serialize_tagged_newtype\u003cS, T\u003e(\n    serializer: S,\n    type_ident: \u0026'static str,\n    variant_ident: \u0026'static str,\n    tag: \u0026'static str,\n    variant_name: \u0026'static str,\n    value: \u0026T,\n) -\u003e Result\u003cS::Ok, S::Error\u003e\nwhere\n    S: Serializer,\n    T: Serialize,\n{\n    value.serialize(TaggedSerializer {\n        type_ident: type_ident,\n        variant_ident: variant_ident,\n        tag: tag,\n        variant_name: variant_name,\n        delegate: serializer,\n    })\n}\n\nstruct TaggedSerializer\u003cS\u003e {\n    type_ident: \u0026'static str,\n    variant_ident: \u0026'static str,\n    tag: \u0026'static str,\n    variant_name: \u0026'static str,\n    delegate: S,\n}\n\nenum Unsupported {\n    Boolean,\n    Integer,\n    Float,\n    Char,\n    String,\n    ByteArray,\n    Optional,\n    Unit,\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    UnitStruct,\n    Sequence,\n    Tuple,\n    TupleStruct,\n    Enum,\n}\n\nimpl Display for Unsupported {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match *self {\n            Unsupported::Boolean =\u003e formatter.write_str(\"a boolean\"),\n            Unsupported::Integer =\u003e formatter.write_str(\"an integer\"),\n            Unsupported::Float =\u003e formatter.write_str(\"a float\"),\n            Unsupported::Char =\u003e formatter.write_str(\"a char\"),\n            Unsupported::String =\u003e formatter.write_str(\"a string\"),\n            Unsupported::ByteArray =\u003e formatter.write_str(\"a byte array\"),\n            Unsupported::Optional =\u003e formatter.write_str(\"an optional\"),\n            Unsupported::Unit =\u003e formatter.write_str(\"unit\"),\n            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n            Unsupported::UnitStruct =\u003e formatter.write_str(\"unit struct\"),\n            Unsupported::Sequence =\u003e formatter.write_str(\"a sequence\"),\n            Unsupported::Tuple =\u003e formatter.write_str(\"a tuple\"),\n            Unsupported::TupleStruct =\u003e formatter.write_str(\"a tuple struct\"),\n            Unsupported::Enum =\u003e formatter.write_str(\"an enum\"),\n        }\n    }\n}\n\nimpl\u003cS\u003e TaggedSerializer\u003cS\u003e\nwhere\n    S: Serializer,\n{\n    fn bad_type(self, what: Unsupported) -\u003e S::Error {\n        ser::Error::custom(format_args!(\n            \"cannot serialize tagged newtype variant {}::{} containing {}\",\n            self.type_ident, self.variant_ident, what\n        ))\n    }\n}\n\nimpl\u003cS\u003e Serializer for TaggedSerializer\u003cS\u003e\nwhere\n    S: Serializer,\n{\n    type Ok = S::Ok;\n    type Error = S::Error;\n\n    type SerializeSeq = Impossible\u003cS::Ok, S::Error\u003e;\n    type SerializeTuple = Impossible\u003cS::Ok, S::Error\u003e;\n    type SerializeTupleStruct = Impossible\u003cS::Ok, S::Error\u003e;\n    type SerializeMap = S::SerializeMap;\n    type SerializeStruct = S::SerializeStruct;\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    type SerializeTupleVariant = Impossible\u003cS::Ok, S::Error\u003e;\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    type SerializeTupleVariant = SerializeTupleVariantAsMapValue\u003cS::SerializeMap\u003e;\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    type SerializeStructVariant = Impossible\u003cS::Ok, S::Error\u003e;\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    type SerializeStructVariant = SerializeStructVariantAsMapValue\u003cS::SerializeMap\u003e;\n\n    fn serialize_bool(self, _: bool) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Boolean))\n    }\n\n    fn serialize_i8(self, _: i8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i16(self, _: i16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i32(self, _: i32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i64(self, _: i64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u8(self, _: u8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u16(self, _: u16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u32(self, _: u32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u64(self, _: u64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_f32(self, _: f32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Float))\n    }\n\n    fn serialize_f64(self, _: f64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Float))\n    }\n\n    fn serialize_char(self, _: char) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Char))\n    }\n\n    fn serialize_str(self, _: \u0026str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::String))\n    }\n\n    fn serialize_bytes(self, _: \u0026[u8]) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::ByteArray))\n    }\n\n    fn serialize_none(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Optional))\n    }\n\n    fn serialize_some\u003cT: ?Sized\u003e(self, _: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        Err(self.bad_type(Unsupported::Optional))\n    }\n\n    fn serialize_unit(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Unit))\n    }\n\n    fn serialize_unit_struct(self, _: \u0026'static str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        let mut map = try!(self.delegate.serialize_map(Some(1)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        map.end()\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        inner_variant: \u0026'static str,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        let mut map = try!(self.delegate.serialize_map(Some(2)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        try!(map.serialize_entry(inner_variant, \u0026()));\n        map.end()\n    }\n\n    fn serialize_newtype_struct\u003cT: ?Sized\u003e(\n        self,\n        _: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        inner_variant: \u0026'static str,\n        inner_value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        let mut map = try!(self.delegate.serialize_map(Some(2)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        try!(map.serialize_entry(inner_variant, inner_value));\n        map.end()\n    }\n\n    fn serialize_seq(self, _: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeSeq, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Sequence))\n    }\n\n    fn serialize_tuple(self, _: usize) -\u003e Result\u003cSelf::SerializeTuple, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Tuple))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleStruct, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::TupleStruct))\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn serialize_tuple_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        _: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleVariant, Self::Error\u003e {\n        // Lack of push-based serialization means we need to buffer the content\n        // of the tuple variant, so it requires std.\n        Err(self.bad_type(Unsupported::Enum))\n    }\n\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn serialize_tuple_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        inner_variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleVariant, Self::Error\u003e {\n        let mut map = try!(self.delegate.serialize_map(Some(2)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        try!(map.serialize_key(inner_variant));\n        Ok(SerializeTupleVariantAsMapValue::new(\n            map,\n            inner_variant,\n            len,\n        ))\n    }\n\n    fn serialize_map(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeMap, Self::Error\u003e {\n        let mut map = try!(self.delegate.serialize_map(len.map(|len| len + 1)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        Ok(map)\n    }\n\n    fn serialize_struct(\n        self,\n        name: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStruct, Self::Error\u003e {\n        let mut state = try!(self.delegate.serialize_struct(name, len + 1));\n        try!(state.serialize_field(self.tag, self.variant_name));\n        Ok(state)\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn serialize_struct_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        _: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeStructVariant, Self::Error\u003e {\n        // Lack of push-based serialization means we need to buffer the content\n        // of the struct variant, so it requires std.\n        Err(self.bad_type(Unsupported::Enum))\n    }\n\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn serialize_struct_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        inner_variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStructVariant, Self::Error\u003e {\n        let mut map = try!(self.delegate.serialize_map(Some(2)));\n        try!(map.serialize_entry(self.tag, self.variant_name));\n        try!(map.serialize_key(inner_variant));\n        Ok(SerializeStructVariantAsMapValue::new(\n            map,\n            inner_variant,\n            len,\n        ))\n    }\n\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn collect_str\u003cT: ?Sized\u003e(self, _: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Display,\n    {\n        Err(self.bad_type(Unsupported::String))\n    }\n}\n\n/// Used only by Serde doc tests. Not public API.\n#[doc(hidden)]\n#[derive(Debug)]\npub struct Error;\n\nimpl ser::Error for Error {\n    fn custom\u003cT\u003e(_: T) -\u003e Self\n    where\n        T: Display,\n    {\n        unimplemented!()\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl error::Error for Error {\n    fn description(\u0026self) -\u003e \u0026str {\n        unimplemented!()\n    }\n}\n\nimpl Display for Error {\n    fn fmt(\u0026self, _: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        unimplemented!()\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmod content {\n    use lib::*;\n\n    use ser::{self, Serialize, Serializer};\n\n    pub struct SerializeTupleVariantAsMapValue\u003cM\u003e {\n        map: M,\n        name: \u0026'static str,\n        fields: Vec\u003cContent\u003e,\n    }\n\n    impl\u003cM\u003e SerializeTupleVariantAsMapValue\u003cM\u003e {\n        pub fn new(map: M, name: \u0026'static str, len: usize) -\u003e Self {\n            SerializeTupleVariantAsMapValue {\n                map: map,\n                name: name,\n                fields: Vec::with_capacity(len),\n            }\n        }\n    }\n\n    impl\u003cM\u003e ser::SerializeTupleVariant for SerializeTupleVariantAsMapValue\u003cM\u003e\n    where\n        M: ser::SerializeMap,\n    {\n        type Ok = M::Ok;\n        type Error = M::Error;\n\n        fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), M::Error\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cM::Error\u003e::new()));\n            self.fields.push(value);\n            Ok(())\n        }\n\n        fn end(mut self) -\u003e Result\u003cM::Ok, M::Error\u003e {\n            try!(self\n                .map\n                .serialize_value(\u0026Content::TupleStruct(self.name, self.fields)));\n            self.map.end()\n        }\n    }\n\n    pub struct SerializeStructVariantAsMapValue\u003cM\u003e {\n        map: M,\n        name: \u0026'static str,\n        fields: Vec\u003c(\u0026'static str, Content)\u003e,\n    }\n\n    impl\u003cM\u003e SerializeStructVariantAsMapValue\u003cM\u003e {\n        pub fn new(map: M, name: \u0026'static str, len: usize) -\u003e Self {\n            SerializeStructVariantAsMapValue {\n                map: map,\n                name: name,\n                fields: Vec::with_capacity(len),\n            }\n        }\n    }\n\n    impl\u003cM\u003e ser::SerializeStructVariant for SerializeStructVariantAsMapValue\u003cM\u003e\n    where\n        M: ser::SerializeMap,\n    {\n        type Ok = M::Ok;\n        type Error = M::Error;\n\n        fn serialize_field\u003cT: ?Sized\u003e(\n            \u0026mut self,\n            key: \u0026'static str,\n            value: \u0026T,\n        ) -\u003e Result\u003c(), M::Error\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cM::Error\u003e::new()));\n            self.fields.push((key, value));\n            Ok(())\n        }\n\n        fn end(mut self) -\u003e Result\u003cM::Ok, M::Error\u003e {\n            try!(self\n                .map\n                .serialize_value(\u0026Content::Struct(self.name, self.fields)));\n            self.map.end()\n        }\n    }\n\n    #[derive(Debug)]\n    pub enum Content {\n        Bool(bool),\n\n        U8(u8),\n        U16(u16),\n        U32(u32),\n        U64(u64),\n\n        I8(i8),\n        I16(i16),\n        I32(i32),\n        I64(i64),\n\n        F32(f32),\n        F64(f64),\n\n        Char(char),\n        String(String),\n        Bytes(Vec\u003cu8\u003e),\n\n        None,\n        Some(Box\u003cContent\u003e),\n\n        Unit,\n        UnitStruct(\u0026'static str),\n        UnitVariant(\u0026'static str, u32, \u0026'static str),\n        NewtypeStruct(\u0026'static str, Box\u003cContent\u003e),\n        NewtypeVariant(\u0026'static str, u32, \u0026'static str, Box\u003cContent\u003e),\n\n        Seq(Vec\u003cContent\u003e),\n        Tuple(Vec\u003cContent\u003e),\n        TupleStruct(\u0026'static str, Vec\u003cContent\u003e),\n        TupleVariant(\u0026'static str, u32, \u0026'static str, Vec\u003cContent\u003e),\n        Map(Vec\u003c(Content, Content)\u003e),\n        Struct(\u0026'static str, Vec\u003c(\u0026'static str, Content)\u003e),\n        StructVariant(\n            \u0026'static str,\n            u32,\n            \u0026'static str,\n            Vec\u003c(\u0026'static str, Content)\u003e,\n        ),\n    }\n\n    impl Serialize for Content {\n        fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n        where\n            S: Serializer,\n        {\n            match *self {\n                Content::Bool(b) =\u003e serializer.serialize_bool(b),\n                Content::U8(u) =\u003e serializer.serialize_u8(u),\n                Content::U16(u) =\u003e serializer.serialize_u16(u),\n                Content::U32(u) =\u003e serializer.serialize_u32(u),\n                Content::U64(u) =\u003e serializer.serialize_u64(u),\n                Content::I8(i) =\u003e serializer.serialize_i8(i),\n                Content::I16(i) =\u003e serializer.serialize_i16(i),\n                Content::I32(i) =\u003e serializer.serialize_i32(i),\n                Content::I64(i) =\u003e serializer.serialize_i64(i),\n                Content::F32(f) =\u003e serializer.serialize_f32(f),\n                Content::F64(f) =\u003e serializer.serialize_f64(f),\n                Content::Char(c) =\u003e serializer.serialize_char(c),\n                Content::String(ref s) =\u003e serializer.serialize_str(s),\n                Content::Bytes(ref b) =\u003e serializer.serialize_bytes(b),\n                Content::None =\u003e serializer.serialize_none(),\n                Content::Some(ref c) =\u003e serializer.serialize_some(\u0026**c),\n                Content::Unit =\u003e serializer.serialize_unit(),\n                Content::UnitStruct(n) =\u003e serializer.serialize_unit_struct(n),\n                Content::UnitVariant(n, i, v) =\u003e serializer.serialize_unit_variant(n, i, v),\n                Content::NewtypeStruct(n, ref c) =\u003e serializer.serialize_newtype_struct(n, \u0026**c),\n                Content::NewtypeVariant(n, i, v, ref c) =\u003e {\n                    serializer.serialize_newtype_variant(n, i, v, \u0026**c)\n                }\n                Content::Seq(ref elements) =\u003e elements.serialize(serializer),\n                Content::Tuple(ref elements) =\u003e {\n                    use ser::SerializeTuple;\n                    let mut tuple = try!(serializer.serialize_tuple(elements.len()));\n                    for e in elements {\n                        try!(tuple.serialize_element(e));\n                    }\n                    tuple.end()\n                }\n                Content::TupleStruct(n, ref fields) =\u003e {\n                    use ser::SerializeTupleStruct;\n                    let mut ts = try!(serializer.serialize_tuple_struct(n, fields.len()));\n                    for f in fields {\n                        try!(ts.serialize_field(f));\n                    }\n                    ts.end()\n                }\n                Content::TupleVariant(n, i, v, ref fields) =\u003e {\n                    use ser::SerializeTupleVariant;\n                    let mut tv = try!(serializer.serialize_tuple_variant(n, i, v, fields.len()));\n                    for f in fields {\n                        try!(tv.serialize_field(f));\n                    }\n                    tv.end()\n                }\n                Content::Map(ref entries) =\u003e {\n                    use ser::SerializeMap;\n                    let mut map = try!(serializer.serialize_map(Some(entries.len())));\n                    for \u0026(ref k, ref v) in entries {\n                        try!(map.serialize_entry(k, v));\n                    }\n                    map.end()\n                }\n                Content::Struct(n, ref fields) =\u003e {\n                    use ser::SerializeStruct;\n                    let mut s = try!(serializer.serialize_struct(n, fields.len()));\n                    for \u0026(k, ref v) in fields {\n                        try!(s.serialize_field(k, v));\n                    }\n                    s.end()\n                }\n                Content::StructVariant(n, i, v, ref fields) =\u003e {\n                    use ser::SerializeStructVariant;\n                    let mut sv = try!(serializer.serialize_struct_variant(n, i, v, fields.len()));\n                    for \u0026(k, ref v) in fields {\n                        try!(sv.serialize_field(k, v));\n                    }\n                    sv.end()\n                }\n            }\n        }\n    }\n\n    pub struct ContentSerializer\u003cE\u003e {\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ContentSerializer\u003cE\u003e {\n        pub fn new() -\u003e Self {\n            ContentSerializer { error: PhantomData }\n        }\n    }\n\n    impl\u003cE\u003e Serializer for ContentSerializer\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        type SerializeSeq = SerializeSeq\u003cE\u003e;\n        type SerializeTuple = SerializeTuple\u003cE\u003e;\n        type SerializeTupleStruct = SerializeTupleStruct\u003cE\u003e;\n        type SerializeTupleVariant = SerializeTupleVariant\u003cE\u003e;\n        type SerializeMap = SerializeMap\u003cE\u003e;\n        type SerializeStruct = SerializeStruct\u003cE\u003e;\n        type SerializeStructVariant = SerializeStructVariant\u003cE\u003e;\n\n        fn serialize_bool(self, v: bool) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Bool(v))\n        }\n\n        fn serialize_i8(self, v: i8) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::I8(v))\n        }\n\n        fn serialize_i16(self, v: i16) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::I16(v))\n        }\n\n        fn serialize_i32(self, v: i32) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::I32(v))\n        }\n\n        fn serialize_i64(self, v: i64) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::I64(v))\n        }\n\n        fn serialize_u8(self, v: u8) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::U8(v))\n        }\n\n        fn serialize_u16(self, v: u16) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::U16(v))\n        }\n\n        fn serialize_u32(self, v: u32) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::U32(v))\n        }\n\n        fn serialize_u64(self, v: u64) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::U64(v))\n        }\n\n        fn serialize_f32(self, v: f32) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::F32(v))\n        }\n\n        fn serialize_f64(self, v: f64) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::F64(v))\n        }\n\n        fn serialize_char(self, v: char) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Char(v))\n        }\n\n        fn serialize_str(self, value: \u0026str) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::String(value.to_owned()))\n        }\n\n        fn serialize_bytes(self, value: \u0026[u8]) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Bytes(value.to_owned()))\n        }\n\n        fn serialize_none(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::None)\n        }\n\n        fn serialize_some\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cContent, E\u003e\n        where\n            T: Serialize,\n        {\n            Ok(Content::Some(Box::new(try!(value.serialize(self)))))\n        }\n\n        fn serialize_unit(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Unit)\n        }\n\n        fn serialize_unit_struct(self, name: \u0026'static str) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::UnitStruct(name))\n        }\n\n        fn serialize_unit_variant(\n            self,\n            name: \u0026'static str,\n            variant_index: u32,\n            variant: \u0026'static str,\n        ) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::UnitVariant(name, variant_index, variant))\n        }\n\n        fn serialize_newtype_struct\u003cT: ?Sized\u003e(\n            self,\n            name: \u0026'static str,\n            value: \u0026T,\n        ) -\u003e Result\u003cContent, E\u003e\n        where\n            T: Serialize,\n        {\n            Ok(Content::NewtypeStruct(\n                name,\n                Box::new(try!(value.serialize(self))),\n            ))\n        }\n\n        fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n            self,\n            name: \u0026'static str,\n            variant_index: u32,\n            variant: \u0026'static str,\n            value: \u0026T,\n        ) -\u003e Result\u003cContent, E\u003e\n        where\n            T: Serialize,\n        {\n            Ok(Content::NewtypeVariant(\n                name,\n                variant_index,\n                variant,\n                Box::new(try!(value.serialize(self))),\n            ))\n        }\n\n        fn serialize_seq(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeSeq, E\u003e {\n            Ok(SerializeSeq {\n                elements: Vec::with_capacity(len.unwrap_or(0)),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_tuple(self, len: usize) -\u003e Result\u003cSelf::SerializeTuple, E\u003e {\n            Ok(SerializeTuple {\n                elements: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_tuple_struct(\n            self,\n            name: \u0026'static str,\n            len: usize,\n        ) -\u003e Result\u003cSelf::SerializeTupleStruct, E\u003e {\n            Ok(SerializeTupleStruct {\n                name: name,\n                fields: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_tuple_variant(\n            self,\n            name: \u0026'static str,\n            variant_index: u32,\n            variant: \u0026'static str,\n            len: usize,\n        ) -\u003e Result\u003cSelf::SerializeTupleVariant, E\u003e {\n            Ok(SerializeTupleVariant {\n                name: name,\n                variant_index: variant_index,\n                variant: variant,\n                fields: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_map(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeMap, E\u003e {\n            Ok(SerializeMap {\n                entries: Vec::with_capacity(len.unwrap_or(0)),\n                key: None,\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_struct(\n            self,\n            name: \u0026'static str,\n            len: usize,\n        ) -\u003e Result\u003cSelf::SerializeStruct, E\u003e {\n            Ok(SerializeStruct {\n                name: name,\n                fields: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n\n        fn serialize_struct_variant(\n            self,\n            name: \u0026'static str,\n            variant_index: u32,\n            variant: \u0026'static str,\n            len: usize,\n        ) -\u003e Result\u003cSelf::SerializeStructVariant, E\u003e {\n            Ok(SerializeStructVariant {\n                name: name,\n                variant_index: variant_index,\n                variant: variant,\n                fields: Vec::with_capacity(len),\n                error: PhantomData,\n            })\n        }\n    }\n\n    pub struct SerializeSeq\u003cE\u003e {\n        elements: Vec\u003cContent\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeSeq for SerializeSeq\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.elements.push(value);\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Seq(self.elements))\n        }\n    }\n\n    pub struct SerializeTuple\u003cE\u003e {\n        elements: Vec\u003cContent\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeTuple for SerializeTuple\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.elements.push(value);\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Tuple(self.elements))\n        }\n    }\n\n    pub struct SerializeTupleStruct\u003cE\u003e {\n        name: \u0026'static str,\n        fields: Vec\u003cContent\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeTupleStruct for SerializeTupleStruct\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.fields.push(value);\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::TupleStruct(self.name, self.fields))\n        }\n    }\n\n    pub struct SerializeTupleVariant\u003cE\u003e {\n        name: \u0026'static str,\n        variant_index: u32,\n        variant: \u0026'static str,\n        fields: Vec\u003cContent\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeTupleVariant for SerializeTupleVariant\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.fields.push(value);\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::TupleVariant(\n                self.name,\n                self.variant_index,\n                self.variant,\n                self.fields,\n            ))\n        }\n    }\n\n    pub struct SerializeMap\u003cE\u003e {\n        entries: Vec\u003c(Content, Content)\u003e,\n        key: Option\u003cContent\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeMap for SerializeMap\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let key = try!(key.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.key = Some(key);\n            Ok(())\n        }\n\n        fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let key = self\n                .key\n                .take()\n                .expect(\"serialize_value called before serialize_key\");\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.entries.push((key, value));\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Map(self.entries))\n        }\n\n        fn serialize_entry\u003cK: ?Sized, V: ?Sized\u003e(\u0026mut self, key: \u0026K, value: \u0026V) -\u003e Result\u003c(), E\u003e\n        where\n            K: Serialize,\n            V: Serialize,\n        {\n            let key = try!(key.serialize(ContentSerializer::\u003cE\u003e::new()));\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.entries.push((key, value));\n            Ok(())\n        }\n    }\n\n    pub struct SerializeStruct\u003cE\u003e {\n        name: \u0026'static str,\n        fields: Vec\u003c(\u0026'static str, Content)\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeStruct for SerializeStruct\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026'static str, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.fields.push((key, value));\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::Struct(self.name, self.fields))\n        }\n    }\n\n    pub struct SerializeStructVariant\u003cE\u003e {\n        name: \u0026'static str,\n        variant_index: u32,\n        variant: \u0026'static str,\n        fields: Vec\u003c(\u0026'static str, Content)\u003e,\n        error: PhantomData\u003cE\u003e,\n    }\n\n    impl\u003cE\u003e ser::SerializeStructVariant for SerializeStructVariant\u003cE\u003e\n    where\n        E: ser::Error,\n    {\n        type Ok = Content;\n        type Error = E;\n\n        fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026'static str, value: \u0026T) -\u003e Result\u003c(), E\u003e\n        where\n            T: Serialize,\n        {\n            let value = try!(value.serialize(ContentSerializer::\u003cE\u003e::new()));\n            self.fields.push((key, value));\n            Ok(())\n        }\n\n        fn end(self) -\u003e Result\u003cContent, E\u003e {\n            Ok(Content::StructVariant(\n                self.name,\n                self.variant_index,\n                self.variant,\n                self.fields,\n            ))\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapSerializer\u003c'a, M: 'a\u003e(pub \u0026'a mut M);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, M\u003e FlatMapSerializer\u003c'a, M\u003e\nwhere\n    M: SerializeMap + 'a,\n{\n    fn bad_type(self, what: Unsupported) -\u003e M::Error {\n        ser::Error::custom(format_args!(\n            \"can only flatten structs and maps (got {})\",\n            what\n        ))\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, M\u003e Serializer for FlatMapSerializer\u003c'a, M\u003e\nwhere\n    M: SerializeMap + 'a,\n{\n    type Ok = ();\n    type Error = M::Error;\n\n    type SerializeSeq = Impossible\u003cSelf::Ok, M::Error\u003e;\n    type SerializeTuple = Impossible\u003cSelf::Ok, M::Error\u003e;\n    type SerializeTupleStruct = Impossible\u003cSelf::Ok, M::Error\u003e;\n    type SerializeMap = FlatMapSerializeMap\u003c'a, M\u003e;\n    type SerializeStruct = FlatMapSerializeStruct\u003c'a, M\u003e;\n    type SerializeTupleVariant = Impossible\u003cSelf::Ok, M::Error\u003e;\n    type SerializeStructVariant = FlatMapSerializeStructVariantAsMapValue\u003c'a, M\u003e;\n\n    fn serialize_bool(self, _: bool) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Boolean))\n    }\n\n    fn serialize_i8(self, _: i8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i16(self, _: i16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i32(self, _: i32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_i64(self, _: i64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u8(self, _: u8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u16(self, _: u16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u32(self, _: u32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_u64(self, _: u64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Integer))\n    }\n\n    fn serialize_f32(self, _: f32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Float))\n    }\n\n    fn serialize_f64(self, _: f64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Float))\n    }\n\n    fn serialize_char(self, _: char) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Char))\n    }\n\n    fn serialize_str(self, _: \u0026str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::String))\n    }\n\n    fn serialize_bytes(self, _: \u0026[u8]) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::ByteArray))\n    }\n\n    fn serialize_none(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Ok(())\n    }\n\n    fn serialize_some\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_unit(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Unit))\n    }\n\n    fn serialize_unit_struct(self, _: \u0026'static str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::UnitStruct))\n    }\n\n    fn serialize_unit_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        _: \u0026'static str,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Enum))\n    }\n\n    fn serialize_newtype_struct\u003cT: ?Sized\u003e(\n        self,\n        _: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        variant: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        try!(self.0.serialize_key(variant));\n        self.0.serialize_value(value)\n    }\n\n    fn serialize_seq(self, _: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeSeq, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Sequence))\n    }\n\n    fn serialize_tuple(self, _: usize) -\u003e Result\u003cSelf::SerializeTuple, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Tuple))\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        _: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleStruct, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::TupleStruct))\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        _: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleVariant, Self::Error\u003e {\n        Err(self.bad_type(Unsupported::Enum))\n    }\n\n    fn serialize_map(self, _: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeMap, Self::Error\u003e {\n        Ok(FlatMapSerializeMap(self.0))\n    }\n\n    fn serialize_struct(\n        self,\n        _: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeStruct, Self::Error\u003e {\n        Ok(FlatMapSerializeStruct(self.0))\n    }\n\n    fn serialize_struct_variant(\n        self,\n        _: \u0026'static str,\n        _: u32,\n        inner_variant: \u0026'static str,\n        _: usize,\n    ) -\u003e Result\u003cSelf::SerializeStructVariant, Self::Error\u003e {\n        try!(self.0.serialize_key(inner_variant));\n        Ok(FlatMapSerializeStructVariantAsMapValue::new(\n            self.0,\n            inner_variant,\n        ))\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapSerializeMap\u003c'a, M: 'a\u003e(\u0026'a mut M);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, M\u003e ser::SerializeMap for FlatMapSerializeMap\u003c'a, M\u003e\nwhere\n    M: SerializeMap + 'a,\n{\n    type Ok = ();\n    type Error = M::Error;\n\n    fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.0.serialize_key(key)\n    }\n\n    fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.0.serialize_value(value)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapSerializeStruct\u003c'a, M: 'a\u003e(\u0026'a mut M);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, M\u003e ser::SerializeStruct for FlatMapSerializeStruct\u003c'a, M\u003e\nwhere\n    M: SerializeMap + 'a,\n{\n    type Ok = ();\n    type Error = M::Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        self.0.serialize_entry(key, value)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\npub struct FlatMapSerializeStructVariantAsMapValue\u003c'a, M: 'a\u003e {\n    map: \u0026'a mut M,\n    name: \u0026'static str,\n    fields: Vec\u003c(\u0026'static str, Content)\u003e,\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, M\u003e FlatMapSerializeStructVariantAsMapValue\u003c'a, M\u003e\nwhere\n    M: SerializeMap + 'a,\n{\n    fn new(map: \u0026'a mut M, name: \u0026'static str) -\u003e FlatMapSerializeStructVariantAsMapValue\u003c'a, M\u003e {\n        FlatMapSerializeStructVariantAsMapValue {\n            map: map,\n            name: name,\n            fields: Vec::new(),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl\u003c'a, M\u003e ser::SerializeStructVariant for FlatMapSerializeStructVariantAsMapValue\u003c'a, M\u003e\nwhere\n    M: SerializeMap + 'a,\n{\n    type Ok = ();\n    type Error = M::Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        let value = try!(value.serialize(ContentSerializer::\u003cM::Error\u003e::new()));\n        self.fields.push((key, value));\n        Ok(())\n    }\n\n    fn end(self) -\u003e Result\u003c(), Self::Error\u003e {\n        try!(self\n            .map\n            .serialize_value(\u0026Content::Struct(self.name, self.fields)));\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","ser","impls.rs"],"content":"use lib::*;\n\nuse ser::{Error, Serialize, SerializeTuple, Serializer};\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! primitive_impl {\n    ($ty:ident, $method:ident $($cast:tt)*) =\u003e {\n        impl Serialize for $ty {\n            #[inline]\n            fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                S: Serializer,\n            {\n                serializer.$method(*self $($cast)*)\n            }\n        }\n    }\n}\n\nprimitive_impl!(bool, serialize_bool);\nprimitive_impl!(isize, serialize_i64 as i64);\nprimitive_impl!(i8, serialize_i8);\nprimitive_impl!(i16, serialize_i16);\nprimitive_impl!(i32, serialize_i32);\nprimitive_impl!(i64, serialize_i64);\nprimitive_impl!(usize, serialize_u64 as u64);\nprimitive_impl!(u8, serialize_u8);\nprimitive_impl!(u16, serialize_u16);\nprimitive_impl!(u32, serialize_u32);\nprimitive_impl!(u64, serialize_u64);\nprimitive_impl!(f32, serialize_f32);\nprimitive_impl!(f64, serialize_f64);\nprimitive_impl!(char, serialize_char);\n\nserde_if_integer128! {\n    primitive_impl!(i128, serialize_i128);\n    primitive_impl!(u128, serialize_u128);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Serialize for str {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.serialize_str(self)\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl Serialize for String {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.serialize_str(self)\n    }\n}\n\nimpl\u003c'a\u003e Serialize for fmt::Arguments\u003c'a\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.collect_str(self)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl Serialize for CStr {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.serialize_bytes(self.to_bytes())\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for CString {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.serialize_bytes(self.to_bytes())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003cT\u003e Serialize for Option\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match *self {\n            Some(ref value) =\u003e serializer.serialize_some(value),\n            None =\u003e serializer.serialize_none(),\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003cT: ?Sized\u003e Serialize for PhantomData\u003cT\u003e {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.serialize_unit_struct(\"PhantomData\")\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Does not require T: Serialize.\nimpl\u003cT\u003e Serialize for [T; 0] {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        try!(serializer.serialize_tuple(0)).end()\n    }\n}\n\nmacro_rules! array_impls {\n    ($($len:tt)+) =\u003e {\n        $(\n            impl\u003cT\u003e Serialize for [T; $len]\n            where\n                T: Serialize,\n            {\n                #[inline]\n                fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n                where\n                    S: Serializer,\n                {\n                    let mut seq = try!(serializer.serialize_tuple($len));\n                    for e in self {\n                        try!(seq.serialize_element(e));\n                    }\n                    seq.end()\n                }\n            }\n        )+\n    }\n}\n\narray_impls! {\n    01 02 03 04 05 06 07 08 09 10\n    11 12 13 14 15 16 17 18 19 20\n    21 22 23 24 25 26 27 28 29 30\n    31 32\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003cT\u003e Serialize for [T]\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.collect_seq(self)\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! seq_impl {\n    ($ty:ident \u003c T $(: $tbound1:ident $(+ $tbound2:ident)*)* $(, $typaram:ident : $bound:ident)* \u003e) =\u003e {\n        impl\u003cT $(, $typaram)*\u003e Serialize for $ty\u003cT $(, $typaram)*\u003e\n        where\n            T: Serialize $(+ $tbound1 $(+ $tbound2)*)*,\n            $($typaram: $bound,)*\n        {\n            #[inline]\n            fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                S: Serializer,\n            {\n                serializer.collect_seq(self)\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(BinaryHeap\u003cT: Ord\u003e);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(BTreeSet\u003cT: Ord\u003e);\n\n#[cfg(feature = \"std\")]\nseq_impl!(HashSet\u003cT: Eq + Hash, H: BuildHasher\u003e);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(LinkedList\u003cT\u003e);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(Vec\u003cT\u003e);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nseq_impl!(VecDeque\u003cT\u003e);\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003cIdx\u003e Serialize for Range\u003cIdx\u003e\nwhere\n    Idx: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use super::SerializeStruct;\n        let mut state = try!(serializer.serialize_struct(\"Range\", 2));\n        try!(state.serialize_field(\"start\", \u0026self.start));\n        try!(state.serialize_field(\"end\", \u0026self.end));\n        state.end()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(range_inclusive)]\nimpl\u003cIdx\u003e Serialize for RangeInclusive\u003cIdx\u003e\nwhere\n    Idx: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use super::SerializeStruct;\n        let mut state = try!(serializer.serialize_struct(\"RangeInclusive\", 2));\n        try!(state.serialize_field(\"start\", \u0026self.start()));\n        try!(state.serialize_field(\"end\", \u0026self.end()));\n        state.end()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(ops_bound, collections_bound))]\nimpl\u003cT\u003e Serialize for Bound\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match *self {\n            Bound::Unbounded =\u003e serializer.serialize_unit_variant(\"Bound\", 0, \"Unbounded\"),\n            Bound::Included(ref value) =\u003e {\n                serializer.serialize_newtype_variant(\"Bound\", 1, \"Included\", value)\n            }\n            Bound::Excluded(ref value) =\u003e {\n                serializer.serialize_newtype_variant(\"Bound\", 2, \"Excluded\", value)\n            }\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Serialize for () {\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        serializer.serialize_unit()\n    }\n}\n\n#[cfg(feature = \"unstable\")]\nimpl Serialize for ! {\n    fn serialize\u003cS\u003e(\u0026self, _serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        *self\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! tuple_impls {\n    ($($len:expr =\u003e ($($n:tt $name:ident)+))+) =\u003e {\n        $(\n            impl\u003c$($name),+\u003e Serialize for ($($name,)+)\n            where\n                $($name: Serialize,)+\n            {\n                #[inline]\n                fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n                where\n                    S: Serializer,\n                {\n                    let mut tuple = try!(serializer.serialize_tuple($len));\n                    $(\n                        try!(tuple.serialize_element(\u0026self.$n));\n                    )+\n                    tuple.end()\n                }\n            }\n        )+\n    }\n}\n\ntuple_impls! {\n    1 =\u003e (0 T0)\n    2 =\u003e (0 T0 1 T1)\n    3 =\u003e (0 T0 1 T1 2 T2)\n    4 =\u003e (0 T0 1 T1 2 T2 3 T3)\n    5 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4)\n    6 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5)\n    7 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6)\n    8 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7)\n    9 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8)\n    10 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9)\n    11 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10)\n    12 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11)\n    13 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12)\n    14 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13)\n    15 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14)\n    16 =\u003e (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmacro_rules! map_impl {\n    ($ty:ident \u003c K $(: $kbound1:ident $(+ $kbound2:ident)*)*, V $(, $typaram:ident : $bound:ident)* \u003e) =\u003e {\n        impl\u003cK, V $(, $typaram)*\u003e Serialize for $ty\u003cK, V $(, $typaram)*\u003e\n        where\n            K: Serialize $(+ $kbound1 $(+ $kbound2)*)*,\n            V: Serialize,\n            $($typaram: $bound,)*\n        {\n            #[inline]\n            fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                S: Serializer,\n            {\n                serializer.collect_map(self)\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nmap_impl!(BTreeMap\u003cK: Ord, V\u003e);\n\n#[cfg(feature = \"std\")]\nmap_impl!(HashMap\u003cK: Eq + Hash, V, H: BuildHasher\u003e);\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! deref_impl {\n    (\n        $(#[doc = $doc:tt])*\n        \u003c$($desc:tt)+\n    ) =\u003e {\n        $(#[doc = $doc])*\n        impl \u003c$($desc)+ {\n            #[inline]\n            fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                S: Serializer,\n            {\n                (**self).serialize(serializer)\n            }\n        }\n    };\n}\n\nderef_impl!(\u003c'a, T: ?Sized\u003e Serialize for \u0026'a T where T: Serialize);\nderef_impl!(\u003c'a, T: ?Sized\u003e Serialize for \u0026'a mut T where T: Serialize);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nderef_impl!(\u003cT: ?Sized\u003e Serialize for Box\u003cT\u003e where T: Serialize);\n\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nderef_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Serializing a data structure containing `Rc` will serialize a copy of\n    /// the contents of the `Rc` each time the `Rc` is referenced within the\n    /// data structure. Serialization will not attempt to deduplicate these\n    /// repeated data.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    \u003cT: ?Sized\u003e Serialize for Rc\u003cT\u003e where T: Serialize\n}\n\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nderef_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Serializing a data structure containing `Arc` will serialize a copy of\n    /// the contents of the `Arc` each time the `Arc` is referenced within the\n    /// data structure. Serialization will not attempt to deduplicate these\n    /// repeated data.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    \u003cT: ?Sized\u003e Serialize for Arc\u003cT\u003e where T: Serialize\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nderef_impl!(\u003c'a, T: ?Sized\u003e Serialize for Cow\u003c'a, T\u003e where T: Serialize + ToOwned);\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nimpl\u003cT: ?Sized\u003e Serialize for RcWeak\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.upgrade().serialize(serializer)\n    }\n}\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\nimpl\u003cT: ?Sized\u003e Serialize for ArcWeak\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.upgrade().serialize(serializer)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! nonzero_integers {\n    ( $( $T: ident, )+ ) =\u003e {\n        $(\n            #[cfg(num_nonzero)]\n            impl Serialize for num::$T {\n                fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n                where\n                    S: Serializer,\n                {\n                    self.get().serialize(serializer)\n                }\n            }\n        )+\n    }\n}\n\nnonzero_integers! {\n    NonZeroU8,\n    NonZeroU16,\n    NonZeroU32,\n    NonZeroU64,\n    NonZeroUsize,\n}\n\n#[cfg(num_nonzero_signed)]\nnonzero_integers! {\n    NonZeroI8,\n    NonZeroI16,\n    NonZeroI32,\n    NonZeroI64,\n    NonZeroIsize,\n}\n\n// Currently 128-bit integers do not work on Emscripten targets so we need an\n// additional `#[cfg]`\nserde_if_integer128! {\n    nonzero_integers! {\n        NonZeroU128,\n    }\n\n    #[cfg(num_nonzero_signed)]\n    nonzero_integers! {\n        NonZeroI128,\n    }\n}\n\nimpl\u003cT\u003e Serialize for Cell\u003cT\u003e\nwhere\n    T: Serialize + Copy,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.get().serialize(serializer)\n    }\n}\n\nimpl\u003cT\u003e Serialize for RefCell\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match self.try_borrow() {\n            Ok(value) =\u003e value.serialize(serializer),\n            Err(_) =\u003e Err(S::Error::custom(\"already mutably borrowed\")),\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT\u003e Serialize for Mutex\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match self.lock() {\n            Ok(locked) =\u003e locked.serialize(serializer),\n            Err(_) =\u003e Err(S::Error::custom(\"lock poison error while serializing\")),\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl\u003cT\u003e Serialize for RwLock\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match self.read() {\n            Ok(locked) =\u003e locked.serialize(serializer),\n            Err(_) =\u003e Err(S::Error::custom(\"lock poison error while serializing\")),\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl\u003cT, E\u003e Serialize for Result\u003cT, E\u003e\nwhere\n    T: Serialize,\n    E: Serialize,\n{\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match *self {\n            Result::Ok(ref value) =\u003e serializer.serialize_newtype_variant(\"Result\", 0, \"Ok\", value),\n            Result::Err(ref value) =\u003e {\n                serializer.serialize_newtype_variant(\"Result\", 1, \"Err\", value)\n            }\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(core_duration, feature = \"std\"))]\nimpl Serialize for Duration {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use super::SerializeStruct;\n        let mut state = try!(serializer.serialize_struct(\"Duration\", 2));\n        try!(state.serialize_field(\"secs\", \u0026self.as_secs()));\n        try!(state.serialize_field(\"nanos\", \u0026self.subsec_nanos()));\n        state.end()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl Serialize for SystemTime {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use super::SerializeStruct;\n        let duration_since_epoch = self\n            .duration_since(UNIX_EPOCH)\n            .expect(\"SystemTime must be later than UNIX_EPOCH\");\n        let mut state = try!(serializer.serialize_struct(\"SystemTime\", 2));\n        try!(state.serialize_field(\"secs_since_epoch\", \u0026duration_since_epoch.as_secs()));\n        try!(state.serialize_field(\"nanos_since_epoch\", \u0026duration_since_epoch.subsec_nanos()));\n        state.end()\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// Serialize a value that implements `Display` as a string, when that string is\n/// statically known to never have more than a constant `MAX_LEN` bytes.\n///\n/// Panics if the `Display` impl tries to write more than `MAX_LEN` bytes.\n#[cfg(feature = \"std\")]\nmacro_rules! serialize_display_bounded_length {\n    ($value:expr, $max:expr, $serializer:expr) =\u003e {{\n        #[allow(deprecated)]\n        let mut buffer: [u8; $max] = unsafe { mem::uninitialized() };\n        let remaining_len = {\n            let mut remaining = \u0026mut buffer[..];\n            write!(remaining, \"{}\", $value).unwrap();\n            remaining.len()\n        };\n        let written_len = buffer.len() - remaining_len;\n        let written = \u0026buffer[..written_len];\n\n        // write! only provides fmt::Formatter to Display implementations, which\n        // has methods write_str and write_char but no method to write arbitrary\n        // bytes. Therefore `written` must be valid UTF-8.\n        let written_str = unsafe { str::from_utf8_unchecked(written) };\n        $serializer.serialize_str(written_str)\n    }};\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::IpAddr {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            match *self {\n                net::IpAddr::V4(ref a) =\u003e a.serialize(serializer),\n                net::IpAddr::V6(ref a) =\u003e a.serialize(serializer),\n            }\n        } else {\n            match *self {\n                net::IpAddr::V4(ref a) =\u003e {\n                    serializer.serialize_newtype_variant(\"IpAddr\", 0, \"V4\", a)\n                }\n                net::IpAddr::V6(ref a) =\u003e {\n                    serializer.serialize_newtype_variant(\"IpAddr\", 1, \"V6\", a)\n                }\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::Ipv4Addr {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            const MAX_LEN: usize = 15;\n            debug_assert_eq!(MAX_LEN, \"101.102.103.104\".len());\n            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n        } else {\n            self.octets().serialize(serializer)\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::Ipv6Addr {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            const MAX_LEN: usize = 39;\n            debug_assert_eq!(MAX_LEN, \"1001:1002:1003:1004:1005:1006:1007:1008\".len());\n            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n        } else {\n            self.octets().serialize(serializer)\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::SocketAddr {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            match *self {\n                net::SocketAddr::V4(ref addr) =\u003e addr.serialize(serializer),\n                net::SocketAddr::V6(ref addr) =\u003e addr.serialize(serializer),\n            }\n        } else {\n            match *self {\n                net::SocketAddr::V4(ref addr) =\u003e {\n                    serializer.serialize_newtype_variant(\"SocketAddr\", 0, \"V4\", addr)\n                }\n                net::SocketAddr::V6(ref addr) =\u003e {\n                    serializer.serialize_newtype_variant(\"SocketAddr\", 1, \"V6\", addr)\n                }\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::SocketAddrV4 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            const MAX_LEN: usize = 21;\n            debug_assert_eq!(MAX_LEN, \"101.102.103.104:65000\".len());\n            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n        } else {\n            (self.ip(), self.port()).serialize(serializer)\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for net::SocketAddrV6 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if serializer.is_human_readable() {\n            const MAX_LEN: usize = 47;\n            debug_assert_eq!(\n                MAX_LEN,\n                \"[1001:1002:1003:1004:1005:1006:1007:1008]:65000\".len()\n            );\n            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n        } else {\n            (self.ip(), self.port()).serialize(serializer)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl Serialize for Path {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        match self.to_str() {\n            Some(s) =\u003e s.serialize(serializer),\n            None =\u003e Err(Error::custom(\"path contains invalid UTF-8 characters\")),\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\nimpl Serialize for PathBuf {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.as_path().serialize(serializer)\n    }\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl Serialize for OsStr {\n    #[cfg(unix)]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use std::os::unix::ffi::OsStrExt;\n        serializer.serialize_newtype_variant(\"OsString\", 0, \"Unix\", self.as_bytes())\n    }\n\n    #[cfg(windows)]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        use std::os::windows::ffi::OsStrExt;\n        let val = self.encode_wide().collect::\u003cVec\u003c_\u003e\u003e();\n        serializer.serialize_newtype_variant(\"OsString\", 1, \"Windows\", \u0026val)\n    }\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl Serialize for OsString {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.as_os_str().serialize(serializer)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nimpl\u003cT\u003e Serialize for Wrapping\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.0.serialize(serializer)\n    }\n}\n\n#[cfg(core_reverse)]\nimpl\u003cT\u003e Serialize for Reverse\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.0.serialize(serializer)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(all(feature = \"std\", std_atomic))]\nmacro_rules! atomic_impl {\n    ($($ty:ident)*) =\u003e {\n        $(\n            impl Serialize for $ty {\n                fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n                where\n                    S: Serializer,\n                {\n                    self.load(Ordering::SeqCst).serialize(serializer)\n                }\n            }\n        )*\n    }\n}\n\n#[cfg(all(feature = \"std\", std_atomic))]\natomic_impl! {\n    AtomicBool\n    AtomicI8 AtomicI16 AtomicI32 AtomicIsize\n    AtomicU8 AtomicU16 AtomicU32 AtomicUsize\n}\n\n#[cfg(all(feature = \"std\", std_atomic64))]\natomic_impl! {\n    AtomicI64 AtomicU64\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","ser","impossible.rs"],"content":"//! This module contains `Impossible` serializer and its implementations.\n\nuse lib::*;\n\nuse ser::{\n    self, Serialize, SerializeMap, SerializeSeq, SerializeStruct, SerializeStructVariant,\n    SerializeTuple, SerializeTupleStruct, SerializeTupleVariant,\n};\n\n/// Helper type for implementing a `Serializer` that does not support\n/// serializing one of the compound types.\n///\n/// This type cannot be instantiated, but implements every one of the traits\n/// corresponding to the [`Serializer`] compound types: [`SerializeSeq`],\n/// [`SerializeTuple`], [`SerializeTupleStruct`], [`SerializeTupleVariant`],\n/// [`SerializeMap`], [`SerializeStruct`], and [`SerializeStructVariant`].\n///\n/// ```edition2018\n/// # use serde::ser::{Serializer, Impossible};\n/// # use serde::private::ser::Error;\n/// #\n/// # struct MySerializer;\n/// #\n/// impl Serializer for MySerializer {\n///     type Ok = ();\n///     type Error = Error;\n///\n///     type SerializeSeq = Impossible\u003c(), Error\u003e;\n///     /* other associated types */\n///\n///     /// This data format does not support serializing sequences.\n///     fn serialize_seq(self,\n///                      len: Option\u003cusize\u003e)\n///                      -\u003e Result\u003cSelf::SerializeSeq, Error\u003e {\n///         // Given Impossible cannot be instantiated, the only\n///         // thing we can do here is to return an error.\n/// #         stringify! {\n///         Err(...)\n/// #         };\n/// #         unimplemented!()\n///     }\n///\n///     /* other Serializer methods */\n/// #     serde::__serialize_unimplemented! {\n/// #         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str bytes none some\n/// #         unit unit_struct unit_variant newtype_struct newtype_variant\n/// #         tuple tuple_struct tuple_variant map struct struct_variant\n/// #     }\n/// }\n/// ```\n///\n/// [`Serializer`]: trait.Serializer.html\n/// [`SerializeSeq`]: trait.SerializeSeq.html\n/// [`SerializeTuple`]: trait.SerializeTuple.html\n/// [`SerializeTupleStruct`]: trait.SerializeTupleStruct.html\n/// [`SerializeTupleVariant`]: trait.SerializeTupleVariant.html\n/// [`SerializeMap`]: trait.SerializeMap.html\n/// [`SerializeStruct`]: trait.SerializeStruct.html\n/// [`SerializeStructVariant`]: trait.SerializeStructVariant.html\npub struct Impossible\u003cOk, Error\u003e {\n    void: Void,\n    ok: PhantomData\u003cOk\u003e,\n    error: PhantomData\u003cError\u003e,\n}\n\nenum Void {}\n\nimpl\u003cOk, Error\u003e SerializeSeq for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n\nimpl\u003cOk, Error\u003e SerializeTuple for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n\nimpl\u003cOk, Error\u003e SerializeTupleStruct for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n\nimpl\u003cOk, Error\u003e SerializeTupleVariant for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n\nimpl\u003cOk, Error\u003e SerializeMap for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = key;\n        match self.void {}\n    }\n\n    fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n\nimpl\u003cOk, Error\u003e SerializeStruct for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026'static str, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = key;\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n\nimpl\u003cOk, Error\u003e SerializeStructVariant for Impossible\u003cOk, Error\u003e\nwhere\n    Error: ser::Error,\n{\n    type Ok = Ok;\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026'static str, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        let _ = key;\n        let _ = value;\n        match self.void {}\n    }\n\n    fn end(self) -\u003e Result\u003cOk, Error\u003e {\n        match self.void {}\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","ser","mod.rs"],"content":"//! Generic data structure serialization framework.\n//!\n//! The two most important traits in this module are [`Serialize`] and\n//! [`Serializer`].\n//!\n//!  - **A type that implements `Serialize` is a data structure** that can be\n//!    serialized to any data format supported by Serde, and conversely\n//!  - **A type that implements `Serializer` is a data format** that can\n//!    serialize any data structure supported by Serde.\n//!\n//! # The Serialize trait\n//!\n//! Serde provides [`Serialize`] implementations for many Rust primitive and\n//! standard library types. The complete list is below. All of these can be\n//! serialized using Serde out of the box.\n//!\n//! Additionally, Serde provides a procedural macro called [`serde_derive`] to\n//! automatically generate [`Serialize`] implementations for structs and enums\n//! in your program. See the [derive section of the manual] for how to use this.\n//!\n//! In rare cases it may be necessary to implement [`Serialize`] manually for\n//! some type in your program. See the [Implementing `Serialize`] section of the\n//! manual for more about this.\n//!\n//! Third-party crates may provide [`Serialize`] implementations for types that\n//! they expose. For example the [`linked-hash-map`] crate provides a\n//! [`LinkedHashMap\u003cK, V\u003e`] type that is serializable by Serde because the crate\n//! provides an implementation of [`Serialize`] for it.\n//!\n//! # The Serializer trait\n//!\n//! [`Serializer`] implementations are provided by third-party crates, for\n//! example [`serde_json`], [`serde_yaml`] and [`bincode`].\n//!\n//! A partial list of well-maintained formats is given on the [Serde\n//! website][data formats].\n//!\n//! # Implementations of Serialize provided by Serde\n//!\n//!  - **Primitive types**:\n//!    - bool\n//!    - i8, i16, i32, i64, i128, isize\n//!    - u8, u16, u32, u64, u128, usize\n//!    - f32, f64\n//!    - char\n//!    - str\n//!    - \u0026T and \u0026mut T\n//!  - **Compound types**:\n//!    - \\[T\\]\n//!    - \\[T; 0\\] through \\[T; 32\\]\n//!    - tuples up to size 16\n//!  - **Common standard library types**:\n//!    - String\n//!    - Option\\\u003cT\\\u003e\n//!    - Result\\\u003cT, E\\\u003e\n//!    - PhantomData\\\u003cT\\\u003e\n//!  - **Wrapper types**:\n//!    - Box\\\u003cT\\\u003e\n//!    - Cow\\\u003c'a, T\\\u003e\n//!    - Cell\\\u003cT\\\u003e\n//!    - RefCell\\\u003cT\\\u003e\n//!    - Mutex\\\u003cT\\\u003e\n//!    - RwLock\\\u003cT\\\u003e\n//!    - Rc\\\u003cT\\\u003e\u0026emsp;*(if* features = [\"rc\"] *is enabled)*\n//!    - Arc\\\u003cT\\\u003e\u0026emsp;*(if* features = [\"rc\"] *is enabled)*\n//!  - **Collection types**:\n//!    - BTreeMap\\\u003cK, V\\\u003e\n//!    - BTreeSet\\\u003cT\\\u003e\n//!    - BinaryHeap\\\u003cT\\\u003e\n//!    - HashMap\\\u003cK, V, H\\\u003e\n//!    - HashSet\\\u003cT, H\\\u003e\n//!    - LinkedList\\\u003cT\\\u003e\n//!    - VecDeque\\\u003cT\\\u003e\n//!    - Vec\\\u003cT\\\u003e\n//!  - **FFI types**:\n//!    - CStr\n//!    - CString\n//!    - OsStr\n//!    - OsString\n//!  - **Miscellaneous standard library types**:\n//!    - Duration\n//!    - SystemTime\n//!    - Path\n//!    - PathBuf\n//!    - Range\\\u003cT\\\u003e\n//!    - RangeInclusive\\\u003cT\\\u003e\n//!    - Bound\\\u003cT\\\u003e\n//!    - num::NonZero*\n//!    - `!` *(unstable)*\n//!  - **Net types**:\n//!    - IpAddr\n//!    - Ipv4Addr\n//!    - Ipv6Addr\n//!    - SocketAddr\n//!    - SocketAddrV4\n//!    - SocketAddrV6\n//!\n//! [Implementing `Serialize`]: https://serde.rs/impl-serialize.html\n//! [`LinkedHashMap\u003cK, V\u003e`]: https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html\n//! [`Serialize`]: ../trait.Serialize.html\n//! [`Serializer`]: ../trait.Serializer.html\n//! [`bincode`]: https://github.com/TyOverby/bincode\n//! [`linked-hash-map`]: https://crates.io/crates/linked-hash-map\n//! [`serde_derive`]: https://crates.io/crates/serde_derive\n//! [`serde_json`]: https://github.com/serde-rs/json\n//! [`serde_yaml`]: https://github.com/dtolnay/serde-yaml\n//! [derive section of the manual]: https://serde.rs/derive.html\n//! [data formats]: https://serde.rs/#data-formats\n\nuse lib::*;\n\nmod impls;\nmod impossible;\n\npub use self::impossible::Impossible;\n\n#[cfg(feature = \"std\")]\n#[doc(no_inline)]\npub use std::error::Error as StdError;\n#[cfg(not(feature = \"std\"))]\n#[doc(no_inline)]\npub use std_error::Error as StdError;\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! declare_error_trait {\n    (Error: Sized $(+ $($supertrait:ident)::+)*) =\u003e {\n        /// Trait used by `Serialize` implementations to generically construct\n        /// errors belonging to the `Serializer` against which they are\n        /// currently running.\n        ///\n        /// # Example implementation\n        ///\n        /// The [example data format] presented on the website shows an error\n        /// type appropriate for a basic JSON data format.\n        ///\n        /// [example data format]: https://serde.rs/data-format.html\n        pub trait Error: Sized $(+ $($supertrait)::+)* {\n            /// Used when a [`Serialize`] implementation encounters any error\n            /// while serializing a type.\n            ///\n            /// The message should not be capitalized and should not end with a\n            /// period.\n            ///\n            /// For example, a filesystem [`Path`] may refuse to serialize\n            /// itself if it contains invalid UTF-8 data.\n            ///\n            /// ```edition2018\n            /// # struct Path;\n            /// #\n            /// # impl Path {\n            /// #     fn to_str(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n            /// #         unimplemented!()\n            /// #     }\n            /// # }\n            /// #\n            /// use serde::ser::{self, Serialize, Serializer};\n            ///\n            /// impl Serialize for Path {\n            ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n            ///     where\n            ///         S: Serializer,\n            ///     {\n            ///         match self.to_str() {\n            ///             Some(s) =\u003e serializer.serialize_str(s),\n            ///             None =\u003e Err(ser::Error::custom(\"path contains invalid UTF-8 characters\")),\n            ///         }\n            ///     }\n            /// }\n            /// ```\n            ///\n            /// [`Path`]: https://doc.rust-lang.org/std/path/struct.Path.html\n            /// [`Serialize`]: ../trait.Serialize.html\n            fn custom\u003cT\u003e(msg: T) -\u003e Self\n            where\n                T: Display;\n        }\n    }\n}\n\n#[cfg(feature = \"std\")]\ndeclare_error_trait!(Error: Sized + StdError);\n\n#[cfg(not(feature = \"std\"))]\ndeclare_error_trait!(Error: Sized + Debug + Display);\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A **data structure** that can be serialized into any data format supported\n/// by Serde.\n///\n/// Serde provides `Serialize` implementations for many Rust primitive and\n/// standard library types. The complete list is [here][ser]. All of these can\n/// be serialized using Serde out of the box.\n///\n/// Additionally, Serde provides a procedural macro called [`serde_derive`] to\n/// automatically generate `Serialize` implementations for structs and enums in\n/// your program. See the [derive section of the manual] for how to use this.\n///\n/// In rare cases it may be necessary to implement `Serialize` manually for some\n/// type in your program. See the [Implementing `Serialize`] section of the\n/// manual for more about this.\n///\n/// Third-party crates may provide `Serialize` implementations for types that\n/// they expose. For example the [`linked-hash-map`] crate provides a\n/// [`LinkedHashMap\u003cK, V\u003e`] type that is serializable by Serde because the crate\n/// provides an implementation of `Serialize` for it.\n///\n/// [Implementing `Serialize`]: https://serde.rs/impl-serialize.html\n/// [`LinkedHashMap\u003cK, V\u003e`]: https://docs.rs/linked-hash-map/*/linked_hash_map/struct.LinkedHashMap.html\n/// [`linked-hash-map`]: https://crates.io/crates/linked-hash-map\n/// [`serde_derive`]: https://crates.io/crates/serde_derive\n/// [derive section of the manual]: https://serde.rs/derive.html\n/// [ser]: https://docs.serde.rs/serde/ser/index.html\npub trait Serialize {\n    /// Serialize this value into the given Serde serializer.\n    ///\n    /// See the [Implementing `Serialize`] section of the manual for more\n    /// information about how to implement this method.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeStruct, Serializer};\n    ///\n    /// struct Person {\n    ///     name: String,\n    ///     age: u8,\n    ///     phones: Vec\u003cString\u003e,\n    /// }\n    ///\n    /// // This is what #[derive(Serialize)] would generate.\n    /// impl Serialize for Person {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut s = serializer.serialize_struct(\"Person\", 3)?;\n    ///         s.serialize_field(\"name\", \u0026self.name)?;\n    ///         s.serialize_field(\"age\", \u0026self.age)?;\n    ///         s.serialize_field(\"phones\", \u0026self.phones)?;\n    ///         s.end()\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [Implementing `Serialize`]: https://serde.rs/impl-serialize.html\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// A **data format** that can serialize any data structure supported by Serde.\n///\n/// The role of this trait is to define the serialization half of the [Serde\n/// data model], which is a way to categorize every Rust data structure into one\n/// of 29 possible types. Each method of the `Serializer` trait corresponds to\n/// one of the types of the data model.\n///\n/// Implementations of `Serialize` map themselves into this data model by\n/// invoking exactly one of the `Serializer` methods.\n///\n/// The types that make up the Serde data model are:\n///\n///  - **14 primitive types**\n///    - bool\n///    - i8, i16, i32, i64, i128\n///    - u8, u16, u32, u64, u128\n///    - f32, f64\n///    - char\n///  - **string**\n///    - UTF-8 bytes with a length and no null terminator.\n///    - When serializing, all strings are handled equally. When deserializing,\n///      there are three flavors of strings: transient, owned, and borrowed.\n///  - **byte array** - \\[u8\\]\n///    - Similar to strings, during deserialization byte arrays can be\n///      transient, owned, or borrowed.\n///  - **option**\n///    - Either none or some value.\n///  - **unit**\n///    - The type of `()` in Rust. It represents an anonymous value containing\n///      no data.\n///  - **unit_struct**\n///    - For example `struct Unit` or `PhantomData\u003cT\u003e`. It represents a named\n///      value containing no data.\n///  - **unit_variant**\n///    - For example the `E::A` and `E::B` in `enum E { A, B }`.\n///  - **newtype_struct**\n///    - For example `struct Millimeters(u8)`.\n///  - **newtype_variant**\n///    - For example the `E::N` in `enum E { N(u8) }`.\n///  - **seq**\n///    - A variably sized heterogeneous sequence of values, for example\n///      `Vec\u003cT\u003e` or `HashSet\u003cT\u003e`. When serializing, the length may or may not\n///      be known before iterating through all the data. When deserializing,\n///      the length is determined by looking at the serialized data.\n///  - **tuple**\n///    - A statically sized heterogeneous sequence of values for which the\n///      length will be known at deserialization time without looking at the\n///      serialized data, for example `(u8,)` or `(String, u64, Vec\u003cT\u003e)` or\n///      `[u64; 10]`.\n///  - **tuple_struct**\n///    - A named tuple, for example `struct Rgb(u8, u8, u8)`.\n///  - **tuple_variant**\n///    - For example the `E::T` in `enum E { T(u8, u8) }`.\n///  - **map**\n///    - A heterogeneous key-value pairing, for example `BTreeMap\u003cK, V\u003e`.\n///  - **struct**\n///    - A heterogeneous key-value pairing in which the keys are strings and\n///      will be known at deserialization time without looking at the\n///      serialized data, for example `struct S { r: u8, g: u8, b: u8 }`.\n///  - **struct_variant**\n///    - For example the `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`.\n///\n/// Many Serde serializers produce text or binary data as output, for example\n/// JSON or Bincode. This is not a requirement of the `Serializer` trait, and\n/// there are serializers that do not produce text or binary output. One example\n/// is the `serde_json::value::Serializer` (distinct from the main `serde_json`\n/// serializer) that produces a `serde_json::Value` data structure in memory as\n/// output.\n///\n/// [Serde data model]: https://serde.rs/data-model.html\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website contains example code for\n/// a basic JSON `Serializer`.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait Serializer: Sized {\n    /// The output type produced by this `Serializer` during successful\n    /// serialization. Most serializers that produce text or binary output\n    /// should set `Ok = ()` and serialize into an [`io::Write`] or buffer\n    /// contained within the `Serializer` instance. Serializers that build\n    /// in-memory data structures may be simplified by using `Ok` to propagate\n    /// the data structure around.\n    ///\n    /// [`io::Write`]: https://doc.rust-lang.org/std/io/trait.Write.html\n    type Ok;\n\n    /// The error type when some error occurs during serialization.\n    type Error: Error;\n\n    /// Type returned from [`serialize_seq`] for serializing the content of the\n    /// sequence.\n    ///\n    /// [`serialize_seq`]: #tymethod.serialize_seq\n    type SerializeSeq: SerializeSeq\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Type returned from [`serialize_tuple`] for serializing the content of\n    /// the tuple.\n    ///\n    /// [`serialize_tuple`]: #tymethod.serialize_tuple\n    type SerializeTuple: SerializeTuple\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Type returned from [`serialize_tuple_struct`] for serializing the\n    /// content of the tuple struct.\n    ///\n    /// [`serialize_tuple_struct`]: #tymethod.serialize_tuple_struct\n    type SerializeTupleStruct: SerializeTupleStruct\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Type returned from [`serialize_tuple_variant`] for serializing the\n    /// content of the tuple variant.\n    ///\n    /// [`serialize_tuple_variant`]: #tymethod.serialize_tuple_variant\n    type SerializeTupleVariant: SerializeTupleVariant\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Type returned from [`serialize_map`] for serializing the content of the\n    /// map.\n    ///\n    /// [`serialize_map`]: #tymethod.serialize_map\n    type SerializeMap: SerializeMap\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Type returned from [`serialize_struct`] for serializing the content of\n    /// the struct.\n    ///\n    /// [`serialize_struct`]: #tymethod.serialize_struct\n    type SerializeStruct: SerializeStruct\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Type returned from [`serialize_struct_variant`] for serializing the\n    /// content of the struct variant.\n    ///\n    /// [`serialize_struct_variant`]: #tymethod.serialize_struct_variant\n    type SerializeStructVariant: SerializeStructVariant\u003cOk = Self::Ok, Error = Self::Error\u003e;\n\n    /// Serialize a `bool` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for bool {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_bool(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_bool(self, v: bool) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize an `i8` value.\n    ///\n    /// If the format does not differentiate between `i8` and `i64`, a\n    /// reasonable implementation would be to cast the value to `i64` and\n    /// forward to `serialize_i64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for i8 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_i8(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_i8(self, v: i8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize an `i16` value.\n    ///\n    /// If the format does not differentiate between `i16` and `i64`, a\n    /// reasonable implementation would be to cast the value to `i64` and\n    /// forward to `serialize_i64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for i16 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_i16(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_i16(self, v: i16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize an `i32` value.\n    ///\n    /// If the format does not differentiate between `i32` and `i64`, a\n    /// reasonable implementation would be to cast the value to `i64` and\n    /// forward to `serialize_i64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for i32 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_i32(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_i32(self, v: i32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize an `i64` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for i64 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_i64(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_i64(self, v: i64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    serde_if_integer128! {\n        /// Serialize an `i128` value.\n        ///\n        /// ```edition2018\n        /// # use serde::Serializer;\n        /// #\n        /// # serde::__private_serialize!();\n        /// #\n        /// impl Serialize for i128 {\n        ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n        ///     where\n        ///         S: Serializer,\n        ///     {\n        ///         serializer.serialize_i128(*self)\n        ///     }\n        /// }\n        /// ```\n        ///\n        /// This method is available only on Rust compiler versions \u003e=1.26. The\n        /// default behavior unconditionally returns an error.\n        fn serialize_i128(self, v: i128) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n            let _ = v;\n            Err(Error::custom(\"i128 is not supported\"))\n        }\n    }\n\n    /// Serialize a `u8` value.\n    ///\n    /// If the format does not differentiate between `u8` and `u64`, a\n    /// reasonable implementation would be to cast the value to `u64` and\n    /// forward to `serialize_u64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for u8 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_u8(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_u8(self, v: u8) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a `u16` value.\n    ///\n    /// If the format does not differentiate between `u16` and `u64`, a\n    /// reasonable implementation would be to cast the value to `u64` and\n    /// forward to `serialize_u64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for u16 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_u16(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_u16(self, v: u16) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a `u32` value.\n    ///\n    /// If the format does not differentiate between `u32` and `u64`, a\n    /// reasonable implementation would be to cast the value to `u64` and\n    /// forward to `serialize_u64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for u32 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_u32(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_u32(self, v: u32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a `u64` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for u64 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_u64(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_u64(self, v: u64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    serde_if_integer128! {\n        /// Serialize a `u128` value.\n        ///\n        /// ```edition2018\n        /// # use serde::Serializer;\n        /// #\n        /// # serde::__private_serialize!();\n        /// #\n        /// impl Serialize for u128 {\n        ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n        ///     where\n        ///         S: Serializer,\n        ///     {\n        ///         serializer.serialize_u128(*self)\n        ///     }\n        /// }\n        /// ```\n        ///\n        /// This method is available only on Rust compiler versions \u003e=1.26. The\n        /// default behavior unconditionally returns an error.\n        fn serialize_u128(self, v: u128) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n            let _ = v;\n            Err(Error::custom(\"u128 is not supported\"))\n        }\n    }\n\n    /// Serialize an `f32` value.\n    ///\n    /// If the format does not differentiate between `f32` and `f64`, a\n    /// reasonable implementation would be to cast the value to `f64` and\n    /// forward to `serialize_f64`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for f32 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_f32(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_f32(self, v: f32) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize an `f64` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for f64 {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_f64(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_f64(self, v: f64) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a character.\n    ///\n    /// If the format does not support characters, it is reasonable to serialize\n    /// it as a single element `str` or a `u32`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for char {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_char(*self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_char(self, v: char) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a `\u0026str`.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for str {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_str(self)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_str(self, v: \u0026str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a chunk of raw byte data.\n    ///\n    /// Enables serializers to serialize byte slices more compactly or more\n    /// efficiently than other types of slices. If no efficient implementation\n    /// is available, a reasonable implementation would be to forward to\n    /// `serialize_seq`. If forwarded, the implementation looks usually just\n    /// like this:\n    ///\n    /// ```edition2018\n    /// # use serde::ser::{Serializer, SerializeSeq};\n    /// # use serde::private::ser::Error;\n    /// #\n    /// # struct MySerializer;\n    /// #\n    /// # impl Serializer for MySerializer {\n    /// #     type Ok = ();\n    /// #     type Error = Error;\n    /// #\n    /// fn serialize_bytes(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Ok, Self::Error\u003e {\n    ///     let mut seq = self.serialize_seq(Some(v.len()))?;\n    ///     for b in v {\n    ///         seq.serialize_element(b)?;\n    ///     }\n    ///     seq.end()\n    /// }\n    /// #\n    /// #     serde::__serialize_unimplemented! {\n    /// #         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str none some\n    /// #         unit unit_struct unit_variant newtype_struct newtype_variant\n    /// #         seq tuple tuple_struct tuple_variant map struct struct_variant\n    /// #     }\n    /// # }\n    /// ```\n    fn serialize_bytes(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a [`None`] value.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Serializer};\n    /// #\n    /// # enum Option\u003cT\u003e {\n    /// #     Some(T),\n    /// #     None,\n    /// # }\n    /// #\n    /// # use self::Option::{Some, None};\n    /// #\n    /// impl\u003cT\u003e Serialize for Option\u003cT\u003e\n    /// where\n    ///     T: Serialize,\n    /// {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             Some(ref value) =\u003e serializer.serialize_some(value),\n    ///             None =\u003e serializer.serialize_none(),\n    ///         }\n    ///     }\n    /// }\n    /// #\n    /// # fn main() {}\n    /// ```\n    ///\n    /// [`None`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.None\n    fn serialize_none(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a [`Some(T)`] value.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Serializer};\n    /// #\n    /// # enum Option\u003cT\u003e {\n    /// #     Some(T),\n    /// #     None,\n    /// # }\n    /// #\n    /// # use self::Option::{Some, None};\n    /// #\n    /// impl\u003cT\u003e Serialize for Option\u003cT\u003e\n    /// where\n    ///     T: Serialize,\n    /// {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             Some(ref value) =\u003e serializer.serialize_some(value),\n    ///             None =\u003e serializer.serialize_none(),\n    ///         }\n    ///     }\n    /// }\n    /// #\n    /// # fn main() {}\n    /// ```\n    ///\n    /// [`Some(T)`]: https://doc.rust-lang.org/std/option/enum.Option.html#variant.Some\n    fn serialize_some\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Serialize a `()` value.\n    ///\n    /// ```edition2018\n    /// # use serde::Serializer;\n    /// #\n    /// # serde::__private_serialize!();\n    /// #\n    /// impl Serialize for () {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_unit()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_unit(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a unit struct like `struct Unit` or `PhantomData\u003cT\u003e`.\n    ///\n    /// A reasonable implementation would be to forward to `serialize_unit`.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// struct Nothing;\n    ///\n    /// impl Serialize for Nothing {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_unit_struct(\"Nothing\")\n    ///     }\n    /// }\n    /// ```\n    fn serialize_unit_struct(self, name: \u0026'static str) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a unit variant like `E::A` in `enum E { A, B }`.\n    ///\n    /// The `name` is the name of the enum, the `variant_index` is the index of\n    /// this variant within the enum, and the `variant` is the name of the\n    /// variant.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// enum E {\n    ///     A,\n    ///     B,\n    /// }\n    ///\n    /// impl Serialize for E {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             E::A =\u003e serializer.serialize_unit_variant(\"E\", 0, \"A\"),\n    ///             E::B =\u003e serializer.serialize_unit_variant(\"E\", 1, \"B\"),\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn serialize_unit_variant(\n        self,\n        name: \u0026'static str,\n        variant_index: u32,\n        variant: \u0026'static str,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n\n    /// Serialize a newtype struct like `struct Millimeters(u8)`.\n    ///\n    /// Serializers are encouraged to treat newtype structs as insignificant\n    /// wrappers around the data they contain. A reasonable implementation would\n    /// be to forward to `value.serialize(self)`.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// struct Millimeters(u8);\n    ///\n    /// impl Serialize for Millimeters {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.serialize_newtype_struct(\"Millimeters\", \u0026self.0)\n    ///     }\n    /// }\n    /// ```\n    fn serialize_newtype_struct\u003cT: ?Sized\u003e(\n        self,\n        name: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Serialize a newtype variant like `E::N` in `enum E { N(u8) }`.\n    ///\n    /// The `name` is the name of the enum, the `variant_index` is the index of\n    /// this variant within the enum, and the `variant` is the name of the\n    /// variant. The `value` is the data contained within this newtype variant.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// enum E {\n    ///     M(String),\n    ///     N(u8),\n    /// }\n    ///\n    /// impl Serialize for E {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             E::M(ref s) =\u003e serializer.serialize_newtype_variant(\"E\", 0, \"M\", s),\n    ///             E::N(n) =\u003e serializer.serialize_newtype_variant(\"E\", 1, \"N\", \u0026n),\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n        self,\n        name: \u0026'static str,\n        variant_index: u32,\n        variant: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Begin to serialize a variably sized sequence. This call must be\n    /// followed by zero or more calls to `serialize_element`, then a call to\n    /// `end`.\n    ///\n    /// The argument is the number of elements in the sequence, which may or may\n    /// not be computable before the sequence is iterated. Some serializers only\n    /// support sequences whose length is known up front.\n    ///\n    /// ```edition2018\n    /// # use std::marker::PhantomData;\n    /// #\n    /// # struct Vec\u003cT\u003e(PhantomData\u003cT\u003e);\n    /// #\n    /// # impl\u003cT\u003e Vec\u003cT\u003e {\n    /// #     fn len(\u0026self) -\u003e usize {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// # impl\u003c'a, T\u003e IntoIterator for \u0026'a Vec\u003cT\u003e {\n    /// #     type Item = \u0026'a T;\n    /// #     type IntoIter = Box\u003cIterator\u003cItem = \u0026'a T\u003e\u003e;\n    /// #\n    /// #     fn into_iter(self) -\u003e Self::IntoIter {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// use serde::ser::{Serialize, Serializer, SerializeSeq};\n    ///\n    /// impl\u003cT\u003e Serialize for Vec\u003cT\u003e\n    /// where\n    ///     T: Serialize,\n    /// {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut seq = serializer.serialize_seq(Some(self.len()))?;\n    ///         for element in self {\n    ///             seq.serialize_element(element)?;\n    ///         }\n    ///         seq.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_seq(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeSeq, Self::Error\u003e;\n\n    /// Begin to serialize a statically sized sequence whose length will be\n    /// known at deserialization time without looking at the serialized data.\n    /// This call must be followed by zero or more calls to `serialize_element`,\n    /// then a call to `end`.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, Serializer, SerializeTuple};\n    ///\n    /// # mod fool {\n    /// #     trait Serialize {}\n    /// impl\u003cA, B, C\u003e Serialize for (A, B, C)\n    /// #     {}\n    /// # }\n    /// #\n    /// # struct Tuple3\u003cA, B, C\u003e(A, B, C);\n    /// #\n    /// # impl\u003cA, B, C\u003e Serialize for Tuple3\u003cA, B, C\u003e\n    /// where\n    ///     A: Serialize,\n    ///     B: Serialize,\n    ///     C: Serialize,\n    /// {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut tup = serializer.serialize_tuple(3)?;\n    ///         tup.serialize_element(\u0026self.0)?;\n    ///         tup.serialize_element(\u0026self.1)?;\n    ///         tup.serialize_element(\u0026self.2)?;\n    ///         tup.end()\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeTuple, Serializer};\n    ///\n    /// const VRAM_SIZE: usize = 386;\n    /// struct Vram([u16; VRAM_SIZE]);\n    ///\n    /// impl Serialize for Vram {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut seq = serializer.serialize_tuple(VRAM_SIZE)?;\n    ///         for element in \u0026self.0[..] {\n    ///             seq.serialize_element(element)?;\n    ///         }\n    ///         seq.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_tuple(self, len: usize) -\u003e Result\u003cSelf::SerializeTuple, Self::Error\u003e;\n\n    /// Begin to serialize a tuple struct like `struct Rgb(u8, u8, u8)`. This\n    /// call must be followed by zero or more calls to `serialize_field`, then a\n    /// call to `end`.\n    ///\n    /// The `name` is the name of the tuple struct and the `len` is the number\n    /// of data fields that will be serialized.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeTupleStruct, Serializer};\n    ///\n    /// struct Rgb(u8, u8, u8);\n    ///\n    /// impl Serialize for Rgb {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut ts = serializer.serialize_tuple_struct(\"Rgb\", 3)?;\n    ///         ts.serialize_field(\u0026self.0)?;\n    ///         ts.serialize_field(\u0026self.1)?;\n    ///         ts.serialize_field(\u0026self.2)?;\n    ///         ts.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_tuple_struct(\n        self,\n        name: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleStruct, Self::Error\u003e;\n\n    /// Begin to serialize a tuple variant like `E::T` in `enum E { T(u8, u8)\n    /// }`. This call must be followed by zero or more calls to\n    /// `serialize_field`, then a call to `end`.\n    ///\n    /// The `name` is the name of the enum, the `variant_index` is the index of\n    /// this variant within the enum, the `variant` is the name of the variant,\n    /// and the `len` is the number of data fields that will be serialized.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeTupleVariant, Serializer};\n    ///\n    /// enum E {\n    ///     T(u8, u8),\n    ///     U(String, u32, u32),\n    /// }\n    ///\n    /// impl Serialize for E {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             E::T(ref a, ref b) =\u003e {\n    ///                 let mut tv = serializer.serialize_tuple_variant(\"E\", 0, \"T\", 2)?;\n    ///                 tv.serialize_field(a)?;\n    ///                 tv.serialize_field(b)?;\n    ///                 tv.end()\n    ///             }\n    ///             E::U(ref a, ref b, ref c) =\u003e {\n    ///                 let mut tv = serializer.serialize_tuple_variant(\"E\", 1, \"U\", 3)?;\n    ///                 tv.serialize_field(a)?;\n    ///                 tv.serialize_field(b)?;\n    ///                 tv.serialize_field(c)?;\n    ///                 tv.end()\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn serialize_tuple_variant(\n        self,\n        name: \u0026'static str,\n        variant_index: u32,\n        variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleVariant, Self::Error\u003e;\n\n    /// Begin to serialize a map. This call must be followed by zero or more\n    /// calls to `serialize_key` and `serialize_value`, then a call to `end`.\n    ///\n    /// The argument is the number of elements in the map, which may or may not\n    /// be computable before the map is iterated. Some serializers only support\n    /// maps whose length is known up front.\n    ///\n    /// ```edition2018\n    /// # use std::marker::PhantomData;\n    /// #\n    /// # struct HashMap\u003cK, V\u003e(PhantomData\u003cK\u003e, PhantomData\u003cV\u003e);\n    /// #\n    /// # impl\u003cK, V\u003e HashMap\u003cK, V\u003e {\n    /// #     fn len(\u0026self) -\u003e usize {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// # impl\u003c'a, K, V\u003e IntoIterator for \u0026'a HashMap\u003cK, V\u003e {\n    /// #     type Item = (\u0026'a K, \u0026'a V);\n    /// #     type IntoIter = Box\u003cIterator\u003cItem = (\u0026'a K, \u0026'a V)\u003e\u003e;\n    /// #\n    /// #     fn into_iter(self) -\u003e Self::IntoIter {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// use serde::ser::{Serialize, Serializer, SerializeMap};\n    ///\n    /// impl\u003cK, V\u003e Serialize for HashMap\u003cK, V\u003e\n    /// where\n    ///     K: Serialize,\n    ///     V: Serialize,\n    /// {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut map = serializer.serialize_map(Some(self.len()))?;\n    ///         for (k, v) in self {\n    ///             map.serialize_entry(k, v)?;\n    ///         }\n    ///         map.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_map(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeMap, Self::Error\u003e;\n\n    /// Begin to serialize a struct like `struct Rgb { r: u8, g: u8, b: u8 }`.\n    /// This call must be followed by zero or more calls to `serialize_field`,\n    /// then a call to `end`.\n    ///\n    /// The `name` is the name of the struct and the `len` is the number of\n    /// data fields that will be serialized.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeStruct, Serializer};\n    ///\n    /// struct Rgb {\n    ///     r: u8,\n    ///     g: u8,\n    ///     b: u8,\n    /// }\n    ///\n    /// impl Serialize for Rgb {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         let mut rgb = serializer.serialize_struct(\"Rgb\", 3)?;\n    ///         rgb.serialize_field(\"r\", \u0026self.r)?;\n    ///         rgb.serialize_field(\"g\", \u0026self.g)?;\n    ///         rgb.serialize_field(\"b\", \u0026self.b)?;\n    ///         rgb.end()\n    ///     }\n    /// }\n    /// ```\n    fn serialize_struct(\n        self,\n        name: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStruct, Self::Error\u003e;\n\n    /// Begin to serialize a struct variant like `E::S` in `enum E { S { r: u8,\n    /// g: u8, b: u8 } }`. This call must be followed by zero or more calls to\n    /// `serialize_field`, then a call to `end`.\n    ///\n    /// The `name` is the name of the enum, the `variant_index` is the index of\n    /// this variant within the enum, the `variant` is the name of the variant,\n    /// and the `len` is the number of data fields that will be serialized.\n    ///\n    /// ```edition2018\n    /// use serde::ser::{Serialize, SerializeStructVariant, Serializer};\n    ///\n    /// enum E {\n    ///     S { r: u8, g: u8, b: u8 },\n    /// }\n    ///\n    /// impl Serialize for E {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         match *self {\n    ///             E::S {\n    ///                 ref r,\n    ///                 ref g,\n    ///                 ref b,\n    ///             } =\u003e {\n    ///                 let mut sv = serializer.serialize_struct_variant(\"E\", 0, \"S\", 3)?;\n    ///                 sv.serialize_field(\"r\", r)?;\n    ///                 sv.serialize_field(\"g\", g)?;\n    ///                 sv.serialize_field(\"b\", b)?;\n    ///                 sv.end()\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn serialize_struct_variant(\n        self,\n        name: \u0026'static str,\n        variant_index: u32,\n        variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStructVariant, Self::Error\u003e;\n\n    /// Collect an iterator as a sequence.\n    ///\n    /// The default implementation serializes each item yielded by the iterator\n    /// using [`serialize_seq`]. Implementors should not need to override this\n    /// method.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// struct SecretlyOneHigher {\n    ///     data: Vec\u003ci32\u003e,\n    /// }\n    ///\n    /// impl Serialize for SecretlyOneHigher {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.collect_seq(self.data.iter().map(|x| x + 1))\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`serialize_seq`]: #tymethod.serialize_seq\n    fn collect_seq\u003cI\u003e(self, iter: I) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        I: IntoIterator,\n        \u003cI as IntoIterator\u003e::Item: Serialize,\n    {\n        let iter = iter.into_iter();\n        let mut serializer = try!(self.serialize_seq(iter.len_hint()));\n        for item in iter {\n            try!(serializer.serialize_element(\u0026item));\n        }\n        serializer.end()\n    }\n\n    /// Collect an iterator as a map.\n    ///\n    /// The default implementation serializes each pair yielded by the iterator\n    /// using [`serialize_map`]. Implementors should not need to override this\n    /// method.\n    ///\n    /// ```edition2018\n    /// use serde::{Serialize, Serializer};\n    /// use std::collections::BTreeSet;\n    ///\n    /// struct MapToUnit {\n    ///     keys: BTreeSet\u003ci32\u003e,\n    /// }\n    ///\n    /// // Serializes as a map in which the values are all unit.\n    /// impl Serialize for MapToUnit {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.collect_map(self.keys.iter().map(|k| (k, ())))\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`serialize_map`]: #tymethod.serialize_map\n    fn collect_map\u003cK, V, I\u003e(self, iter: I) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        K: Serialize,\n        V: Serialize,\n        I: IntoIterator\u003cItem = (K, V)\u003e,\n    {\n        let iter = iter.into_iter();\n        let mut serializer = try!(self.serialize_map(iter.len_hint()));\n        for (key, value) in iter {\n            try!(serializer.serialize_entry(\u0026key, \u0026value));\n        }\n        serializer.end()\n    }\n\n    /// Serialize a string produced by an implementation of `Display`.\n    ///\n    /// The default implementation builds a heap-allocated [`String`] and\n    /// delegates to [`serialize_str`]. Serializers are encouraged to provide a\n    /// more efficient implementation if possible.\n    ///\n    /// ```edition2018\n    /// # struct DateTime;\n    /// #\n    /// # impl DateTime {\n    /// #     fn naive_local(\u0026self) -\u003e () { () }\n    /// #     fn offset(\u0026self) -\u003e () { () }\n    /// # }\n    /// #\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// impl Serialize for DateTime {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.collect_str(\u0026format_args!(\"{:?}{:?}\",\n    ///                                              self.naive_local(),\n    ///                                              self.offset()))\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`String`]: https://doc.rust-lang.org/std/string/struct.String.html\n    /// [`serialize_str`]: #tymethod.serialize_str\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    fn collect_str\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Display,\n    {\n        use lib::fmt::Write;\n        let mut string = String::new();\n        write!(string, \"{}\", value).unwrap();\n        self.serialize_str(\u0026string)\n    }\n\n    /// Serialize a string produced by an implementation of `Display`.\n    ///\n    /// Serializers that use `no_std` are required to provide an implementation\n    /// of this method. If no more sensible behavior is possible, the\n    /// implementation is expected to return an error.\n    ///\n    /// ```edition2018\n    /// # struct DateTime;\n    /// #\n    /// # impl DateTime {\n    /// #     fn naive_local(\u0026self) -\u003e () { () }\n    /// #     fn offset(\u0026self) -\u003e () { () }\n    /// # }\n    /// #\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// impl Serialize for DateTime {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         serializer.collect_str(\u0026format_args!(\"{:?}{:?}\",\n    ///                                              self.naive_local(),\n    ///                                              self.offset()))\n    ///     }\n    /// }\n    /// ```\n    #[cfg(not(any(feature = \"std\", feature = \"alloc\")))]\n    fn collect_str\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cSelf::Ok, Self::Error\u003e\n    where\n        T: Display;\n\n    /// Determine whether `Serialize` implementations should serialize in\n    /// human-readable form.\n    ///\n    /// Some types have a human-readable form that may be somewhat expensive to\n    /// construct, as well as a binary form that is compact and efficient.\n    /// Generally text-based formats like JSON and YAML will prefer to use the\n    /// human-readable one and binary formats like Bincode will prefer the\n    /// compact one.\n    ///\n    /// ```edition2018\n    /// # use std::fmt::{self, Display};\n    /// #\n    /// # struct Timestamp;\n    /// #\n    /// # impl Timestamp {\n    /// #     fn seconds_since_epoch(\u0026self) -\u003e u64 { unimplemented!() }\n    /// # }\n    /// #\n    /// # impl Display for Timestamp {\n    /// #     fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    /// #         unimplemented!()\n    /// #     }\n    /// # }\n    /// #\n    /// use serde::{Serialize, Serializer};\n    ///\n    /// impl Serialize for Timestamp {\n    ///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    ///     where\n    ///         S: Serializer,\n    ///     {\n    ///         if serializer.is_human_readable() {\n    ///             // Serialize to a human-readable string \"2015-05-15T17:01:00Z\".\n    ///             self.to_string().serialize(serializer)\n    ///         } else {\n    ///             // Serialize to a compact binary representation.\n    ///             self.seconds_since_epoch().serialize(serializer)\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// The default implementation of this method returns `true`. Data formats\n    /// may override this to `false` to request a compact form for types that\n    /// support one. Note that modifying this method to change a format from\n    /// human-readable to compact or vice versa should be regarded as a breaking\n    /// change, as a value serialized in human-readable mode is not required to\n    /// deserialize from the same data in compact mode.\n    #[inline]\n    fn is_human_readable(\u0026self) -\u003e bool {\n        true\n    }\n}\n\n/// Returned from `Serializer::serialize_seq`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// # use std::marker::PhantomData;\n/// #\n/// # struct Vec\u003cT\u003e(PhantomData\u003cT\u003e);\n/// #\n/// # impl\u003cT\u003e Vec\u003cT\u003e {\n/// #     fn len(\u0026self) -\u003e usize {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// # impl\u003c'a, T\u003e IntoIterator for \u0026'a Vec\u003cT\u003e {\n/// #     type Item = \u0026'a T;\n/// #     type IntoIter = Box\u003cIterator\u003cItem = \u0026'a T\u003e\u003e;\n/// #     fn into_iter(self) -\u003e Self::IntoIter {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// use serde::ser::{Serialize, Serializer, SerializeSeq};\n///\n/// impl\u003cT\u003e Serialize for Vec\u003cT\u003e\n/// where\n///     T: Serialize,\n/// {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         let mut seq = serializer.serialize_seq(Some(self.len()))?;\n///         for element in self {\n///             seq.serialize_element(element)?;\n///         }\n///         seq.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeSeq` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeSeq {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a sequence element.\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Finish serializing a sequence.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\n/// Returned from `Serializer::serialize_tuple`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, Serializer, SerializeTuple};\n///\n/// # mod fool {\n/// #     trait Serialize {}\n/// impl\u003cA, B, C\u003e Serialize for (A, B, C)\n/// #     {}\n/// # }\n/// #\n/// # struct Tuple3\u003cA, B, C\u003e(A, B, C);\n/// #\n/// # impl\u003cA, B, C\u003e Serialize for Tuple3\u003cA, B, C\u003e\n/// where\n///     A: Serialize,\n///     B: Serialize,\n///     C: Serialize,\n/// {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         let mut tup = serializer.serialize_tuple(3)?;\n///         tup.serialize_element(\u0026self.0)?;\n///         tup.serialize_element(\u0026self.1)?;\n///         tup.serialize_element(\u0026self.2)?;\n///         tup.end()\n///     }\n/// }\n/// ```\n///\n/// ```edition2018\n/// # use std::marker::PhantomData;\n/// #\n/// # struct Array\u003cT\u003e(PhantomData\u003cT\u003e);\n/// #\n/// # impl\u003cT\u003e Array\u003cT\u003e {\n/// #     fn len(\u0026self) -\u003e usize {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// # impl\u003c'a, T\u003e IntoIterator for \u0026'a Array\u003cT\u003e {\n/// #     type Item = \u0026'a T;\n/// #     type IntoIter = Box\u003cIterator\u003cItem = \u0026'a T\u003e\u003e;\n/// #     fn into_iter(self) -\u003e Self::IntoIter {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// use serde::ser::{Serialize, Serializer, SerializeTuple};\n///\n/// # mod fool {\n/// #     trait Serialize {}\n/// impl\u003cT\u003e Serialize for [T; 16]\n/// #     {}\n/// # }\n/// #\n/// # impl\u003cT\u003e Serialize for Array\u003cT\u003e\n/// where\n///     T: Serialize,\n/// {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         let mut seq = serializer.serialize_tuple(16)?;\n///         for element in self {\n///             seq.serialize_element(element)?;\n///         }\n///         seq.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeTuple` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeTuple {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a tuple element.\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Finish serializing a tuple.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\n/// Returned from `Serializer::serialize_tuple_struct`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, SerializeTupleStruct, Serializer};\n///\n/// struct Rgb(u8, u8, u8);\n///\n/// impl Serialize for Rgb {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         let mut ts = serializer.serialize_tuple_struct(\"Rgb\", 3)?;\n///         ts.serialize_field(\u0026self.0)?;\n///         ts.serialize_field(\u0026self.1)?;\n///         ts.serialize_field(\u0026self.2)?;\n///         ts.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeTupleStruct` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeTupleStruct {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a tuple struct field.\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Finish serializing a tuple struct.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\n/// Returned from `Serializer::serialize_tuple_variant`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, SerializeTupleVariant, Serializer};\n///\n/// enum E {\n///     T(u8, u8),\n///     U(String, u32, u32),\n/// }\n///\n/// impl Serialize for E {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         match *self {\n///             E::T(ref a, ref b) =\u003e {\n///                 let mut tv = serializer.serialize_tuple_variant(\"E\", 0, \"T\", 2)?;\n///                 tv.serialize_field(a)?;\n///                 tv.serialize_field(b)?;\n///                 tv.end()\n///             }\n///             E::U(ref a, ref b, ref c) =\u003e {\n///                 let mut tv = serializer.serialize_tuple_variant(\"E\", 1, \"U\", 3)?;\n///                 tv.serialize_field(a)?;\n///                 tv.serialize_field(b)?;\n///                 tv.serialize_field(c)?;\n///                 tv.end()\n///             }\n///         }\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeTupleVariant` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeTupleVariant {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a tuple variant field.\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Finish serializing a tuple variant.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\n/// Returned from `Serializer::serialize_map`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// # use std::marker::PhantomData;\n/// #\n/// # struct HashMap\u003cK, V\u003e(PhantomData\u003cK\u003e, PhantomData\u003cV\u003e);\n/// #\n/// # impl\u003cK, V\u003e HashMap\u003cK, V\u003e {\n/// #     fn len(\u0026self) -\u003e usize {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// # impl\u003c'a, K, V\u003e IntoIterator for \u0026'a HashMap\u003cK, V\u003e {\n/// #     type Item = (\u0026'a K, \u0026'a V);\n/// #     type IntoIter = Box\u003cIterator\u003cItem = (\u0026'a K, \u0026'a V)\u003e\u003e;\n/// #\n/// #     fn into_iter(self) -\u003e Self::IntoIter {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// use serde::ser::{Serialize, Serializer, SerializeMap};\n///\n/// impl\u003cK, V\u003e Serialize for HashMap\u003cK, V\u003e\n/// where\n///     K: Serialize,\n///     V: Serialize,\n/// {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         let mut map = serializer.serialize_map(Some(self.len()))?;\n///         for (k, v) in self {\n///             map.serialize_entry(k, v)?;\n///         }\n///         map.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeMap` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeMap {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a map key.\n    ///\n    /// If possible, `Serialize` implementations are encouraged to use\n    /// `serialize_entry` instead as it may be implemented more efficiently in\n    /// some formats compared to a pair of calls to `serialize_key` and\n    /// `serialize_value`.\n    fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Serialize a map value.\n    ///\n    /// # Panics\n    ///\n    /// Calling `serialize_value` before `serialize_key` is incorrect and is\n    /// allowed to panic or produce bogus results.\n    fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Serialize a map entry consisting of a key and a value.\n    ///\n    /// Some [`Serialize`] types are not able to hold a key and value in memory\n    /// at the same time so `SerializeMap` implementations are required to\n    /// support [`serialize_key`] and [`serialize_value`] individually. The\n    /// `serialize_entry` method allows serializers to optimize for the case\n    /// where key and value are both available. [`Serialize`] implementations\n    /// are encouraged to use `serialize_entry` if possible.\n    ///\n    /// The default implementation delegates to [`serialize_key`] and\n    /// [`serialize_value`]. This is appropriate for serializers that do not\n    /// care about performance or are not able to optimize `serialize_entry` any\n    /// better than this.\n    ///\n    /// [`Serialize`]: ../trait.Serialize.html\n    /// [`serialize_key`]: #tymethod.serialize_key\n    /// [`serialize_value`]: #tymethod.serialize_value\n    fn serialize_entry\u003cK: ?Sized, V: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026K,\n        value: \u0026V,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        K: Serialize,\n        V: Serialize,\n    {\n        try!(self.serialize_key(key));\n        self.serialize_value(value)\n    }\n\n    /// Finish serializing a map.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\n/// Returned from `Serializer::serialize_struct`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, SerializeStruct, Serializer};\n///\n/// struct Rgb {\n///     r: u8,\n///     g: u8,\n///     b: u8,\n/// }\n///\n/// impl Serialize for Rgb {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         let mut rgb = serializer.serialize_struct(\"Rgb\", 3)?;\n///         rgb.serialize_field(\"r\", \u0026self.r)?;\n///         rgb.serialize_field(\"g\", \u0026self.g)?;\n///         rgb.serialize_field(\"b\", \u0026self.b)?;\n///         rgb.end()\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeStruct` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeStruct {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a struct field.\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Indicate that a struct field has been skipped.\n    #[inline]\n    fn skip_field(\u0026mut self, key: \u0026'static str) -\u003e Result\u003c(), Self::Error\u003e {\n        let _ = key;\n        Ok(())\n    }\n\n    /// Finish serializing a struct.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\n/// Returned from `Serializer::serialize_struct_variant`.\n///\n/// # Example use\n///\n/// ```edition2018\n/// use serde::ser::{Serialize, SerializeStructVariant, Serializer};\n///\n/// enum E {\n///     S { r: u8, g: u8, b: u8 },\n/// }\n///\n/// impl Serialize for E {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         match *self {\n///             E::S {\n///                 ref r,\n///                 ref g,\n///                 ref b,\n///             } =\u003e {\n///                 let mut sv = serializer.serialize_struct_variant(\"E\", 0, \"S\", 3)?;\n///                 sv.serialize_field(\"r\", r)?;\n///                 sv.serialize_field(\"g\", g)?;\n///                 sv.serialize_field(\"b\", b)?;\n///                 sv.end()\n///             }\n///         }\n///     }\n/// }\n/// ```\n///\n/// # Example implementation\n///\n/// The [example data format] presented on the website demonstrates an\n/// implementation of `SerializeStructVariant` for a basic JSON data format.\n///\n/// [example data format]: https://serde.rs/data-format.html\npub trait SerializeStructVariant {\n    /// Must match the `Ok` type of our `Serializer`.\n    type Ok;\n\n    /// Must match the `Error` type of our `Serializer`.\n    type Error: Error;\n\n    /// Serialize a struct variant field.\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize;\n\n    /// Indicate that a struct variant field has been skipped.\n    #[inline]\n    fn skip_field(\u0026mut self, key: \u0026'static str) -\u003e Result\u003c(), Self::Error\u003e {\n        let _ = key;\n        Ok(())\n    }\n\n    /// Finish serializing a struct variant.\n    fn end(self) -\u003e Result\u003cSelf::Ok, Self::Error\u003e;\n}\n\ntrait LenHint: Iterator {\n    fn len_hint(\u0026self) -\u003e Option\u003cusize\u003e;\n}\n\nimpl\u003cI\u003e LenHint for I\nwhere\n    I: Iterator,\n{\n    #[cfg(not(feature = \"unstable\"))]\n    fn len_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        iterator_len_hint(self)\n    }\n\n    #[cfg(feature = \"unstable\")]\n    default fn len_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        iterator_len_hint(self)\n    }\n}\n\n#[cfg(feature = \"unstable\")]\nimpl\u003cI\u003e LenHint for I\nwhere\n    I: ExactSizeIterator,\n{\n    fn len_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        Some(self.len())\n    }\n}\n\nfn iterator_len_hint\u003cI\u003e(iter: \u0026I) -\u003e Option\u003cusize\u003e\nwhere\n    I: Iterator,\n{\n    match iter.size_hint() {\n        (lo, Some(hi)) if lo == hi =\u003e Some(lo),\n        _ =\u003e None,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde","src","std_error.rs"],"content":"use lib::{Debug, Display};\n\n/// Either a re-export of std::error::Error or a new identical trait, depending\n/// on whether Serde's \"std\" feature is enabled.\n///\n/// Serde's error traits [`serde::ser::Error`] and [`serde::de::Error`] require\n/// [`std::error::Error`] as a supertrait, but only when Serde is built with\n/// \"std\" enabled. Data formats that don't care about no\\_std support should\n/// generally provide their error types with a `std::error::Error` impl\n/// directly:\n///\n/// ```edition2018\n/// #[derive(Debug)]\n/// struct MySerError {...}\n///\n/// impl serde::ser::Error for MySerError {...}\n///\n/// impl std::fmt::Display for MySerError {...}\n///\n/// // We don't support no_std!\n/// impl std::error::Error for MySerError {}\n/// ```\n///\n/// Data formats that *do* support no\\_std may either have a \"std\" feature of\n/// their own:\n///\n/// ```toml\n/// [features]\n/// std = [\"serde/std\"]\n/// ```\n///\n/// ```edition2018\n/// #[cfg(feature = \"std\")]\n/// impl std::error::Error for MySerError {}\n/// ```\n///\n/// ... or else provide the std Error impl unconditionally via Serde's\n/// re-export:\n///\n/// ```edition2018\n/// impl serde::ser::StdError for MySerError {}\n/// ```\npub trait Error: Debug + Display {\n    /// The underlying cause of this error, if any.\n    fn source(\u0026self) -\u003e Option\u003c\u0026(Error + 'static)\u003e {\n        None\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","bound.rs"],"content":"use std::collections::HashSet;\n\nuse syn;\nuse syn::punctuated::{Pair, Punctuated};\nuse syn::visit::{self, Visit};\n\nuse internals::ast::{Container, Data};\nuse internals::attr;\n\nuse proc_macro2::Span;\n\n// Remove the default from every type parameter because in the generated impls\n// they look like associated types: \"error: associated type bindings are not\n// allowed here\".\npub fn without_defaults(generics: \u0026syn::Generics) -\u003e syn::Generics {\n    syn::Generics {\n        params: generics\n            .params\n            .iter()\n            .map(|param| match *param {\n                syn::GenericParam::Type(ref param) =\u003e syn::GenericParam::Type(syn::TypeParam {\n                    eq_token: None,\n                    default: None,\n                    ..param.clone()\n                }),\n                _ =\u003e param.clone(),\n            })\n            .collect(),\n        ..generics.clone()\n    }\n}\n\npub fn with_where_predicates(\n    generics: \u0026syn::Generics,\n    predicates: \u0026[syn::WherePredicate],\n) -\u003e syn::Generics {\n    let mut generics = generics.clone();\n    generics\n        .make_where_clause()\n        .predicates\n        .extend(predicates.iter().cloned());\n    generics\n}\n\npub fn with_where_predicates_from_fields(\n    cont: \u0026Container,\n    generics: \u0026syn::Generics,\n    from_field: fn(\u0026attr::Field) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e,\n) -\u003e syn::Generics {\n    let predicates = cont\n        .data\n        .all_fields()\n        .flat_map(|field| from_field(\u0026field.attrs))\n        .flat_map(|predicates| predicates.to_vec());\n\n    let mut generics = generics.clone();\n    generics.make_where_clause().predicates.extend(predicates);\n    generics\n}\n\npub fn with_where_predicates_from_variants(\n    cont: \u0026Container,\n    generics: \u0026syn::Generics,\n    from_variant: fn(\u0026attr::Variant) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e,\n) -\u003e syn::Generics {\n    let variants = match cont.data {\n        Data::Enum(ref variants) =\u003e variants,\n        Data::Struct(_, _) =\u003e {\n            return generics.clone();\n        }\n    };\n\n    let predicates = variants\n        .iter()\n        .flat_map(|variant| from_variant(\u0026variant.attrs))\n        .flat_map(|predicates| predicates.to_vec());\n\n    let mut generics = generics.clone();\n    generics.make_where_clause().predicates.extend(predicates);\n    generics\n}\n\n// Puts the given bound on any generic type parameters that are used in fields\n// for which filter returns true.\n//\n// For example, the following struct needs the bound `A: Serialize, B:\n// Serialize`.\n//\n//     struct S\u003c'b, A, B: 'b, C\u003e {\n//         a: A,\n//         b: Option\u003c\u0026'b B\u003e\n//         #[serde(skip_serializing)]\n//         c: C,\n//     }\npub fn with_bound(\n    cont: \u0026Container,\n    generics: \u0026syn::Generics,\n    filter: fn(\u0026attr::Field, Option\u003c\u0026attr::Variant\u003e) -\u003e bool,\n    bound: \u0026syn::Path,\n) -\u003e syn::Generics {\n    struct FindTyParams\u003c'ast\u003e {\n        // Set of all generic type parameters on the current struct (A, B, C in\n        // the example). Initialized up front.\n        all_type_params: HashSet\u003csyn::Ident\u003e,\n\n        // Set of generic type parameters used in fields for which filter\n        // returns true (A and B in the example). Filled in as the visitor sees\n        // them.\n        relevant_type_params: HashSet\u003csyn::Ident\u003e,\n\n        // Fields whose type is an associated type of one of the generic type\n        // parameters.\n        associated_type_usage: Vec\u003c\u0026'ast syn::TypePath\u003e,\n    }\n    impl\u003c'ast\u003e Visit\u003c'ast\u003e for FindTyParams\u003c'ast\u003e {\n        fn visit_field(\u0026mut self, field: \u0026'ast syn::Field) {\n            if let syn::Type::Path(ref ty) = field.ty {\n                if let Some(Pair::Punctuated(ref t, _)) = ty.path.segments.pairs().next() {\n                    if self.all_type_params.contains(\u0026t.ident) {\n                        self.associated_type_usage.push(ty);\n                    }\n                }\n            }\n            self.visit_type(\u0026field.ty);\n        }\n\n        fn visit_path(\u0026mut self, path: \u0026'ast syn::Path) {\n            if let Some(seg) = path.segments.last() {\n                if seg.ident == \"PhantomData\" {\n                    // Hardcoded exception, because PhantomData\u003cT\u003e implements\n                    // Serialize and Deserialize whether or not T implements it.\n                    return;\n                }\n            }\n            if path.leading_colon.is_none() \u0026\u0026 path.segments.len() == 1 {\n                let id = \u0026path.segments[0].ident;\n                if self.all_type_params.contains(id) {\n                    self.relevant_type_params.insert(id.clone());\n                }\n            }\n            visit::visit_path(self, path);\n        }\n\n        // Type parameter should not be considered used by a macro path.\n        //\n        //     struct TypeMacro\u003cT\u003e {\n        //         mac: T!(),\n        //         marker: PhantomData\u003cT\u003e,\n        //     }\n        fn visit_macro(\u0026mut self, _mac: \u0026'ast syn::Macro) {}\n    }\n\n    let all_type_params = generics\n        .type_params()\n        .map(|param| param.ident.clone())\n        .collect();\n\n    let mut visitor = FindTyParams {\n        all_type_params: all_type_params,\n        relevant_type_params: HashSet::new(),\n        associated_type_usage: Vec::new(),\n    };\n    match cont.data {\n        Data::Enum(ref variants) =\u003e {\n            for variant in variants.iter() {\n                let relevant_fields = variant\n                    .fields\n                    .iter()\n                    .filter(|field| filter(\u0026field.attrs, Some(\u0026variant.attrs)));\n                for field in relevant_fields {\n                    visitor.visit_field(field.original);\n                }\n            }\n        }\n        Data::Struct(_, ref fields) =\u003e {\n            for field in fields.iter().filter(|field| filter(\u0026field.attrs, None)) {\n                visitor.visit_field(field.original);\n            }\n        }\n    }\n\n    let relevant_type_params = visitor.relevant_type_params;\n    let associated_type_usage = visitor.associated_type_usage;\n    let new_predicates = generics\n        .type_params()\n        .map(|param| param.ident.clone())\n        .filter(|id| relevant_type_params.contains(id))\n        .map(|id| syn::TypePath {\n            qself: None,\n            path: id.into(),\n        })\n        .chain(associated_type_usage.into_iter().cloned())\n        .map(|bounded_ty| {\n            syn::WherePredicate::Type(syn::PredicateType {\n                lifetimes: None,\n                // the type parameter that is being bounded e.g. T\n                bounded_ty: syn::Type::Path(bounded_ty),\n                colon_token: \u003cToken![:]\u003e::default(),\n                // the bound e.g. Serialize\n                bounds: vec![syn::TypeParamBound::Trait(syn::TraitBound {\n                    paren_token: None,\n                    modifier: syn::TraitBoundModifier::None,\n                    lifetimes: None,\n                    path: bound.clone(),\n                })]\n                .into_iter()\n                .collect(),\n            })\n        });\n\n    let mut generics = generics.clone();\n    generics\n        .make_where_clause()\n        .predicates\n        .extend(new_predicates);\n    generics\n}\n\npub fn with_self_bound(\n    cont: \u0026Container,\n    generics: \u0026syn::Generics,\n    bound: \u0026syn::Path,\n) -\u003e syn::Generics {\n    let mut generics = generics.clone();\n    generics\n        .make_where_clause()\n        .predicates\n        .push(syn::WherePredicate::Type(syn::PredicateType {\n            lifetimes: None,\n            // the type that is being bounded e.g. MyStruct\u003c'a, T\u003e\n            bounded_ty: type_of_item(cont),\n            colon_token: \u003cToken![:]\u003e::default(),\n            // the bound e.g. Default\n            bounds: vec![syn::TypeParamBound::Trait(syn::TraitBound {\n                paren_token: None,\n                modifier: syn::TraitBoundModifier::None,\n                lifetimes: None,\n                path: bound.clone(),\n            })]\n            .into_iter()\n            .collect(),\n        }));\n    generics\n}\n\npub fn with_lifetime_bound(generics: \u0026syn::Generics, lifetime: \u0026str) -\u003e syn::Generics {\n    let bound = syn::Lifetime::new(lifetime, Span::call_site());\n    let def = syn::LifetimeDef {\n        attrs: Vec::new(),\n        lifetime: bound.clone(),\n        colon_token: None,\n        bounds: Punctuated::new(),\n    };\n\n    let params = Some(syn::GenericParam::Lifetime(def))\n        .into_iter()\n        .chain(generics.params.iter().cloned().map(|mut param| {\n            match param {\n                syn::GenericParam::Lifetime(ref mut param) =\u003e {\n                    param.bounds.push(bound.clone());\n                }\n                syn::GenericParam::Type(ref mut param) =\u003e {\n                    param\n                        .bounds\n                        .push(syn::TypeParamBound::Lifetime(bound.clone()));\n                }\n                syn::GenericParam::Const(_) =\u003e {}\n            }\n            param\n        }))\n        .collect();\n\n    syn::Generics {\n        params: params,\n        ..generics.clone()\n    }\n}\n\nfn type_of_item(cont: \u0026Container) -\u003e syn::Type {\n    syn::Type::Path(syn::TypePath {\n        qself: None,\n        path: syn::Path {\n            leading_colon: None,\n            segments: vec![syn::PathSegment {\n                ident: cont.ident.clone(),\n                arguments: syn::PathArguments::AngleBracketed(\n                    syn::AngleBracketedGenericArguments {\n                        colon2_token: None,\n                        lt_token: \u003cToken![\u003c]\u003e::default(),\n                        args: cont\n                            .generics\n                            .params\n                            .iter()\n                            .map(|param| match *param {\n                                syn::GenericParam::Type(ref param) =\u003e {\n                                    syn::GenericArgument::Type(syn::Type::Path(syn::TypePath {\n                                        qself: None,\n                                        path: param.ident.clone().into(),\n                                    }))\n                                }\n                                syn::GenericParam::Lifetime(ref param) =\u003e {\n                                    syn::GenericArgument::Lifetime(param.lifetime.clone())\n                                }\n                                syn::GenericParam::Const(_) =\u003e {\n                                    panic!(\"Serde does not support const generics yet\");\n                                }\n                            })\n                            .collect(),\n                        gt_token: \u003cToken![\u003e]\u003e::default(),\n                    },\n                ),\n            }]\n            .into_iter()\n            .collect(),\n        },\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","de.rs"],"content":"use proc_macro2::{Literal, Span, TokenStream};\nuse quote::ToTokens;\nuse syn::punctuated::Punctuated;\nuse syn::spanned::Spanned;\nuse syn::{self, Ident, Index, Member};\n\nuse bound;\nuse dummy;\nuse fragment::{Expr, Fragment, Match, Stmts};\nuse internals::ast::{Container, Data, Field, Style, Variant};\nuse internals::{attr, Ctxt, Derive};\nuse pretend;\n\nuse std::collections::BTreeSet;\n\npub fn expand_derive_deserialize(input: \u0026syn::DeriveInput) -\u003e Result\u003cTokenStream, Vec\u003csyn::Error\u003e\u003e {\n    let ctxt = Ctxt::new();\n    let cont = match Container::from_ast(\u0026ctxt, input, Derive::Deserialize) {\n        Some(cont) =\u003e cont,\n        None =\u003e return Err(ctxt.check().unwrap_err()),\n    };\n    precondition(\u0026ctxt, \u0026cont);\n    ctxt.check()?;\n\n    let ident = \u0026cont.ident;\n    let params = Parameters::new(\u0026cont);\n    let (de_impl_generics, _, ty_generics, where_clause) = split_with_de_lifetime(\u0026params);\n    let body = Stmts(deserialize_body(\u0026cont, \u0026params));\n    let delife = params.borrowed.de_lifetime();\n    let serde = cont.attrs.serde_path();\n\n    let impl_block = if let Some(remote) = cont.attrs.remote() {\n        let vis = \u0026input.vis;\n        let used = pretend::pretend_used(\u0026cont);\n        quote! {\n            impl #de_impl_generics #ident #ty_generics #where_clause {\n                #vis fn deserialize\u003c__D\u003e(__deserializer: __D) -\u003e #serde::export::Result\u003c#remote #ty_generics, __D::Error\u003e\n                where\n                    __D: #serde::Deserializer\u003c#delife\u003e,\n                {\n                    #used\n                    #body\n                }\n            }\n        }\n    } else {\n        let fn_deserialize_in_place = deserialize_in_place_body(\u0026cont, \u0026params);\n\n        quote! {\n            #[automatically_derived]\n            impl #de_impl_generics #serde::Deserialize\u003c#delife\u003e for #ident #ty_generics #where_clause {\n                fn deserialize\u003c__D\u003e(__deserializer: __D) -\u003e #serde::export::Result\u003cSelf, __D::Error\u003e\n                where\n                    __D: #serde::Deserializer\u003c#delife\u003e,\n                {\n                    #body\n                }\n\n                #fn_deserialize_in_place\n            }\n        }\n    };\n\n    Ok(dummy::wrap_in_const(\n        cont.attrs.custom_serde_path(),\n        \"DESERIALIZE\",\n        ident,\n        impl_block,\n    ))\n}\n\nfn precondition(cx: \u0026Ctxt, cont: \u0026Container) {\n    precondition_sized(cx, cont);\n    precondition_no_de_lifetime(cx, cont);\n}\n\nfn precondition_sized(cx: \u0026Ctxt, cont: \u0026Container) {\n    if let Data::Struct(_, ref fields) = cont.data {\n        if let Some(last) = fields.last() {\n            if let syn::Type::Slice(_) = *last.ty {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"cannot deserialize a dynamically sized struct\",\n                );\n            }\n        }\n    }\n}\n\nfn precondition_no_de_lifetime(cx: \u0026Ctxt, cont: \u0026Container) {\n    if let BorrowedLifetimes::Borrowed(_) = borrowed_lifetimes(cont) {\n        for param in cont.generics.lifetimes() {\n            if param.lifetime.to_string() == \"'de\" {\n                cx.error_spanned_by(\n                    \u0026param.lifetime,\n                    \"cannot deserialize when there is a lifetime parameter called 'de\",\n                );\n                return;\n            }\n        }\n    }\n}\n\nstruct Parameters {\n    /// Name of the type the `derive` is on.\n    local: syn::Ident,\n\n    /// Path to the type the impl is for. Either a single `Ident` for local\n    /// types or `some::remote::Ident` for remote types. Does not include\n    /// generic parameters.\n    this: syn::Path,\n\n    /// Generics including any explicit and inferred bounds for the impl.\n    generics: syn::Generics,\n\n    /// Lifetimes borrowed from the deserializer. These will become bounds on\n    /// the `'de` lifetime of the deserializer.\n    borrowed: BorrowedLifetimes,\n\n    /// At least one field has a serde(getter) attribute, implying that the\n    /// remote type has a private field.\n    has_getter: bool,\n}\n\nimpl Parameters {\n    fn new(cont: \u0026Container) -\u003e Self {\n        let local = cont.ident.clone();\n        let this = match cont.attrs.remote() {\n            Some(remote) =\u003e remote.clone(),\n            None =\u003e cont.ident.clone().into(),\n        };\n        let borrowed = borrowed_lifetimes(cont);\n        let generics = build_generics(cont, \u0026borrowed);\n        let has_getter = cont.data.has_getter();\n\n        Parameters {\n            local: local,\n            this: this,\n            generics: generics,\n            borrowed: borrowed,\n            has_getter: has_getter,\n        }\n    }\n\n    /// Type name to use in error messages and `\u0026'static str` arguments to\n    /// various Deserializer methods.\n    fn type_name(\u0026self) -\u003e String {\n        self.this.segments.last().unwrap().ident.to_string()\n    }\n}\n\n// All the generics in the input, plus a bound `T: Deserialize` for each generic\n// field type that will be deserialized by us, plus a bound `T: Default` for\n// each generic field type that will be set to a default value.\nfn build_generics(cont: \u0026Container, borrowed: \u0026BorrowedLifetimes) -\u003e syn::Generics {\n    let generics = bound::without_defaults(cont.generics);\n\n    let generics = bound::with_where_predicates_from_fields(cont, \u0026generics, attr::Field::de_bound);\n\n    let generics =\n        bound::with_where_predicates_from_variants(cont, \u0026generics, attr::Variant::de_bound);\n\n    match cont.attrs.de_bound() {\n        Some(predicates) =\u003e bound::with_where_predicates(\u0026generics, predicates),\n        None =\u003e {\n            let generics = match *cont.attrs.default() {\n                attr::Default::Default =\u003e {\n                    bound::with_self_bound(cont, \u0026generics, \u0026parse_quote!(_serde::export::Default))\n                }\n                attr::Default::None | attr::Default::Path(_) =\u003e generics,\n            };\n\n            let delife = borrowed.de_lifetime();\n            let generics = bound::with_bound(\n                cont,\n                \u0026generics,\n                needs_deserialize_bound,\n                \u0026parse_quote!(_serde::Deserialize\u003c#delife\u003e),\n            );\n\n            bound::with_bound(\n                cont,\n                \u0026generics,\n                requires_default,\n                \u0026parse_quote!(_serde::export::Default),\n            )\n        }\n    }\n}\n\n// Fields with a `skip_deserializing` or `deserialize_with` attribute, or which\n// belong to a variant with a `skip_deserializing` or `deserialize_with`\n// attribute, are not deserialized by us so we do not generate a bound. Fields\n// with a `bound` attribute specify their own bound so we do not generate one.\n// All other fields may need a `T: Deserialize` bound where T is the type of the\n// field.\nfn needs_deserialize_bound(field: \u0026attr::Field, variant: Option\u003c\u0026attr::Variant\u003e) -\u003e bool {\n    !field.skip_deserializing()\n        \u0026\u0026 field.deserialize_with().is_none()\n        \u0026\u0026 field.de_bound().is_none()\n        \u0026\u0026 variant.map_or(true, |variant| {\n            !variant.skip_deserializing()\n                \u0026\u0026 variant.deserialize_with().is_none()\n                \u0026\u0026 variant.de_bound().is_none()\n        })\n}\n\n// Fields with a `default` attribute (not `default=...`), and fields with a\n// `skip_deserializing` attribute that do not also have `default=...`.\nfn requires_default(field: \u0026attr::Field, _variant: Option\u003c\u0026attr::Variant\u003e) -\u003e bool {\n    if let attr::Default::Default = *field.default() {\n        true\n    } else {\n        false\n    }\n}\n\nenum BorrowedLifetimes {\n    Borrowed(BTreeSet\u003csyn::Lifetime\u003e),\n    Static,\n}\n\nimpl BorrowedLifetimes {\n    fn de_lifetime(\u0026self) -\u003e syn::Lifetime {\n        match *self {\n            BorrowedLifetimes::Borrowed(_) =\u003e syn::Lifetime::new(\"'de\", Span::call_site()),\n            BorrowedLifetimes::Static =\u003e syn::Lifetime::new(\"'static\", Span::call_site()),\n        }\n    }\n\n    fn de_lifetime_def(\u0026self) -\u003e Option\u003csyn::LifetimeDef\u003e {\n        match *self {\n            BorrowedLifetimes::Borrowed(ref bounds) =\u003e Some(syn::LifetimeDef {\n                attrs: Vec::new(),\n                lifetime: syn::Lifetime::new(\"'de\", Span::call_site()),\n                colon_token: None,\n                bounds: bounds.iter().cloned().collect(),\n            }),\n            BorrowedLifetimes::Static =\u003e None,\n        }\n    }\n}\n\n// The union of lifetimes borrowed by each field of the container.\n//\n// These turn into bounds on the `'de` lifetime of the Deserialize impl. If\n// lifetimes `'a` and `'b` are borrowed but `'c` is not, the impl is:\n//\n//     impl\u003c'de: 'a + 'b, 'a, 'b, 'c\u003e Deserialize\u003c'de\u003e for S\u003c'a, 'b, 'c\u003e\n//\n// If any borrowed lifetime is `'static`, then `'de: 'static` would be redundant\n// and we use plain `'static` instead of `'de`.\nfn borrowed_lifetimes(cont: \u0026Container) -\u003e BorrowedLifetimes {\n    let mut lifetimes = BTreeSet::new();\n    for field in cont.data.all_fields() {\n        if !field.attrs.skip_deserializing() {\n            lifetimes.extend(field.attrs.borrowed_lifetimes().iter().cloned());\n        }\n    }\n    if lifetimes.iter().any(|b| b.to_string() == \"'static\") {\n        BorrowedLifetimes::Static\n    } else {\n        BorrowedLifetimes::Borrowed(lifetimes)\n    }\n}\n\nfn deserialize_body(cont: \u0026Container, params: \u0026Parameters) -\u003e Fragment {\n    if cont.attrs.transparent() {\n        deserialize_transparent(cont, params)\n    } else if let Some(type_from) = cont.attrs.type_from() {\n        deserialize_from(type_from)\n    } else if let Some(type_try_from) = cont.attrs.type_try_from() {\n        deserialize_try_from(type_try_from)\n    } else if let attr::Identifier::No = cont.attrs.identifier() {\n        match cont.data {\n            Data::Enum(ref variants) =\u003e deserialize_enum(params, variants, \u0026cont.attrs),\n            Data::Struct(Style::Struct, ref fields) =\u003e {\n                deserialize_struct(None, params, fields, \u0026cont.attrs, None, \u0026Untagged::No)\n            }\n            Data::Struct(Style::Tuple, ref fields) | Data::Struct(Style::Newtype, ref fields) =\u003e {\n                deserialize_tuple(None, params, fields, \u0026cont.attrs, None)\n            }\n            Data::Struct(Style::Unit, _) =\u003e deserialize_unit_struct(params, \u0026cont.attrs),\n        }\n    } else {\n        match cont.data {\n            Data::Enum(ref variants) =\u003e {\n                deserialize_custom_identifier(params, variants, \u0026cont.attrs)\n            }\n            Data::Struct(_, _) =\u003e unreachable!(\"checked in serde_derive_internals\"),\n        }\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_in_place_body(cont: \u0026Container, params: \u0026Parameters) -\u003e Option\u003cStmts\u003e {\n    // Only remote derives have getters, and we do not generate\n    // deserialize_in_place for remote derives.\n    assert!(!params.has_getter);\n\n    if cont.attrs.transparent()\n        || cont.attrs.type_from().is_some()\n        || cont.attrs.type_try_from().is_some()\n        || cont.attrs.identifier().is_some()\n        || cont\n            .data\n            .all_fields()\n            .all(|f| f.attrs.deserialize_with().is_some())\n    {\n        return None;\n    }\n\n    let code = match cont.data {\n        Data::Struct(Style::Struct, ref fields) =\u003e {\n            if let Some(code) = deserialize_struct_in_place(None, params, fields, \u0026cont.attrs, None)\n            {\n                code\n            } else {\n                return None;\n            }\n        }\n        Data::Struct(Style::Tuple, ref fields) | Data::Struct(Style::Newtype, ref fields) =\u003e {\n            deserialize_tuple_in_place(None, params, fields, \u0026cont.attrs, None)\n        }\n        Data::Enum(_) | Data::Struct(Style::Unit, _) =\u003e {\n            return None;\n        }\n    };\n\n    let delife = params.borrowed.de_lifetime();\n    let stmts = Stmts(code);\n\n    let fn_deserialize_in_place = quote_block! {\n        fn deserialize_in_place\u003c__D\u003e(__deserializer: __D, __place: \u0026mut Self) -\u003e _serde::export::Result\u003c(), __D::Error\u003e\n        where\n            __D: _serde::Deserializer\u003c#delife\u003e,\n        {\n            #stmts\n        }\n    };\n\n    Some(Stmts(fn_deserialize_in_place))\n}\n\n#[cfg(not(feature = \"deserialize_in_place\"))]\nfn deserialize_in_place_body(_cont: \u0026Container, _params: \u0026Parameters) -\u003e Option\u003cStmts\u003e {\n    None\n}\n\nfn deserialize_transparent(cont: \u0026Container, params: \u0026Parameters) -\u003e Fragment {\n    let fields = match cont.data {\n        Data::Struct(_, ref fields) =\u003e fields,\n        Data::Enum(_) =\u003e unreachable!(),\n    };\n\n    let this = \u0026params.this;\n    let transparent_field = fields.iter().find(|f| f.attrs.transparent()).unwrap();\n\n    let path = match transparent_field.attrs.deserialize_with() {\n        Some(path) =\u003e quote!(#path),\n        None =\u003e {\n            let span = transparent_field.original.span();\n            quote_spanned!(span=\u003e _serde::Deserialize::deserialize)\n        }\n    };\n\n    let assign = fields.iter().map(|field| {\n        let member = \u0026field.member;\n        if field as *const Field == transparent_field as *const Field {\n            quote!(#member: __transparent)\n        } else {\n            let value = match *field.attrs.default() {\n                attr::Default::Default =\u003e quote!(_serde::export::Default::default()),\n                attr::Default::Path(ref path) =\u003e quote!(#path()),\n                attr::Default::None =\u003e quote!(_serde::export::PhantomData),\n            };\n            quote!(#member: #value)\n        }\n    });\n\n    quote_block! {\n        _serde::export::Result::map(\n            #path(__deserializer),\n            |__transparent| #this { #(#assign),* })\n    }\n}\n\nfn deserialize_from(type_from: \u0026syn::Type) -\u003e Fragment {\n    quote_block! {\n        _serde::export::Result::map(\n            \u003c#type_from as _serde::Deserialize\u003e::deserialize(__deserializer),\n            _serde::export::From::from)\n    }\n}\n\nfn deserialize_try_from(type_try_from: \u0026syn::Type) -\u003e Fragment {\n    quote_block! {\n        _serde::export::Result::and_then(\n            \u003c#type_try_from as _serde::Deserialize\u003e::deserialize(__deserializer),\n            |v| _serde::export::TryFrom::try_from(v).map_err(_serde::de::Error::custom))\n    }\n}\n\nfn deserialize_unit_struct(params: \u0026Parameters, cattrs: \u0026attr::Container) -\u003e Fragment {\n    let this = \u0026params.this;\n    let type_name = cattrs.name().deserialize_name();\n\n    let expecting = format!(\"unit struct {}\", params.type_name());\n\n    quote_block! {\n        struct __Visitor;\n\n        impl\u003c'de\u003e _serde::de::Visitor\u003c'de\u003e for __Visitor {\n            type Value = #this;\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #[inline]\n            fn visit_unit\u003c__E\u003e(self) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(#this)\n            }\n        }\n\n        _serde::Deserializer::deserialize_unit_struct(__deserializer, #type_name, __Visitor)\n    }\n}\n\nfn deserialize_tuple(\n    variant_ident: Option\u003c\u0026syn::Ident\u003e,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n    deserializer: Option\u003cTokenStream\u003e,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    assert!(!cattrs.has_flatten());\n\n    // If there are getters (implying private fields), construct the local type\n    // and use an `Into` conversion to get the remote type. If there are no\n    // getters then construct the target type directly.\n    let construct = if params.has_getter {\n        let local = \u0026params.local;\n        quote!(#local)\n    } else {\n        quote!(#this)\n    };\n\n    let is_enum = variant_ident.is_some();\n    let type_path = match variant_ident {\n        Some(ref variant_ident) =\u003e quote!(#construct::#variant_ident),\n        None =\u003e construct,\n    };\n    let expecting = match variant_ident {\n        Some(variant_ident) =\u003e format!(\"tuple variant {}::{}\", params.type_name(), variant_ident),\n        None =\u003e format!(\"tuple struct {}\", params.type_name()),\n    };\n\n    let nfields = fields.len();\n\n    let visit_newtype_struct = if !is_enum \u0026\u0026 nfields == 1 {\n        Some(deserialize_newtype_struct(\u0026type_path, params, \u0026fields[0]))\n    } else {\n        None\n    };\n\n    let visit_seq = Stmts(deserialize_seq(\n        \u0026type_path, params, fields, false, cattrs, \u0026expecting,\n    ));\n\n    let visitor_expr = quote! {\n        __Visitor {\n            marker: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData,\n        }\n    };\n    let dispatch = if let Some(deserializer) = deserializer {\n        quote!(_serde::Deserializer::deserialize_tuple(#deserializer, #nfields, #visitor_expr))\n    } else if is_enum {\n        quote!(_serde::de::VariantAccess::tuple_variant(__variant, #nfields, #visitor_expr))\n    } else if nfields == 1 {\n        let type_name = cattrs.name().deserialize_name();\n        quote!(_serde::Deserializer::deserialize_newtype_struct(__deserializer, #type_name, #visitor_expr))\n    } else {\n        let type_name = cattrs.name().deserialize_name();\n        quote!(_serde::Deserializer::deserialize_tuple_struct(__deserializer, #type_name, #nfields, #visitor_expr))\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let visitor_var = if all_skipped {\n        quote!(_)\n    } else {\n        quote!(mut __seq)\n    };\n\n    quote_block! {\n        struct __Visitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor\u003c#delife\u003e for __Visitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #visit_newtype_struct\n\n            #[inline]\n            fn visit_seq\u003c__A\u003e(self, #visitor_var: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::SeqAccess\u003c#delife\u003e,\n            {\n                #visit_seq\n            }\n        }\n\n        #dispatch\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_tuple_in_place(\n    variant_ident: Option\u003csyn::Ident\u003e,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n    deserializer: Option\u003cTokenStream\u003e,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    assert!(!cattrs.has_flatten());\n\n    let is_enum = variant_ident.is_some();\n    let expecting = match variant_ident {\n        Some(variant_ident) =\u003e format!(\"tuple variant {}::{}\", params.type_name(), variant_ident),\n        None =\u003e format!(\"tuple struct {}\", params.type_name()),\n    };\n\n    let nfields = fields.len();\n\n    let visit_newtype_struct = if !is_enum \u0026\u0026 nfields == 1 {\n        Some(deserialize_newtype_struct_in_place(params, \u0026fields[0]))\n    } else {\n        None\n    };\n\n    let visit_seq = Stmts(deserialize_seq_in_place(params, fields, cattrs, \u0026expecting));\n\n    let visitor_expr = quote! {\n        __Visitor {\n            place: __place,\n            lifetime: _serde::export::PhantomData,\n        }\n    };\n\n    let dispatch = if let Some(deserializer) = deserializer {\n        quote!(_serde::Deserializer::deserialize_tuple(#deserializer, #nfields, #visitor_expr))\n    } else if is_enum {\n        quote!(_serde::de::VariantAccess::tuple_variant(__variant, #nfields, #visitor_expr))\n    } else if nfields == 1 {\n        let type_name = cattrs.name().deserialize_name();\n        quote!(_serde::Deserializer::deserialize_newtype_struct(__deserializer, #type_name, #visitor_expr))\n    } else {\n        let type_name = cattrs.name().deserialize_name();\n        quote!(_serde::Deserializer::deserialize_tuple_struct(__deserializer, #type_name, #nfields, #visitor_expr))\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let visitor_var = if all_skipped {\n        quote!(_)\n    } else {\n        quote!(mut __seq)\n    };\n\n    let in_place_impl_generics = de_impl_generics.in_place();\n    let in_place_ty_generics = de_ty_generics.in_place();\n    let place_life = place_lifetime();\n\n    quote_block! {\n        struct __Visitor #in_place_impl_generics #where_clause {\n            place: \u0026#place_life mut #this #ty_generics,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #in_place_impl_generics _serde::de::Visitor\u003c#delife\u003e for __Visitor #in_place_ty_generics #where_clause {\n            type Value = ();\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #visit_newtype_struct\n\n            #[inline]\n            fn visit_seq\u003c__A\u003e(self, #visitor_var: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::SeqAccess\u003c#delife\u003e,\n            {\n                #visit_seq\n            }\n        }\n\n        #dispatch\n    }\n}\n\nfn deserialize_seq(\n    type_path: \u0026TokenStream,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    is_struct: bool,\n    cattrs: \u0026attr::Container,\n    expecting: \u0026str,\n) -\u003e Fragment {\n    let vars = (0..fields.len()).map(field_i as fn(_) -\u003e _);\n\n    let deserialized_count = fields\n        .iter()\n        .filter(|field| !field.attrs.skip_deserializing())\n        .count();\n    let expecting = if deserialized_count == 1 {\n        format!(\"{} with 1 element\", expecting)\n    } else {\n        format!(\"{} with {} elements\", expecting, deserialized_count)\n    };\n\n    let mut index_in_seq = 0_usize;\n    let let_values = vars.clone().zip(fields).map(|(var, field)| {\n        if field.attrs.skip_deserializing() {\n            let default = Expr(expr_is_missing(field, cattrs));\n            quote! {\n                let #var = #default;\n            }\n        } else {\n            let visit = match field.attrs.deserialize_with() {\n                None =\u003e {\n                    let field_ty = field.ty;\n                    let span = field.original.span();\n                    let func =\n                        quote_spanned!(span=\u003e _serde::de::SeqAccess::next_element::\u003c#field_ty\u003e);\n                    quote!(try!(#func(\u0026mut __seq)))\n                }\n                Some(path) =\u003e {\n                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n                    quote!({\n                        #wrapper\n                        _serde::export::Option::map(\n                            try!(_serde::de::SeqAccess::next_element::\u003c#wrapper_ty\u003e(\u0026mut __seq)),\n                            |__wrap| __wrap.value)\n                    })\n                }\n            };\n            let value_if_none = match *field.attrs.default() {\n                attr::Default::Default =\u003e quote!(_serde::export::Default::default()),\n                attr::Default::Path(ref path) =\u003e quote!(#path()),\n                attr::Default::None =\u003e quote!(\n                    return _serde::export::Err(_serde::de::Error::invalid_length(#index_in_seq, \u0026#expecting));\n                ),\n            };\n            let assign = quote! {\n                let #var = match #visit {\n                    _serde::export::Some(__value) =\u003e __value,\n                    _serde::export::None =\u003e {\n                        #value_if_none\n                    }\n                };\n            };\n            index_in_seq += 1;\n            assign\n        }\n    });\n\n    let mut result = if is_struct {\n        let names = fields.iter().map(|f| \u0026f.member);\n        quote! {\n            #type_path { #( #names: #vars ),* }\n        }\n    } else {\n        quote! {\n            #type_path ( #(#vars),* )\n        }\n    };\n\n    if params.has_getter {\n        let this = \u0026params.this;\n        result = quote! {\n            _serde::export::Into::\u003c#this\u003e::into(#result)\n        };\n    }\n\n    let let_default = match *cattrs.default() {\n        attr::Default::Default =\u003e Some(quote!(\n            let __default: Self::Value = _serde::export::Default::default();\n        )),\n        attr::Default::Path(ref path) =\u003e Some(quote!(\n            let __default: Self::Value = #path();\n        )),\n        attr::Default::None =\u003e {\n            // We don't need the default value, to prevent an unused variable warning\n            // we'll leave the line empty.\n            None\n        }\n    };\n\n    quote_block! {\n        #let_default\n        #(#let_values)*\n        _serde::export::Ok(#result)\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_seq_in_place(\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n    expecting: \u0026str,\n) -\u003e Fragment {\n    let deserialized_count = fields\n        .iter()\n        .filter(|field| !field.attrs.skip_deserializing())\n        .count();\n    let expecting = if deserialized_count == 1 {\n        format!(\"{} with 1 element\", expecting)\n    } else {\n        format!(\"{} with {} elements\", expecting, deserialized_count)\n    };\n\n    let mut index_in_seq = 0usize;\n    let write_values = fields.iter().map(|field| {\n        let member = \u0026field.member;\n\n        if field.attrs.skip_deserializing() {\n            let default = Expr(expr_is_missing(field, cattrs));\n            quote! {\n                self.place.#member = #default;\n            }\n        } else {\n            let value_if_none = match *field.attrs.default() {\n                attr::Default::Default =\u003e quote!(\n                    self.place.#member = _serde::export::Default::default();\n                ),\n                attr::Default::Path(ref path) =\u003e quote!(\n                    self.place.#member = #path();\n                ),\n                attr::Default::None =\u003e quote!(\n                    return _serde::export::Err(_serde::de::Error::invalid_length(#index_in_seq, \u0026#expecting));\n                ),\n            };\n            let write = match field.attrs.deserialize_with() {\n                None =\u003e {\n                    quote! {\n                        if let _serde::export::None = try!(_serde::de::SeqAccess::next_element_seed(\u0026mut __seq,\n                            _serde::private::de::InPlaceSeed(\u0026mut self.place.#member)))\n                        {\n                            #value_if_none\n                        }\n                    }\n                }\n                Some(path) =\u003e {\n                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n                    quote!({\n                        #wrapper\n                        match try!(_serde::de::SeqAccess::next_element::\u003c#wrapper_ty\u003e(\u0026mut __seq)) {\n                            _serde::export::Some(__wrap) =\u003e {\n                                self.place.#member = __wrap.value;\n                            }\n                            _serde::export::None =\u003e {\n                                #value_if_none\n                            }\n                        }\n                    })\n                }\n            };\n            index_in_seq += 1;\n            write\n        }\n    });\n\n    let this = \u0026params.this;\n    let (_, ty_generics, _) = params.generics.split_for_impl();\n    let let_default = match *cattrs.default() {\n        attr::Default::Default =\u003e Some(quote!(\n            let __default: #this #ty_generics  = _serde::export::Default::default();\n        )),\n        attr::Default::Path(ref path) =\u003e Some(quote!(\n            let __default: #this #ty_generics  = #path();\n        )),\n        attr::Default::None =\u003e {\n            // We don't need the default value, to prevent an unused variable warning\n            // we'll leave the line empty.\n            None\n        }\n    };\n\n    quote_block! {\n        #let_default\n        #(#write_values)*\n        _serde::export::Ok(())\n    }\n}\n\nfn deserialize_newtype_struct(\n    type_path: \u0026TokenStream,\n    params: \u0026Parameters,\n    field: \u0026Field,\n) -\u003e TokenStream {\n    let delife = params.borrowed.de_lifetime();\n    let field_ty = field.ty;\n\n    let value = match field.attrs.deserialize_with() {\n        None =\u003e {\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e \u003c#field_ty as _serde::Deserialize\u003e::deserialize);\n            quote! {\n                try!(#func(__e))\n            }\n        }\n        Some(path) =\u003e {\n            quote! {\n                try!(#path(__e))\n            }\n        }\n    };\n\n    let mut result = quote!(#type_path(__field0));\n    if params.has_getter {\n        let this = \u0026params.this;\n        result = quote! {\n            _serde::export::Into::\u003c#this\u003e::into(#result)\n        };\n    }\n\n    quote! {\n        #[inline]\n        fn visit_newtype_struct\u003c__E\u003e(self, __e: __E) -\u003e _serde::export::Result\u003cSelf::Value, __E::Error\u003e\n        where\n            __E: _serde::Deserializer\u003c#delife\u003e,\n        {\n            let __field0: #field_ty = #value;\n            _serde::export::Ok(#result)\n        }\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_newtype_struct_in_place(params: \u0026Parameters, field: \u0026Field) -\u003e TokenStream {\n    // We do not generate deserialize_in_place if every field has a\n    // deserialize_with.\n    assert!(field.attrs.deserialize_with().is_none());\n\n    let delife = params.borrowed.de_lifetime();\n\n    quote! {\n        #[inline]\n        fn visit_newtype_struct\u003c__E\u003e(self, __e: __E) -\u003e _serde::export::Result\u003cSelf::Value, __E::Error\u003e\n        where\n            __E: _serde::Deserializer\u003c#delife\u003e,\n        {\n            _serde::Deserialize::deserialize_in_place(__e, \u0026mut self.place.0)\n        }\n    }\n}\n\nenum Untagged {\n    Yes,\n    No,\n}\n\nfn deserialize_struct(\n    variant_ident: Option\u003c\u0026syn::Ident\u003e,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n    deserializer: Option\u003cTokenStream\u003e,\n    untagged: \u0026Untagged,\n) -\u003e Fragment {\n    let is_enum = variant_ident.is_some();\n\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    // If there are getters (implying private fields), construct the local type\n    // and use an `Into` conversion to get the remote type. If there are no\n    // getters then construct the target type directly.\n    let construct = if params.has_getter {\n        let local = \u0026params.local;\n        quote!(#local)\n    } else {\n        quote!(#this)\n    };\n\n    let type_path = match variant_ident {\n        Some(ref variant_ident) =\u003e quote!(#construct::#variant_ident),\n        None =\u003e construct,\n    };\n    let expecting = match variant_ident {\n        Some(variant_ident) =\u003e format!(\"struct variant {}::{}\", params.type_name(), variant_ident),\n        None =\u003e format!(\"struct {}\", params.type_name()),\n    };\n\n    let visit_seq = Stmts(deserialize_seq(\n        \u0026type_path, params, fields, true, cattrs, \u0026expecting,\n    ));\n\n    let (field_visitor, fields_stmt, visit_map) = if cattrs.has_flatten() {\n        deserialize_struct_as_map_visitor(\u0026type_path, params, fields, cattrs)\n    } else {\n        deserialize_struct_as_struct_visitor(\u0026type_path, params, fields, cattrs)\n    };\n    let field_visitor = Stmts(field_visitor);\n    let fields_stmt = fields_stmt.map(Stmts);\n    let visit_map = Stmts(visit_map);\n\n    let visitor_expr = quote! {\n        __Visitor {\n            marker: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData,\n        }\n    };\n    let dispatch = if let Some(deserializer) = deserializer {\n        quote! {\n            _serde::Deserializer::deserialize_any(#deserializer, #visitor_expr)\n        }\n    } else if is_enum \u0026\u0026 cattrs.has_flatten() {\n        quote! {\n            _serde::de::VariantAccess::newtype_variant_seed(__variant, #visitor_expr)\n        }\n    } else if is_enum {\n        quote! {\n            _serde::de::VariantAccess::struct_variant(__variant, FIELDS, #visitor_expr)\n        }\n    } else if cattrs.has_flatten() {\n        quote! {\n            _serde::Deserializer::deserialize_map(__deserializer, #visitor_expr)\n        }\n    } else {\n        let type_name = cattrs.name().deserialize_name();\n        quote! {\n            _serde::Deserializer::deserialize_struct(__deserializer, #type_name, FIELDS, #visitor_expr)\n        }\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let visitor_var = if all_skipped {\n        quote!(_)\n    } else {\n        quote!(mut __seq)\n    };\n\n    // untagged struct variants do not get a visit_seq method. The same applies to\n    // structs that only have a map representation.\n    let visit_seq = match *untagged {\n        Untagged::No if !cattrs.has_flatten() =\u003e Some(quote! {\n            #[inline]\n            fn visit_seq\u003c__A\u003e(self, #visitor_var: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::SeqAccess\u003c#delife\u003e,\n            {\n                #visit_seq\n            }\n        }),\n        _ =\u003e None,\n    };\n\n    let visitor_seed = if is_enum \u0026\u0026 cattrs.has_flatten() {\n        Some(quote! {\n            impl #de_impl_generics _serde::de::DeserializeSeed\u003c#delife\u003e for __Visitor #de_ty_generics #where_clause {\n                type Value = #this #ty_generics;\n\n                fn deserialize\u003c__D\u003e(self, __deserializer: __D) -\u003e _serde::export::Result\u003cSelf::Value, __D::Error\u003e\n                where\n                    __D: _serde::Deserializer\u003c'de\u003e,\n                {\n                    _serde::Deserializer::deserialize_map(__deserializer, self)\n                }\n            }\n        })\n    } else {\n        None\n    };\n\n    quote_block! {\n        #field_visitor\n\n        struct __Visitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor\u003c#delife\u003e for __Visitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #visit_seq\n\n            #[inline]\n            fn visit_map\u003c__A\u003e(self, mut __map: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::MapAccess\u003c#delife\u003e,\n            {\n                #visit_map\n            }\n        }\n\n        #visitor_seed\n\n        #fields_stmt\n\n        #dispatch\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_struct_in_place(\n    variant_ident: Option\u003csyn::Ident\u003e,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n    deserializer: Option\u003cTokenStream\u003e,\n) -\u003e Option\u003cFragment\u003e {\n    let is_enum = variant_ident.is_some();\n\n    // for now we do not support in_place deserialization for structs that\n    // are represented as map.\n    if cattrs.has_flatten() {\n        return None;\n    }\n\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    let expecting = match variant_ident {\n        Some(variant_ident) =\u003e format!(\"struct variant {}::{}\", params.type_name(), variant_ident),\n        None =\u003e format!(\"struct {}\", params.type_name()),\n    };\n\n    let visit_seq = Stmts(deserialize_seq_in_place(params, fields, cattrs, \u0026expecting));\n\n    let (field_visitor, fields_stmt, visit_map) =\n        deserialize_struct_as_struct_in_place_visitor(params, fields, cattrs);\n\n    let field_visitor = Stmts(field_visitor);\n    let fields_stmt = Stmts(fields_stmt);\n    let visit_map = Stmts(visit_map);\n\n    let visitor_expr = quote! {\n        __Visitor {\n            place: __place,\n            lifetime: _serde::export::PhantomData,\n        }\n    };\n    let dispatch = if let Some(deserializer) = deserializer {\n        quote! {\n            _serde::Deserializer::deserialize_any(#deserializer, #visitor_expr)\n        }\n    } else if is_enum {\n        quote! {\n            _serde::de::VariantAccess::struct_variant(__variant, FIELDS, #visitor_expr)\n        }\n    } else {\n        let type_name = cattrs.name().deserialize_name();\n        quote! {\n            _serde::Deserializer::deserialize_struct(__deserializer, #type_name, FIELDS, #visitor_expr)\n        }\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let visitor_var = if all_skipped {\n        quote!(_)\n    } else {\n        quote!(mut __seq)\n    };\n\n    let visit_seq = quote! {\n        #[inline]\n        fn visit_seq\u003c__A\u003e(self, #visitor_var: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n        where\n            __A: _serde::de::SeqAccess\u003c#delife\u003e,\n        {\n            #visit_seq\n        }\n    };\n\n    let in_place_impl_generics = de_impl_generics.in_place();\n    let in_place_ty_generics = de_ty_generics.in_place();\n    let place_life = place_lifetime();\n\n    Some(quote_block! {\n        #field_visitor\n\n        struct __Visitor #in_place_impl_generics #where_clause {\n            place: \u0026#place_life mut #this #ty_generics,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #in_place_impl_generics _serde::de::Visitor\u003c#delife\u003e for __Visitor #in_place_ty_generics #where_clause {\n            type Value = ();\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            #visit_seq\n\n            #[inline]\n            fn visit_map\u003c__A\u003e(self, mut __map: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::MapAccess\u003c#delife\u003e,\n            {\n                #visit_map\n            }\n        }\n\n        #fields_stmt\n\n        #dispatch\n    })\n}\n\nfn deserialize_enum(\n    params: \u0026Parameters,\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    match *cattrs.tag() {\n        attr::TagType::External =\u003e deserialize_externally_tagged_enum(params, variants, cattrs),\n        attr::TagType::Internal { ref tag } =\u003e {\n            deserialize_internally_tagged_enum(params, variants, cattrs, tag)\n        }\n        attr::TagType::Adjacent {\n            ref tag,\n            ref content,\n        } =\u003e deserialize_adjacently_tagged_enum(params, variants, cattrs, tag, content),\n        attr::TagType::None =\u003e deserialize_untagged_enum(params, variants, cattrs),\n    }\n}\n\nfn prepare_enum_variant_enum(\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n) -\u003e (TokenStream, Stmts) {\n    let variant_names_idents: Vec\u003c_\u003e = variants\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, variant)| !variant.attrs.skip_deserializing())\n        .map(|(i, variant)| {\n            (\n                variant.attrs.name().deserialize_name(),\n                field_i(i),\n                variant.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let other_idx = variants\n        .iter()\n        .position(|ref variant| variant.attrs.other());\n\n    let variants_stmt = {\n        let variant_names = variant_names_idents.iter().map(|\u0026(ref name, _, _)| name);\n        quote! {\n            const VARIANTS: \u0026'static [\u0026'static str] = \u0026[ #(#variant_names),* ];\n        }\n    };\n\n    let variant_visitor = Stmts(deserialize_generated_identifier(\n        \u0026variant_names_idents,\n        cattrs,\n        true,\n        other_idx,\n    ));\n\n    (variants_stmt, variant_visitor)\n}\n\nfn deserialize_externally_tagged_enum(\n    params: \u0026Parameters,\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    let type_name = cattrs.name().deserialize_name();\n    let expecting = format!(\"enum {}\", params.type_name());\n\n    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n\n    // Match arms to extract a variant from a string\n    let variant_arms = variants\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, variant)| !variant.attrs.skip_deserializing())\n        .map(|(i, variant)| {\n            let variant_name = field_i(i);\n\n            let block = Match(deserialize_externally_tagged_variant(\n                params, variant, cattrs,\n            ));\n\n            quote! {\n                (__Field::#variant_name, __variant) =\u003e #block\n            }\n        });\n\n    let all_skipped = variants\n        .iter()\n        .all(|variant| variant.attrs.skip_deserializing());\n    let match_variant = if all_skipped {\n        // This is an empty enum like `enum Impossible {}` or an enum in which\n        // all variants have `#[serde(skip_deserializing)]`.\n        quote! {\n            // FIXME: Once we drop support for Rust 1.15:\n            // let _serde::export::Err(__err) = _serde::de::EnumAccess::variant::\u003c__Field\u003e(__data);\n            // _serde::export::Err(__err)\n            _serde::export::Result::map(\n                _serde::de::EnumAccess::variant::\u003c__Field\u003e(__data),\n                |(__impossible, _)| match __impossible {})\n        }\n    } else {\n        quote! {\n            match try!(_serde::de::EnumAccess::variant(__data)) {\n                #(#variant_arms)*\n            }\n        }\n    };\n\n    quote_block! {\n        #variant_visitor\n\n        struct __Visitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor\u003c#delife\u003e for __Visitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            fn visit_enum\u003c__A\u003e(self, __data: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::EnumAccess\u003c#delife\u003e,\n            {\n                #match_variant\n            }\n        }\n\n        #variants_stmt\n\n        _serde::Deserializer::deserialize_enum(\n            __deserializer,\n            #type_name,\n            VARIANTS,\n            __Visitor {\n                marker: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n                lifetime: _serde::export::PhantomData,\n            },\n        )\n    }\n}\n\nfn deserialize_internally_tagged_enum(\n    params: \u0026Parameters,\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n    tag: \u0026str,\n) -\u003e Fragment {\n    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n\n    // Match arms to extract a variant from a string\n    let variant_arms = variants\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, variant)| !variant.attrs.skip_deserializing())\n        .map(|(i, variant)| {\n            let variant_name = field_i(i);\n\n            let block = Match(deserialize_internally_tagged_variant(\n                params,\n                variant,\n                cattrs,\n                quote! {\n                    _serde::private::de::ContentDeserializer::\u003c__D::Error\u003e::new(__tagged.content)\n                },\n            ));\n\n            quote! {\n                __Field::#variant_name =\u003e #block\n            }\n        });\n\n    quote_block! {\n        #variant_visitor\n\n        #variants_stmt\n\n        let __tagged = try!(_serde::Deserializer::deserialize_any(\n            __deserializer,\n            _serde::private::de::TaggedContentVisitor::\u003c__Field\u003e::new(#tag)));\n\n        match __tagged.tag {\n            #(#variant_arms)*\n        }\n    }\n}\n\nfn deserialize_adjacently_tagged_enum(\n    params: \u0026Parameters,\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n    tag: \u0026str,\n    content: \u0026str,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n\n    let variant_arms: \u0026Vec\u003c_\u003e = \u0026variants\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, variant)| !variant.attrs.skip_deserializing())\n        .map(|(i, variant)| {\n            let variant_index = field_i(i);\n\n            let block = Match(deserialize_untagged_variant(\n                params,\n                variant,\n                cattrs,\n                quote!(__deserializer),\n            ));\n\n            quote! {\n                __Field::#variant_index =\u003e #block\n            }\n        })\n        .collect();\n\n    let expecting = format!(\"adjacently tagged enum {}\", params.type_name());\n    let type_name = cattrs.name().deserialize_name();\n    let deny_unknown_fields = cattrs.deny_unknown_fields();\n\n    // If unknown fields are allowed, we pick the visitor that can step over\n    // those. Otherwise we pick the visitor that fails on unknown keys.\n    let field_visitor_ty = if deny_unknown_fields {\n        quote! { _serde::private::de::TagOrContentFieldVisitor }\n    } else {\n        quote! { _serde::private::de::TagContentOtherFieldVisitor }\n    };\n\n    let tag_or_content = quote! {\n        #field_visitor_ty {\n            tag: #tag,\n            content: #content,\n        }\n    };\n\n    fn is_unit(variant: \u0026Variant) -\u003e bool {\n        match variant.style {\n            Style::Unit =\u003e true,\n            Style::Struct | Style::Tuple | Style::Newtype =\u003e false,\n        }\n    }\n\n    let mut missing_content = quote! {\n        _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::missing_field(#content))\n    };\n    if variants.iter().any(is_unit) {\n        let fallthrough = if variants.iter().all(is_unit) {\n            None\n        } else {\n            Some(quote! {\n                _ =\u003e #missing_content\n            })\n        };\n        let arms = variants\n            .iter()\n            .enumerate()\n            .filter(|\u0026(_, variant)| !variant.attrs.skip_deserializing() \u0026\u0026 is_unit(variant))\n            .map(|(i, variant)| {\n                let variant_index = field_i(i);\n                let variant_ident = \u0026variant.ident;\n                quote! {\n                    __Field::#variant_index =\u003e _serde::export::Ok(#this::#variant_ident),\n                }\n            });\n        missing_content = quote! {\n            match __field {\n                #(#arms)*\n                #fallthrough\n            }\n        };\n    }\n\n    // Advance the map by one key, returning early in case of error.\n    let next_key = quote! {\n        try!(_serde::de::MapAccess::next_key_seed(\u0026mut __map, #tag_or_content))\n    };\n\n    // When allowing unknown fields, we want to transparently step through keys\n    // we don't care about until we find `tag`, `content`, or run out of keys.\n    let next_relevant_key = if deny_unknown_fields {\n        next_key\n    } else {\n        quote!({\n            let mut __rk : _serde::export::Option\u003c_serde::private::de::TagOrContentField\u003e = _serde::export::None;\n            while let _serde::export::Some(__k) = #next_key {\n                match __k {\n                    _serde::private::de::TagContentOtherField::Other =\u003e {\n                        try!(_serde::de::MapAccess::next_value::\u003c_serde::de::IgnoredAny\u003e(\u0026mut __map));\n                        continue;\n                    },\n                    _serde::private::de::TagContentOtherField::Tag =\u003e {\n                        __rk = _serde::export::Some(_serde::private::de::TagOrContentField::Tag);\n                        break;\n                    }\n                    _serde::private::de::TagContentOtherField::Content =\u003e {\n                        __rk = _serde::export::Some(_serde::private::de::TagOrContentField::Content);\n                        break;\n                    }\n                }\n            }\n\n            __rk\n        })\n    };\n\n    // Step through remaining keys, looking for duplicates of previously-seen\n    // keys. When unknown fields are denied, any key that isn't a duplicate will\n    // at this point immediately produce an error.\n    let visit_remaining_keys = quote! {\n        match #next_relevant_key {\n            _serde::export::Some(_serde::private::de::TagOrContentField::Tag) =\u003e {\n                _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::duplicate_field(#tag))\n            }\n            _serde::export::Some(_serde::private::de::TagOrContentField::Content) =\u003e {\n                _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::duplicate_field(#content))\n            }\n            _serde::export::None =\u003e _serde::export::Ok(__ret),\n        }\n    };\n\n    let finish_content_then_tag = if variant_arms.is_empty() {\n        quote! {\n            match try!(_serde::de::MapAccess::next_value::\u003c__Field\u003e(\u0026mut __map)) {}\n        }\n    } else {\n        quote! {\n            let __ret = try!(match try!(_serde::de::MapAccess::next_value(\u0026mut __map)) {\n                // Deserialize the buffered content now that we know the variant.\n                #(#variant_arms)*\n            });\n            // Visit remaining keys, looking for duplicates.\n            #visit_remaining_keys\n        }\n    };\n\n    quote_block! {\n        #variant_visitor\n\n        #variants_stmt\n\n        struct __Seed #de_impl_generics #where_clause {\n            field: __Field,\n            marker: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::de::DeserializeSeed\u003c#delife\u003e for __Seed #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn deserialize\u003c__D\u003e(self, __deserializer: __D) -\u003e _serde::export::Result\u003cSelf::Value, __D::Error\u003e\n            where\n                __D: _serde::Deserializer\u003c#delife\u003e,\n            {\n                match self.field {\n                    #(#variant_arms)*\n                }\n            }\n        }\n\n        struct __Visitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor\u003c#delife\u003e for __Visitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n                _serde::export::Formatter::write_str(__formatter, #expecting)\n            }\n\n            fn visit_map\u003c__A\u003e(self, mut __map: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::MapAccess\u003c#delife\u003e,\n            {\n                // Visit the first relevant key.\n                match #next_relevant_key {\n                    // First key is the tag.\n                    _serde::export::Some(_serde::private::de::TagOrContentField::Tag) =\u003e {\n                        // Parse the tag.\n                        let __field = try!(_serde::de::MapAccess::next_value(\u0026mut __map));\n                        // Visit the second key.\n                        match #next_relevant_key {\n                            // Second key is a duplicate of the tag.\n                            _serde::export::Some(_serde::private::de::TagOrContentField::Tag) =\u003e {\n                                _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::duplicate_field(#tag))\n                            }\n                            // Second key is the content.\n                            _serde::export::Some(_serde::private::de::TagOrContentField::Content) =\u003e {\n                                let __ret = try!(_serde::de::MapAccess::next_value_seed(\u0026mut __map,\n                                    __Seed {\n                                        field: __field,\n                                        marker: _serde::export::PhantomData,\n                                        lifetime: _serde::export::PhantomData,\n                                    }));\n                                // Visit remaining keys, looking for duplicates.\n                                #visit_remaining_keys\n                            }\n                            // There is no second key; might be okay if the we have a unit variant.\n                            _serde::export::None =\u003e #missing_content\n                        }\n                    }\n                    // First key is the content.\n                    _serde::export::Some(_serde::private::de::TagOrContentField::Content) =\u003e {\n                        // Buffer up the content.\n                        let __content = try!(_serde::de::MapAccess::next_value::\u003c_serde::private::de::Content\u003e(\u0026mut __map));\n                        // Visit the second key.\n                        match #next_relevant_key {\n                            // Second key is the tag.\n                            _serde::export::Some(_serde::private::de::TagOrContentField::Tag) =\u003e {\n                                let __deserializer = _serde::private::de::ContentDeserializer::\u003c__A::Error\u003e::new(__content);\n                                #finish_content_then_tag\n                            }\n                            // Second key is a duplicate of the content.\n                            _serde::export::Some(_serde::private::de::TagOrContentField::Content) =\u003e {\n                                _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::duplicate_field(#content))\n                            }\n                            // There is no second key.\n                            _serde::export::None =\u003e {\n                                _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::missing_field(#tag))\n                            }\n                        }\n                    }\n                    // There is no first key.\n                    _serde::export::None =\u003e {\n                        _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::missing_field(#tag))\n                    }\n                }\n            }\n\n            fn visit_seq\u003c__A\u003e(self, mut __seq: __A) -\u003e _serde::export::Result\u003cSelf::Value, __A::Error\u003e\n            where\n                __A: _serde::de::SeqAccess\u003c#delife\u003e,\n            {\n                // Visit the first element - the tag.\n                match try!(_serde::de::SeqAccess::next_element(\u0026mut __seq)) {\n                    _serde::export::Some(__field) =\u003e {\n                        // Visit the second element - the content.\n                        match try!(_serde::de::SeqAccess::next_element_seed(\n                            \u0026mut __seq,\n                            __Seed {\n                                field: __field,\n                                marker: _serde::export::PhantomData,\n                                lifetime: _serde::export::PhantomData,\n                            },\n                        )) {\n                            _serde::export::Some(__ret) =\u003e _serde::export::Ok(__ret),\n                            // There is no second element.\n                            _serde::export::None =\u003e {\n                                _serde::export::Err(_serde::de::Error::invalid_length(1, \u0026self))\n                            }\n                        }\n                    }\n                    // There is no first element.\n                    _serde::export::None =\u003e {\n                        _serde::export::Err(_serde::de::Error::invalid_length(0, \u0026self))\n                    }\n                }\n            }\n        }\n\n        const FIELDS: \u0026'static [\u0026'static str] = \u0026[#tag, #content];\n        _serde::Deserializer::deserialize_struct(\n            __deserializer,\n            #type_name,\n            FIELDS,\n            __Visitor {\n                marker: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n                lifetime: _serde::export::PhantomData,\n            },\n        )\n    }\n}\n\nfn deserialize_untagged_enum(\n    params: \u0026Parameters,\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let attempts = variants\n        .iter()\n        .filter(|variant| !variant.attrs.skip_deserializing())\n        .map(|variant| {\n            Expr(deserialize_untagged_variant(\n                params,\n                variant,\n                cattrs,\n                quote!(_serde::private::de::ContentRefDeserializer::\u003c__D::Error\u003e::new(\u0026__content)),\n            ))\n        });\n\n    // TODO this message could be better by saving the errors from the failed\n    // attempts. The heuristic used by TOML was to count the number of fields\n    // processed before an error, and use the error that happened after the\n    // largest number of fields. I'm not sure I like that. Maybe it would be\n    // better to save all the errors and combine them into one message that\n    // explains why none of the variants matched.\n    let fallthrough_msg = format!(\n        \"data did not match any variant of untagged enum {}\",\n        params.type_name()\n    );\n\n    quote_block! {\n        let __content = try!(\u003c_serde::private::de::Content as _serde::Deserialize\u003e::deserialize(__deserializer));\n\n        #(\n            if let _serde::export::Ok(__ok) = #attempts {\n                return _serde::export::Ok(__ok);\n            }\n        )*\n\n        _serde::export::Err(_serde::de::Error::custom(#fallthrough_msg))\n    }\n}\n\nfn deserialize_externally_tagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    if let Some(path) = variant.attrs.deserialize_with() {\n        let (wrapper, wrapper_ty, unwrap_fn) = wrap_deserialize_variant_with(params, variant, path);\n        return quote_block! {\n            #wrapper\n            _serde::export::Result::map(\n                _serde::de::VariantAccess::newtype_variant::\u003c#wrapper_ty\u003e(__variant), #unwrap_fn)\n        };\n    }\n\n    let variant_ident = \u0026variant.ident;\n\n    match variant.style {\n        Style::Unit =\u003e {\n            let this = \u0026params.this;\n            quote_block! {\n                try!(_serde::de::VariantAccess::unit_variant(__variant));\n                _serde::export::Ok(#this::#variant_ident)\n            }\n        }\n        Style::Newtype =\u003e {\n            deserialize_externally_tagged_newtype_variant(variant_ident, params, \u0026variant.fields[0])\n        }\n        Style::Tuple =\u003e {\n            deserialize_tuple(Some(variant_ident), params, \u0026variant.fields, cattrs, None)\n        }\n        Style::Struct =\u003e deserialize_struct(\n            Some(variant_ident),\n            params,\n            \u0026variant.fields,\n            cattrs,\n            None,\n            \u0026Untagged::No,\n        ),\n    }\n}\n\nfn deserialize_internally_tagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    cattrs: \u0026attr::Container,\n    deserializer: TokenStream,\n) -\u003e Fragment {\n    if variant.attrs.deserialize_with().is_some() {\n        return deserialize_untagged_variant(params, variant, cattrs, deserializer);\n    }\n\n    let variant_ident = \u0026variant.ident;\n\n    match variant.style {\n        Style::Unit =\u003e {\n            let this = \u0026params.this;\n            let type_name = params.type_name();\n            let variant_name = variant.ident.to_string();\n            quote_block! {\n                try!(_serde::Deserializer::deserialize_any(#deserializer, _serde::private::de::InternallyTaggedUnitVisitor::new(#type_name, #variant_name)));\n                _serde::export::Ok(#this::#variant_ident)\n            }\n        }\n        Style::Newtype =\u003e deserialize_untagged_newtype_variant(\n            variant_ident,\n            params,\n            \u0026variant.fields[0],\n            \u0026deserializer,\n        ),\n        Style::Struct =\u003e deserialize_struct(\n            Some(variant_ident),\n            params,\n            \u0026variant.fields,\n            cattrs,\n            Some(deserializer),\n            \u0026Untagged::No,\n        ),\n        Style::Tuple =\u003e unreachable!(\"checked in serde_derive_internals\"),\n    }\n}\n\nfn deserialize_untagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    cattrs: \u0026attr::Container,\n    deserializer: TokenStream,\n) -\u003e Fragment {\n    if let Some(path) = variant.attrs.deserialize_with() {\n        let (wrapper, wrapper_ty, unwrap_fn) = wrap_deserialize_variant_with(params, variant, path);\n        return quote_block! {\n            #wrapper\n            _serde::export::Result::map(\n                \u003c#wrapper_ty as _serde::Deserialize\u003e::deserialize(#deserializer), #unwrap_fn)\n        };\n    }\n\n    let variant_ident = \u0026variant.ident;\n\n    match variant.style {\n        Style::Unit =\u003e {\n            let this = \u0026params.this;\n            let type_name = params.type_name();\n            let variant_name = variant.ident.to_string();\n            quote_expr! {\n                match _serde::Deserializer::deserialize_any(\n                    #deserializer,\n                    _serde::private::de::UntaggedUnitVisitor::new(#type_name, #variant_name)\n                ) {\n                    _serde::export::Ok(()) =\u003e _serde::export::Ok(#this::#variant_ident),\n                    _serde::export::Err(__err) =\u003e _serde::export::Err(__err),\n                }\n            }\n        }\n        Style::Newtype =\u003e deserialize_untagged_newtype_variant(\n            variant_ident,\n            params,\n            \u0026variant.fields[0],\n            \u0026deserializer,\n        ),\n        Style::Tuple =\u003e deserialize_tuple(\n            Some(variant_ident),\n            params,\n            \u0026variant.fields,\n            cattrs,\n            Some(deserializer),\n        ),\n        Style::Struct =\u003e deserialize_struct(\n            Some(variant_ident),\n            params,\n            \u0026variant.fields,\n            cattrs,\n            Some(deserializer),\n            \u0026Untagged::Yes,\n        ),\n    }\n}\n\nfn deserialize_externally_tagged_newtype_variant(\n    variant_ident: \u0026syn::Ident,\n    params: \u0026Parameters,\n    field: \u0026Field,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    match field.attrs.deserialize_with() {\n        None =\u003e {\n            let field_ty = field.ty;\n            let span = field.original.span();\n            let func =\n                quote_spanned!(span=\u003e _serde::de::VariantAccess::newtype_variant::\u003c#field_ty\u003e);\n            quote_expr! {\n                _serde::export::Result::map(#func(__variant), #this::#variant_ident)\n            }\n        }\n        Some(path) =\u003e {\n            let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n            quote_block! {\n                #wrapper\n                _serde::export::Result::map(\n                    _serde::de::VariantAccess::newtype_variant::\u003c#wrapper_ty\u003e(__variant),\n                    |__wrapper| #this::#variant_ident(__wrapper.value))\n            }\n        }\n    }\n}\n\nfn deserialize_untagged_newtype_variant(\n    variant_ident: \u0026syn::Ident,\n    params: \u0026Parameters,\n    field: \u0026Field,\n    deserializer: \u0026TokenStream,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    let field_ty = field.ty;\n    match field.attrs.deserialize_with() {\n        None =\u003e {\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e \u003c#field_ty as _serde::Deserialize\u003e::deserialize);\n            quote_expr! {\n                _serde::export::Result::map(#func(#deserializer), #this::#variant_ident)\n            }\n        }\n        Some(path) =\u003e {\n            quote_block! {\n                let __value: _serde::export::Result\u003c#field_ty, _\u003e = #path(#deserializer);\n                _serde::export::Result::map(__value, #this::#variant_ident)\n            }\n        }\n    }\n}\n\nfn deserialize_generated_identifier(\n    fields: \u0026[(String, Ident, Vec\u003cString\u003e)],\n    cattrs: \u0026attr::Container,\n    is_variant: bool,\n    other_idx: Option\u003cusize\u003e,\n) -\u003e Fragment {\n    let this = quote!(__Field);\n    let field_idents: \u0026Vec\u003c_\u003e = \u0026fields.iter().map(|\u0026(_, ref ident, _)| ident).collect();\n\n    let (ignore_variant, fallthrough) = if !is_variant \u0026\u0026 cattrs.has_flatten() {\n        let ignore_variant = quote!(__other(_serde::private::de::Content\u003c'de\u003e),);\n        let fallthrough = quote!(_serde::export::Ok(__Field::__other(__value)));\n        (Some(ignore_variant), Some(fallthrough))\n    } else if let Some(other_idx) = other_idx {\n        let ignore_variant = fields[other_idx].1.clone();\n        let fallthrough = quote!(_serde::export::Ok(__Field::#ignore_variant));\n        (None, Some(fallthrough))\n    } else if is_variant || cattrs.deny_unknown_fields() {\n        (None, None)\n    } else {\n        let ignore_variant = quote!(__ignore,);\n        let fallthrough = quote!(_serde::export::Ok(__Field::__ignore));\n        (Some(ignore_variant), Some(fallthrough))\n    };\n\n    let visitor_impl = Stmts(deserialize_identifier(\n        \u0026this,\n        fields,\n        is_variant,\n        fallthrough,\n        !is_variant \u0026\u0026 cattrs.has_flatten(),\n    ));\n\n    let lifetime = if !is_variant \u0026\u0026 cattrs.has_flatten() {\n        Some(quote!(\u003c'de\u003e))\n    } else {\n        None\n    };\n\n    quote_block! {\n        #[allow(non_camel_case_types)]\n        enum __Field #lifetime {\n            #(#field_idents,)*\n            #ignore_variant\n        }\n\n        struct __FieldVisitor;\n\n        impl\u003c'de\u003e _serde::de::Visitor\u003c'de\u003e for __FieldVisitor {\n            type Value = __Field #lifetime;\n\n            #visitor_impl\n        }\n\n        impl\u003c'de\u003e _serde::Deserialize\u003c'de\u003e for __Field #lifetime {\n            #[inline]\n            fn deserialize\u003c__D\u003e(__deserializer: __D) -\u003e _serde::export::Result\u003cSelf, __D::Error\u003e\n            where\n                __D: _serde::Deserializer\u003c'de\u003e,\n            {\n                _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)\n            }\n        }\n    }\n}\n\nfn deserialize_custom_identifier(\n    params: \u0026Parameters,\n    variants: \u0026[Variant],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let is_variant = match cattrs.identifier() {\n        attr::Identifier::Variant =\u003e true,\n        attr::Identifier::Field =\u003e false,\n        attr::Identifier::No =\u003e unreachable!(),\n    };\n\n    let this = \u0026params.this;\n    let this = quote!(#this);\n\n    let (ordinary, fallthrough) = if let Some(last) = variants.last() {\n        let last_ident = \u0026last.ident;\n        if last.attrs.other() {\n            let ordinary = \u0026variants[..variants.len() - 1];\n            let fallthrough = quote!(_serde::export::Ok(#this::#last_ident));\n            (ordinary, Some(fallthrough))\n        } else if let Style::Newtype = last.style {\n            let ordinary = \u0026variants[..variants.len() - 1];\n            let deserializer = quote!(_serde::private::de::IdentifierDeserializer::from(__value));\n            let fallthrough = quote! {\n                _serde::export::Result::map(\n                    _serde::Deserialize::deserialize(#deserializer),\n                    #this::#last_ident)\n            };\n            (ordinary, Some(fallthrough))\n        } else {\n            (variants, None)\n        }\n    } else {\n        (variants, None)\n    };\n\n    let names_idents: Vec\u003c_\u003e = ordinary\n        .iter()\n        .map(|variant| {\n            (\n                variant.attrs.name().deserialize_name(),\n                variant.ident.clone(),\n                variant.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let names = names_idents.iter().map(|\u0026(ref name, _, _)| name);\n\n    let names_const = if fallthrough.is_some() {\n        None\n    } else if is_variant {\n        let variants = quote! {\n            const VARIANTS: \u0026'static [\u0026'static str] = \u0026[ #(#names),* ];\n        };\n        Some(variants)\n    } else {\n        let fields = quote! {\n            const FIELDS: \u0026'static [\u0026'static str] = \u0026[ #(#names),* ];\n        };\n        Some(fields)\n    };\n\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n    let visitor_impl = Stmts(deserialize_identifier(\n        \u0026this,\n        \u0026names_idents,\n        is_variant,\n        fallthrough,\n        false,\n    ));\n\n    quote_block! {\n        #names_const\n\n        struct __FieldVisitor #de_impl_generics #where_clause {\n            marker: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::de::Visitor\u003c#delife\u003e for __FieldVisitor #de_ty_generics #where_clause {\n            type Value = #this #ty_generics;\n\n            #visitor_impl\n        }\n\n        let __visitor = __FieldVisitor {\n            marker: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData,\n        };\n        _serde::Deserializer::deserialize_identifier(__deserializer, __visitor)\n    }\n}\n\nfn deserialize_identifier(\n    this: \u0026TokenStream,\n    fields: \u0026[(String, Ident, Vec\u003cString\u003e)],\n    is_variant: bool,\n    fallthrough: Option\u003cTokenStream\u003e,\n    collect_other_fields: bool,\n) -\u003e Fragment {\n    let mut flat_fields = Vec::new();\n    for \u0026(_, ref ident, ref aliases) in fields {\n        flat_fields.extend(aliases.iter().map(|alias| (alias, ident)))\n    }\n\n    let field_strs = flat_fields.iter().map(|\u0026(ref name, _)| name);\n    let field_borrowed_strs = flat_fields.iter().map(|\u0026(ref name, _)| name);\n    let field_bytes = flat_fields\n        .iter()\n        .map(|\u0026(ref name, _)| Literal::byte_string(name.as_bytes()));\n    let field_borrowed_bytes = flat_fields\n        .iter()\n        .map(|\u0026(ref name, _)| Literal::byte_string(name.as_bytes()));\n\n    let constructors: \u0026Vec\u003c_\u003e = \u0026flat_fields\n        .iter()\n        .map(|\u0026(_, ref ident)| quote!(#this::#ident))\n        .collect();\n    let main_constructors: \u0026Vec\u003c_\u003e = \u0026fields\n        .iter()\n        .map(|\u0026(_, ref ident, _)| quote!(#this::#ident))\n        .collect();\n\n    let expecting = if is_variant {\n        \"variant identifier\"\n    } else {\n        \"field identifier\"\n    };\n\n    let index_expecting = if is_variant { \"variant\" } else { \"field\" };\n\n    let bytes_to_str = if fallthrough.is_some() || collect_other_fields {\n        None\n    } else {\n        Some(quote! {\n            let __value = \u0026_serde::export::from_utf8_lossy(__value);\n        })\n    };\n\n    let (\n        value_as_str_content,\n        value_as_borrowed_str_content,\n        value_as_bytes_content,\n        value_as_borrowed_bytes_content,\n    ) = if collect_other_fields {\n        (\n            Some(quote! {\n                let __value = _serde::private::de::Content::String(_serde::export::ToString::to_string(__value));\n            }),\n            Some(quote! {\n                let __value = _serde::private::de::Content::Str(__value);\n            }),\n            Some(quote! {\n                let __value = _serde::private::de::Content::ByteBuf(__value.to_vec());\n            }),\n            Some(quote! {\n                let __value = _serde::private::de::Content::Bytes(__value);\n            }),\n        )\n    } else {\n        (None, None, None, None)\n    };\n\n    let fallthrough_arm = if let Some(fallthrough) = fallthrough {\n        fallthrough\n    } else if is_variant {\n        quote! {\n            _serde::export::Err(_serde::de::Error::unknown_variant(__value, VARIANTS))\n        }\n    } else {\n        quote! {\n            _serde::export::Err(_serde::de::Error::unknown_field(__value, FIELDS))\n        }\n    };\n\n    let variant_indices = 0_u64..;\n    let fallthrough_msg = format!(\"{} index 0 \u003c= i \u003c {}\", index_expecting, fields.len());\n    let visit_other = if collect_other_fields {\n        quote! {\n            fn visit_bool\u003c__E\u003e(self, __value: bool) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::Bool(__value)))\n            }\n\n            fn visit_i8\u003c__E\u003e(self, __value: i8) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I8(__value)))\n            }\n\n            fn visit_i16\u003c__E\u003e(self, __value: i16) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I16(__value)))\n            }\n\n            fn visit_i32\u003c__E\u003e(self, __value: i32) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I32(__value)))\n            }\n\n            fn visit_i64\u003c__E\u003e(self, __value: i64) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I64(__value)))\n            }\n\n            fn visit_u8\u003c__E\u003e(self, __value: u8) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U8(__value)))\n            }\n\n            fn visit_u16\u003c__E\u003e(self, __value: u16) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U16(__value)))\n            }\n\n            fn visit_u32\u003c__E\u003e(self, __value: u32) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U32(__value)))\n            }\n\n            fn visit_u64\u003c__E\u003e(self, __value: u64) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U64(__value)))\n            }\n\n            fn visit_f32\u003c__E\u003e(self, __value: f32) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::F32(__value)))\n            }\n\n            fn visit_f64\u003c__E\u003e(self, __value: f64) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::F64(__value)))\n            }\n\n            fn visit_char\u003c__E\u003e(self, __value: char) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::Char(__value)))\n            }\n\n            fn visit_unit\u003c__E\u003e(self) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                _serde::export::Ok(__Field::__other(_serde::private::de::Content::Unit))\n            }\n\n            fn visit_borrowed_str\u003c__E\u003e(self, __value: \u0026'de str) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                match __value {\n                    #(\n                        #field_borrowed_strs =\u003e _serde::export::Ok(#constructors),\n                    )*\n                    _ =\u003e {\n                        #value_as_borrowed_str_content\n                        #fallthrough_arm\n                    }\n                }\n            }\n\n            fn visit_borrowed_bytes\u003c__E\u003e(self, __value: \u0026'de [u8]) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                match __value {\n                    #(\n                        #field_borrowed_bytes =\u003e _serde::export::Ok(#constructors),\n                    )*\n                    _ =\u003e {\n                        #bytes_to_str\n                        #value_as_borrowed_bytes_content\n                        #fallthrough_arm\n                    }\n                }\n            }\n        }\n    } else {\n        quote! {\n            fn visit_u64\u003c__E\u003e(self, __value: u64) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n            where\n                __E: _serde::de::Error,\n            {\n                match __value {\n                    #(\n                        #variant_indices =\u003e _serde::export::Ok(#main_constructors),\n                    )*\n                    _ =\u003e _serde::export::Err(_serde::de::Error::invalid_value(\n                        _serde::de::Unexpected::Unsigned(__value),\n                        \u0026#fallthrough_msg,\n                    ))\n                }\n            }\n        }\n    };\n\n    quote_block! {\n        fn expecting(\u0026self, __formatter: \u0026mut _serde::export::Formatter) -\u003e _serde::export::fmt::Result {\n            _serde::export::Formatter::write_str(__formatter, #expecting)\n        }\n\n        #visit_other\n\n        fn visit_str\u003c__E\u003e(self, __value: \u0026str) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n        where\n            __E: _serde::de::Error,\n        {\n            match __value {\n                #(\n                    #field_strs =\u003e _serde::export::Ok(#constructors),\n                )*\n                _ =\u003e {\n                    #value_as_str_content\n                    #fallthrough_arm\n                }\n            }\n        }\n\n        fn visit_bytes\u003c__E\u003e(self, __value: \u0026[u8]) -\u003e _serde::export::Result\u003cSelf::Value, __E\u003e\n        where\n            __E: _serde::de::Error,\n        {\n            match __value {\n                #(\n                    #field_bytes =\u003e _serde::export::Ok(#constructors),\n                )*\n                _ =\u003e {\n                    #bytes_to_str\n                    #value_as_bytes_content\n                    #fallthrough_arm\n                }\n            }\n        }\n    }\n}\n\nfn deserialize_struct_as_struct_visitor(\n    struct_path: \u0026TokenStream,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e (Fragment, Option\u003cFragment\u003e, Fragment) {\n    assert!(!cattrs.has_flatten());\n\n    let field_names_idents: Vec\u003c_\u003e = fields\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, field)| !field.attrs.skip_deserializing())\n        .map(|(i, field)| {\n            (\n                field.attrs.name().deserialize_name(),\n                field_i(i),\n                field.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let fields_stmt = {\n        let field_names = field_names_idents.iter().map(|\u0026(ref name, _, _)| name);\n        quote_block! {\n            const FIELDS: \u0026'static [\u0026'static str] = \u0026[ #(#field_names),* ];\n        }\n    };\n\n    let field_visitor = deserialize_generated_identifier(\u0026field_names_idents, cattrs, false, None);\n\n    let visit_map = deserialize_map(struct_path, params, fields, cattrs);\n\n    (field_visitor, Some(fields_stmt), visit_map)\n}\n\nfn deserialize_struct_as_map_visitor(\n    struct_path: \u0026TokenStream,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e (Fragment, Option\u003cFragment\u003e, Fragment) {\n    let field_names_idents: Vec\u003c_\u003e = fields\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, field)| !field.attrs.skip_deserializing() \u0026\u0026 !field.attrs.flatten())\n        .map(|(i, field)| {\n            (\n                field.attrs.name().deserialize_name(),\n                field_i(i),\n                field.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let field_visitor = deserialize_generated_identifier(\u0026field_names_idents, cattrs, false, None);\n\n    let visit_map = deserialize_map(struct_path, params, fields, cattrs);\n\n    (field_visitor, None, visit_map)\n}\n\nfn deserialize_map(\n    struct_path: \u0026TokenStream,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    // Create the field names for the fields.\n    let fields_names: Vec\u003c_\u003e = fields\n        .iter()\n        .enumerate()\n        .map(|(i, field)| (field, field_i(i)))\n        .collect();\n\n    // Declare each field that will be deserialized.\n    let let_values = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| !field.attrs.skip_deserializing() \u0026\u0026 !field.attrs.flatten())\n        .map(|\u0026(field, ref name)| {\n            let field_ty = field.ty;\n            quote! {\n                let mut #name: _serde::export::Option\u003c#field_ty\u003e = _serde::export::None;\n            }\n        });\n\n    // Collect contents for flatten fields into a buffer\n    let let_collect = if cattrs.has_flatten() {\n        Some(quote! {\n            let mut __collect = _serde::export::Vec::\u003c_serde::export::Option\u003c(\n                _serde::private::de::Content,\n                _serde::private::de::Content\n            )\u003e\u003e::new();\n        })\n    } else {\n        None\n    };\n\n    // Match arms to extract a value for a field.\n    let value_arms = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| !field.attrs.skip_deserializing() \u0026\u0026 !field.attrs.flatten())\n        .map(|\u0026(field, ref name)| {\n            let deser_name = field.attrs.name().deserialize_name();\n\n            let visit = match field.attrs.deserialize_with() {\n                None =\u003e {\n                    let field_ty = field.ty;\n                    let span = field.original.span();\n                    let func =\n                        quote_spanned!(span=\u003e _serde::de::MapAccess::next_value::\u003c#field_ty\u003e);\n                    quote! {\n                        try!(#func(\u0026mut __map))\n                    }\n                }\n                Some(path) =\u003e {\n                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n                    quote!({\n                        #wrapper\n                        match _serde::de::MapAccess::next_value::\u003c#wrapper_ty\u003e(\u0026mut __map) {\n                            _serde::export::Ok(__wrapper) =\u003e __wrapper.value,\n                            _serde::export::Err(__err) =\u003e {\n                                return _serde::export::Err(__err);\n                            }\n                        }\n                    })\n                }\n            };\n            quote! {\n                __Field::#name =\u003e {\n                    if _serde::export::Option::is_some(\u0026#name) {\n                        return _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::duplicate_field(#deser_name));\n                    }\n                    #name = _serde::export::Some(#visit);\n                }\n            }\n        });\n\n    // Visit ignored values to consume them\n    let ignored_arm = if cattrs.has_flatten() {\n        Some(quote! {\n            __Field::__other(__name) =\u003e {\n                __collect.push(_serde::export::Some((\n                    __name,\n                    try!(_serde::de::MapAccess::next_value(\u0026mut __map)))));\n            }\n        })\n    } else if cattrs.deny_unknown_fields() {\n        None\n    } else {\n        Some(quote! {\n            _ =\u003e { let _ = try!(_serde::de::MapAccess::next_value::\u003c_serde::de::IgnoredAny\u003e(\u0026mut __map)); }\n        })\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n    let match_keys = if cattrs.deny_unknown_fields() \u0026\u0026 all_skipped {\n        quote! {\n            // FIXME: Once we drop support for Rust 1.15:\n            // let _serde::export::None::\u003c__Field\u003e = try!(_serde::de::MapAccess::next_key(\u0026mut __map));\n            _serde::export::Option::map(\n                try!(_serde::de::MapAccess::next_key::\u003c__Field\u003e(\u0026mut __map)),\n                |__impossible| match __impossible {});\n        }\n    } else {\n        quote! {\n            while let _serde::export::Some(__key) = try!(_serde::de::MapAccess::next_key::\u003c__Field\u003e(\u0026mut __map)) {\n                match __key {\n                    #(#value_arms)*\n                    #ignored_arm\n                }\n            }\n        }\n    };\n\n    let extract_values = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| !field.attrs.skip_deserializing() \u0026\u0026 !field.attrs.flatten())\n        .map(|\u0026(field, ref name)| {\n            let missing_expr = Match(expr_is_missing(field, cattrs));\n\n            quote! {\n                let #name = match #name {\n                    _serde::export::Some(#name) =\u003e #name,\n                    _serde::export::None =\u003e #missing_expr\n                };\n            }\n        });\n\n    let extract_collected = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| field.attrs.flatten() \u0026\u0026 !field.attrs.skip_deserializing())\n        .map(|\u0026(field, ref name)| {\n            let field_ty = field.ty;\n            let func = match field.attrs.deserialize_with() {\n                None =\u003e {\n                    let span = field.original.span();\n                    quote_spanned!(span=\u003e _serde::de::Deserialize::deserialize)\n                }\n                Some(path) =\u003e quote!(#path),\n            };\n            quote! {\n                let #name: #field_ty = try!(#func(\n                    _serde::private::de::FlatMapDeserializer(\n                        \u0026mut __collect,\n                        _serde::export::PhantomData)));\n            }\n        });\n\n    let collected_deny_unknown_fields = if cattrs.has_flatten() \u0026\u0026 cattrs.deny_unknown_fields() {\n        Some(quote! {\n            if let _serde::export::Some(_serde::export::Some((__key, _))) =\n                __collect.into_iter().filter(_serde::export::Option::is_some).next()\n            {\n                if let _serde::export::Some(__key) = __key.as_str() {\n                    return _serde::export::Err(\n                        _serde::de::Error::custom(format_args!(\"unknown field `{}`\", \u0026__key)));\n                } else {\n                    return _serde::export::Err(\n                        _serde::de::Error::custom(format_args!(\"unexpected map key\")));\n                }\n            }\n        })\n    } else {\n        None\n    };\n\n    let result = fields_names.iter().map(|\u0026(field, ref name)| {\n        let member = \u0026field.member;\n        if field.attrs.skip_deserializing() {\n            let value = Expr(expr_is_missing(field, cattrs));\n            quote!(#member: #value)\n        } else {\n            quote!(#member: #name)\n        }\n    });\n\n    let let_default = match *cattrs.default() {\n        attr::Default::Default =\u003e Some(quote!(\n            let __default: Self::Value = _serde::export::Default::default();\n        )),\n        attr::Default::Path(ref path) =\u003e Some(quote!(\n            let __default: Self::Value = #path();\n        )),\n        attr::Default::None =\u003e {\n            // We don't need the default value, to prevent an unused variable warning\n            // we'll leave the line empty.\n            None\n        }\n    };\n\n    let mut result = quote!(#struct_path { #(#result),* });\n    if params.has_getter {\n        let this = \u0026params.this;\n        result = quote! {\n            _serde::export::Into::\u003c#this\u003e::into(#result)\n        };\n    }\n\n    quote_block! {\n        #(#let_values)*\n\n        #let_collect\n\n        #match_keys\n\n        #let_default\n\n        #(#extract_values)*\n\n        #(#extract_collected)*\n\n        #collected_deny_unknown_fields\n\n        _serde::export::Ok(#result)\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_struct_as_struct_in_place_visitor(\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e (Fragment, Fragment, Fragment) {\n    assert!(!cattrs.has_flatten());\n\n    let field_names_idents: Vec\u003c_\u003e = fields\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, field)| !field.attrs.skip_deserializing())\n        .map(|(i, field)| {\n            (\n                field.attrs.name().deserialize_name(),\n                field_i(i),\n                field.attrs.aliases(),\n            )\n        })\n        .collect();\n\n    let fields_stmt = {\n        let field_names = field_names_idents.iter().map(|\u0026(ref name, _, _)| name);\n        quote_block! {\n            const FIELDS: \u0026'static [\u0026'static str] = \u0026[ #(#field_names),* ];\n        }\n    };\n\n    let field_visitor = deserialize_generated_identifier(\u0026field_names_idents, cattrs, false, None);\n\n    let visit_map = deserialize_map_in_place(params, fields, cattrs);\n\n    (field_visitor, fields_stmt, visit_map)\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn deserialize_map_in_place(\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    assert!(!cattrs.has_flatten());\n\n    // Create the field names for the fields.\n    let fields_names: Vec\u003c_\u003e = fields\n        .iter()\n        .enumerate()\n        .map(|(i, field)| (field, field_i(i)))\n        .collect();\n\n    // For deserialize_in_place, declare booleans for each field that will be\n    // deserialized.\n    let let_flags = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| !field.attrs.skip_deserializing())\n        .map(|\u0026(_, ref name)| {\n            quote! {\n                let mut #name: bool = false;\n            }\n        });\n\n    // Match arms to extract a value for a field.\n    let value_arms_from = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| !field.attrs.skip_deserializing())\n        .map(|\u0026(field, ref name)| {\n            let deser_name = field.attrs.name().deserialize_name();\n            let member = \u0026field.member;\n\n            let visit = match field.attrs.deserialize_with() {\n                None =\u003e {\n                    quote! {\n                        try!(_serde::de::MapAccess::next_value_seed(\u0026mut __map, _serde::private::de::InPlaceSeed(\u0026mut self.place.#member)))\n                    }\n                }\n                Some(path) =\u003e {\n                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n                    quote!({\n                        #wrapper\n                        self.place.#member = match _serde::de::MapAccess::next_value::\u003c#wrapper_ty\u003e(\u0026mut __map) {\n                            _serde::export::Ok(__wrapper) =\u003e __wrapper.value,\n                            _serde::export::Err(__err) =\u003e {\n                                return _serde::export::Err(__err);\n                            }\n                        };\n                    })\n                }\n            };\n            quote! {\n                __Field::#name =\u003e {\n                    if #name {\n                        return _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::duplicate_field(#deser_name));\n                    }\n                    #visit;\n                    #name = true;\n                }\n            }\n        });\n\n    // Visit ignored values to consume them\n    let ignored_arm = if cattrs.deny_unknown_fields() {\n        None\n    } else {\n        Some(quote! {\n            _ =\u003e { let _ = try!(_serde::de::MapAccess::next_value::\u003c_serde::de::IgnoredAny\u003e(\u0026mut __map)); }\n        })\n    };\n\n    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n\n    let match_keys = if cattrs.deny_unknown_fields() \u0026\u0026 all_skipped {\n        quote! {\n            // FIXME: Once we drop support for Rust 1.15:\n            // let _serde::export::None::\u003c__Field\u003e = try!(_serde::de::MapAccess::next_key(\u0026mut __map));\n            _serde::export::Option::map(\n                try!(_serde::de::MapAccess::next_key::\u003c__Field\u003e(\u0026mut __map)),\n                |__impossible| match __impossible {});\n        }\n    } else {\n        quote! {\n            while let _serde::export::Some(__key) = try!(_serde::de::MapAccess::next_key::\u003c__Field\u003e(\u0026mut __map)) {\n                match __key {\n                    #(#value_arms_from)*\n                    #ignored_arm\n                }\n            }\n        }\n    };\n\n    let check_flags = fields_names\n        .iter()\n        .filter(|\u0026\u0026(field, _)| !field.attrs.skip_deserializing())\n        .map(|\u0026(field, ref name)| {\n            let missing_expr = expr_is_missing(field, cattrs);\n            // If missing_expr unconditionally returns an error, don't try\n            // to assign its value to self.place.\n            if field.attrs.default().is_none()\n                \u0026\u0026 cattrs.default().is_none()\n                \u0026\u0026 field.attrs.deserialize_with().is_some()\n            {\n                let missing_expr = Stmts(missing_expr);\n                quote! {\n                    if !#name {\n                        #missing_expr;\n                    }\n                }\n            } else {\n                let member = \u0026field.member;\n                let missing_expr = Expr(missing_expr);\n                quote! {\n                    if !#name {\n                        self.place.#member = #missing_expr;\n                    };\n                }\n            }\n        });\n\n    let this = \u0026params.this;\n    let (_, _, ty_generics, _) = split_with_de_lifetime(params);\n\n    let let_default = match *cattrs.default() {\n        attr::Default::Default =\u003e Some(quote!(\n            let __default: #this #ty_generics = _serde::export::Default::default();\n        )),\n        attr::Default::Path(ref path) =\u003e Some(quote!(\n            let __default: #this #ty_generics = #path();\n        )),\n        attr::Default::None =\u003e {\n            // We don't need the default value, to prevent an unused variable warning\n            // we'll leave the line empty.\n            None\n        }\n    };\n\n    quote_block! {\n        #(#let_flags)*\n\n        #match_keys\n\n        #let_default\n\n        #(#check_flags)*\n\n        _serde::export::Ok(())\n    }\n}\n\nfn field_i(i: usize) -\u003e Ident {\n    Ident::new(\u0026format!(\"__field{}\", i), Span::call_site())\n}\n\n/// This function wraps the expression in `#[serde(deserialize_with = \"...\")]`\n/// in a trait to prevent it from accessing the internal `Deserialize` state.\nfn wrap_deserialize_with(\n    params: \u0026Parameters,\n    value_ty: \u0026TokenStream,\n    deserialize_with: \u0026syn::ExprPath,\n) -\u003e (TokenStream, TokenStream) {\n    let this = \u0026params.this;\n    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =\n        split_with_de_lifetime(params);\n    let delife = params.borrowed.de_lifetime();\n\n    let wrapper = quote! {\n        struct __DeserializeWith #de_impl_generics #where_clause {\n            value: #value_ty,\n            phantom: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n            lifetime: _serde::export::PhantomData\u003c\u0026#delife ()\u003e,\n        }\n\n        impl #de_impl_generics _serde::Deserialize\u003c#delife\u003e for __DeserializeWith #de_ty_generics #where_clause {\n            fn deserialize\u003c__D\u003e(__deserializer: __D) -\u003e _serde::export::Result\u003cSelf, __D::Error\u003e\n            where\n                __D: _serde::Deserializer\u003c#delife\u003e,\n            {\n                _serde::export::Ok(__DeserializeWith {\n                    value: try!(#deserialize_with(__deserializer)),\n                    phantom: _serde::export::PhantomData,\n                    lifetime: _serde::export::PhantomData,\n                })\n            }\n        }\n    };\n\n    let wrapper_ty = quote!(__DeserializeWith #de_ty_generics);\n\n    (wrapper, wrapper_ty)\n}\n\nfn wrap_deserialize_field_with(\n    params: \u0026Parameters,\n    field_ty: \u0026syn::Type,\n    deserialize_with: \u0026syn::ExprPath,\n) -\u003e (TokenStream, TokenStream) {\n    wrap_deserialize_with(params, \u0026quote!(#field_ty), deserialize_with)\n}\n\nfn wrap_deserialize_variant_with(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    deserialize_with: \u0026syn::ExprPath,\n) -\u003e (TokenStream, TokenStream, TokenStream) {\n    let this = \u0026params.this;\n    let variant_ident = \u0026variant.ident;\n\n    let field_tys = variant.fields.iter().map(|field| field.ty);\n    let (wrapper, wrapper_ty) =\n        wrap_deserialize_with(params, \u0026quote!((#(#field_tys),*)), deserialize_with);\n\n    let field_access = (0..variant.fields.len()).map(|n| {\n        Member::Unnamed(Index {\n            index: n as u32,\n            span: Span::call_site(),\n        })\n    });\n    let unwrap_fn = match variant.style {\n        Style::Struct if variant.fields.len() == 1 =\u003e {\n            let member = \u0026variant.fields[0].member;\n            quote! {\n                |__wrap| #this::#variant_ident { #member: __wrap.value }\n            }\n        }\n        Style::Struct =\u003e {\n            let members = variant.fields.iter().map(|field| \u0026field.member);\n            quote! {\n                |__wrap| #this::#variant_ident { #(#members: __wrap.value.#field_access),* }\n            }\n        }\n        Style::Tuple =\u003e quote! {\n            |__wrap| #this::#variant_ident(#(__wrap.value.#field_access),*)\n        },\n        Style::Newtype =\u003e quote! {\n            |__wrap| #this::#variant_ident(__wrap.value)\n        },\n        Style::Unit =\u003e quote! {\n            |__wrap| #this::#variant_ident\n        },\n    };\n\n    (wrapper, wrapper_ty, unwrap_fn)\n}\n\nfn expr_is_missing(field: \u0026Field, cattrs: \u0026attr::Container) -\u003e Fragment {\n    match *field.attrs.default() {\n        attr::Default::Default =\u003e {\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e _serde::export::Default::default);\n            return quote_expr!(#func());\n        }\n        attr::Default::Path(ref path) =\u003e {\n            return quote_expr!(#path());\n        }\n        attr::Default::None =\u003e { /* below */ }\n    }\n\n    match *cattrs.default() {\n        attr::Default::Default | attr::Default::Path(_) =\u003e {\n            let member = \u0026field.member;\n            return quote_expr!(__default.#member);\n        }\n        attr::Default::None =\u003e { /* below */ }\n    }\n\n    let name = field.attrs.name().deserialize_name();\n    match field.attrs.deserialize_with() {\n        None =\u003e {\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e _serde::private::de::missing_field);\n            quote_expr! {\n                try!(#func(#name))\n            }\n        }\n        Some(_) =\u003e {\n            quote_expr! {\n                return _serde::export::Err(\u003c__A::Error as _serde::de::Error\u003e::missing_field(#name))\n            }\n        }\n    }\n}\n\nstruct DeImplGenerics\u003c'a\u003e(\u0026'a Parameters);\n#[cfg(feature = \"deserialize_in_place\")]\nstruct InPlaceImplGenerics\u003c'a\u003e(\u0026'a Parameters);\n\nimpl\u003c'a\u003e ToTokens for DeImplGenerics\u003c'a\u003e {\n    fn to_tokens(\u0026self, tokens: \u0026mut TokenStream) {\n        let mut generics = self.0.generics.clone();\n        if let Some(de_lifetime) = self.0.borrowed.de_lifetime_def() {\n            generics.params = Some(syn::GenericParam::Lifetime(de_lifetime))\n                .into_iter()\n                .chain(generics.params)\n                .collect();\n        }\n        let (impl_generics, _, _) = generics.split_for_impl();\n        impl_generics.to_tokens(tokens);\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nimpl\u003c'a\u003e ToTokens for InPlaceImplGenerics\u003c'a\u003e {\n    fn to_tokens(\u0026self, tokens: \u0026mut TokenStream) {\n        let place_lifetime = place_lifetime();\n        let mut generics = self.0.generics.clone();\n\n        // Add lifetime for `\u0026'place mut Self, and `'a: 'place`\n        for param in \u0026mut generics.params {\n            match *param {\n                syn::GenericParam::Lifetime(ref mut param) =\u003e {\n                    param.bounds.push(place_lifetime.lifetime.clone());\n                }\n                syn::GenericParam::Type(ref mut param) =\u003e {\n                    param.bounds.push(syn::TypeParamBound::Lifetime(\n                        place_lifetime.lifetime.clone(),\n                    ));\n                }\n                syn::GenericParam::Const(_) =\u003e {}\n            }\n        }\n        generics.params = Some(syn::GenericParam::Lifetime(place_lifetime))\n            .into_iter()\n            .chain(generics.params)\n            .collect();\n        if let Some(de_lifetime) = self.0.borrowed.de_lifetime_def() {\n            generics.params = Some(syn::GenericParam::Lifetime(de_lifetime))\n                .into_iter()\n                .chain(generics.params)\n                .collect();\n        }\n        let (impl_generics, _, _) = generics.split_for_impl();\n        impl_generics.to_tokens(tokens);\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nimpl\u003c'a\u003e DeImplGenerics\u003c'a\u003e {\n    fn in_place(self) -\u003e InPlaceImplGenerics\u003c'a\u003e {\n        InPlaceImplGenerics(self.0)\n    }\n}\n\nstruct DeTypeGenerics\u003c'a\u003e(\u0026'a Parameters);\n#[cfg(feature = \"deserialize_in_place\")]\nstruct InPlaceTypeGenerics\u003c'a\u003e(\u0026'a Parameters);\n\nimpl\u003c'a\u003e ToTokens for DeTypeGenerics\u003c'a\u003e {\n    fn to_tokens(\u0026self, tokens: \u0026mut TokenStream) {\n        let mut generics = self.0.generics.clone();\n        if self.0.borrowed.de_lifetime_def().is_some() {\n            let def = syn::LifetimeDef {\n                attrs: Vec::new(),\n                lifetime: syn::Lifetime::new(\"'de\", Span::call_site()),\n                colon_token: None,\n                bounds: Punctuated::new(),\n            };\n            generics.params = Some(syn::GenericParam::Lifetime(def))\n                .into_iter()\n                .chain(generics.params)\n                .collect();\n        }\n        let (_, ty_generics, _) = generics.split_for_impl();\n        ty_generics.to_tokens(tokens);\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nimpl\u003c'a\u003e ToTokens for InPlaceTypeGenerics\u003c'a\u003e {\n    fn to_tokens(\u0026self, tokens: \u0026mut TokenStream) {\n        let mut generics = self.0.generics.clone();\n        generics.params = Some(syn::GenericParam::Lifetime(place_lifetime()))\n            .into_iter()\n            .chain(generics.params)\n            .collect();\n\n        if self.0.borrowed.de_lifetime_def().is_some() {\n            let def = syn::LifetimeDef {\n                attrs: Vec::new(),\n                lifetime: syn::Lifetime::new(\"'de\", Span::call_site()),\n                colon_token: None,\n                bounds: Punctuated::new(),\n            };\n            generics.params = Some(syn::GenericParam::Lifetime(def))\n                .into_iter()\n                .chain(generics.params)\n                .collect();\n        }\n        let (_, ty_generics, _) = generics.split_for_impl();\n        ty_generics.to_tokens(tokens);\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nimpl\u003c'a\u003e DeTypeGenerics\u003c'a\u003e {\n    fn in_place(self) -\u003e InPlaceTypeGenerics\u003c'a\u003e {\n        InPlaceTypeGenerics(self.0)\n    }\n}\n\n#[cfg(feature = \"deserialize_in_place\")]\nfn place_lifetime() -\u003e syn::LifetimeDef {\n    syn::LifetimeDef {\n        attrs: Vec::new(),\n        lifetime: syn::Lifetime::new(\"'place\", Span::call_site()),\n        colon_token: None,\n        bounds: Punctuated::new(),\n    }\n}\n\nfn split_with_de_lifetime(\n    params: \u0026Parameters,\n) -\u003e (\n    DeImplGenerics,\n    DeTypeGenerics,\n    syn::TypeGenerics,\n    Option\u003c\u0026syn::WhereClause\u003e,\n) {\n    let de_impl_generics = DeImplGenerics(params);\n    let de_ty_generics = DeTypeGenerics(params);\n    let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n    (de_impl_generics, de_ty_generics, ty_generics, where_clause)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","dummy.rs"],"content":"use proc_macro2::{Ident, Span, TokenStream};\n\nuse syn;\nuse try;\n\npub fn wrap_in_const(\n    serde_path: Option\u003c\u0026syn::Path\u003e,\n    trait_: \u0026str,\n    ty: \u0026Ident,\n    code: TokenStream,\n) -\u003e TokenStream {\n    let try_replacement = try::replacement();\n\n    let dummy_const = Ident::new(\n        \u0026format!(\"_IMPL_{}_FOR_{}\", trait_, unraw(ty)),\n        Span::call_site(),\n    );\n\n    let use_serde = match serde_path {\n        Some(path) =\u003e quote! {\n            use #path as _serde;\n        },\n        None =\u003e quote! {\n            #[allow(unknown_lints)]\n            #[cfg_attr(feature = \"cargo-clippy\", allow(useless_attribute))]\n            #[allow(rust_2018_idioms)]\n            extern crate serde as _serde;\n        },\n    };\n\n    quote! {\n        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n        const #dummy_const: () = {\n            #use_serde\n            #try_replacement\n            #code\n        };\n    }\n}\n\n#[allow(deprecated)]\nfn unraw(ident: \u0026Ident) -\u003e String {\n    // str::trim_start_matches was added in 1.30, trim_left_matches deprecated\n    // in 1.33. We currently support rustc back to 1.15 so we need to continue\n    // to use the deprecated one.\n    ident.to_string().trim_left_matches(\"r#\").to_owned()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","fragment.rs"],"content":"use proc_macro2::TokenStream;\nuse quote::ToTokens;\nuse syn::token;\n\npub enum Fragment {\n    /// Tokens that can be used as an expression.\n    Expr(TokenStream),\n    /// Tokens that can be used inside a block. The surrounding curly braces are\n    /// not part of these tokens.\n    Block(TokenStream),\n}\n\nmacro_rules! quote_expr {\n    ($($tt:tt)*) =\u003e {\n        $crate::fragment::Fragment::Expr(quote!($($tt)*))\n    }\n}\n\nmacro_rules! quote_block {\n    ($($tt:tt)*) =\u003e {\n        $crate::fragment::Fragment::Block(quote!($($tt)*))\n    }\n}\n\n/// Interpolate a fragment in place of an expression. This involves surrounding\n/// Block fragments in curly braces.\npub struct Expr(pub Fragment);\nimpl ToTokens for Expr {\n    fn to_tokens(\u0026self, out: \u0026mut TokenStream) {\n        match self.0 {\n            Fragment::Expr(ref expr) =\u003e expr.to_tokens(out),\n            Fragment::Block(ref block) =\u003e {\n                token::Brace::default().surround(out, |out| block.to_tokens(out));\n            }\n        }\n    }\n}\n\n/// Interpolate a fragment as the statements of a block.\npub struct Stmts(pub Fragment);\nimpl ToTokens for Stmts {\n    fn to_tokens(\u0026self, out: \u0026mut TokenStream) {\n        match self.0 {\n            Fragment::Expr(ref expr) =\u003e expr.to_tokens(out),\n            Fragment::Block(ref block) =\u003e block.to_tokens(out),\n        }\n    }\n}\n\n/// Interpolate a fragment as the value part of a `match` expression. This\n/// involves putting a comma after expressions and curly braces around blocks.\npub struct Match(pub Fragment);\nimpl ToTokens for Match {\n    fn to_tokens(\u0026self, out: \u0026mut TokenStream) {\n        match self.0 {\n            Fragment::Expr(ref expr) =\u003e {\n                expr.to_tokens(out);\n                \u003cToken![,]\u003e::default().to_tokens(out);\n            }\n            Fragment::Block(ref block) =\u003e {\n                token::Brace::default().surround(out, |out| block.to_tokens(out));\n            }\n        }\n    }\n}\n\nimpl AsRef\u003cTokenStream\u003e for Fragment {\n    fn as_ref(\u0026self) -\u003e \u0026TokenStream {\n        match *self {\n            Fragment::Expr(ref expr) =\u003e expr,\n            Fragment::Block(ref block) =\u003e block,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","ast.rs"],"content":"//! A Serde ast, parsed from the Syn ast and ready to generate Rust code.\n\nuse internals::attr;\nuse internals::check;\nuse internals::{Ctxt, Derive};\nuse syn;\nuse syn::punctuated::Punctuated;\n\n/// A source data structure annotated with `#[derive(Serialize)]` and/or `#[derive(Deserialize)]`,\n/// parsed into an internal representation.\npub struct Container\u003c'a\u003e {\n    /// The struct or enum name (without generics).\n    pub ident: syn::Ident,\n    /// Attributes on the structure, parsed for Serde.\n    pub attrs: attr::Container,\n    /// The contents of the struct or enum.\n    pub data: Data\u003c'a\u003e,\n    /// Any generics on the struct or enum.\n    pub generics: \u0026'a syn::Generics,\n    /// Original input.\n    pub original: \u0026'a syn::DeriveInput,\n}\n\n/// The fields of a struct or enum.\n///\n/// Analagous to `syn::Data`.\npub enum Data\u003c'a\u003e {\n    Enum(Vec\u003cVariant\u003c'a\u003e\u003e),\n    Struct(Style, Vec\u003cField\u003c'a\u003e\u003e),\n}\n\n/// A variant of an enum.\npub struct Variant\u003c'a\u003e {\n    pub ident: syn::Ident,\n    pub attrs: attr::Variant,\n    pub style: Style,\n    pub fields: Vec\u003cField\u003c'a\u003e\u003e,\n    pub original: \u0026'a syn::Variant,\n}\n\n/// A field of a struct.\npub struct Field\u003c'a\u003e {\n    pub member: syn::Member,\n    pub attrs: attr::Field,\n    pub ty: \u0026'a syn::Type,\n    pub original: \u0026'a syn::Field,\n}\n\n#[derive(Copy, Clone)]\npub enum Style {\n    /// Named fields.\n    Struct,\n    /// Many unnamed fields.\n    Tuple,\n    /// One unnamed field.\n    Newtype,\n    /// No fields.\n    Unit,\n}\n\nimpl\u003c'a\u003e Container\u003c'a\u003e {\n    /// Convert the raw Syn ast into a parsed container object, collecting errors in `cx`.\n    pub fn from_ast(\n        cx: \u0026Ctxt,\n        item: \u0026'a syn::DeriveInput,\n        derive: Derive,\n    ) -\u003e Option\u003cContainer\u003c'a\u003e\u003e {\n        let mut attrs = attr::Container::from_ast(cx, item);\n\n        let mut data = match item.data {\n            syn::Data::Enum(ref data) =\u003e {\n                Data::Enum(enum_from_ast(cx, \u0026data.variants, attrs.default()))\n            }\n            syn::Data::Struct(ref data) =\u003e {\n                let (style, fields) = struct_from_ast(cx, \u0026data.fields, None, attrs.default());\n                Data::Struct(style, fields)\n            }\n            syn::Data::Union(_) =\u003e {\n                cx.error_spanned_by(item, \"Serde does not support derive for unions\");\n                return None;\n            }\n        };\n\n        let mut has_flatten = false;\n        match data {\n            Data::Enum(ref mut variants) =\u003e {\n                for variant in variants {\n                    variant.attrs.rename_by_rules(attrs.rename_all_rules());\n                    for field in \u0026mut variant.fields {\n                        if field.attrs.flatten() {\n                            has_flatten = true;\n                        }\n                        field\n                            .attrs\n                            .rename_by_rules(variant.attrs.rename_all_rules());\n                    }\n                }\n            }\n            Data::Struct(_, ref mut fields) =\u003e {\n                for field in fields {\n                    if field.attrs.flatten() {\n                        has_flatten = true;\n                    }\n                    field.attrs.rename_by_rules(attrs.rename_all_rules());\n                }\n            }\n        }\n\n        if has_flatten {\n            attrs.mark_has_flatten();\n        }\n\n        let mut item = Container {\n            ident: item.ident.clone(),\n            attrs: attrs,\n            data: data,\n            generics: \u0026item.generics,\n            original: item,\n        };\n        check::check(cx, \u0026mut item, derive);\n        Some(item)\n    }\n}\n\nimpl\u003c'a\u003e Data\u003c'a\u003e {\n    pub fn all_fields(\u0026'a self) -\u003e Box\u003cIterator\u003cItem = \u0026'a Field\u003c'a\u003e\u003e + 'a\u003e {\n        match *self {\n            Data::Enum(ref variants) =\u003e {\n                Box::new(variants.iter().flat_map(|variant| variant.fields.iter()))\n            }\n            Data::Struct(_, ref fields) =\u003e Box::new(fields.iter()),\n        }\n    }\n\n    pub fn has_getter(\u0026self) -\u003e bool {\n        self.all_fields().any(|f| f.attrs.getter().is_some())\n    }\n}\n\nfn enum_from_ast\u003c'a\u003e(\n    cx: \u0026Ctxt,\n    variants: \u0026'a Punctuated\u003csyn::Variant, Token![,]\u003e,\n    container_default: \u0026attr::Default,\n) -\u003e Vec\u003cVariant\u003c'a\u003e\u003e {\n    variants\n        .iter()\n        .map(|variant| {\n            let attrs = attr::Variant::from_ast(cx, variant);\n            let (style, fields) =\n                struct_from_ast(cx, \u0026variant.fields, Some(\u0026attrs), container_default);\n            Variant {\n                ident: variant.ident.clone(),\n                attrs: attrs,\n                style: style,\n                fields: fields,\n                original: variant,\n            }\n        })\n        .collect()\n}\n\nfn struct_from_ast\u003c'a\u003e(\n    cx: \u0026Ctxt,\n    fields: \u0026'a syn::Fields,\n    attrs: Option\u003c\u0026attr::Variant\u003e,\n    container_default: \u0026attr::Default,\n) -\u003e (Style, Vec\u003cField\u003c'a\u003e\u003e) {\n    match *fields {\n        syn::Fields::Named(ref fields) =\u003e (\n            Style::Struct,\n            fields_from_ast(cx, \u0026fields.named, attrs, container_default),\n        ),\n        syn::Fields::Unnamed(ref fields) if fields.unnamed.len() == 1 =\u003e (\n            Style::Newtype,\n            fields_from_ast(cx, \u0026fields.unnamed, attrs, container_default),\n        ),\n        syn::Fields::Unnamed(ref fields) =\u003e (\n            Style::Tuple,\n            fields_from_ast(cx, \u0026fields.unnamed, attrs, container_default),\n        ),\n        syn::Fields::Unit =\u003e (Style::Unit, Vec::new()),\n    }\n}\n\nfn fields_from_ast\u003c'a\u003e(\n    cx: \u0026Ctxt,\n    fields: \u0026'a Punctuated\u003csyn::Field, Token![,]\u003e,\n    attrs: Option\u003c\u0026attr::Variant\u003e,\n    container_default: \u0026attr::Default,\n) -\u003e Vec\u003cField\u003c'a\u003e\u003e {\n    fields\n        .iter()\n        .enumerate()\n        .map(|(i, field)| Field {\n            member: match field.ident {\n                Some(ref ident) =\u003e syn::Member::Named(ident.clone()),\n                None =\u003e syn::Member::Unnamed(i.into()),\n            },\n            attrs: attr::Field::from_ast(cx, i, field, attrs, container_default),\n            ty: \u0026field.ty,\n            original: field,\n        })\n        .collect()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","attr.rs"],"content":"use internals::symbol::*;\nuse internals::Ctxt;\nuse proc_macro2::{Group, Span, TokenStream, TokenTree};\nuse quote::ToTokens;\nuse std::borrow::Cow;\nuse std::collections::BTreeSet;\nuse std::str::FromStr;\nuse syn;\nuse syn::parse::{self, Parse, ParseStream};\nuse syn::punctuated::Punctuated;\nuse syn::Ident;\nuse syn::Meta::{List, NameValue, Path};\nuse syn::NestedMeta::{Lit, Meta};\n\n// This module handles parsing of `#[serde(...)]` attributes. The entrypoints\n// are `attr::Container::from_ast`, `attr::Variant::from_ast`, and\n// `attr::Field::from_ast`. Each returns an instance of the corresponding\n// struct. Note that none of them return a Result. Unrecognized, malformed, or\n// duplicated attributes result in a span_err but otherwise are ignored. The\n// user will see errors simultaneously for all bad attributes in the crate\n// rather than just the first.\n\npub use internals::case::RenameRule;\n\nstruct Attr\u003c'c, T\u003e {\n    cx: \u0026'c Ctxt,\n    name: Symbol,\n    tokens: TokenStream,\n    value: Option\u003cT\u003e,\n}\n\nimpl\u003c'c, T\u003e Attr\u003c'c, T\u003e {\n    fn none(cx: \u0026'c Ctxt, name: Symbol) -\u003e Self {\n        Attr {\n            cx: cx,\n            name: name,\n            tokens: TokenStream::new(),\n            value: None,\n        }\n    }\n\n    fn set\u003cA: ToTokens\u003e(\u0026mut self, obj: A, value: T) {\n        let tokens = obj.into_token_stream();\n\n        if self.value.is_some() {\n            self.cx\n                .error_spanned_by(tokens, format!(\"duplicate serde attribute `{}`\", self.name));\n        } else {\n            self.tokens = tokens;\n            self.value = Some(value);\n        }\n    }\n\n    fn set_opt\u003cA: ToTokens\u003e(\u0026mut self, obj: A, value: Option\u003cT\u003e) {\n        if let Some(value) = value {\n            self.set(obj, value);\n        }\n    }\n\n    fn set_if_none(\u0026mut self, value: T) {\n        if self.value.is_none() {\n            self.value = Some(value);\n        }\n    }\n\n    fn get(self) -\u003e Option\u003cT\u003e {\n        self.value\n    }\n\n    fn get_with_tokens(self) -\u003e Option\u003c(TokenStream, T)\u003e {\n        match self.value {\n            Some(v) =\u003e Some((self.tokens, v)),\n            None =\u003e None,\n        }\n    }\n}\n\nstruct BoolAttr\u003c'c\u003e(Attr\u003c'c, ()\u003e);\n\nimpl\u003c'c\u003e BoolAttr\u003c'c\u003e {\n    fn none(cx: \u0026'c Ctxt, name: Symbol) -\u003e Self {\n        BoolAttr(Attr::none(cx, name))\n    }\n\n    fn set_true\u003cA: ToTokens\u003e(\u0026mut self, obj: A) {\n        self.0.set(obj, ());\n    }\n\n    fn get(\u0026self) -\u003e bool {\n        self.0.value.is_some()\n    }\n}\n\nstruct VecAttr\u003c'c, T\u003e {\n    cx: \u0026'c Ctxt,\n    name: Symbol,\n    first_dup_tokens: TokenStream,\n    values: Vec\u003cT\u003e,\n}\n\nimpl\u003c'c, T\u003e VecAttr\u003c'c, T\u003e {\n    fn none(cx: \u0026'c Ctxt, name: Symbol) -\u003e Self {\n        VecAttr {\n            cx: cx,\n            name: name,\n            first_dup_tokens: TokenStream::new(),\n            values: Vec::new(),\n        }\n    }\n\n    fn insert\u003cA: ToTokens\u003e(\u0026mut self, obj: A, value: T) {\n        if self.values.len() == 1 {\n            self.first_dup_tokens = obj.into_token_stream();\n        }\n        self.values.push(value);\n    }\n\n    fn at_most_one(mut self) -\u003e Result\u003cOption\u003cT\u003e, ()\u003e {\n        if self.values.len() \u003e 1 {\n            let dup_token = self.first_dup_tokens;\n            self.cx.error_spanned_by(\n                dup_token,\n                format!(\"duplicate serde attribute `{}`\", self.name),\n            );\n            Err(())\n        } else {\n            Ok(self.values.pop())\n        }\n    }\n\n    fn get(self) -\u003e Vec\u003cT\u003e {\n        self.values\n    }\n}\n\npub struct Name {\n    serialize: String,\n    serialize_renamed: bool,\n    deserialize: String,\n    deserialize_renamed: bool,\n    deserialize_aliases: Vec\u003cString\u003e,\n}\n\n#[allow(deprecated)]\nfn unraw(ident: \u0026Ident) -\u003e String {\n    // str::trim_start_matches was added in 1.30, trim_left_matches deprecated\n    // in 1.33. We currently support rustc back to 1.15 so we need to continue\n    // to use the deprecated one.\n    ident.to_string().trim_left_matches(\"r#\").to_owned()\n}\n\nimpl Name {\n    fn from_attrs(\n        source_name: String,\n        ser_name: Attr\u003cString\u003e,\n        de_name: Attr\u003cString\u003e,\n        de_aliases: Option\u003cVecAttr\u003cString\u003e\u003e,\n    ) -\u003e Name {\n        let deserialize_aliases = match de_aliases {\n            Some(de_aliases) =\u003e {\n                let mut alias_list = BTreeSet::new();\n                for alias_name in de_aliases.get() {\n                    alias_list.insert(alias_name);\n                }\n                alias_list.into_iter().collect()\n            }\n            None =\u003e Vec::new(),\n        };\n\n        let ser_name = ser_name.get();\n        let ser_renamed = ser_name.is_some();\n        let de_name = de_name.get();\n        let de_renamed = de_name.is_some();\n        Name {\n            serialize: ser_name.unwrap_or_else(|| source_name.clone()),\n            serialize_renamed: ser_renamed,\n            deserialize: de_name.unwrap_or(source_name),\n            deserialize_renamed: de_renamed,\n            deserialize_aliases: deserialize_aliases,\n        }\n    }\n\n    /// Return the container name for the container when serializing.\n    pub fn serialize_name(\u0026self) -\u003e String {\n        self.serialize.clone()\n    }\n\n    /// Return the container name for the container when deserializing.\n    pub fn deserialize_name(\u0026self) -\u003e String {\n        self.deserialize.clone()\n    }\n\n    fn deserialize_aliases(\u0026self) -\u003e Vec\u003cString\u003e {\n        let mut aliases = self.deserialize_aliases.clone();\n        let main_name = self.deserialize_name();\n        if !aliases.contains(\u0026main_name) {\n            aliases.push(main_name);\n        }\n        aliases\n    }\n}\n\npub struct RenameAllRules {\n    serialize: RenameRule,\n    deserialize: RenameRule,\n}\n\n/// Represents struct or enum attribute information.\npub struct Container {\n    name: Name,\n    transparent: bool,\n    deny_unknown_fields: bool,\n    default: Default,\n    rename_all_rules: RenameAllRules,\n    ser_bound: Option\u003cVec\u003csyn::WherePredicate\u003e\u003e,\n    de_bound: Option\u003cVec\u003csyn::WherePredicate\u003e\u003e,\n    tag: TagType,\n    type_from: Option\u003csyn::Type\u003e,\n    type_try_from: Option\u003csyn::Type\u003e,\n    type_into: Option\u003csyn::Type\u003e,\n    remote: Option\u003csyn::Path\u003e,\n    identifier: Identifier,\n    has_flatten: bool,\n    serde_path: Option\u003csyn::Path\u003e,\n}\n\n/// Styles of representing an enum.\npub enum TagType {\n    /// The default.\n    ///\n    /// ```json\n    /// {\"variant1\": {\"key1\": \"value1\", \"key2\": \"value2\"}}\n    /// ```\n    External,\n\n    /// `#[serde(tag = \"type\")]`\n    ///\n    /// ```json\n    /// {\"type\": \"variant1\", \"key1\": \"value1\", \"key2\": \"value2\"}\n    /// ```\n    Internal { tag: String },\n\n    /// `#[serde(tag = \"t\", content = \"c\")]`\n    ///\n    /// ```json\n    /// {\"t\": \"variant1\", \"c\": {\"key1\": \"value1\", \"key2\": \"value2\"}}\n    /// ```\n    Adjacent { tag: String, content: String },\n\n    /// `#[serde(untagged)]`\n    ///\n    /// ```json\n    /// {\"key1\": \"value1\", \"key2\": \"value2\"}\n    /// ```\n    None,\n}\n\n/// Whether this enum represents the fields of a struct or the variants of an\n/// enum.\n#[derive(Copy, Clone)]\npub enum Identifier {\n    /// It does not.\n    No,\n\n    /// This enum represents the fields of a struct. All of the variants must be\n    /// unit variants, except possibly one which is annotated with\n    /// `#[serde(other)]` and is a newtype variant.\n    Field,\n\n    /// This enum represents the variants of an enum. All of the variants must\n    /// be unit variants.\n    Variant,\n}\n\nimpl Identifier {\n    #[cfg(feature = \"deserialize_in_place\")]\n    pub fn is_some(self) -\u003e bool {\n        match self {\n            Identifier::No =\u003e false,\n            Identifier::Field | Identifier::Variant =\u003e true,\n        }\n    }\n}\n\nimpl Container {\n    /// Extract out the `#[serde(...)]` attributes from an item.\n    pub fn from_ast(cx: \u0026Ctxt, item: \u0026syn::DeriveInput) -\u003e Self {\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut transparent = BoolAttr::none(cx, TRANSPARENT);\n        let mut deny_unknown_fields = BoolAttr::none(cx, DENY_UNKNOWN_FIELDS);\n        let mut default = Attr::none(cx, DEFAULT);\n        let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);\n        let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut untagged = BoolAttr::none(cx, UNTAGGED);\n        let mut internal_tag = Attr::none(cx, TAG);\n        let mut content = Attr::none(cx, CONTENT);\n        let mut type_from = Attr::none(cx, FROM);\n        let mut type_try_from = Attr::none(cx, TRY_FROM);\n        let mut type_into = Attr::none(cx, INTO);\n        let mut remote = Attr::none(cx, REMOTE);\n        let mut field_identifier = BoolAttr::none(cx, FIELD_IDENTIFIER);\n        let mut variant_identifier = BoolAttr::none(cx, VARIANT_IDENTIFIER);\n        let mut serde_path = Attr::none(cx, CRATE);\n\n        for meta_items in item.attrs.iter().filter_map(get_serde_meta_items) {\n            for meta_item in meta_items {\n                match meta_item {\n                    // Parse `#[serde(rename = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME =\u003e {\n                        if let Ok(s) = get_lit_str(cx, RENAME, \u0026m.lit) {\n                            ser_name.set(\u0026m.path, s.value());\n                            de_name.set(\u0026m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME =\u003e {\n                        if let Ok((ser, de)) = get_renames(cx, \u0026m.nested) {\n                            ser_name.set_opt(\u0026m.path, ser.map(syn::LitStr::value));\n                            de_name.set_opt(\u0026m.path, de.map(syn::LitStr::value));\n                        }\n                    }\n\n                    // Parse `#[serde(rename_all = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME_ALL =\u003e {\n                        if let Ok(s) = get_lit_str(cx, RENAME_ALL, \u0026m.lit) {\n                            match RenameRule::from_str(\u0026s.value()) {\n                                Ok(rename_rule) =\u003e {\n                                    rename_all_ser_rule.set(\u0026m.path, rename_rule);\n                                    rename_all_de_rule.set(\u0026m.path, rename_rule);\n                                }\n                                Err(()) =\u003e cx.error_spanned_by(\n                                    s,\n                                    format!(\n                                        \"unknown rename rule for #[serde(rename_all \\\n                                         = {:?})]\",\n                                        s.value(),\n                                    ),\n                                ),\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME_ALL =\u003e {\n                        if let Ok((ser, de)) = get_renames(cx, \u0026m.nested) {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(\u0026ser.value()) {\n                                    Ok(rename_rule) =\u003e {\n                                        rename_all_ser_rule.set(\u0026m.path, rename_rule)\n                                    }\n                                    Err(()) =\u003e cx.error_spanned_by(\n                                        ser,\n                                        format!(\n                                            \"unknown rename rule for #[serde(rename_all \\\n                                             = {:?})]\",\n                                            ser.value(),\n                                        ),\n                                    ),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(\u0026de.value()) {\n                                    Ok(rename_rule) =\u003e rename_all_de_rule.set(\u0026m.path, rename_rule),\n                                    Err(()) =\u003e cx.error_spanned_by(\n                                        de,\n                                        format!(\n                                            \"unknown rename rule for #[serde(rename_all \\\n                                             = {:?})]\",\n                                            de.value(),\n                                        ),\n                                    ),\n                                }\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(transparent)]`\n                    Meta(Path(ref word)) if word == TRANSPARENT =\u003e {\n                        transparent.set_true(word);\n                    }\n\n                    // Parse `#[serde(deny_unknown_fields)]`\n                    Meta(Path(ref word)) if word == DENY_UNKNOWN_FIELDS =\u003e {\n                        deny_unknown_fields.set_true(word);\n                    }\n\n                    // Parse `#[serde(default)]`\n                    Meta(Path(ref word)) if word == DEFAULT =\u003e match item.data {\n                        syn::Data::Struct(syn::DataStruct { ref fields, .. }) =\u003e match *fields {\n                            syn::Fields::Named(_) =\u003e {\n                                default.set(word, Default::Default);\n                            }\n                            syn::Fields::Unnamed(_) | syn::Fields::Unit =\u003e cx.error_spanned_by(\n                                fields,\n                                \"#[serde(default)] can only be used on structs \\\n                                 with named fields\",\n                            ),\n                        },\n                        syn::Data::Enum(syn::DataEnum { ref enum_token, .. }) =\u003e cx\n                            .error_spanned_by(\n                                enum_token,\n                                \"#[serde(default)] can only be used on structs \\\n                                 with named fields\",\n                            ),\n                        syn::Data::Union(syn::DataUnion {\n                            ref union_token, ..\n                        }) =\u003e cx.error_spanned_by(\n                            union_token,\n                            \"#[serde(default)] can only be used on structs \\\n                             with named fields\",\n                        ),\n                    },\n\n                    // Parse `#[serde(default = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == DEFAULT =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, DEFAULT, \u0026m.lit) {\n                            match item.data {\n                                syn::Data::Struct(syn::DataStruct { ref fields, .. }) =\u003e {\n                                    match *fields {\n                                        syn::Fields::Named(_) =\u003e {\n                                            default.set(\u0026m.path, Default::Path(path));\n                                        }\n                                        syn::Fields::Unnamed(_) | syn::Fields::Unit =\u003e cx\n                                            .error_spanned_by(\n                                                fields,\n                                                \"#[serde(default = \\\"...\\\")] can only be used \\\n                                                 on structs with named fields\",\n                                            ),\n                                    }\n                                }\n                                syn::Data::Enum(syn::DataEnum { ref enum_token, .. }) =\u003e cx\n                                    .error_spanned_by(\n                                        enum_token,\n                                        \"#[serde(default = \\\"...\\\")] can only be used \\\n                                         on structs with named fields\",\n                                    ),\n                                syn::Data::Union(syn::DataUnion {\n                                    ref union_token, ..\n                                }) =\u003e cx.error_spanned_by(\n                                    union_token,\n                                    \"#[serde(default = \\\"...\\\")] can only be used \\\n                                     on structs with named fields\",\n                                ),\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(bound = \"T: SomeBound\")]`\n                    Meta(NameValue(ref m)) if m.path == BOUND =\u003e {\n                        if let Ok(where_predicates) = parse_lit_into_where(cx, BOUND, BOUND, \u0026m.lit)\n                        {\n                            ser_bound.set(\u0026m.path, where_predicates.clone());\n                            de_bound.set(\u0026m.path, where_predicates);\n                        }\n                    }\n\n                    // Parse `#[serde(bound(serialize = \"...\", deserialize = \"...\"))]`\n                    Meta(List(ref m)) if m.path == BOUND =\u003e {\n                        if let Ok((ser, de)) = get_where_predicates(cx, \u0026m.nested) {\n                            ser_bound.set_opt(\u0026m.path, ser);\n                            de_bound.set_opt(\u0026m.path, de);\n                        }\n                    }\n\n                    // Parse `#[serde(untagged)]`\n                    Meta(Path(ref word)) if word == UNTAGGED =\u003e match item.data {\n                        syn::Data::Enum(_) =\u003e {\n                            untagged.set_true(word);\n                        }\n                        syn::Data::Struct(syn::DataStruct {\n                            ref struct_token, ..\n                        }) =\u003e {\n                            cx.error_spanned_by(\n                                struct_token,\n                                \"#[serde(untagged)] can only be used on enums\",\n                            );\n                        }\n                        syn::Data::Union(syn::DataUnion {\n                            ref union_token, ..\n                        }) =\u003e {\n                            cx.error_spanned_by(\n                                union_token,\n                                \"#[serde(untagged)] can only be used on enums\",\n                            );\n                        }\n                    },\n\n                    // Parse `#[serde(tag = \"type\")]`\n                    Meta(NameValue(ref m)) if m.path == TAG =\u003e {\n                        if let Ok(s) = get_lit_str(cx, TAG, \u0026m.lit) {\n                            match item.data {\n                                syn::Data::Enum(_) =\u003e {\n                                    internal_tag.set(\u0026m.path, s.value());\n                                }\n                                syn::Data::Struct(syn::DataStruct { ref fields, .. }) =\u003e {\n                                    match *fields {\n                                        syn::Fields::Named(_) =\u003e {\n                                            internal_tag.set(\u0026m.path, s.value());\n                                        }\n                                        syn::Fields::Unnamed(_) | syn::Fields::Unit =\u003e {\n                                            cx.error_spanned_by(\n                                                fields,\n                                                \"#[serde(tag = \\\"...\\\")] can only be used on enums \\\n                                                and structs with named fields\",\n                                            );\n                                        }\n                                    }\n                                }\n                                syn::Data::Union(syn::DataUnion {\n                                    ref union_token, ..\n                                }) =\u003e {\n                                    cx.error_spanned_by(\n                                        union_token,\n                                        \"#[serde(tag = \\\"...\\\")] can only be used on enums \\\n                                         and structs with named fields\",\n                                    );\n                                }\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(content = \"c\")]`\n                    Meta(NameValue(ref m)) if m.path == CONTENT =\u003e {\n                        if let Ok(s) = get_lit_str(cx, CONTENT, \u0026m.lit) {\n                            match item.data {\n                                syn::Data::Enum(_) =\u003e {\n                                    content.set(\u0026m.path, s.value());\n                                }\n                                syn::Data::Struct(syn::DataStruct {\n                                    ref struct_token, ..\n                                }) =\u003e {\n                                    cx.error_spanned_by(\n                                        struct_token,\n                                        \"#[serde(content = \\\"...\\\")] can only be used on enums\",\n                                    );\n                                }\n                                syn::Data::Union(syn::DataUnion {\n                                    ref union_token, ..\n                                }) =\u003e {\n                                    cx.error_spanned_by(\n                                        union_token,\n                                        \"#[serde(content = \\\"...\\\")] can only be used on enums\",\n                                    );\n                                }\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(from = \"Type\")]\n                    Meta(NameValue(ref m)) if m.path == FROM =\u003e {\n                        if let Ok(from_ty) = parse_lit_into_ty(cx, FROM, \u0026m.lit) {\n                            type_from.set_opt(\u0026m.path, Some(from_ty));\n                        }\n                    }\n\n                    // Parse `#[serde(try_from = \"Type\")]\n                    Meta(NameValue(ref m)) if m.path == TRY_FROM =\u003e {\n                        if let Ok(try_from_ty) = parse_lit_into_ty(cx, TRY_FROM, \u0026m.lit) {\n                            type_try_from.set_opt(\u0026m.path, Some(try_from_ty));\n                        }\n                    }\n\n                    // Parse `#[serde(into = \"Type\")]\n                    Meta(NameValue(ref m)) if m.path == INTO =\u003e {\n                        if let Ok(into_ty) = parse_lit_into_ty(cx, INTO, \u0026m.lit) {\n                            type_into.set_opt(\u0026m.path, Some(into_ty));\n                        }\n                    }\n\n                    // Parse `#[serde(remote = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == REMOTE =\u003e {\n                        if let Ok(path) = parse_lit_into_path(cx, REMOTE, \u0026m.lit) {\n                            if is_primitive_path(\u0026path, \"Self\") {\n                                remote.set(\u0026m.path, item.ident.clone().into());\n                            } else {\n                                remote.set(\u0026m.path, path);\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(field_identifier)]`\n                    Meta(Path(ref word)) if word == FIELD_IDENTIFIER =\u003e {\n                        field_identifier.set_true(word);\n                    }\n\n                    // Parse `#[serde(variant_identifier)]`\n                    Meta(Path(ref word)) if word == VARIANT_IDENTIFIER =\u003e {\n                        variant_identifier.set_true(word);\n                    }\n\n                    // Parse `#[serde(crate = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == CRATE =\u003e {\n                        if let Ok(path) = parse_lit_into_path(cx, CRATE, \u0026m.lit) {\n                            serde_path.set(\u0026m.path, path)\n                        }\n                    }\n\n                    Meta(ref meta_item) =\u003e {\n                        let path = meta_item\n                            .path()\n                            .into_token_stream()\n                            .to_string()\n                            .replace(' ', \"\");\n                        cx.error_spanned_by(\n                            meta_item.path(),\n                            format!(\"unknown serde container attribute `{}`\", path),\n                        );\n                    }\n\n                    Lit(ref lit) =\u003e {\n                        cx.error_spanned_by(lit, \"unexpected literal in serde container attribute\");\n                    }\n                }\n            }\n        }\n\n        Container {\n            name: Name::from_attrs(unraw(\u0026item.ident), ser_name, de_name, None),\n            transparent: transparent.get(),\n            deny_unknown_fields: deny_unknown_fields.get(),\n            default: default.get().unwrap_or(Default::None),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            tag: decide_tag(cx, item, untagged, internal_tag, content),\n            type_from: type_from.get(),\n            type_try_from: type_try_from.get(),\n            type_into: type_into.get(),\n            remote: remote.get(),\n            identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n            has_flatten: false,\n            serde_path: serde_path.get(),\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026Name {\n        \u0026self.name\n    }\n\n    pub fn rename_all_rules(\u0026self) -\u003e \u0026RenameAllRules {\n        \u0026self.rename_all_rules\n    }\n\n    pub fn transparent(\u0026self) -\u003e bool {\n        self.transparent\n    }\n\n    pub fn deny_unknown_fields(\u0026self) -\u003e bool {\n        self.deny_unknown_fields\n    }\n\n    pub fn default(\u0026self) -\u003e \u0026Default {\n        \u0026self.default\n    }\n\n    pub fn ser_bound(\u0026self) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e {\n        self.ser_bound.as_ref().map(|vec| \u0026vec[..])\n    }\n\n    pub fn de_bound(\u0026self) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e {\n        self.de_bound.as_ref().map(|vec| \u0026vec[..])\n    }\n\n    pub fn tag(\u0026self) -\u003e \u0026TagType {\n        \u0026self.tag\n    }\n\n    pub fn type_from(\u0026self) -\u003e Option\u003c\u0026syn::Type\u003e {\n        self.type_from.as_ref()\n    }\n\n    pub fn type_try_from(\u0026self) -\u003e Option\u003c\u0026syn::Type\u003e {\n        self.type_try_from.as_ref()\n    }\n\n    pub fn type_into(\u0026self) -\u003e Option\u003c\u0026syn::Type\u003e {\n        self.type_into.as_ref()\n    }\n\n    pub fn remote(\u0026self) -\u003e Option\u003c\u0026syn::Path\u003e {\n        self.remote.as_ref()\n    }\n\n    pub fn identifier(\u0026self) -\u003e Identifier {\n        self.identifier\n    }\n\n    pub fn has_flatten(\u0026self) -\u003e bool {\n        self.has_flatten\n    }\n\n    pub fn mark_has_flatten(\u0026mut self) {\n        self.has_flatten = true;\n    }\n\n    pub fn custom_serde_path(\u0026self) -\u003e Option\u003c\u0026syn::Path\u003e {\n        self.serde_path.as_ref()\n    }\n\n    pub fn serde_path(\u0026self) -\u003e Cow\u003csyn::Path\u003e {\n        self.custom_serde_path()\n            .map_or_else(|| Cow::Owned(parse_quote!(_serde)), Cow::Borrowed)\n    }\n}\n\nfn decide_tag(\n    cx: \u0026Ctxt,\n    item: \u0026syn::DeriveInput,\n    untagged: BoolAttr,\n    internal_tag: Attr\u003cString\u003e,\n    content: Attr\u003cString\u003e,\n) -\u003e TagType {\n    match (\n        untagged.0.get_with_tokens(),\n        internal_tag.get_with_tokens(),\n        content.get_with_tokens(),\n    ) {\n        (None, None, None) =\u003e TagType::External,\n        (Some(_), None, None) =\u003e TagType::None,\n        (None, Some((_, tag)), None) =\u003e {\n            // Check that there are no tuple variants.\n            if let syn::Data::Enum(ref data) = item.data {\n                for variant in \u0026data.variants {\n                    match variant.fields {\n                        syn::Fields::Named(_) | syn::Fields::Unit =\u003e {}\n                        syn::Fields::Unnamed(ref fields) =\u003e {\n                            if fields.unnamed.len() != 1 {\n                                cx.error_spanned_by(\n                                    variant,\n                                    \"#[serde(tag = \\\"...\\\")] cannot be used with tuple \\\n                                     variants\",\n                                );\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            TagType::Internal { tag: tag }\n        }\n        (Some((untagged_tokens, _)), Some((tag_tokens, _)), None) =\u003e {\n            cx.error_spanned_by(\n                untagged_tokens,\n                \"enum cannot be both untagged and internally tagged\",\n            );\n            cx.error_spanned_by(\n                tag_tokens,\n                \"enum cannot be both untagged and internally tagged\",\n            );\n            TagType::External // doesn't matter, will error\n        }\n        (None, None, Some((content_tokens, _))) =\u003e {\n            cx.error_spanned_by(\n                content_tokens,\n                \"#[serde(tag = \\\"...\\\", content = \\\"...\\\")] must be used together\",\n            );\n            TagType::External\n        }\n        (Some((untagged_tokens, _)), None, Some((content_tokens, _))) =\u003e {\n            cx.error_spanned_by(\n                untagged_tokens,\n                \"untagged enum cannot have #[serde(content = \\\"...\\\")]\",\n            );\n            cx.error_spanned_by(\n                content_tokens,\n                \"untagged enum cannot have #[serde(content = \\\"...\\\")]\",\n            );\n            TagType::External\n        }\n        (None, Some((_, tag)), Some((_, content))) =\u003e TagType::Adjacent {\n            tag: tag,\n            content: content,\n        },\n        (Some((untagged_tokens, _)), Some((tag_tokens, _)), Some((content_tokens, _))) =\u003e {\n            cx.error_spanned_by(\n                untagged_tokens,\n                \"untagged enum cannot have #[serde(tag = \\\"...\\\", content = \\\"...\\\")]\",\n            );\n            cx.error_spanned_by(\n                tag_tokens,\n                \"untagged enum cannot have #[serde(tag = \\\"...\\\", content = \\\"...\\\")]\",\n            );\n            cx.error_spanned_by(\n                content_tokens,\n                \"untagged enum cannot have #[serde(tag = \\\"...\\\", content = \\\"...\\\")]\",\n            );\n            TagType::External\n        }\n    }\n}\n\nfn decide_identifier(\n    cx: \u0026Ctxt,\n    item: \u0026syn::DeriveInput,\n    field_identifier: BoolAttr,\n    variant_identifier: BoolAttr,\n) -\u003e Identifier {\n    match (\n        \u0026item.data,\n        field_identifier.0.get_with_tokens(),\n        variant_identifier.0.get_with_tokens(),\n    ) {\n        (_, None, None) =\u003e Identifier::No,\n        (_, Some((field_identifier_tokens, _)), Some((variant_identifier_tokens, _))) =\u003e {\n            cx.error_spanned_by(\n                field_identifier_tokens,\n                \"#[serde(field_identifier)] and #[serde(variant_identifier)] cannot both be set\",\n            );\n            cx.error_spanned_by(\n                variant_identifier_tokens,\n                \"#[serde(field_identifier)] and #[serde(variant_identifier)] cannot both be set\",\n            );\n            Identifier::No\n        }\n        (\u0026syn::Data::Enum(_), Some(_), None) =\u003e Identifier::Field,\n        (\u0026syn::Data::Enum(_), None, Some(_)) =\u003e Identifier::Variant,\n        (\n            \u0026syn::Data::Struct(syn::DataStruct {\n                ref struct_token, ..\n            }),\n            Some(_),\n            None,\n        ) =\u003e {\n            cx.error_spanned_by(\n                struct_token,\n                \"#[serde(field_identifier)] can only be used on an enum\",\n            );\n            Identifier::No\n        }\n        (\n            \u0026syn::Data::Union(syn::DataUnion {\n                ref union_token, ..\n            }),\n            Some(_),\n            None,\n        ) =\u003e {\n            cx.error_spanned_by(\n                union_token,\n                \"#[serde(field_identifier)] can only be used on an enum\",\n            );\n            Identifier::No\n        }\n        (\n            \u0026syn::Data::Struct(syn::DataStruct {\n                ref struct_token, ..\n            }),\n            None,\n            Some(_),\n        ) =\u003e {\n            cx.error_spanned_by(\n                struct_token,\n                \"#[serde(variant_identifier)] can only be used on an enum\",\n            );\n            Identifier::No\n        }\n        (\n            \u0026syn::Data::Union(syn::DataUnion {\n                ref union_token, ..\n            }),\n            None,\n            Some(_),\n        ) =\u003e {\n            cx.error_spanned_by(\n                union_token,\n                \"#[serde(variant_identifier)] can only be used on an enum\",\n            );\n            Identifier::No\n        }\n    }\n}\n\n/// Represents variant attribute information\npub struct Variant {\n    name: Name,\n    rename_all_rules: RenameAllRules,\n    ser_bound: Option\u003cVec\u003csyn::WherePredicate\u003e\u003e,\n    de_bound: Option\u003cVec\u003csyn::WherePredicate\u003e\u003e,\n    skip_deserializing: bool,\n    skip_serializing: bool,\n    other: bool,\n    serialize_with: Option\u003csyn::ExprPath\u003e,\n    deserialize_with: Option\u003csyn::ExprPath\u003e,\n    borrow: Option\u003csyn::Meta\u003e,\n}\n\nimpl Variant {\n    pub fn from_ast(cx: \u0026Ctxt, variant: \u0026syn::Variant) -\u003e Self {\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut de_aliases = VecAttr::none(cx, RENAME);\n        let mut skip_deserializing = BoolAttr::none(cx, SKIP_DESERIALIZING);\n        let mut skip_serializing = BoolAttr::none(cx, SKIP_SERIALIZING);\n        let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);\n        let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut other = BoolAttr::none(cx, OTHER);\n        let mut serialize_with = Attr::none(cx, SERIALIZE_WITH);\n        let mut deserialize_with = Attr::none(cx, DESERIALIZE_WITH);\n        let mut borrow = Attr::none(cx, BORROW);\n\n        for meta_items in variant.attrs.iter().filter_map(get_serde_meta_items) {\n            for meta_item in meta_items {\n                match meta_item {\n                    // Parse `#[serde(rename = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME =\u003e {\n                        if let Ok(s) = get_lit_str(cx, RENAME, \u0026m.lit) {\n                            ser_name.set(\u0026m.path, s.value());\n                            de_name.set_if_none(s.value());\n                            de_aliases.insert(\u0026m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME =\u003e {\n                        if let Ok((ser, de)) = get_multiple_renames(cx, \u0026m.nested) {\n                            ser_name.set_opt(\u0026m.path, ser.map(syn::LitStr::value));\n                            for de_value in de {\n                                de_name.set_if_none(de_value.value());\n                                de_aliases.insert(\u0026m.path, de_value.value());\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(alias = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == ALIAS =\u003e {\n                        if let Ok(s) = get_lit_str(cx, ALIAS, \u0026m.lit) {\n                            de_aliases.insert(\u0026m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(rename_all = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME_ALL =\u003e {\n                        if let Ok(s) = get_lit_str(cx, RENAME_ALL, \u0026m.lit) {\n                            match RenameRule::from_str(\u0026s.value()) {\n                                Ok(rename_rule) =\u003e {\n                                    rename_all_ser_rule.set(\u0026m.path, rename_rule);\n                                    rename_all_de_rule.set(\u0026m.path, rename_rule);\n                                }\n                                Err(()) =\u003e cx.error_spanned_by(\n                                    s,\n                                    format!(\n                                        \"unknown rename rule for #[serde(rename_all \\\n                                         = {:?})]\",\n                                        s.value()\n                                    ),\n                                ),\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(rename_all(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME_ALL =\u003e {\n                        if let Ok((ser, de)) = get_renames(cx, \u0026m.nested) {\n                            if let Some(ser) = ser {\n                                match RenameRule::from_str(\u0026ser.value()) {\n                                    Ok(rename_rule) =\u003e {\n                                        rename_all_ser_rule.set(\u0026m.path, rename_rule)\n                                    }\n                                    Err(()) =\u003e cx.error_spanned_by(\n                                        ser,\n                                        format!(\n                                            \"unknown rename rule for #[serde(rename_all \\\n                                             = {:?})]\",\n                                            ser.value(),\n                                        ),\n                                    ),\n                                }\n                            }\n                            if let Some(de) = de {\n                                match RenameRule::from_str(\u0026de.value()) {\n                                    Ok(rename_rule) =\u003e rename_all_de_rule.set(\u0026m.path, rename_rule),\n                                    Err(()) =\u003e cx.error_spanned_by(\n                                        de,\n                                        format!(\n                                            \"unknown rename rule for #[serde(rename_all \\\n                                             = {:?})]\",\n                                            de.value(),\n                                        ),\n                                    ),\n                                }\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(skip)]`\n                    Meta(Path(ref word)) if word == SKIP =\u003e {\n                        skip_serializing.set_true(word);\n                        skip_deserializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip_deserializing)]`\n                    Meta(Path(ref word)) if word == SKIP_DESERIALIZING =\u003e {\n                        skip_deserializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip_serializing)]`\n                    Meta(Path(ref word)) if word == SKIP_SERIALIZING =\u003e {\n                        skip_serializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(other)]`\n                    Meta(Path(ref word)) if word == OTHER =\u003e {\n                        other.set_true(word);\n                    }\n\n                    // Parse `#[serde(bound = \"T: SomeBound\")]`\n                    Meta(NameValue(ref m)) if m.path == BOUND =\u003e {\n                        if let Ok(where_predicates) = parse_lit_into_where(cx, BOUND, BOUND, \u0026m.lit)\n                        {\n                            ser_bound.set(\u0026m.path, where_predicates.clone());\n                            de_bound.set(\u0026m.path, where_predicates);\n                        }\n                    }\n\n                    // Parse `#[serde(bound(serialize = \"...\", deserialize = \"...\"))]`\n                    Meta(List(ref m)) if m.path == BOUND =\u003e {\n                        if let Ok((ser, de)) = get_where_predicates(cx, \u0026m.nested) {\n                            ser_bound.set_opt(\u0026m.path, ser);\n                            de_bound.set_opt(\u0026m.path, de);\n                        }\n                    }\n\n                    // Parse `#[serde(with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == WITH =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, WITH, \u0026m.lit) {\n                            let mut ser_path = path.clone();\n                            ser_path\n                                .path\n                                .segments\n                                .push(Ident::new(\"serialize\", Span::call_site()).into());\n                            serialize_with.set(\u0026m.path, ser_path);\n                            let mut de_path = path;\n                            de_path\n                                .path\n                                .segments\n                                .push(Ident::new(\"deserialize\", Span::call_site()).into());\n                            deserialize_with.set(\u0026m.path, de_path);\n                        }\n                    }\n\n                    // Parse `#[serde(serialize_with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == SERIALIZE_WITH =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, \u0026m.lit) {\n                            serialize_with.set(\u0026m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(deserialize_with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == DESERIALIZE_WITH =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, \u0026m.lit) {\n                            deserialize_with.set(\u0026m.path, path);\n                        }\n                    }\n\n                    // Defer `#[serde(borrow)]` and `#[serde(borrow = \"'a + 'b\")]`\n                    Meta(ref m) if m.path() == BORROW =\u003e match variant.fields {\n                        syn::Fields::Unnamed(ref fields) if fields.unnamed.len() == 1 =\u003e {\n                            borrow.set(m.path(), m.clone());\n                        }\n                        _ =\u003e {\n                            cx.error_spanned_by(\n                                variant,\n                                \"#[serde(borrow)] may only be used on newtype variants\",\n                            );\n                        }\n                    },\n\n                    Meta(ref meta_item) =\u003e {\n                        let path = meta_item\n                            .path()\n                            .into_token_stream()\n                            .to_string()\n                            .replace(' ', \"\");\n                        cx.error_spanned_by(\n                            meta_item.path(),\n                            format!(\"unknown serde variant attribute `{}`\", path),\n                        );\n                    }\n\n                    Lit(ref lit) =\u003e {\n                        cx.error_spanned_by(lit, \"unexpected literal in serde variant attribute\");\n                    }\n                }\n            }\n        }\n\n        Variant {\n            name: Name::from_attrs(unraw(\u0026variant.ident), ser_name, de_name, Some(de_aliases)),\n            rename_all_rules: RenameAllRules {\n                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n            },\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing: skip_serializing.get(),\n            other: other.get(),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            borrow: borrow.get(),\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026Name {\n        \u0026self.name\n    }\n\n    pub fn aliases(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.name.deserialize_aliases()\n    }\n\n    pub fn rename_by_rules(\u0026mut self, rules: \u0026RenameAllRules) {\n        if !self.name.serialize_renamed {\n            self.name.serialize = rules.serialize.apply_to_variant(\u0026self.name.serialize);\n        }\n        if !self.name.deserialize_renamed {\n            self.name.deserialize = rules.deserialize.apply_to_variant(\u0026self.name.deserialize);\n        }\n    }\n\n    pub fn rename_all_rules(\u0026self) -\u003e \u0026RenameAllRules {\n        \u0026self.rename_all_rules\n    }\n\n    pub fn ser_bound(\u0026self) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e {\n        self.ser_bound.as_ref().map(|vec| \u0026vec[..])\n    }\n\n    pub fn de_bound(\u0026self) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e {\n        self.de_bound.as_ref().map(|vec| \u0026vec[..])\n    }\n\n    pub fn skip_deserializing(\u0026self) -\u003e bool {\n        self.skip_deserializing\n    }\n\n    pub fn skip_serializing(\u0026self) -\u003e bool {\n        self.skip_serializing\n    }\n\n    pub fn other(\u0026self) -\u003e bool {\n        self.other\n    }\n\n    pub fn serialize_with(\u0026self) -\u003e Option\u003c\u0026syn::ExprPath\u003e {\n        self.serialize_with.as_ref()\n    }\n\n    pub fn deserialize_with(\u0026self) -\u003e Option\u003c\u0026syn::ExprPath\u003e {\n        self.deserialize_with.as_ref()\n    }\n}\n\n/// Represents field attribute information\npub struct Field {\n    name: Name,\n    skip_serializing: bool,\n    skip_deserializing: bool,\n    skip_serializing_if: Option\u003csyn::ExprPath\u003e,\n    default: Default,\n    serialize_with: Option\u003csyn::ExprPath\u003e,\n    deserialize_with: Option\u003csyn::ExprPath\u003e,\n    ser_bound: Option\u003cVec\u003csyn::WherePredicate\u003e\u003e,\n    de_bound: Option\u003cVec\u003csyn::WherePredicate\u003e\u003e,\n    borrowed_lifetimes: BTreeSet\u003csyn::Lifetime\u003e,\n    getter: Option\u003csyn::ExprPath\u003e,\n    flatten: bool,\n    transparent: bool,\n}\n\n/// Represents the default to use for a field when deserializing.\npub enum Default {\n    /// Field must always be specified because it does not have a default.\n    None,\n    /// The default is given by `std::default::Default::default()`.\n    Default,\n    /// The default is given by this function.\n    Path(syn::ExprPath),\n}\n\nimpl Default {\n    pub fn is_none(\u0026self) -\u003e bool {\n        match *self {\n            Default::None =\u003e true,\n            Default::Default | Default::Path(_) =\u003e false,\n        }\n    }\n}\n\nimpl Field {\n    /// Extract out the `#[serde(...)]` attributes from a struct field.\n    pub fn from_ast(\n        cx: \u0026Ctxt,\n        index: usize,\n        field: \u0026syn::Field,\n        attrs: Option\u003c\u0026Variant\u003e,\n        container_default: \u0026Default,\n    ) -\u003e Self {\n        let mut ser_name = Attr::none(cx, RENAME);\n        let mut de_name = Attr::none(cx, RENAME);\n        let mut de_aliases = VecAttr::none(cx, RENAME);\n        let mut skip_serializing = BoolAttr::none(cx, SKIP_SERIALIZING);\n        let mut skip_deserializing = BoolAttr::none(cx, SKIP_DESERIALIZING);\n        let mut skip_serializing_if = Attr::none(cx, SKIP_SERIALIZING_IF);\n        let mut default = Attr::none(cx, DEFAULT);\n        let mut serialize_with = Attr::none(cx, SERIALIZE_WITH);\n        let mut deserialize_with = Attr::none(cx, DESERIALIZE_WITH);\n        let mut ser_bound = Attr::none(cx, BOUND);\n        let mut de_bound = Attr::none(cx, BOUND);\n        let mut borrowed_lifetimes = Attr::none(cx, BORROW);\n        let mut getter = Attr::none(cx, GETTER);\n        let mut flatten = BoolAttr::none(cx, FLATTEN);\n\n        let ident = match field.ident {\n            Some(ref ident) =\u003e unraw(ident),\n            None =\u003e index.to_string(),\n        };\n\n        let variant_borrow = attrs\n            .and_then(|variant| variant.borrow.as_ref())\n            .map(|borrow| vec![Meta(borrow.clone())]);\n\n        for meta_items in field\n            .attrs\n            .iter()\n            .filter_map(get_serde_meta_items)\n            .chain(variant_borrow)\n        {\n            for meta_item in meta_items {\n                match meta_item {\n                    // Parse `#[serde(rename = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == RENAME =\u003e {\n                        if let Ok(s) = get_lit_str(cx, RENAME, \u0026m.lit) {\n                            ser_name.set(\u0026m.path, s.value());\n                            de_name.set_if_none(s.value());\n                            de_aliases.insert(\u0026m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(rename(serialize = \"foo\", deserialize = \"bar\"))]`\n                    Meta(List(ref m)) if m.path == RENAME =\u003e {\n                        if let Ok((ser, de)) = get_multiple_renames(cx, \u0026m.nested) {\n                            ser_name.set_opt(\u0026m.path, ser.map(syn::LitStr::value));\n                            for de_value in de {\n                                de_name.set_if_none(de_value.value());\n                                de_aliases.insert(\u0026m.path, de_value.value());\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(alias = \"foo\")]`\n                    Meta(NameValue(ref m)) if m.path == ALIAS =\u003e {\n                        if let Ok(s) = get_lit_str(cx, ALIAS, \u0026m.lit) {\n                            de_aliases.insert(\u0026m.path, s.value());\n                        }\n                    }\n\n                    // Parse `#[serde(default)]`\n                    Meta(Path(ref word)) if word == DEFAULT =\u003e {\n                        default.set(word, Default::Default);\n                    }\n\n                    // Parse `#[serde(default = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == DEFAULT =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, DEFAULT, \u0026m.lit) {\n                            default.set(\u0026m.path, Default::Path(path));\n                        }\n                    }\n\n                    // Parse `#[serde(skip_serializing)]`\n                    Meta(Path(ref word)) if word == SKIP_SERIALIZING =\u003e {\n                        skip_serializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip_deserializing)]`\n                    Meta(Path(ref word)) if word == SKIP_DESERIALIZING =\u003e {\n                        skip_deserializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip)]`\n                    Meta(Path(ref word)) if word == SKIP =\u003e {\n                        skip_serializing.set_true(word);\n                        skip_deserializing.set_true(word);\n                    }\n\n                    // Parse `#[serde(skip_serializing_if = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == SKIP_SERIALIZING_IF =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, SKIP_SERIALIZING_IF, \u0026m.lit)\n                        {\n                            skip_serializing_if.set(\u0026m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(serialize_with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == SERIALIZE_WITH =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, SERIALIZE_WITH, \u0026m.lit) {\n                            serialize_with.set(\u0026m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(deserialize_with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == DESERIALIZE_WITH =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, DESERIALIZE_WITH, \u0026m.lit) {\n                            deserialize_with.set(\u0026m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(with = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == WITH =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, WITH, \u0026m.lit) {\n                            let mut ser_path = path.clone();\n                            ser_path\n                                .path\n                                .segments\n                                .push(Ident::new(\"serialize\", Span::call_site()).into());\n                            serialize_with.set(\u0026m.path, ser_path);\n                            let mut de_path = path;\n                            de_path\n                                .path\n                                .segments\n                                .push(Ident::new(\"deserialize\", Span::call_site()).into());\n                            deserialize_with.set(\u0026m.path, de_path);\n                        }\n                    }\n\n                    // Parse `#[serde(bound = \"T: SomeBound\")]`\n                    Meta(NameValue(ref m)) if m.path == BOUND =\u003e {\n                        if let Ok(where_predicates) = parse_lit_into_where(cx, BOUND, BOUND, \u0026m.lit)\n                        {\n                            ser_bound.set(\u0026m.path, where_predicates.clone());\n                            de_bound.set(\u0026m.path, where_predicates);\n                        }\n                    }\n\n                    // Parse `#[serde(bound(serialize = \"...\", deserialize = \"...\"))]`\n                    Meta(List(ref m)) if m.path == BOUND =\u003e {\n                        if let Ok((ser, de)) = get_where_predicates(cx, \u0026m.nested) {\n                            ser_bound.set_opt(\u0026m.path, ser);\n                            de_bound.set_opt(\u0026m.path, de);\n                        }\n                    }\n\n                    // Parse `#[serde(borrow)]`\n                    Meta(Path(ref word)) if word == BORROW =\u003e {\n                        if let Ok(borrowable) = borrowable_lifetimes(cx, \u0026ident, field) {\n                            borrowed_lifetimes.set(word, borrowable);\n                        }\n                    }\n\n                    // Parse `#[serde(borrow = \"'a + 'b\")]`\n                    Meta(NameValue(ref m)) if m.path == BORROW =\u003e {\n                        if let Ok(lifetimes) = parse_lit_into_lifetimes(cx, BORROW, \u0026m.lit) {\n                            if let Ok(borrowable) = borrowable_lifetimes(cx, \u0026ident, field) {\n                                for lifetime in \u0026lifetimes {\n                                    if !borrowable.contains(lifetime) {\n                                        cx.error_spanned_by(\n                                            field,\n                                            format!(\n                                                \"field `{}` does not have lifetime {}\",\n                                                ident, lifetime\n                                            ),\n                                        );\n                                    }\n                                }\n                                borrowed_lifetimes.set(\u0026m.path, lifetimes);\n                            }\n                        }\n                    }\n\n                    // Parse `#[serde(getter = \"...\")]`\n                    Meta(NameValue(ref m)) if m.path == GETTER =\u003e {\n                        if let Ok(path) = parse_lit_into_expr_path(cx, GETTER, \u0026m.lit) {\n                            getter.set(\u0026m.path, path);\n                        }\n                    }\n\n                    // Parse `#[serde(flatten)]`\n                    Meta(Path(ref word)) if word == FLATTEN =\u003e {\n                        flatten.set_true(word);\n                    }\n\n                    Meta(ref meta_item) =\u003e {\n                        let path = meta_item\n                            .path()\n                            .into_token_stream()\n                            .to_string()\n                            .replace(' ', \"\");\n                        cx.error_spanned_by(\n                            meta_item.path(),\n                            format!(\"unknown serde field attribute `{}`\", path),\n                        );\n                    }\n\n                    Lit(ref lit) =\u003e {\n                        cx.error_spanned_by(lit, \"unexpected literal in serde field attribute\");\n                    }\n                }\n            }\n        }\n\n        // Is skip_deserializing, initialize the field to Default::default() unless a\n        // different default is specified by `#[serde(default = \"...\")]` on\n        // ourselves or our container (e.g. the struct we are in).\n        if let Default::None = *container_default {\n            if skip_deserializing.0.value.is_some() {\n                default.set_if_none(Default::Default);\n            }\n        }\n\n        let mut borrowed_lifetimes = borrowed_lifetimes.get().unwrap_or_default();\n        if !borrowed_lifetimes.is_empty() {\n            // Cow\u003cstr\u003e and Cow\u003c[u8]\u003e never borrow by default:\n            //\n            //     impl\u003c'de, 'a, T: ?Sized\u003e Deserialize\u003c'de\u003e for Cow\u003c'a, T\u003e\n            //\n            // A #[serde(borrow)] attribute enables borrowing that corresponds\n            // roughly to these impls:\n            //\n            //     impl\u003c'de: 'a, 'a\u003e Deserialize\u003c'de\u003e for Cow\u003c'a, str\u003e\n            //     impl\u003c'de: 'a, 'a\u003e Deserialize\u003c'de\u003e for Cow\u003c'a, [u8]\u003e\n            if is_cow(\u0026field.ty, is_str) {\n                let mut path = syn::Path {\n                    leading_colon: None,\n                    segments: Punctuated::new(),\n                };\n                path.segments\n                    .push(Ident::new(\"_serde\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"private\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"de\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"borrow_cow_str\", Span::call_site()).into());\n                let expr = syn::ExprPath {\n                    attrs: Vec::new(),\n                    qself: None,\n                    path: path,\n                };\n                deserialize_with.set_if_none(expr);\n            } else if is_cow(\u0026field.ty, is_slice_u8) {\n                let mut path = syn::Path {\n                    leading_colon: None,\n                    segments: Punctuated::new(),\n                };\n                path.segments\n                    .push(Ident::new(\"_serde\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"private\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"de\", Span::call_site()).into());\n                path.segments\n                    .push(Ident::new(\"borrow_cow_bytes\", Span::call_site()).into());\n                let expr = syn::ExprPath {\n                    attrs: Vec::new(),\n                    qself: None,\n                    path: path,\n                };\n                deserialize_with.set_if_none(expr);\n            }\n        } else if is_implicitly_borrowed(\u0026field.ty) {\n            // Types \u0026str and \u0026[u8] are always implicitly borrowed. No need for\n            // a #[serde(borrow)].\n            collect_lifetimes(\u0026field.ty, \u0026mut borrowed_lifetimes);\n        }\n\n        Field {\n            name: Name::from_attrs(ident, ser_name, de_name, Some(de_aliases)),\n            skip_serializing: skip_serializing.get(),\n            skip_deserializing: skip_deserializing.get(),\n            skip_serializing_if: skip_serializing_if.get(),\n            default: default.get().unwrap_or(Default::None),\n            serialize_with: serialize_with.get(),\n            deserialize_with: deserialize_with.get(),\n            ser_bound: ser_bound.get(),\n            de_bound: de_bound.get(),\n            borrowed_lifetimes: borrowed_lifetimes,\n            getter: getter.get(),\n            flatten: flatten.get(),\n            transparent: false,\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026Name {\n        \u0026self.name\n    }\n\n    pub fn aliases(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.name.deserialize_aliases()\n    }\n\n    pub fn rename_by_rules(\u0026mut self, rules: \u0026RenameAllRules) {\n        if !self.name.serialize_renamed {\n            self.name.serialize = rules.serialize.apply_to_field(\u0026self.name.serialize);\n        }\n        if !self.name.deserialize_renamed {\n            self.name.deserialize = rules.deserialize.apply_to_field(\u0026self.name.deserialize);\n        }\n    }\n\n    pub fn skip_serializing(\u0026self) -\u003e bool {\n        self.skip_serializing\n    }\n\n    pub fn skip_deserializing(\u0026self) -\u003e bool {\n        self.skip_deserializing\n    }\n\n    pub fn skip_serializing_if(\u0026self) -\u003e Option\u003c\u0026syn::ExprPath\u003e {\n        self.skip_serializing_if.as_ref()\n    }\n\n    pub fn default(\u0026self) -\u003e \u0026Default {\n        \u0026self.default\n    }\n\n    pub fn serialize_with(\u0026self) -\u003e Option\u003c\u0026syn::ExprPath\u003e {\n        self.serialize_with.as_ref()\n    }\n\n    pub fn deserialize_with(\u0026self) -\u003e Option\u003c\u0026syn::ExprPath\u003e {\n        self.deserialize_with.as_ref()\n    }\n\n    pub fn ser_bound(\u0026self) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e {\n        self.ser_bound.as_ref().map(|vec| \u0026vec[..])\n    }\n\n    pub fn de_bound(\u0026self) -\u003e Option\u003c\u0026[syn::WherePredicate]\u003e {\n        self.de_bound.as_ref().map(|vec| \u0026vec[..])\n    }\n\n    pub fn borrowed_lifetimes(\u0026self) -\u003e \u0026BTreeSet\u003csyn::Lifetime\u003e {\n        \u0026self.borrowed_lifetimes\n    }\n\n    pub fn getter(\u0026self) -\u003e Option\u003c\u0026syn::ExprPath\u003e {\n        self.getter.as_ref()\n    }\n\n    pub fn flatten(\u0026self) -\u003e bool {\n        self.flatten\n    }\n\n    pub fn transparent(\u0026self) -\u003e bool {\n        self.transparent\n    }\n\n    pub fn mark_transparent(\u0026mut self) {\n        self.transparent = true;\n    }\n}\n\ntype SerAndDe\u003cT\u003e = (Option\u003cT\u003e, Option\u003cT\u003e);\n\nfn get_ser_and_de\u003c'a, 'b, T, F\u003e(\n    cx: \u0026'b Ctxt,\n    attr_name: Symbol,\n    metas: \u0026'a Punctuated\u003csyn::NestedMeta, Token![,]\u003e,\n    f: F,\n) -\u003e Result\u003c(VecAttr\u003c'b, T\u003e, VecAttr\u003c'b, T\u003e), ()\u003e\nwhere\n    T: 'a,\n    F: Fn(\u0026Ctxt, Symbol, Symbol, \u0026'a syn::Lit) -\u003e Result\u003cT, ()\u003e,\n{\n    let mut ser_meta = VecAttr::none(cx, attr_name);\n    let mut de_meta = VecAttr::none(cx, attr_name);\n\n    for meta in metas {\n        match *meta {\n            Meta(NameValue(ref meta)) if meta.path == SERIALIZE =\u003e {\n                if let Ok(v) = f(cx, attr_name, SERIALIZE, \u0026meta.lit) {\n                    ser_meta.insert(\u0026meta.path, v);\n                }\n            }\n\n            Meta(NameValue(ref meta)) if meta.path == DESERIALIZE =\u003e {\n                if let Ok(v) = f(cx, attr_name, DESERIALIZE, \u0026meta.lit) {\n                    de_meta.insert(\u0026meta.path, v);\n                }\n            }\n\n            _ =\u003e {\n                cx.error_spanned_by(\n                    meta,\n                    format!(\n                        \"malformed {0} attribute, expected `{0}(serialize = ..., \\\n                         deserialize = ...)`\",\n                        attr_name\n                    ),\n                );\n                return Err(());\n            }\n        }\n    }\n\n    Ok((ser_meta, de_meta))\n}\n\nfn get_renames\u003c'a\u003e(\n    cx: \u0026Ctxt,\n    items: \u0026'a Punctuated\u003csyn::NestedMeta, Token![,]\u003e,\n) -\u003e Result\u003cSerAndDe\u003c\u0026'a syn::LitStr\u003e, ()\u003e {\n    let (ser, de) = get_ser_and_de(cx, RENAME, items, get_lit_str2)?;\n    Ok((ser.at_most_one()?, de.at_most_one()?))\n}\n\nfn get_multiple_renames\u003c'a\u003e(\n    cx: \u0026Ctxt,\n    items: \u0026'a Punctuated\u003csyn::NestedMeta, Token![,]\u003e,\n) -\u003e Result\u003c(Option\u003c\u0026'a syn::LitStr\u003e, Vec\u003c\u0026'a syn::LitStr\u003e), ()\u003e {\n    let (ser, de) = get_ser_and_de(cx, RENAME, items, get_lit_str2)?;\n    Ok((ser.at_most_one()?, de.get()))\n}\n\nfn get_where_predicates(\n    cx: \u0026Ctxt,\n    items: \u0026Punctuated\u003csyn::NestedMeta, Token![,]\u003e,\n) -\u003e Result\u003cSerAndDe\u003cVec\u003csyn::WherePredicate\u003e\u003e, ()\u003e {\n    let (ser, de) = get_ser_and_de(cx, BOUND, items, parse_lit_into_where)?;\n    Ok((ser.at_most_one()?, de.at_most_one()?))\n}\n\npub fn get_serde_meta_items(attr: \u0026syn::Attribute) -\u003e Option\u003cVec\u003csyn::NestedMeta\u003e\u003e {\n    if attr.path == SERDE {\n        match attr.parse_meta() {\n            Ok(List(ref meta)) =\u003e Some(meta.nested.iter().cloned().collect()),\n            _ =\u003e {\n                // TODO: produce an error\n                None\n            }\n        }\n    } else {\n        None\n    }\n}\n\nfn get_lit_str\u003c'a\u003e(cx: \u0026Ctxt, attr_name: Symbol, lit: \u0026'a syn::Lit) -\u003e Result\u003c\u0026'a syn::LitStr, ()\u003e {\n    get_lit_str2(cx, attr_name, attr_name, lit)\n}\n\nfn get_lit_str2\u003c'a\u003e(\n    cx: \u0026Ctxt,\n    attr_name: Symbol,\n    meta_item_name: Symbol,\n    lit: \u0026'a syn::Lit,\n) -\u003e Result\u003c\u0026'a syn::LitStr, ()\u003e {\n    if let syn::Lit::Str(ref lit) = *lit {\n        Ok(lit)\n    } else {\n        cx.error_spanned_by(\n            lit,\n            format!(\n                \"expected serde {} attribute to be a string: `{} = \\\"...\\\"`\",\n                attr_name, meta_item_name\n            ),\n        );\n        Err(())\n    }\n}\n\nfn parse_lit_into_path(cx: \u0026Ctxt, attr_name: Symbol, lit: \u0026syn::Lit) -\u003e Result\u003csyn::Path, ()\u003e {\n    let string = get_lit_str(cx, attr_name, lit)?;\n    parse_lit_str(string).map_err(|_| {\n        cx.error_spanned_by(lit, format!(\"failed to parse path: {:?}\", string.value()))\n    })\n}\n\nfn parse_lit_into_expr_path(\n    cx: \u0026Ctxt,\n    attr_name: Symbol,\n    lit: \u0026syn::Lit,\n) -\u003e Result\u003csyn::ExprPath, ()\u003e {\n    let string = get_lit_str(cx, attr_name, lit)?;\n    parse_lit_str(string).map_err(|_| {\n        cx.error_spanned_by(lit, format!(\"failed to parse path: {:?}\", string.value()))\n    })\n}\n\nfn parse_lit_into_where(\n    cx: \u0026Ctxt,\n    attr_name: Symbol,\n    meta_item_name: Symbol,\n    lit: \u0026syn::Lit,\n) -\u003e Result\u003cVec\u003csyn::WherePredicate\u003e, ()\u003e {\n    let string = get_lit_str2(cx, attr_name, meta_item_name, lit)?;\n    if string.value().is_empty() {\n        return Ok(Vec::new());\n    }\n\n    let where_string = syn::LitStr::new(\u0026format!(\"where {}\", string.value()), string.span());\n\n    parse_lit_str::\u003csyn::WhereClause\u003e(\u0026where_string)\n        .map(|wh| wh.predicates.into_iter().collect())\n        .map_err(|err| cx.error_spanned_by(lit, err))\n}\n\nfn parse_lit_into_ty(cx: \u0026Ctxt, attr_name: Symbol, lit: \u0026syn::Lit) -\u003e Result\u003csyn::Type, ()\u003e {\n    let string = get_lit_str(cx, attr_name, lit)?;\n\n    parse_lit_str(string).map_err(|_| {\n        cx.error_spanned_by(\n            lit,\n            format!(\"failed to parse type: {} = {:?}\", attr_name, string.value()),\n        )\n    })\n}\n\n// Parses a string literal like \"'a + 'b + 'c\" containing a nonempty list of\n// lifetimes separated by `+`.\nfn parse_lit_into_lifetimes(\n    cx: \u0026Ctxt,\n    attr_name: Symbol,\n    lit: \u0026syn::Lit,\n) -\u003e Result\u003cBTreeSet\u003csyn::Lifetime\u003e, ()\u003e {\n    let string = get_lit_str(cx, attr_name, lit)?;\n    if string.value().is_empty() {\n        cx.error_spanned_by(lit, \"at least one lifetime must be borrowed\");\n        return Err(());\n    }\n\n    struct BorrowedLifetimes(Punctuated\u003csyn::Lifetime, Token![+]\u003e);\n\n    impl Parse for BorrowedLifetimes {\n        fn parse(input: ParseStream) -\u003e parse::Result\u003cSelf\u003e {\n            Punctuated::parse_separated_nonempty(input).map(BorrowedLifetimes)\n        }\n    }\n\n    if let Ok(BorrowedLifetimes(lifetimes)) = parse_lit_str(string) {\n        let mut set = BTreeSet::new();\n        for lifetime in lifetimes {\n            if !set.insert(lifetime.clone()) {\n                cx.error_spanned_by(lit, format!(\"duplicate borrowed lifetime `{}`\", lifetime));\n            }\n        }\n        return Ok(set);\n    }\n\n    cx.error_spanned_by(\n        lit,\n        format!(\"failed to parse borrowed lifetimes: {:?}\", string.value()),\n    );\n    Err(())\n}\n\nfn is_implicitly_borrowed(ty: \u0026syn::Type) -\u003e bool {\n    is_implicitly_borrowed_reference(ty) || is_option(ty, is_implicitly_borrowed_reference)\n}\n\nfn is_implicitly_borrowed_reference(ty: \u0026syn::Type) -\u003e bool {\n    is_reference(ty, is_str) || is_reference(ty, is_slice_u8)\n}\n\n// Whether the type looks like it might be `std::borrow::Cow\u003cT\u003e` where elem=\"T\".\n// This can have false negatives and false positives.\n//\n// False negative:\n//\n//     use std::borrow::Cow as Pig;\n//\n//     #[derive(Deserialize)]\n//     struct S\u003c'a\u003e {\n//         #[serde(borrow)]\n//         pig: Pig\u003c'a, str\u003e,\n//     }\n//\n// False positive:\n//\n//     type str = [i16];\n//\n//     #[derive(Deserialize)]\n//     struct S\u003c'a\u003e {\n//         #[serde(borrow)]\n//         cow: Cow\u003c'a, str\u003e,\n//     }\nfn is_cow(ty: \u0026syn::Type, elem: fn(\u0026syn::Type) -\u003e bool) -\u003e bool {\n    let path = match *ty {\n        syn::Type::Path(ref ty) =\u003e \u0026ty.path,\n        _ =\u003e {\n            return false;\n        }\n    };\n    let seg = match path.segments.last() {\n        Some(seg) =\u003e seg,\n        None =\u003e {\n            return false;\n        }\n    };\n    let args = match seg.arguments {\n        syn::PathArguments::AngleBracketed(ref bracketed) =\u003e \u0026bracketed.args,\n        _ =\u003e {\n            return false;\n        }\n    };\n    seg.ident == \"Cow\"\n        \u0026\u0026 args.len() == 2\n        \u0026\u0026 match (\u0026args[0], \u0026args[1]) {\n            (\u0026syn::GenericArgument::Lifetime(_), \u0026syn::GenericArgument::Type(ref arg)) =\u003e elem(arg),\n            _ =\u003e false,\n        }\n}\n\nfn is_option(ty: \u0026syn::Type, elem: fn(\u0026syn::Type) -\u003e bool) -\u003e bool {\n    let path = match *ty {\n        syn::Type::Path(ref ty) =\u003e \u0026ty.path,\n        _ =\u003e {\n            return false;\n        }\n    };\n    let seg = match path.segments.last() {\n        Some(seg) =\u003e seg,\n        None =\u003e {\n            return false;\n        }\n    };\n    let args = match seg.arguments {\n        syn::PathArguments::AngleBracketed(ref bracketed) =\u003e \u0026bracketed.args,\n        _ =\u003e {\n            return false;\n        }\n    };\n    seg.ident == \"Option\"\n        \u0026\u0026 args.len() == 1\n        \u0026\u0026 match args[0] {\n            syn::GenericArgument::Type(ref arg) =\u003e elem(arg),\n            _ =\u003e false,\n        }\n}\n\n// Whether the type looks like it might be `\u0026T` where elem=\"T\". This can have\n// false negatives and false positives.\n//\n// False negative:\n//\n//     type Yarn = str;\n//\n//     #[derive(Deserialize)]\n//     struct S\u003c'a\u003e {\n//         r: \u0026'a Yarn,\n//     }\n//\n// False positive:\n//\n//     type str = [i16];\n//\n//     #[derive(Deserialize)]\n//     struct S\u003c'a\u003e {\n//         r: \u0026'a str,\n//     }\nfn is_reference(ty: \u0026syn::Type, elem: fn(\u0026syn::Type) -\u003e bool) -\u003e bool {\n    match *ty {\n        syn::Type::Reference(ref ty) =\u003e ty.mutability.is_none() \u0026\u0026 elem(\u0026ty.elem),\n        _ =\u003e false,\n    }\n}\n\nfn is_str(ty: \u0026syn::Type) -\u003e bool {\n    is_primitive_type(ty, \"str\")\n}\n\nfn is_slice_u8(ty: \u0026syn::Type) -\u003e bool {\n    match *ty {\n        syn::Type::Slice(ref ty) =\u003e is_primitive_type(\u0026ty.elem, \"u8\"),\n        _ =\u003e false,\n    }\n}\n\nfn is_primitive_type(ty: \u0026syn::Type, primitive: \u0026str) -\u003e bool {\n    match *ty {\n        syn::Type::Path(ref ty) =\u003e ty.qself.is_none() \u0026\u0026 is_primitive_path(\u0026ty.path, primitive),\n        _ =\u003e false,\n    }\n}\n\nfn is_primitive_path(path: \u0026syn::Path, primitive: \u0026str) -\u003e bool {\n    path.leading_colon.is_none()\n        \u0026\u0026 path.segments.len() == 1\n        \u0026\u0026 path.segments[0].ident == primitive\n        \u0026\u0026 path.segments[0].arguments.is_empty()\n}\n\n// All lifetimes that this type could borrow from a Deserializer.\n//\n// For example a type `S\u003c'a, 'b\u003e` could borrow `'a` and `'b`. On the other hand\n// a type `for\u003c'a\u003e fn(\u0026'a str)` could not borrow `'a` from the Deserializer.\n//\n// This is used when there is an explicit or implicit `#[serde(borrow)]`\n// attribute on the field so there must be at least one borrowable lifetime.\nfn borrowable_lifetimes(\n    cx: \u0026Ctxt,\n    name: \u0026str,\n    field: \u0026syn::Field,\n) -\u003e Result\u003cBTreeSet\u003csyn::Lifetime\u003e, ()\u003e {\n    let mut lifetimes = BTreeSet::new();\n    collect_lifetimes(\u0026field.ty, \u0026mut lifetimes);\n    if lifetimes.is_empty() {\n        cx.error_spanned_by(\n            field,\n            format!(\"field `{}` has no lifetimes to borrow\", name),\n        );\n        Err(())\n    } else {\n        Ok(lifetimes)\n    }\n}\n\nfn collect_lifetimes(ty: \u0026syn::Type, out: \u0026mut BTreeSet\u003csyn::Lifetime\u003e) {\n    match *ty {\n        syn::Type::Slice(ref ty) =\u003e {\n            collect_lifetimes(\u0026ty.elem, out);\n        }\n        syn::Type::Array(ref ty) =\u003e {\n            collect_lifetimes(\u0026ty.elem, out);\n        }\n        syn::Type::Ptr(ref ty) =\u003e {\n            collect_lifetimes(\u0026ty.elem, out);\n        }\n        syn::Type::Reference(ref ty) =\u003e {\n            out.extend(ty.lifetime.iter().cloned());\n            collect_lifetimes(\u0026ty.elem, out);\n        }\n        syn::Type::Tuple(ref ty) =\u003e {\n            for elem in \u0026ty.elems {\n                collect_lifetimes(elem, out);\n            }\n        }\n        syn::Type::Path(ref ty) =\u003e {\n            if let Some(ref qself) = ty.qself {\n                collect_lifetimes(\u0026qself.ty, out);\n            }\n            for seg in \u0026ty.path.segments {\n                if let syn::PathArguments::AngleBracketed(ref bracketed) = seg.arguments {\n                    for arg in \u0026bracketed.args {\n                        match *arg {\n                            syn::GenericArgument::Lifetime(ref lifetime) =\u003e {\n                                out.insert(lifetime.clone());\n                            }\n                            syn::GenericArgument::Type(ref ty) =\u003e {\n                                collect_lifetimes(ty, out);\n                            }\n                            syn::GenericArgument::Binding(ref binding) =\u003e {\n                                collect_lifetimes(\u0026binding.ty, out);\n                            }\n                            syn::GenericArgument::Constraint(_)\n                            | syn::GenericArgument::Const(_) =\u003e {}\n                        }\n                    }\n                }\n            }\n        }\n        syn::Type::Paren(ref ty) =\u003e {\n            collect_lifetimes(\u0026ty.elem, out);\n        }\n        syn::Type::Group(ref ty) =\u003e {\n            collect_lifetimes(\u0026ty.elem, out);\n        }\n        syn::Type::BareFn(_)\n        | syn::Type::Never(_)\n        | syn::Type::TraitObject(_)\n        | syn::Type::ImplTrait(_)\n        | syn::Type::Infer(_)\n        | syn::Type::Macro(_)\n        | syn::Type::Verbatim(_)\n        | _ =\u003e {}\n    }\n}\n\nfn parse_lit_str\u003cT\u003e(s: \u0026syn::LitStr) -\u003e parse::Result\u003cT\u003e\nwhere\n    T: Parse,\n{\n    let tokens = spanned_tokens(s)?;\n    syn::parse2(tokens)\n}\n\nfn spanned_tokens(s: \u0026syn::LitStr) -\u003e parse::Result\u003cTokenStream\u003e {\n    let stream = syn::parse_str(\u0026s.value())?;\n    Ok(respan_token_stream(stream, s.span()))\n}\n\nfn respan_token_stream(stream: TokenStream, span: Span) -\u003e TokenStream {\n    stream\n        .into_iter()\n        .map(|token| respan_token_tree(token, span))\n        .collect()\n}\n\nfn respan_token_tree(mut token: TokenTree, span: Span) -\u003e TokenTree {\n    if let TokenTree::Group(ref mut g) = token {\n        *g = Group::new(g.delimiter(), respan_token_stream(g.stream().clone(), span));\n    }\n    token.set_span(span);\n    token\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","case.rs"],"content":"//! Code to convert the Rust-styled field/variant (e.g. `my_field`, `MyType`) to the\n//! case of the source (e.g. `my-field`, `MY_FIELD`).\n\n// See https://users.rust-lang.org/t/psa-dealing-with-warning-unused-import-std-ascii-asciiext-in-today-s-nightly/13726\n#[allow(deprecated, unused_imports)]\nuse std::ascii::AsciiExt;\n\nuse std::str::FromStr;\n\nuse self::RenameRule::*;\n\n/// The different possible ways to change case of fields in a struct, or variants in an enum.\n#[derive(Copy, Clone, PartialEq)]\npub enum RenameRule {\n    /// Don't apply a default rename rule.\n    None,\n    /// Rename direct children to \"lowercase\" style.\n    LowerCase,\n    /// Rename direct children to \"UPPERCASE\" style.\n    UPPERCASE,\n    /// Rename direct children to \"PascalCase\" style, as typically used for\n    /// enum variants.\n    PascalCase,\n    /// Rename direct children to \"camelCase\" style.\n    CamelCase,\n    /// Rename direct children to \"snake_case\" style, as commonly used for\n    /// fields.\n    SnakeCase,\n    /// Rename direct children to \"SCREAMING_SNAKE_CASE\" style, as commonly\n    /// used for constants.\n    ScreamingSnakeCase,\n    /// Rename direct children to \"kebab-case\" style.\n    KebabCase,\n    /// Rename direct children to \"SCREAMING-KEBAB-CASE\" style.\n    ScreamingKebabCase,\n}\n\nimpl RenameRule {\n    /// Apply a renaming rule to an enum variant, returning the version expected in the source.\n    pub fn apply_to_variant(\u0026self, variant: \u0026str) -\u003e String {\n        match *self {\n            None | PascalCase =\u003e variant.to_owned(),\n            LowerCase =\u003e variant.to_ascii_lowercase(),\n            UPPERCASE =\u003e variant.to_ascii_uppercase(),\n            CamelCase =\u003e variant[..1].to_ascii_lowercase() + \u0026variant[1..],\n            SnakeCase =\u003e {\n                let mut snake = String::new();\n                for (i, ch) in variant.char_indices() {\n                    if i \u003e 0 \u0026\u0026 ch.is_uppercase() {\n                        snake.push('_');\n                    }\n                    snake.push(ch.to_ascii_lowercase());\n                }\n                snake\n            }\n            ScreamingSnakeCase =\u003e SnakeCase.apply_to_variant(variant).to_ascii_uppercase(),\n            KebabCase =\u003e SnakeCase.apply_to_variant(variant).replace('_', \"-\"),\n            ScreamingKebabCase =\u003e ScreamingSnakeCase\n                .apply_to_variant(variant)\n                .replace('_', \"-\"),\n        }\n    }\n\n    /// Apply a renaming rule to a struct field, returning the version expected in the source.\n    pub fn apply_to_field(\u0026self, field: \u0026str) -\u003e String {\n        match *self {\n            None | LowerCase | SnakeCase =\u003e field.to_owned(),\n            UPPERCASE =\u003e field.to_ascii_uppercase(),\n            PascalCase =\u003e {\n                let mut pascal = String::new();\n                let mut capitalize = true;\n                for ch in field.chars() {\n                    if ch == '_' {\n                        capitalize = true;\n                    } else if capitalize {\n                        pascal.push(ch.to_ascii_uppercase());\n                        capitalize = false;\n                    } else {\n                        pascal.push(ch);\n                    }\n                }\n                pascal\n            }\n            CamelCase =\u003e {\n                let pascal = PascalCase.apply_to_field(field);\n                pascal[..1].to_ascii_lowercase() + \u0026pascal[1..]\n            }\n            ScreamingSnakeCase =\u003e field.to_ascii_uppercase(),\n            KebabCase =\u003e field.replace('_', \"-\"),\n            ScreamingKebabCase =\u003e ScreamingSnakeCase.apply_to_field(field).replace('_', \"-\"),\n        }\n    }\n}\n\nimpl FromStr for RenameRule {\n    type Err = ();\n\n    fn from_str(rename_all_str: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match rename_all_str {\n            \"lowercase\" =\u003e Ok(LowerCase),\n            \"UPPERCASE\" =\u003e Ok(UPPERCASE),\n            \"PascalCase\" =\u003e Ok(PascalCase),\n            \"camelCase\" =\u003e Ok(CamelCase),\n            \"snake_case\" =\u003e Ok(SnakeCase),\n            \"SCREAMING_SNAKE_CASE\" =\u003e Ok(ScreamingSnakeCase),\n            \"kebab-case\" =\u003e Ok(KebabCase),\n            \"SCREAMING-KEBAB-CASE\" =\u003e Ok(ScreamingKebabCase),\n            _ =\u003e Err(()),\n        }\n    }\n}\n\n#[test]\nfn rename_variants() {\n    for \u0026(original, lower, upper, camel, snake, screaming, kebab, screaming_kebab) in \u0026[\n        (\n            \"Outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"OUTCOME\",\n        ),\n        (\n            \"VeryTasty\",\n            \"verytasty\",\n            \"VERYTASTY\",\n            \"veryTasty\",\n            \"very_tasty\",\n            \"VERY_TASTY\",\n            \"very-tasty\",\n            \"VERY-TASTY\",\n        ),\n        (\"A\", \"a\", \"A\", \"a\", \"a\", \"A\", \"a\", \"A\"),\n        (\"Z42\", \"z42\", \"Z42\", \"z42\", \"z42\", \"Z42\", \"z42\", \"Z42\"),\n    ] {\n        assert_eq!(None.apply_to_variant(original), original);\n        assert_eq!(LowerCase.apply_to_variant(original), lower);\n        assert_eq!(UPPERCASE.apply_to_variant(original), upper);\n        assert_eq!(PascalCase.apply_to_variant(original), original);\n        assert_eq!(CamelCase.apply_to_variant(original), camel);\n        assert_eq!(SnakeCase.apply_to_variant(original), snake);\n        assert_eq!(ScreamingSnakeCase.apply_to_variant(original), screaming);\n        assert_eq!(KebabCase.apply_to_variant(original), kebab);\n        assert_eq!(\n            ScreamingKebabCase.apply_to_variant(original),\n            screaming_kebab\n        );\n    }\n}\n\n#[test]\nfn rename_fields() {\n    for \u0026(original, upper, pascal, camel, screaming, kebab, screaming_kebab) in \u0026[\n        (\n            \"outcome\", \"OUTCOME\", \"Outcome\", \"outcome\", \"OUTCOME\", \"outcome\", \"OUTCOME\",\n        ),\n        (\n            \"very_tasty\",\n            \"VERY_TASTY\",\n            \"VeryTasty\",\n            \"veryTasty\",\n            \"VERY_TASTY\",\n            \"very-tasty\",\n            \"VERY-TASTY\",\n        ),\n        (\"a\", \"A\", \"A\", \"a\", \"A\", \"a\", \"A\"),\n        (\"z42\", \"Z42\", \"Z42\", \"z42\", \"Z42\", \"z42\", \"Z42\"),\n    ] {\n        assert_eq!(None.apply_to_field(original), original);\n        assert_eq!(UPPERCASE.apply_to_field(original), upper);\n        assert_eq!(PascalCase.apply_to_field(original), pascal);\n        assert_eq!(CamelCase.apply_to_field(original), camel);\n        assert_eq!(SnakeCase.apply_to_field(original), original);\n        assert_eq!(ScreamingSnakeCase.apply_to_field(original), screaming);\n        assert_eq!(KebabCase.apply_to_field(original), kebab);\n        assert_eq!(ScreamingKebabCase.apply_to_field(original), screaming_kebab);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","check.rs"],"content":"use internals::ast::{Container, Data, Field, Style};\nuse internals::attr::{Identifier, TagType};\nuse internals::{Ctxt, Derive};\nuse syn::{Member, Type};\n\n/// Cross-cutting checks that require looking at more than a single attrs\n/// object. Simpler checks should happen when parsing and building the attrs.\npub fn check(cx: \u0026Ctxt, cont: \u0026mut Container, derive: Derive) {\n    check_getter(cx, cont);\n    check_flatten(cx, cont);\n    check_identifier(cx, cont);\n    check_variant_skip_attrs(cx, cont);\n    check_internal_tag_field_name_conflict(cx, cont);\n    check_adjacent_tag_conflict(cx, cont);\n    check_transparent(cx, cont, derive);\n    check_from_and_try_from(cx, cont);\n}\n\n/// Getters are only allowed inside structs (not enums) with the `remote`\n/// attribute.\nfn check_getter(cx: \u0026Ctxt, cont: \u0026Container) {\n    match cont.data {\n        Data::Enum(_) =\u003e {\n            if cont.data.has_getter() {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(getter = \\\"...\\\")] is not allowed in an enum\",\n                );\n            }\n        }\n        Data::Struct(_, _) =\u003e {\n            if cont.data.has_getter() \u0026\u0026 cont.attrs.remote().is_none() {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(getter = \\\"...\\\")] can only be used in structs \\\n                     that have #[serde(remote = \\\"...\\\")]\",\n                );\n            }\n        }\n    }\n}\n\n/// Flattening has some restrictions we can test.\nfn check_flatten(cx: \u0026Ctxt, cont: \u0026Container) {\n    match cont.data {\n        Data::Enum(ref variants) =\u003e {\n            for variant in variants {\n                for field in \u0026variant.fields {\n                    check_flatten_field(cx, variant.style, field);\n                }\n            }\n        }\n        Data::Struct(style, ref fields) =\u003e {\n            for field in fields {\n                check_flatten_field(cx, style, field);\n            }\n        }\n    }\n}\n\nfn check_flatten_field(cx: \u0026Ctxt, style: Style, field: \u0026Field) {\n    if !field.attrs.flatten() {\n        return;\n    }\n    match style {\n        Style::Tuple =\u003e {\n            cx.error_spanned_by(\n                field.original,\n                \"#[serde(flatten)] cannot be used on tuple structs\",\n            );\n        }\n        Style::Newtype =\u003e {\n            cx.error_spanned_by(\n                field.original,\n                \"#[serde(flatten)] cannot be used on newtype structs\",\n            );\n        }\n        _ =\u003e {}\n    }\n}\n\n/// The `other` attribute must be used at most once and it must be the last\n/// variant of an enum.\n///\n/// Inside a `variant_identifier` all variants must be unit variants. Inside a\n/// `field_identifier` all but possibly one variant must be unit variants. The\n/// last variant may be a newtype variant which is an implicit \"other\" case.\nfn check_identifier(cx: \u0026Ctxt, cont: \u0026Container) {\n    let variants = match cont.data {\n        Data::Enum(ref variants) =\u003e variants,\n        Data::Struct(_, _) =\u003e {\n            return;\n        }\n    };\n\n    for (i, variant) in variants.iter().enumerate() {\n        match (\n            variant.style,\n            cont.attrs.identifier(),\n            variant.attrs.other(),\n            cont.attrs.tag(),\n        ) {\n            // The `other` attribute may not be used in a variant_identifier.\n            (_, Identifier::Variant, true, _) =\u003e {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(other)] may not be used on a variant identifier\",\n                );\n            }\n\n            // Variant with `other` attribute cannot appear in untagged enum\n            (_, Identifier::No, true, \u0026TagType::None) =\u003e {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(other)] cannot appear on untagged enum\",\n                );\n            }\n\n            // Variant with `other` attribute must be the last one.\n            (Style::Unit, Identifier::Field, true, _) | (Style::Unit, Identifier::No, true, _) =\u003e {\n                if i \u003c variants.len() - 1 {\n                    cx.error_spanned_by(\n                        variant.original,\n                        \"#[serde(other)] must be on the last variant\",\n                    );\n                }\n            }\n\n            // Variant with `other` attribute must be a unit variant.\n            (_, Identifier::Field, true, _) | (_, Identifier::No, true, _) =\u003e {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(other)] must be on a unit variant\",\n                );\n            }\n\n            // Any sort of variant is allowed if this is not an identifier.\n            (_, Identifier::No, false, _) =\u003e {}\n\n            // Unit variant without `other` attribute is always fine.\n            (Style::Unit, _, false, _) =\u003e {}\n\n            // The last field is allowed to be a newtype catch-all.\n            (Style::Newtype, Identifier::Field, false, _) =\u003e {\n                if i \u003c variants.len() - 1 {\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\"`{}` must be the last variant\", variant.ident),\n                    );\n                }\n            }\n\n            (_, Identifier::Field, false, _) =\u003e {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(field_identifier)] may only contain unit variants\",\n                );\n            }\n\n            (_, Identifier::Variant, false, _) =\u003e {\n                cx.error_spanned_by(\n                    variant.original,\n                    \"#[serde(variant_identifier)] may only contain unit variants\",\n                );\n            }\n        }\n    }\n}\n\n/// Skip-(de)serializing attributes are not allowed on variants marked\n/// (de)serialize_with.\nfn check_variant_skip_attrs(cx: \u0026Ctxt, cont: \u0026Container) {\n    let variants = match cont.data {\n        Data::Enum(ref variants) =\u003e variants,\n        Data::Struct(_, _) =\u003e {\n            return;\n        }\n    };\n\n    for variant in variants.iter() {\n        if variant.attrs.serialize_with().is_some() {\n            if variant.attrs.skip_serializing() {\n                cx.error_spanned_by(\n                    variant.original,\n                    format!(\n                        \"variant `{}` cannot have both #[serde(serialize_with)] and \\\n                         #[serde(skip_serializing)]\",\n                        variant.ident\n                    ),\n                );\n            }\n\n            for field in \u0026variant.fields {\n                let member = member_message(\u0026field.member);\n\n                if field.attrs.skip_serializing() {\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\n                            \"variant `{}` cannot have both #[serde(serialize_with)] and \\\n                             a field {} marked with #[serde(skip_serializing)]\",\n                            variant.ident, member\n                        ),\n                    );\n                }\n\n                if field.attrs.skip_serializing_if().is_some() {\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\n                            \"variant `{}` cannot have both #[serde(serialize_with)] and \\\n                             a field {} marked with #[serde(skip_serializing_if)]\",\n                            variant.ident, member\n                        ),\n                    );\n                }\n            }\n        }\n\n        if variant.attrs.deserialize_with().is_some() {\n            if variant.attrs.skip_deserializing() {\n                cx.error_spanned_by(\n                    variant.original,\n                    format!(\n                        \"variant `{}` cannot have both #[serde(deserialize_with)] and \\\n                         #[serde(skip_deserializing)]\",\n                        variant.ident\n                    ),\n                );\n            }\n\n            for field in \u0026variant.fields {\n                if field.attrs.skip_deserializing() {\n                    let member = member_message(\u0026field.member);\n\n                    cx.error_spanned_by(\n                        variant.original,\n                        format!(\n                            \"variant `{}` cannot have both #[serde(deserialize_with)] \\\n                             and a field {} marked with #[serde(skip_deserializing)]\",\n                            variant.ident, member\n                        ),\n                    );\n                }\n            }\n        }\n    }\n}\n\n/// The tag of an internally-tagged struct variant must not be\n/// the same as either one of its fields, as this would result in\n/// duplicate keys in the serialized output and/or ambiguity in\n/// the to-be-deserialized input.\nfn check_internal_tag_field_name_conflict(cx: \u0026Ctxt, cont: \u0026Container) {\n    let variants = match cont.data {\n        Data::Enum(ref variants) =\u003e variants,\n        Data::Struct(_, _) =\u003e return,\n    };\n\n    let tag = match *cont.attrs.tag() {\n        TagType::Internal { ref tag } =\u003e tag.as_str(),\n        TagType::External | TagType::Adjacent { .. } | TagType::None =\u003e return,\n    };\n\n    let diagnose_conflict = || {\n        cx.error_spanned_by(\n            cont.original,\n            format!(\"variant field name `{}` conflicts with internal tag\", tag),\n        )\n    };\n\n    for variant in variants {\n        match variant.style {\n            Style::Struct =\u003e {\n                for field in \u0026variant.fields {\n                    let check_ser = !field.attrs.skip_serializing();\n                    let check_de = !field.attrs.skip_deserializing();\n                    let name = field.attrs.name();\n                    let ser_name = name.serialize_name();\n\n                    if check_ser \u0026\u0026 ser_name == tag {\n                        diagnose_conflict();\n                        return;\n                    }\n\n                    for de_name in field.attrs.aliases() {\n                        if check_de \u0026\u0026 de_name == tag {\n                            diagnose_conflict();\n                            return;\n                        }\n                    }\n                }\n            }\n            Style::Unit | Style::Newtype | Style::Tuple =\u003e {}\n        }\n    }\n}\n\n/// In the case of adjacently-tagged enums, the type and the\n/// contents tag must differ, for the same reason.\nfn check_adjacent_tag_conflict(cx: \u0026Ctxt, cont: \u0026Container) {\n    let (type_tag, content_tag) = match *cont.attrs.tag() {\n        TagType::Adjacent {\n            ref tag,\n            ref content,\n        } =\u003e (tag, content),\n        TagType::Internal { .. } | TagType::External | TagType::None =\u003e return,\n    };\n\n    if type_tag == content_tag {\n        cx.error_spanned_by(\n            cont.original,\n            format!(\n                \"enum tags `{}` for type and content conflict with each other\",\n                type_tag\n            ),\n        );\n    }\n}\n\n/// Enums and unit structs cannot be transparent.\nfn check_transparent(cx: \u0026Ctxt, cont: \u0026mut Container, derive: Derive) {\n    if !cont.attrs.transparent() {\n        return;\n    }\n\n    if cont.attrs.type_from().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(transparent)] is not allowed with #[serde(from = \\\"...\\\")]\",\n        );\n    }\n\n    if cont.attrs.type_try_from().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(transparent)] is not allowed with #[serde(try_from = \\\"...\\\")]\",\n        );\n    }\n\n    if cont.attrs.type_into().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(transparent)] is not allowed with #[serde(into = \\\"...\\\")]\",\n        );\n    }\n\n    let fields = match cont.data {\n        Data::Enum(_) =\u003e {\n            cx.error_spanned_by(\n                cont.original,\n                \"#[serde(transparent)] is not allowed on an enum\",\n            );\n            return;\n        }\n        Data::Struct(Style::Unit, _) =\u003e {\n            cx.error_spanned_by(\n                cont.original,\n                \"#[serde(transparent)] is not allowed on a unit struct\",\n            );\n            return;\n        }\n        Data::Struct(_, ref mut fields) =\u003e fields,\n    };\n\n    let mut transparent_field = None;\n\n    for field in fields {\n        if allow_transparent(field, derive) {\n            if transparent_field.is_some() {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(transparent)] requires struct to have at most one transparent field\",\n                );\n                return;\n            }\n            transparent_field = Some(field);\n        }\n    }\n\n    match transparent_field {\n        Some(transparent_field) =\u003e transparent_field.attrs.mark_transparent(),\n        None =\u003e match derive {\n            Derive::Serialize =\u003e {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(transparent)] requires at least one field that is not skipped\",\n                );\n            }\n            Derive::Deserialize =\u003e {\n                cx.error_spanned_by(\n                    cont.original,\n                    \"#[serde(transparent)] requires at least one field that is neither skipped nor has a default\",\n                );\n            }\n        },\n    }\n}\n\nfn member_message(member: \u0026Member) -\u003e String {\n    match *member {\n        Member::Named(ref ident) =\u003e format!(\"`{}`\", ident),\n        Member::Unnamed(ref i) =\u003e format!(\"#{}\", i.index),\n    }\n}\n\nfn allow_transparent(field: \u0026Field, derive: Derive) -\u003e bool {\n    if let Type::Path(ref ty) = *field.ty {\n        if let Some(seg) = ty.path.segments.last() {\n            if seg.ident == \"PhantomData\" {\n                return false;\n            }\n        }\n    }\n\n    match derive {\n        Derive::Serialize =\u003e !field.attrs.skip_serializing(),\n        Derive::Deserialize =\u003e !field.attrs.skip_deserializing() \u0026\u0026 field.attrs.default().is_none(),\n    }\n}\n\nfn check_from_and_try_from(cx: \u0026Ctxt, cont: \u0026mut Container) {\n    if cont.attrs.type_from().is_some() \u0026\u0026 cont.attrs.type_try_from().is_some() {\n        cx.error_spanned_by(\n            cont.original,\n            \"#[serde(from = \\\"...\\\")] and #[serde(try_from = \\\"...\\\")] conflict with each other\",\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","ctxt.rs"],"content":"use quote::ToTokens;\nuse std::cell::RefCell;\nuse std::fmt::Display;\nuse std::thread;\nuse syn;\n\n/// A type to collect errors together and format them.\n///\n/// Dropping this object will cause a panic. It must be consumed using `check`.\n///\n/// References can be shared since this type uses run-time exclusive mut checking.\n#[derive(Default)]\npub struct Ctxt {\n    // The contents will be set to `None` during checking. This is so that checking can be\n    // enforced.\n    errors: RefCell\u003cOption\u003cVec\u003csyn::Error\u003e\u003e\u003e,\n}\n\nimpl Ctxt {\n    /// Create a new context object.\n    ///\n    /// This object contains no errors, but will still trigger a panic if it is not `check`ed.\n    pub fn new() -\u003e Self {\n        Ctxt {\n            errors: RefCell::new(Some(Vec::new())),\n        }\n    }\n\n    /// Add an error to the context object with a tokenenizable object.\n    ///\n    /// The object is used for spanning in error messages.\n    pub fn error_spanned_by\u003cA: ToTokens, T: Display\u003e(\u0026self, obj: A, msg: T) {\n        self.errors\n            .borrow_mut()\n            .as_mut()\n            .unwrap()\n            // Curb monomorphization from generating too many identical methods.\n            .push(syn::Error::new_spanned(obj.into_token_stream(), msg));\n    }\n\n    /// Consume this object, producing a formatted error string if there are errors.\n    pub fn check(self) -\u003e Result\u003c(), Vec\u003csyn::Error\u003e\u003e {\n        let errors = self.errors.borrow_mut().take().unwrap();\n        match errors.len() {\n            0 =\u003e Ok(()),\n            _ =\u003e Err(errors),\n        }\n    }\n}\n\nimpl Drop for Ctxt {\n    fn drop(\u0026mut self) {\n        if !thread::panicking() \u0026\u0026 self.errors.borrow().is_some() {\n            panic!(\"forgot to check for errors\");\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","mod.rs"],"content":"pub mod ast;\npub mod attr;\n\nmod ctxt;\npub use self::ctxt::Ctxt;\n\nmod case;\nmod check;\nmod symbol;\n\n#[derive(Copy, Clone)]\npub enum Derive {\n    Serialize,\n    Deserialize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","internals","symbol.rs"],"content":"use std::fmt::{self, Display};\nuse syn::{Ident, Path};\n\n#[derive(Copy, Clone)]\npub struct Symbol(\u0026'static str);\n\npub const ALIAS: Symbol = Symbol(\"alias\");\npub const BORROW: Symbol = Symbol(\"borrow\");\npub const BOUND: Symbol = Symbol(\"bound\");\npub const CONTENT: Symbol = Symbol(\"content\");\npub const CRATE: Symbol = Symbol(\"crate\");\npub const DEFAULT: Symbol = Symbol(\"default\");\npub const DENY_UNKNOWN_FIELDS: Symbol = Symbol(\"deny_unknown_fields\");\npub const DESERIALIZE: Symbol = Symbol(\"deserialize\");\npub const DESERIALIZE_WITH: Symbol = Symbol(\"deserialize_with\");\npub const FIELD_IDENTIFIER: Symbol = Symbol(\"field_identifier\");\npub const FLATTEN: Symbol = Symbol(\"flatten\");\npub const FROM: Symbol = Symbol(\"from\");\npub const GETTER: Symbol = Symbol(\"getter\");\npub const INTO: Symbol = Symbol(\"into\");\npub const OTHER: Symbol = Symbol(\"other\");\npub const REMOTE: Symbol = Symbol(\"remote\");\npub const RENAME: Symbol = Symbol(\"rename\");\npub const RENAME_ALL: Symbol = Symbol(\"rename_all\");\npub const SERDE: Symbol = Symbol(\"serde\");\npub const SERIALIZE: Symbol = Symbol(\"serialize\");\npub const SERIALIZE_WITH: Symbol = Symbol(\"serialize_with\");\npub const SKIP: Symbol = Symbol(\"skip\");\npub const SKIP_DESERIALIZING: Symbol = Symbol(\"skip_deserializing\");\npub const SKIP_SERIALIZING: Symbol = Symbol(\"skip_serializing\");\npub const SKIP_SERIALIZING_IF: Symbol = Symbol(\"skip_serializing_if\");\npub const TAG: Symbol = Symbol(\"tag\");\npub const TRANSPARENT: Symbol = Symbol(\"transparent\");\npub const TRY_FROM: Symbol = Symbol(\"try_from\");\npub const UNTAGGED: Symbol = Symbol(\"untagged\");\npub const VARIANT_IDENTIFIER: Symbol = Symbol(\"variant_identifier\");\npub const WITH: Symbol = Symbol(\"with\");\n\nimpl PartialEq\u003cSymbol\u003e for Ident {\n    fn eq(\u0026self, word: \u0026Symbol) -\u003e bool {\n        self == word.0\n    }\n}\n\nimpl\u003c'a\u003e PartialEq\u003cSymbol\u003e for \u0026'a Ident {\n    fn eq(\u0026self, word: \u0026Symbol) -\u003e bool {\n        *self == word.0\n    }\n}\n\nimpl PartialEq\u003cSymbol\u003e for Path {\n    fn eq(\u0026self, word: \u0026Symbol) -\u003e bool {\n        self.is_ident(word.0)\n    }\n}\n\nimpl\u003c'a\u003e PartialEq\u003cSymbol\u003e for \u0026'a Path {\n    fn eq(\u0026self, word: \u0026Symbol) -\u003e bool {\n        self.is_ident(word.0)\n    }\n}\n\nimpl Display for Symbol {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(self.0)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","lib.rs"],"content":"//! This crate provides Serde's two derive macros.\n//!\n//! ```edition2018\n//! # use serde_derive::{Serialize, Deserialize};\n//! #\n//! #[derive(Serialize, Deserialize)]\n//! # struct S;\n//! #\n//! # fn main() {}\n//! ```\n//!\n//! Please refer to [https://serde.rs/derive.html] for how to set this up.\n//!\n//! [https://serde.rs/derive.html]: https://serde.rs/derive.html\n\n#![doc(html_root_url = \"https://docs.rs/serde_derive/1.0.100\")]\n#![allow(unknown_lints, bare_trait_objects)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(renamed_and_removed_lints))]\n#![cfg_attr(feature = \"cargo-clippy\", deny(clippy, clippy_pedantic))]\n// Ignored clippy lints\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        cognitive_complexity,\n        enum_variant_names,\n        needless_pass_by_value,\n        redundant_field_names,\n        too_many_arguments,\n        trivially_copy_pass_by_ref,\n        used_underscore_binding,\n    )\n)]\n// Ignored clippy_pedantic lints\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        cast_possible_truncation,\n        checked_conversions,\n        doc_markdown,\n        enum_glob_use,\n        filter_map,\n        indexing_slicing,\n        items_after_statements,\n        match_same_arms,\n        module_name_repetitions,\n        similar_names,\n        single_match_else,\n        unseparated_literal_suffix,\n        use_self,\n    )\n)]\n// The `quote!` macro requires deep recursion.\n#![recursion_limit = \"512\"]\n\n#[macro_use]\nextern crate quote;\n#[macro_use]\nextern crate syn;\n\nextern crate proc_macro;\nextern crate proc_macro2;\n\nmod internals;\n\nuse proc_macro::TokenStream;\nuse syn::DeriveInput;\n\n#[macro_use]\nmod bound;\n#[macro_use]\nmod fragment;\n\nmod de;\nmod dummy;\nmod pretend;\nmod ser;\nmod try;\n\n#[proc_macro_derive(Serialize, attributes(serde))]\npub fn derive_serialize(input: TokenStream) -\u003e TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    ser::expand_derive_serialize(\u0026input)\n        .unwrap_or_else(to_compile_errors)\n        .into()\n}\n\n#[proc_macro_derive(Deserialize, attributes(serde))]\npub fn derive_deserialize(input: TokenStream) -\u003e TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    de::expand_derive_deserialize(\u0026input)\n        .unwrap_or_else(to_compile_errors)\n        .into()\n}\n\nfn to_compile_errors(errors: Vec\u003csyn::Error\u003e) -\u003e proc_macro2::TokenStream {\n    let compile_errors = errors.iter().map(syn::Error::to_compile_error);\n    quote!(#(#compile_errors)*)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","pretend.rs"],"content":"use proc_macro2::{Span, TokenStream};\nuse syn::Ident;\n\nuse internals::ast::{Container, Data, Field, Style};\n\n// Suppress dead_code warnings that would otherwise appear when using a remote\n// derive. Other than this pretend code, a struct annotated with remote derive\n// never has its fields referenced and an enum annotated with remote derive\n// never has its variants constructed.\n//\n//     warning: field is never used: `i`\n//      --\u003e src/main.rs:4:20\n//       |\n//     4 | struct StructDef { i: i32 }\n//       |                    ^^^^^^\n//\n//     warning: variant is never constructed: `V`\n//      --\u003e src/main.rs:8:16\n//       |\n//     8 | enum EnumDef { V }\n//       |                ^\n//\npub fn pretend_used(cont: \u0026Container) -\u003e TokenStream {\n    let pretend_fields = pretend_fields_used(cont);\n    let pretend_variants = pretend_variants_used(cont);\n\n    quote! {\n        #pretend_fields\n        #pretend_variants\n    }\n}\n\n// For structs with named fields, expands to:\n//\n//     match None::\u003cT\u003e {\n//         Some(T { a: ref __v0, b: ref __v1 }) =\u003e {}\n//         _ =\u003e {}\n//     }\n//\n// For enums, expands to the following but only including struct variants:\n//\n//     match None::\u003cT\u003e {\n//         Some(T::A { a: ref __v0 }) =\u003e {}\n//         Some(T::B { b: ref __v0 }) =\u003e {}\n//         _ =\u003e {}\n//     }\n//\n// The `ref` is important in case the user has written a Drop impl on their\n// type. Rust does not allow destructuring a struct or enum that has a Drop\n// impl.\nfn pretend_fields_used(cont: \u0026Container) -\u003e TokenStream {\n    let type_ident = \u0026cont.ident;\n    let (_, ty_generics, _) = cont.generics.split_for_impl();\n\n    let patterns = match cont.data {\n        Data::Enum(ref variants) =\u003e variants\n            .iter()\n            .filter_map(|variant| match variant.style {\n                Style::Struct =\u003e {\n                    let variant_ident = \u0026variant.ident;\n                    let pat = struct_pattern(\u0026variant.fields);\n                    Some(quote!(#type_ident::#variant_ident #pat))\n                }\n                _ =\u003e None,\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n        Data::Struct(Style::Struct, ref fields) =\u003e {\n            let pat = struct_pattern(fields);\n            vec![quote!(#type_ident #pat)]\n        }\n        Data::Struct(_, _) =\u003e {\n            return quote!();\n        }\n    };\n\n    quote! {\n        match _serde::export::None::\u003c#type_ident #ty_generics\u003e {\n            #(\n                _serde::export::Some(#patterns) =\u003e {}\n            )*\n            _ =\u003e {}\n        }\n    }\n}\n\n// Expands to one of these per enum variant:\n//\n//     match None {\n//         Some((__v0, __v1,)) =\u003e {\n//             let _ = E::V { a: __v0, b: __v1 };\n//         }\n//         _ =\u003e {}\n//     }\n//\nfn pretend_variants_used(cont: \u0026Container) -\u003e TokenStream {\n    let variants = match cont.data {\n        Data::Enum(ref variants) =\u003e variants,\n        Data::Struct(_, _) =\u003e {\n            return quote!();\n        }\n    };\n\n    let type_ident = \u0026cont.ident;\n    let (_, ty_generics, _) = cont.generics.split_for_impl();\n    let turbofish = ty_generics.as_turbofish();\n\n    let cases = variants.iter().map(|variant| {\n        let variant_ident = \u0026variant.ident;\n        let placeholders = \u0026(0..variant.fields.len())\n            .map(|i| Ident::new(\u0026format!(\"__v{}\", i), Span::call_site()))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let pat = match variant.style {\n            Style::Struct =\u003e {\n                let members = variant.fields.iter().map(|field| \u0026field.member);\n                quote!({ #(#members: #placeholders),* })\n            }\n            Style::Tuple | Style::Newtype =\u003e quote!(( #(#placeholders),* )),\n            Style::Unit =\u003e quote!(),\n        };\n\n        quote! {\n            match _serde::export::None {\n                _serde::export::Some((#(#placeholders,)*)) =\u003e {\n                    let _ = #type_ident::#variant_ident #turbofish #pat;\n                }\n                _ =\u003e {}\n            }\n        }\n    });\n\n    quote!(#(#cases)*)\n}\n\nfn struct_pattern(fields: \u0026[Field]) -\u003e TokenStream {\n    let members = fields.iter().map(|field| \u0026field.member);\n    let placeholders =\n        (0..fields.len()).map(|i| Ident::new(\u0026format!(\"__v{}\", i), Span::call_site()));\n    quote!({ #(#members: ref #placeholders),* })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","ser.rs"],"content":"use proc_macro2::{Span, TokenStream};\nuse syn::spanned::Spanned;\nuse syn::{self, Ident, Index, Member};\n\nuse bound;\nuse dummy;\nuse fragment::{Fragment, Match, Stmts};\nuse internals::ast::{Container, Data, Field, Style, Variant};\nuse internals::{attr, Ctxt, Derive};\nuse pretend;\n\npub fn expand_derive_serialize(input: \u0026syn::DeriveInput) -\u003e Result\u003cTokenStream, Vec\u003csyn::Error\u003e\u003e {\n    let ctxt = Ctxt::new();\n    let cont = match Container::from_ast(\u0026ctxt, input, Derive::Serialize) {\n        Some(cont) =\u003e cont,\n        None =\u003e return Err(ctxt.check().unwrap_err()),\n    };\n    precondition(\u0026ctxt, \u0026cont);\n    ctxt.check()?;\n\n    let ident = \u0026cont.ident;\n    let params = Parameters::new(\u0026cont);\n    let (impl_generics, ty_generics, where_clause) = params.generics.split_for_impl();\n    let body = Stmts(serialize_body(\u0026cont, \u0026params));\n    let serde = cont.attrs.serde_path();\n\n    let impl_block = if let Some(remote) = cont.attrs.remote() {\n        let vis = \u0026input.vis;\n        let used = pretend::pretend_used(\u0026cont);\n        quote! {\n            impl #impl_generics #ident #ty_generics #where_clause {\n                #vis fn serialize\u003c__S\u003e(__self: \u0026#remote #ty_generics, __serializer: __S) -\u003e #serde::export::Result\u003c__S::Ok, __S::Error\u003e\n                where\n                    __S: #serde::Serializer,\n                {\n                    #used\n                    #body\n                }\n            }\n        }\n    } else {\n        quote! {\n            #[automatically_derived]\n            impl #impl_generics #serde::Serialize for #ident #ty_generics #where_clause {\n                fn serialize\u003c__S\u003e(\u0026self, __serializer: __S) -\u003e #serde::export::Result\u003c__S::Ok, __S::Error\u003e\n                where\n                    __S: #serde::Serializer,\n                {\n                    #body\n                }\n            }\n        }\n    };\n\n    Ok(dummy::wrap_in_const(\n        cont.attrs.custom_serde_path(),\n        \"SERIALIZE\",\n        ident,\n        impl_block,\n    ))\n}\n\nfn precondition(cx: \u0026Ctxt, cont: \u0026Container) {\n    match cont.attrs.identifier() {\n        attr::Identifier::No =\u003e {}\n        attr::Identifier::Field =\u003e {\n            cx.error_spanned_by(cont.original, \"field identifiers cannot be serialized\");\n        }\n        attr::Identifier::Variant =\u003e {\n            cx.error_spanned_by(cont.original, \"variant identifiers cannot be serialized\");\n        }\n    }\n}\n\nstruct Parameters {\n    /// Variable holding the value being serialized. Either `self` for local\n    /// types or `__self` for remote types.\n    self_var: Ident,\n\n    /// Path to the type the impl is for. Either a single `Ident` for local\n    /// types or `some::remote::Ident` for remote types. Does not include\n    /// generic parameters.\n    this: syn::Path,\n\n    /// Generics including any explicit and inferred bounds for the impl.\n    generics: syn::Generics,\n\n    /// Type has a `serde(remote = \"...\")` attribute.\n    is_remote: bool,\n}\n\nimpl Parameters {\n    fn new(cont: \u0026Container) -\u003e Self {\n        let is_remote = cont.attrs.remote().is_some();\n        let self_var = if is_remote {\n            Ident::new(\"__self\", Span::call_site())\n        } else {\n            Ident::new(\"self\", Span::call_site())\n        };\n\n        let this = match cont.attrs.remote() {\n            Some(remote) =\u003e remote.clone(),\n            None =\u003e cont.ident.clone().into(),\n        };\n\n        let generics = build_generics(cont);\n\n        Parameters {\n            self_var: self_var,\n            this: this,\n            generics: generics,\n            is_remote: is_remote,\n        }\n    }\n\n    /// Type name to use in error messages and `\u0026'static str` arguments to\n    /// various Serializer methods.\n    fn type_name(\u0026self) -\u003e String {\n        self.this.segments.last().unwrap().ident.to_string()\n    }\n}\n\n// All the generics in the input, plus a bound `T: Serialize` for each generic\n// field type that will be serialized by us.\nfn build_generics(cont: \u0026Container) -\u003e syn::Generics {\n    let generics = bound::without_defaults(cont.generics);\n\n    let generics =\n        bound::with_where_predicates_from_fields(cont, \u0026generics, attr::Field::ser_bound);\n\n    let generics =\n        bound::with_where_predicates_from_variants(cont, \u0026generics, attr::Variant::ser_bound);\n\n    match cont.attrs.ser_bound() {\n        Some(predicates) =\u003e bound::with_where_predicates(\u0026generics, predicates),\n        None =\u003e bound::with_bound(\n            cont,\n            \u0026generics,\n            needs_serialize_bound,\n            \u0026parse_quote!(_serde::Serialize),\n        ),\n    }\n}\n\n// Fields with a `skip_serializing` or `serialize_with` attribute, or which\n// belong to a variant with a 'skip_serializing` or `serialize_with` attribute,\n// are not serialized by us so we do not generate a bound. Fields with a `bound`\n// attribute specify their own bound so we do not generate one. All other fields\n// may need a `T: Serialize` bound where T is the type of the field.\nfn needs_serialize_bound(field: \u0026attr::Field, variant: Option\u003c\u0026attr::Variant\u003e) -\u003e bool {\n    !field.skip_serializing()\n        \u0026\u0026 field.serialize_with().is_none()\n        \u0026\u0026 field.ser_bound().is_none()\n        \u0026\u0026 variant.map_or(true, |variant| {\n            !variant.skip_serializing()\n                \u0026\u0026 variant.serialize_with().is_none()\n                \u0026\u0026 variant.ser_bound().is_none()\n        })\n}\n\nfn serialize_body(cont: \u0026Container, params: \u0026Parameters) -\u003e Fragment {\n    if cont.attrs.transparent() {\n        serialize_transparent(cont, params)\n    } else if let Some(type_into) = cont.attrs.type_into() {\n        serialize_into(params, type_into)\n    } else {\n        match cont.data {\n            Data::Enum(ref variants) =\u003e serialize_enum(params, variants, \u0026cont.attrs),\n            Data::Struct(Style::Struct, ref fields) =\u003e {\n                serialize_struct(params, fields, \u0026cont.attrs)\n            }\n            Data::Struct(Style::Tuple, ref fields) =\u003e {\n                serialize_tuple_struct(params, fields, \u0026cont.attrs)\n            }\n            Data::Struct(Style::Newtype, ref fields) =\u003e {\n                serialize_newtype_struct(params, \u0026fields[0], \u0026cont.attrs)\n            }\n            Data::Struct(Style::Unit, _) =\u003e serialize_unit_struct(\u0026cont.attrs),\n        }\n    }\n}\n\nfn serialize_transparent(cont: \u0026Container, params: \u0026Parameters) -\u003e Fragment {\n    let fields = match cont.data {\n        Data::Struct(_, ref fields) =\u003e fields,\n        Data::Enum(_) =\u003e unreachable!(),\n    };\n\n    let self_var = \u0026params.self_var;\n    let transparent_field = fields.iter().find(|f| f.attrs.transparent()).unwrap();\n    let member = \u0026transparent_field.member;\n\n    let path = match transparent_field.attrs.serialize_with() {\n        Some(path) =\u003e quote!(#path),\n        None =\u003e {\n            let span = transparent_field.original.span();\n            quote_spanned!(span=\u003e _serde::Serialize::serialize)\n        }\n    };\n\n    quote_block! {\n        #path(\u0026#self_var.#member, __serializer)\n    }\n}\n\nfn serialize_into(params: \u0026Parameters, type_into: \u0026syn::Type) -\u003e Fragment {\n    let self_var = \u0026params.self_var;\n    quote_block! {\n        _serde::Serialize::serialize(\n            \u0026_serde::export::Into::\u003c#type_into\u003e::into(_serde::export::Clone::clone(#self_var)),\n            __serializer)\n    }\n}\n\nfn serialize_unit_struct(cattrs: \u0026attr::Container) -\u003e Fragment {\n    let type_name = cattrs.name().serialize_name();\n\n    quote_expr! {\n        _serde::Serializer::serialize_unit_struct(__serializer, #type_name)\n    }\n}\n\nfn serialize_newtype_struct(\n    params: \u0026Parameters,\n    field: \u0026Field,\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let type_name = cattrs.name().serialize_name();\n\n    let mut field_expr = get_member(\n        params,\n        field,\n        \u0026Member::Unnamed(Index {\n            index: 0,\n            span: Span::call_site(),\n        }),\n    );\n    if let Some(path) = field.attrs.serialize_with() {\n        field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n    }\n\n    let span = field.original.span();\n    let func = quote_spanned!(span=\u003e _serde::Serializer::serialize_newtype_struct);\n    quote_expr! {\n        #func(__serializer, #type_name, #field_expr)\n    }\n}\n\nfn serialize_tuple_struct(\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let serialize_stmts =\n        serialize_tuple_struct_visitor(fields, params, false, \u0026TupleTrait::SerializeTupleStruct);\n\n    let type_name = cattrs.name().serialize_name();\n\n    let mut serialized_fields = fields\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, ref field)| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some());\n\n    let len = serialized_fields\n        .map(|(i, field)| match field.attrs.skip_serializing_if() {\n            None =\u003e quote!(1),\n            Some(path) =\u003e {\n                let index = syn::Index {\n                    index: i as u32,\n                    span: Span::call_site(),\n                };\n                let field_expr = get_member(params, field, \u0026Member::Unnamed(index));\n                quote!(if #path(#field_expr) { 0 } else { 1 })\n            }\n        })\n        .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n\n    quote_block! {\n        let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple_struct(__serializer, #type_name, #len));\n        #(#serialize_stmts)*\n        _serde::ser::SerializeTupleStruct::end(__serde_state)\n    }\n}\n\nfn serialize_struct(params: \u0026Parameters, fields: \u0026[Field], cattrs: \u0026attr::Container) -\u003e Fragment {\n    assert!(fields.len() as u64 \u003c= u64::from(u32::max_value()));\n\n    if cattrs.has_flatten() {\n        serialize_struct_as_map(params, fields, cattrs)\n    } else {\n        serialize_struct_as_struct(params, fields, cattrs)\n    }\n}\n\nfn serialize_struct_tag_field(cattrs: \u0026attr::Container, struct_trait: \u0026StructTrait) -\u003e TokenStream {\n    match *cattrs.tag() {\n        attr::TagType::Internal { ref tag } =\u003e {\n            let type_name = cattrs.name().serialize_name();\n            let func = struct_trait.serialize_field(Span::call_site());\n            quote! {\n                try!(#func(\u0026mut __serde_state, #tag, #type_name));\n            }\n        }\n        _ =\u003e quote! {},\n    }\n}\n\nfn serialize_struct_as_struct(\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let serialize_fields =\n        serialize_struct_visitor(fields, params, false, \u0026StructTrait::SerializeStruct);\n\n    let type_name = cattrs.name().serialize_name();\n\n    let tag_field = serialize_struct_tag_field(cattrs, \u0026StructTrait::SerializeStruct);\n    let tag_field_exists = !tag_field.is_empty();\n\n    let mut serialized_fields = fields\n        .iter()\n        .filter(|\u0026field| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some() || tag_field_exists);\n\n    let len = serialized_fields\n        .map(|field| match field.attrs.skip_serializing_if() {\n            None =\u003e quote!(1),\n            Some(path) =\u003e {\n                let field_expr = get_member(params, field, \u0026field.member);\n                quote!(if #path(#field_expr) { 0 } else { 1 })\n            }\n        })\n        .fold(\n            quote!(#tag_field_exists as usize),\n            |sum, expr| quote!(#sum + #expr),\n        );\n\n    quote_block! {\n        let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct(__serializer, #type_name, #len));\n        #tag_field\n        #(#serialize_fields)*\n        _serde::ser::SerializeStruct::end(__serde_state)\n    }\n}\n\nfn serialize_struct_as_map(\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let serialize_fields =\n        serialize_struct_visitor(fields, params, false, \u0026StructTrait::SerializeMap);\n\n    let tag_field = serialize_struct_tag_field(cattrs, \u0026StructTrait::SerializeMap);\n    let tag_field_exists = !tag_field.is_empty();\n\n    let mut serialized_fields = fields\n        .iter()\n        .filter(|\u0026field| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some() || tag_field_exists);\n\n    let len = if cattrs.has_flatten() {\n        quote!(_serde::export::None)\n    } else {\n        let len = serialized_fields\n            .map(|field| match field.attrs.skip_serializing_if() {\n                None =\u003e quote!(1),\n                Some(path) =\u003e {\n                    let field_expr = get_member(params, field, \u0026field.member);\n                    quote!(if #path(#field_expr) { 0 } else { 1 })\n                }\n            })\n            .fold(\n                quote!(#tag_field_exists as usize),\n                |sum, expr| quote!(#sum + #expr),\n            );\n        quote!(_serde::export::Some(#len))\n    };\n\n    quote_block! {\n        let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(__serializer, #len));\n        #tag_field\n        #(#serialize_fields)*\n        _serde::ser::SerializeMap::end(__serde_state)\n    }\n}\n\nfn serialize_enum(params: \u0026Parameters, variants: \u0026[Variant], cattrs: \u0026attr::Container) -\u003e Fragment {\n    assert!(variants.len() as u64 \u003c= u64::from(u32::max_value()));\n\n    let self_var = \u0026params.self_var;\n\n    let arms: Vec\u003c_\u003e = variants\n        .iter()\n        .enumerate()\n        .map(|(variant_index, variant)| {\n            serialize_variant(params, variant, variant_index as u32, cattrs)\n        })\n        .collect();\n\n    quote_expr! {\n        match *#self_var {\n            #(#arms)*\n        }\n    }\n}\n\nfn serialize_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    variant_index: u32,\n    cattrs: \u0026attr::Container,\n) -\u003e TokenStream {\n    let this = \u0026params.this;\n    let variant_ident = \u0026variant.ident;\n\n    if variant.attrs.skip_serializing() {\n        let skipped_msg = format!(\n            \"the enum variant {}::{} cannot be serialized\",\n            params.type_name(),\n            variant_ident\n        );\n        let skipped_err = quote! {\n            _serde::export::Err(_serde::ser::Error::custom(#skipped_msg))\n        };\n        let fields_pat = match variant.style {\n            Style::Unit =\u003e quote!(),\n            Style::Newtype | Style::Tuple =\u003e quote!((..)),\n            Style::Struct =\u003e quote!({ .. }),\n        };\n        quote! {\n            #this::#variant_ident #fields_pat =\u003e #skipped_err,\n        }\n    } else {\n        // variant wasn't skipped\n        let case = match variant.style {\n            Style::Unit =\u003e {\n                quote! {\n                    #this::#variant_ident\n                }\n            }\n            Style::Newtype =\u003e {\n                quote! {\n                    #this::#variant_ident(ref __field0)\n                }\n            }\n            Style::Tuple =\u003e {\n                let field_names = (0..variant.fields.len())\n                    .map(|i| Ident::new(\u0026format!(\"__field{}\", i), Span::call_site()));\n                quote! {\n                    #this::#variant_ident(#(ref #field_names),*)\n                }\n            }\n            Style::Struct =\u003e {\n                let members = variant.fields.iter().map(|f| \u0026f.member);\n                quote! {\n                    #this::#variant_ident { #(ref #members),* }\n                }\n            }\n        };\n\n        let body = Match(match *cattrs.tag() {\n            attr::TagType::External =\u003e {\n                serialize_externally_tagged_variant(params, variant, variant_index, cattrs)\n            }\n            attr::TagType::Internal { ref tag } =\u003e {\n                serialize_internally_tagged_variant(params, variant, cattrs, tag)\n            }\n            attr::TagType::Adjacent {\n                ref tag,\n                ref content,\n            } =\u003e serialize_adjacently_tagged_variant(params, variant, cattrs, tag, content),\n            attr::TagType::None =\u003e serialize_untagged_variant(params, variant, cattrs),\n        });\n\n        quote! {\n            #case =\u003e #body\n        }\n    }\n}\n\nfn serialize_externally_tagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    variant_index: u32,\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    let type_name = cattrs.name().serialize_name();\n    let variant_name = variant.attrs.name().serialize_name();\n\n    if let Some(path) = variant.attrs.serialize_with() {\n        let ser = wrap_serialize_variant_with(params, path, variant);\n        return quote_expr! {\n            _serde::Serializer::serialize_newtype_variant(\n                __serializer,\n                #type_name,\n                #variant_index,\n                #variant_name,\n                #ser,\n            )\n        };\n    }\n\n    match variant.style {\n        Style::Unit =\u003e {\n            quote_expr! {\n                _serde::Serializer::serialize_unit_variant(\n                    __serializer,\n                    #type_name,\n                    #variant_index,\n                    #variant_name,\n                )\n            }\n        }\n        Style::Newtype =\u003e {\n            let field = \u0026variant.fields[0];\n            let mut field_expr = quote!(__field0);\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n            }\n\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e _serde::Serializer::serialize_newtype_variant);\n            quote_expr! {\n                #func(\n                    __serializer,\n                    #type_name,\n                    #variant_index,\n                    #variant_name,\n                    #field_expr,\n                )\n            }\n        }\n        Style::Tuple =\u003e serialize_tuple_variant(\n            TupleVariant::ExternallyTagged {\n                type_name: type_name,\n                variant_index: variant_index,\n                variant_name: variant_name,\n            },\n            params,\n            \u0026variant.fields,\n        ),\n        Style::Struct =\u003e serialize_struct_variant(\n            StructVariant::ExternallyTagged {\n                variant_index: variant_index,\n                variant_name: variant_name,\n            },\n            params,\n            \u0026variant.fields,\n            \u0026type_name,\n        ),\n    }\n}\n\nfn serialize_internally_tagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    cattrs: \u0026attr::Container,\n    tag: \u0026str,\n) -\u003e Fragment {\n    let type_name = cattrs.name().serialize_name();\n    let variant_name = variant.attrs.name().serialize_name();\n\n    let enum_ident_str = params.type_name();\n    let variant_ident_str = variant.ident.to_string();\n\n    if let Some(path) = variant.attrs.serialize_with() {\n        let ser = wrap_serialize_variant_with(params, path, variant);\n        return quote_expr! {\n            _serde::private::ser::serialize_tagged_newtype(\n                __serializer,\n                #enum_ident_str,\n                #variant_ident_str,\n                #tag,\n                #variant_name,\n                #ser,\n            )\n        };\n    }\n\n    match variant.style {\n        Style::Unit =\u003e {\n            quote_block! {\n                let mut __struct = try!(_serde::Serializer::serialize_struct(\n                    __serializer, #type_name, 1));\n                try!(_serde::ser::SerializeStruct::serialize_field(\n                    \u0026mut __struct, #tag, #variant_name));\n                _serde::ser::SerializeStruct::end(__struct)\n            }\n        }\n        Style::Newtype =\u003e {\n            let field = \u0026variant.fields[0];\n            let mut field_expr = quote!(__field0);\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n            }\n\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e _serde::private::ser::serialize_tagged_newtype);\n            quote_expr! {\n                #func(\n                    __serializer,\n                    #enum_ident_str,\n                    #variant_ident_str,\n                    #tag,\n                    #variant_name,\n                    #field_expr,\n                )\n            }\n        }\n        Style::Struct =\u003e serialize_struct_variant(\n            StructVariant::InternallyTagged {\n                tag: tag,\n                variant_name: variant_name,\n            },\n            params,\n            \u0026variant.fields,\n            \u0026type_name,\n        ),\n        Style::Tuple =\u003e unreachable!(\"checked in serde_derive_internals\"),\n    }\n}\n\nfn serialize_adjacently_tagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    cattrs: \u0026attr::Container,\n    tag: \u0026str,\n    content: \u0026str,\n) -\u003e Fragment {\n    let this = \u0026params.this;\n    let type_name = cattrs.name().serialize_name();\n    let variant_name = variant.attrs.name().serialize_name();\n\n    let inner = Stmts(if let Some(path) = variant.attrs.serialize_with() {\n        let ser = wrap_serialize_variant_with(params, path, variant);\n        quote_expr! {\n            _serde::Serialize::serialize(#ser, __serializer)\n        }\n    } else {\n        match variant.style {\n            Style::Unit =\u003e {\n                return quote_block! {\n                    let mut __struct = try!(_serde::Serializer::serialize_struct(\n                        __serializer, #type_name, 1));\n                    try!(_serde::ser::SerializeStruct::serialize_field(\n                        \u0026mut __struct, #tag, #variant_name));\n                    _serde::ser::SerializeStruct::end(__struct)\n                };\n            }\n            Style::Newtype =\u003e {\n                let field = \u0026variant.fields[0];\n                let mut field_expr = quote!(__field0);\n                if let Some(path) = field.attrs.serialize_with() {\n                    field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n                }\n\n                let span = field.original.span();\n                let func = quote_spanned!(span=\u003e _serde::ser::SerializeStruct::serialize_field);\n                return quote_block! {\n                    let mut __struct = try!(_serde::Serializer::serialize_struct(\n                        __serializer, #type_name, 2));\n                    try!(_serde::ser::SerializeStruct::serialize_field(\n                        \u0026mut __struct, #tag, #variant_name));\n                    try!(#func(\n                        \u0026mut __struct, #content, #field_expr));\n                    _serde::ser::SerializeStruct::end(__struct)\n                };\n            }\n            Style::Tuple =\u003e {\n                serialize_tuple_variant(TupleVariant::Untagged, params, \u0026variant.fields)\n            }\n            Style::Struct =\u003e serialize_struct_variant(\n                StructVariant::Untagged,\n                params,\n                \u0026variant.fields,\n                \u0026variant_name,\n            ),\n        }\n    });\n\n    let fields_ty = variant.fields.iter().map(|f| \u0026f.ty);\n    let fields_ident: \u0026Vec\u003c_\u003e = \u0026match variant.style {\n        Style::Unit =\u003e {\n            if variant.attrs.serialize_with().is_some() {\n                vec![]\n            } else {\n                unreachable!()\n            }\n        }\n        Style::Newtype =\u003e vec![Member::Named(Ident::new(\"__field0\", Span::call_site()))],\n        Style::Tuple =\u003e (0..variant.fields.len())\n            .map(|i| Member::Named(Ident::new(\u0026format!(\"__field{}\", i), Span::call_site())))\n            .collect(),\n        Style::Struct =\u003e variant.fields.iter().map(|f| f.member.clone()).collect(),\n    };\n\n    let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n\n    let wrapper_generics = if fields_ident.is_empty() {\n        params.generics.clone()\n    } else {\n        bound::with_lifetime_bound(\u0026params.generics, \"'__a\")\n    };\n    let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n\n    quote_block! {\n        struct __AdjacentlyTagged #wrapper_generics #where_clause {\n            data: (#(\u0026'__a #fields_ty,)*),\n            phantom: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n        }\n\n        impl #wrapper_impl_generics _serde::Serialize for __AdjacentlyTagged #wrapper_ty_generics #where_clause {\n            fn serialize\u003c__S\u003e(\u0026self, __serializer: __S) -\u003e _serde::export::Result\u003c__S::Ok, __S::Error\u003e\n            where\n                __S: _serde::Serializer,\n            {\n                let (#(#fields_ident,)*) = self.data;\n                #inner\n            }\n        }\n\n        let mut __struct = try!(_serde::Serializer::serialize_struct(\n            __serializer, #type_name, 2));\n        try!(_serde::ser::SerializeStruct::serialize_field(\n            \u0026mut __struct, #tag, #variant_name));\n        try!(_serde::ser::SerializeStruct::serialize_field(\n            \u0026mut __struct, #content, \u0026__AdjacentlyTagged {\n                data: (#(#fields_ident,)*),\n                phantom: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n            }));\n        _serde::ser::SerializeStruct::end(__struct)\n    }\n}\n\nfn serialize_untagged_variant(\n    params: \u0026Parameters,\n    variant: \u0026Variant,\n    cattrs: \u0026attr::Container,\n) -\u003e Fragment {\n    if let Some(path) = variant.attrs.serialize_with() {\n        let ser = wrap_serialize_variant_with(params, path, variant);\n        return quote_expr! {\n            _serde::Serialize::serialize(#ser, __serializer)\n        };\n    }\n\n    match variant.style {\n        Style::Unit =\u003e {\n            quote_expr! {\n                _serde::Serializer::serialize_unit(__serializer)\n            }\n        }\n        Style::Newtype =\u003e {\n            let field = \u0026variant.fields[0];\n            let mut field_expr = quote!(__field0);\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n            }\n\n            let span = field.original.span();\n            let func = quote_spanned!(span=\u003e _serde::Serialize::serialize);\n            quote_expr! {\n                #func(#field_expr, __serializer)\n            }\n        }\n        Style::Tuple =\u003e serialize_tuple_variant(TupleVariant::Untagged, params, \u0026variant.fields),\n        Style::Struct =\u003e {\n            let type_name = cattrs.name().serialize_name();\n            serialize_struct_variant(StructVariant::Untagged, params, \u0026variant.fields, \u0026type_name)\n        }\n    }\n}\n\nenum TupleVariant {\n    ExternallyTagged {\n        type_name: String,\n        variant_index: u32,\n        variant_name: String,\n    },\n    Untagged,\n}\n\nfn serialize_tuple_variant(\n    context: TupleVariant,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n) -\u003e Fragment {\n    let tuple_trait = match context {\n        TupleVariant::ExternallyTagged { .. } =\u003e TupleTrait::SerializeTupleVariant,\n        TupleVariant::Untagged =\u003e TupleTrait::SerializeTuple,\n    };\n\n    let serialize_stmts = serialize_tuple_struct_visitor(fields, params, true, \u0026tuple_trait);\n\n    let mut serialized_fields = fields\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, ref field)| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some());\n\n    let len = serialized_fields\n        .map(|(i, field)| match field.attrs.skip_serializing_if() {\n            None =\u003e quote!(1),\n            Some(path) =\u003e {\n                let field_expr = Ident::new(\u0026format!(\"__field{}\", i), Span::call_site());\n                quote!(if #path(#field_expr) { 0 } else { 1 })\n            }\n        })\n        .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n\n    match context {\n        TupleVariant::ExternallyTagged {\n            type_name,\n            variant_index,\n            variant_name,\n        } =\u003e {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple_variant(\n                    __serializer,\n                    #type_name,\n                    #variant_index,\n                    #variant_name,\n                    #len));\n                #(#serialize_stmts)*\n                _serde::ser::SerializeTupleVariant::end(__serde_state)\n            }\n        }\n        TupleVariant::Untagged =\u003e {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple(\n                    __serializer,\n                    #len));\n                #(#serialize_stmts)*\n                _serde::ser::SerializeTuple::end(__serde_state)\n            }\n        }\n    }\n}\n\nenum StructVariant\u003c'a\u003e {\n    ExternallyTagged {\n        variant_index: u32,\n        variant_name: String,\n    },\n    InternallyTagged {\n        tag: \u0026'a str,\n        variant_name: String,\n    },\n    Untagged,\n}\n\nfn serialize_struct_variant\u003c'a\u003e(\n    context: StructVariant\u003c'a\u003e,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    name: \u0026str,\n) -\u003e Fragment {\n    if fields.iter().any(|field| field.attrs.flatten()) {\n        return serialize_struct_variant_with_flatten(context, params, fields, name);\n    }\n\n    let struct_trait = match context {\n        StructVariant::ExternallyTagged { .. } =\u003e (StructTrait::SerializeStructVariant),\n        StructVariant::InternallyTagged { .. } | StructVariant::Untagged =\u003e {\n            (StructTrait::SerializeStruct)\n        }\n    };\n\n    let serialize_fields = serialize_struct_visitor(fields, params, true, \u0026struct_trait);\n\n    let mut serialized_fields = fields\n        .iter()\n        .filter(|\u0026field| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some());\n\n    let len = serialized_fields\n        .map(|field| {\n            let member = \u0026field.member;\n\n            match field.attrs.skip_serializing_if() {\n                Some(path) =\u003e quote!(if #path(#member) { 0 } else { 1 }),\n                None =\u003e quote!(1),\n            }\n        })\n        .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n\n    match context {\n        StructVariant::ExternallyTagged {\n            variant_index,\n            variant_name,\n        } =\u003e {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct_variant(\n                    __serializer,\n                    #name,\n                    #variant_index,\n                    #variant_name,\n                    #len,\n                ));\n                #(#serialize_fields)*\n                _serde::ser::SerializeStructVariant::end(__serde_state)\n            }\n        }\n        StructVariant::InternallyTagged { tag, variant_name } =\u003e {\n            quote_block! {\n                let mut __serde_state = try!(_serde::Serializer::serialize_struct(\n                    __serializer,\n                    #name,\n                    #len + 1,\n                ));\n                try!(_serde::ser::SerializeStruct::serialize_field(\n                    \u0026mut __serde_state,\n                    #tag,\n                    #variant_name,\n                ));\n                #(#serialize_fields)*\n                _serde::ser::SerializeStruct::end(__serde_state)\n            }\n        }\n        StructVariant::Untagged =\u003e {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct(\n                    __serializer,\n                    #name,\n                    #len,\n                ));\n                #(#serialize_fields)*\n                _serde::ser::SerializeStruct::end(__serde_state)\n            }\n        }\n    }\n}\n\nfn serialize_struct_variant_with_flatten\u003c'a\u003e(\n    context: StructVariant\u003c'a\u003e,\n    params: \u0026Parameters,\n    fields: \u0026[Field],\n    name: \u0026str,\n) -\u003e Fragment {\n    let struct_trait = StructTrait::SerializeMap;\n    let serialize_fields = serialize_struct_visitor(fields, params, true, \u0026struct_trait);\n\n    let mut serialized_fields = fields\n        .iter()\n        .filter(|\u0026field| !field.attrs.skip_serializing())\n        .peekable();\n\n    let let_mut = mut_if(serialized_fields.peek().is_some());\n\n    match context {\n        StructVariant::ExternallyTagged {\n            variant_index,\n            variant_name,\n        } =\u003e {\n            let this = \u0026params.this;\n            let fields_ty = fields.iter().map(|f| \u0026f.ty);\n            let members = \u0026fields.iter().map(|f| \u0026f.member).collect::\u003cVec\u003c_\u003e\u003e();\n\n            let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n            let wrapper_generics = bound::with_lifetime_bound(\u0026params.generics, \"'__a\");\n            let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n\n            quote_block! {\n                struct __EnumFlatten #wrapper_generics #where_clause {\n                    data: (#(\u0026'__a #fields_ty,)*),\n                    phantom: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n                }\n\n                impl #wrapper_impl_generics _serde::Serialize for __EnumFlatten #wrapper_ty_generics #where_clause {\n                    fn serialize\u003c__S\u003e(\u0026self, __serializer: __S) -\u003e _serde::export::Result\u003c__S::Ok, __S::Error\u003e\n                    where\n                        __S: _serde::Serializer,\n                    {\n                        let (#(#members,)*) = self.data;\n                        let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(\n                            __serializer,\n                            _serde::export::None));\n                        #(#serialize_fields)*\n                        _serde::ser::SerializeMap::end(__serde_state)\n                    }\n                }\n\n                _serde::Serializer::serialize_newtype_variant(\n                    __serializer,\n                    #name,\n                    #variant_index,\n                    #variant_name,\n                    \u0026__EnumFlatten {\n                        data: (#(#members,)*),\n                        phantom: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n                    })\n            }\n        }\n        StructVariant::InternallyTagged { tag, variant_name } =\u003e {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(\n                    __serializer,\n                    _serde::export::None));\n                try!(_serde::ser::SerializeMap::serialize_entry(\n                    \u0026mut __serde_state,\n                    #tag,\n                    #variant_name,\n                ));\n                #(#serialize_fields)*\n                _serde::ser::SerializeMap::end(__serde_state)\n            }\n        }\n        StructVariant::Untagged =\u003e {\n            quote_block! {\n                let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(\n                    __serializer,\n                    _serde::export::None));\n                #(#serialize_fields)*\n                _serde::ser::SerializeMap::end(__serde_state)\n            }\n        }\n    }\n}\n\nfn serialize_tuple_struct_visitor(\n    fields: \u0026[Field],\n    params: \u0026Parameters,\n    is_enum: bool,\n    tuple_trait: \u0026TupleTrait,\n) -\u003e Vec\u003cTokenStream\u003e {\n    fields\n        .iter()\n        .enumerate()\n        .filter(|\u0026(_, ref field)| !field.attrs.skip_serializing())\n        .map(|(i, field)| {\n            let mut field_expr = if is_enum {\n                let id = Ident::new(\u0026format!(\"__field{}\", i), Span::call_site());\n                quote!(#id)\n            } else {\n                get_member(\n                    params,\n                    field,\n                    \u0026Member::Unnamed(Index {\n                        index: i as u32,\n                        span: Span::call_site(),\n                    }),\n                )\n            };\n\n            let skip = field\n                .attrs\n                .skip_serializing_if()\n                .map(|path| quote!(#path(#field_expr)));\n\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n            }\n\n            let span = field.original.span();\n            let func = tuple_trait.serialize_element(span);\n            let ser = quote! {\n                try!(#func(\u0026mut __serde_state, #field_expr));\n            };\n\n            match skip {\n                None =\u003e ser,\n                Some(skip) =\u003e quote!(if !#skip { #ser }),\n            }\n        })\n        .collect()\n}\n\nfn serialize_struct_visitor(\n    fields: \u0026[Field],\n    params: \u0026Parameters,\n    is_enum: bool,\n    struct_trait: \u0026StructTrait,\n) -\u003e Vec\u003cTokenStream\u003e {\n    fields\n        .iter()\n        .filter(|\u0026field| !field.attrs.skip_serializing())\n        .map(|field| {\n            let member = \u0026field.member;\n\n            let mut field_expr = if is_enum {\n                quote!(#member)\n            } else {\n                get_member(params, field, \u0026member)\n            };\n\n            let key_expr = field.attrs.name().serialize_name();\n\n            let skip = field\n                .attrs\n                .skip_serializing_if()\n                .map(|path| quote!(#path(#field_expr)));\n\n            if let Some(path) = field.attrs.serialize_with() {\n                field_expr = wrap_serialize_field_with(params, field.ty, path, \u0026field_expr);\n            }\n\n            let span = field.original.span();\n            let ser = if field.attrs.flatten() {\n                let func = quote_spanned!(span=\u003e _serde::Serialize::serialize);\n                quote! {\n                    try!(#func(\u0026#field_expr, _serde::private::ser::FlatMapSerializer(\u0026mut __serde_state)));\n                }\n            } else {\n                let func = struct_trait.serialize_field(span);\n                quote! {\n                    try!(#func(\u0026mut __serde_state, #key_expr, #field_expr));\n                }\n            };\n\n            match skip {\n                None =\u003e ser,\n                Some(skip) =\u003e {\n                    if let Some(skip_func) = struct_trait.skip_field(span) {\n                        quote! {\n                            if !#skip {\n                                #ser\n                            } else {\n                                try!(#skip_func(\u0026mut __serde_state, #key_expr));\n                            }\n                        }\n                    } else {\n                        quote! {\n                            if !#skip {\n                                #ser\n                            }\n                        }\n                    }\n                }\n            }\n        })\n        .collect()\n}\n\nfn wrap_serialize_field_with(\n    params: \u0026Parameters,\n    field_ty: \u0026syn::Type,\n    serialize_with: \u0026syn::ExprPath,\n    field_expr: \u0026TokenStream,\n) -\u003e TokenStream {\n    wrap_serialize_with(params, serialize_with, \u0026[field_ty], \u0026[quote!(#field_expr)])\n}\n\nfn wrap_serialize_variant_with(\n    params: \u0026Parameters,\n    serialize_with: \u0026syn::ExprPath,\n    variant: \u0026Variant,\n) -\u003e TokenStream {\n    let field_tys: Vec\u003c_\u003e = variant.fields.iter().map(|field| field.ty).collect();\n    let field_exprs: Vec\u003c_\u003e = variant\n        .fields\n        .iter()\n        .map(|field| {\n            let id = match field.member {\n                Member::Named(ref ident) =\u003e ident.clone(),\n                Member::Unnamed(ref member) =\u003e {\n                    Ident::new(\u0026format!(\"__field{}\", member.index), Span::call_site())\n                }\n            };\n            quote!(#id)\n        })\n        .collect();\n    wrap_serialize_with(\n        params,\n        serialize_with,\n        field_tys.as_slice(),\n        field_exprs.as_slice(),\n    )\n}\n\nfn wrap_serialize_with(\n    params: \u0026Parameters,\n    serialize_with: \u0026syn::ExprPath,\n    field_tys: \u0026[\u0026syn::Type],\n    field_exprs: \u0026[TokenStream],\n) -\u003e TokenStream {\n    let this = \u0026params.this;\n    let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n\n    let wrapper_generics = if field_exprs.is_empty() {\n        params.generics.clone()\n    } else {\n        bound::with_lifetime_bound(\u0026params.generics, \"'__a\")\n    };\n    let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n\n    let field_access = (0..field_exprs.len()).map(|n| {\n        Member::Unnamed(Index {\n            index: n as u32,\n            span: Span::call_site(),\n        })\n    });\n\n    quote!({\n        struct __SerializeWith #wrapper_impl_generics #where_clause {\n            values: (#(\u0026'__a #field_tys, )*),\n            phantom: _serde::export::PhantomData\u003c#this #ty_generics\u003e,\n        }\n\n        impl #wrapper_impl_generics _serde::Serialize for __SerializeWith #wrapper_ty_generics #where_clause {\n            fn serialize\u003c__S\u003e(\u0026self, __s: __S) -\u003e _serde::export::Result\u003c__S::Ok, __S::Error\u003e\n            where\n                __S: _serde::Serializer,\n            {\n                #serialize_with(#(self.values.#field_access, )* __s)\n            }\n        }\n\n        \u0026__SerializeWith {\n            values: (#(#field_exprs, )*),\n            phantom: _serde::export::PhantomData::\u003c#this #ty_generics\u003e,\n        }\n    })\n}\n\n// Serialization of an empty struct results in code like:\n//\n//     let mut __serde_state = try!(serializer.serialize_struct(\"S\", 0));\n//     _serde::ser::SerializeStruct::end(__serde_state)\n//\n// where we want to omit the `mut` to avoid a warning.\nfn mut_if(is_mut: bool) -\u003e Option\u003cTokenStream\u003e {\n    if is_mut {\n        Some(quote!(mut))\n    } else {\n        None\n    }\n}\n\nfn get_member(params: \u0026Parameters, field: \u0026Field, member: \u0026Member) -\u003e TokenStream {\n    let self_var = \u0026params.self_var;\n    match (params.is_remote, field.attrs.getter()) {\n        (false, None) =\u003e quote!(\u0026#self_var.#member),\n        (true, None) =\u003e {\n            let inner = quote!(\u0026#self_var.#member);\n            let ty = field.ty;\n            quote!(_serde::private::ser::constrain::\u003c#ty\u003e(#inner))\n        }\n        (true, Some(getter)) =\u003e {\n            let ty = field.ty;\n            quote!(_serde::private::ser::constrain::\u003c#ty\u003e(\u0026#getter(#self_var)))\n        }\n        (false, Some(_)) =\u003e {\n            unreachable!(\"getter is only allowed for remote impls\");\n        }\n    }\n}\n\nenum StructTrait {\n    SerializeMap,\n    SerializeStruct,\n    SerializeStructVariant,\n}\n\nimpl StructTrait {\n    fn serialize_field(\u0026self, span: Span) -\u003e TokenStream {\n        match *self {\n            StructTrait::SerializeMap =\u003e quote_spanned!(span=\u003e _serde::ser::SerializeMap::serialize_entry),\n            StructTrait::SerializeStruct =\u003e quote_spanned!(span=\u003e _serde::ser::SerializeStruct::serialize_field),\n            StructTrait::SerializeStructVariant =\u003e quote_spanned!(span=\u003e _serde::ser::SerializeStructVariant::serialize_field),\n        }\n    }\n\n    fn skip_field(\u0026self, span: Span) -\u003e Option\u003cTokenStream\u003e {\n        match *self {\n            StructTrait::SerializeMap =\u003e None,\n            StructTrait::SerializeStruct =\u003e {\n                Some(quote_spanned!(span=\u003e _serde::ser::SerializeStruct::skip_field))\n            }\n            StructTrait::SerializeStructVariant =\u003e {\n                Some(quote_spanned!(span=\u003e _serde::ser::SerializeStructVariant::skip_field))\n            }\n        }\n    }\n}\n\nenum TupleTrait {\n    SerializeTuple,\n    SerializeTupleStruct,\n    SerializeTupleVariant,\n}\n\nimpl TupleTrait {\n    fn serialize_element(\u0026self, span: Span) -\u003e TokenStream {\n        match *self {\n            TupleTrait::SerializeTuple =\u003e quote_spanned!(span=\u003e _serde::ser::SerializeTuple::serialize_element),\n            TupleTrait::SerializeTupleStruct =\u003e quote_spanned!(span=\u003e _serde::ser::SerializeTupleStruct::serialize_field),\n            TupleTrait::SerializeTupleVariant =\u003e quote_spanned!(span=\u003e _serde::ser::SerializeTupleVariant::serialize_field),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive","src","try.rs"],"content":"use proc_macro2::{Punct, Spacing, TokenStream};\n\n// None of our generated code requires the `From::from` error conversion\n// performed by the standard library's `try!` macro. With this simplified macro\n// we see a significant improvement in type checking and borrow checking time of\n// the generated code and a slight improvement in binary size.\npub fn replacement() -\u003e TokenStream {\n    // Cannot pass `$expr` to `quote!` prior to Rust 1.17.0 so interpolate it.\n    let dollar = Punct::new('$', Spacing::Alone);\n\n    quote! {\n        #[allow(unused_macros)]\n        macro_rules! try {\n            (#dollar __expr:expr) =\u003e {\n                match #dollar __expr {\n                    _serde::export::Ok(__val) =\u003e __val,\n                    _serde::export::Err(__err) =\u003e {\n                        return _serde::export::Err(__err);\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_derive_internals","lib.rs"],"content":"#![doc(html_root_url = \"https://docs.rs/serde_derive_internals/0.25.0\")]\n#![allow(unknown_lints, bare_trait_objects)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(renamed_and_removed_lints))]\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        cognitive_complexity,\n        redundant_field_names,\n        trivially_copy_pass_by_ref\n    )\n)]\n\n#[macro_use]\nextern crate syn;\n\nextern crate proc_macro2;\nextern crate quote;\n\n#[path = \"src/mod.rs\"]\nmod internals;\n\npub use internals::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","assert.rs"],"content":"use serde::{Deserialize, Serialize};\n\nuse de::Deserializer;\nuse ser::Serializer;\nuse token::Token;\n\nuse std::fmt::Debug;\n\n/// Runs both `assert_ser_tokens` and `assert_de_tokens`.\n///\n/// ```edition2018\n/// # use serde::{Serialize, Deserialize};\n/// # use serde_test::{assert_tokens, Token};\n/// #\n/// # fn main() {\n/// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n/// struct S {\n///     a: u8,\n///     b: u8,\n/// }\n///\n/// let s = S { a: 0, b: 0 };\n/// assert_tokens(\u0026s, \u0026[\n///     Token::Struct { name: \"S\", len: 2 },\n///     Token::Str(\"a\"),\n///     Token::U8(0),\n///     Token::Str(\"b\"),\n///     Token::U8(0),\n///     Token::StructEnd,\n/// ]);\n/// # }\n/// ```\npub fn assert_tokens\u003c'de, T\u003e(value: \u0026T, tokens: \u0026'de [Token])\nwhere\n    T: Serialize + Deserialize\u003c'de\u003e + PartialEq + Debug,\n{\n    assert_ser_tokens(value, tokens);\n    assert_de_tokens(value, tokens);\n}\n\n/// Asserts that `value` serializes to the given `tokens`.\n///\n/// ```edition2018\n/// # use serde::{Serialize, Deserialize};\n/// # use serde_test::{assert_ser_tokens, Token};\n/// #\n/// # fn main() {\n/// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n/// struct S {\n///     a: u8,\n///     b: u8,\n/// }\n///\n/// let s = S { a: 0, b: 0 };\n/// assert_ser_tokens(\u0026s, \u0026[\n///     Token::Struct { name: \"S\", len: 2 },\n///     Token::Str(\"a\"),\n///     Token::U8(0),\n///     Token::Str(\"b\"),\n///     Token::U8(0),\n///     Token::StructEnd,\n/// ]);\n/// # }\n/// ```\npub fn assert_ser_tokens\u003cT\u003e(value: \u0026T, tokens: \u0026[Token])\nwhere\n    T: Serialize,\n{\n    let mut ser = Serializer::new(tokens);\n    match value.serialize(\u0026mut ser) {\n        Ok(_) =\u003e {}\n        Err(err) =\u003e panic!(\"value failed to serialize: {}\", err),\n    }\n\n    if ser.remaining() \u003e 0 {\n        panic!(\"{} remaining tokens\", ser.remaining());\n    }\n}\n\n/// Asserts that `value` serializes to the given `tokens`, and then yields\n/// `error`.\n///\n/// ```edition2018\n/// use std::sync::{Arc, Mutex};\n/// use std::thread;\n///\n/// use serde::Serialize;\n/// use serde_test::{assert_ser_tokens_error, Token};\n///\n/// #[derive(Serialize)]\n/// struct Example {\n///     lock: Arc\u003cMutex\u003cu32\u003e\u003e,\n/// }\n///\n/// fn main() {\n///     let example = Example { lock: Arc::new(Mutex::new(0)) };\n///     let lock = example.lock.clone();\n///\n///     let _ = thread::spawn(move || {\n///         // This thread will acquire the mutex first, unwrapping the result\n///         // of `lock` because the lock has not been poisoned.\n///         let _guard = lock.lock().unwrap();\n///\n///         // This panic while holding the lock (`_guard` is in scope) will\n///         // poison the mutex.\n///         panic!()\n///     }).join();\n///\n///     let expected = \u0026[\n///         Token::Struct { name: \"Example\", len: 1 },\n///         Token::Str(\"lock\"),\n///     ];\n///     let error = \"lock poison error while serializing\";\n///     assert_ser_tokens_error(\u0026example, expected, error);\n/// }\n/// ```\npub fn assert_ser_tokens_error\u003cT\u003e(value: \u0026T, tokens: \u0026[Token], error: \u0026str)\nwhere\n    T: Serialize,\n{\n    let mut ser = Serializer::new(tokens);\n    match value.serialize(\u0026mut ser) {\n        Ok(_) =\u003e panic!(\"value serialized successfully\"),\n        Err(e) =\u003e assert_eq!(e, *error),\n    }\n\n    if ser.remaining() \u003e 0 {\n        panic!(\"{} remaining tokens\", ser.remaining());\n    }\n}\n\n/// Asserts that the given `tokens` deserialize into `value`.\n///\n/// ```edition2018\n/// # use serde::{Serialize, Deserialize};\n/// # use serde_test::{assert_de_tokens, Token};\n/// #\n/// # fn main() {\n/// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n/// struct S {\n///     a: u8,\n///     b: u8,\n/// }\n///\n/// let s = S { a: 0, b: 0 };\n/// assert_de_tokens(\u0026s, \u0026[\n///     Token::Struct { name: \"S\", len: 2 },\n///     Token::Str(\"a\"),\n///     Token::U8(0),\n///     Token::Str(\"b\"),\n///     Token::U8(0),\n///     Token::StructEnd,\n/// ]);\n/// # }\n/// ```\npub fn assert_de_tokens\u003c'de, T\u003e(value: \u0026T, tokens: \u0026'de [Token])\nwhere\n    T: Deserialize\u003c'de\u003e + PartialEq + Debug,\n{\n    let mut de = Deserializer::new(tokens);\n    let mut deserialized_val = match T::deserialize(\u0026mut de) {\n        Ok(v) =\u003e {\n            assert_eq!(v, *value);\n            v\n        }\n        Err(e) =\u003e panic!(\"tokens failed to deserialize: {}\", e),\n    };\n    if de.remaining() \u003e 0 {\n        panic!(\"{} remaining tokens\", de.remaining());\n    }\n\n    // Do the same thing for deserialize_in_place. This isn't *great* because a\n    // no-op impl of deserialize_in_place can technically succeed here. Still,\n    // this should catch a lot of junk.\n    let mut de = Deserializer::new(tokens);\n    match T::deserialize_in_place(\u0026mut de, \u0026mut deserialized_val) {\n        Ok(()) =\u003e {\n            assert_eq!(deserialized_val, *value);\n        }\n        Err(e) =\u003e panic!(\"tokens failed to deserialize_in_place: {}\", e),\n    }\n    if de.remaining() \u003e 0 {\n        panic!(\"{} remaining tokens\", de.remaining());\n    }\n}\n\n/// Asserts that the given `tokens` yield `error` when deserializing.\n///\n/// ```edition2018\n/// # use serde::{Serialize, Deserialize};\n/// # use serde_test::{assert_de_tokens_error, Token};\n/// #\n/// # fn main() {\n/// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n/// #[serde(deny_unknown_fields)]\n/// struct S {\n///     a: u8,\n///     b: u8,\n/// }\n///\n/// assert_de_tokens_error::\u003cS\u003e(\n///     \u0026[\n///         Token::Struct { name: \"S\", len: 2 },\n///         Token::Str(\"x\"),\n///     ],\n///     \"unknown field `x`, expected `a` or `b`\",\n/// );\n/// # }\n/// ```\npub fn assert_de_tokens_error\u003c'de, T\u003e(tokens: \u0026'de [Token], error: \u0026str)\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    let mut de = Deserializer::new(tokens);\n    match T::deserialize(\u0026mut de) {\n        Ok(_) =\u003e panic!(\"tokens deserialized successfully\"),\n        Err(e) =\u003e assert_eq!(e, *error),\n    }\n\n    // There may be one token left if a peek caused the error\n    de.next_token_opt();\n\n    if de.remaining() \u003e 0 {\n        panic!(\"{} remaining tokens\", de.remaining());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","configure.rs"],"content":"use std::fmt;\n\nuse serde::ser::{\n    SerializeMap, SerializeSeq, SerializeStruct, SerializeStructVariant, SerializeTuple,\n    SerializeTupleStruct, SerializeTupleVariant,\n};\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]\npub struct Readable\u003cT: ?Sized\u003e(T);\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]\npub struct Compact\u003cT: ?Sized\u003e(T);\n\n/// Trait to determine whether a value is represented in human-readable or\n/// compact form.\n///\n/// ```edition2018\n/// use serde::{Deserialize, Deserializer, Serialize, Serializer};\n/// use serde_test::{assert_tokens, Configure, Token};\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Example(u8, u8);\n///\n/// impl Serialize for Example {\n///     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n///     where\n///         S: Serializer,\n///     {\n///         if serializer.is_human_readable() {\n///             format!(\"{}.{}\", self.0, self.1).serialize(serializer)\n///         } else {\n///             (self.0, self.1).serialize(serializer)\n///         }\n///     }\n/// }\n///\n/// impl\u003c'de\u003e Deserialize\u003c'de\u003e for Example {\n///     fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n///     where\n///         D: Deserializer\u003c'de\u003e,\n///     {\n///         use serde::de::Error;\n///         if deserializer.is_human_readable() {\n///             let s = String::deserialize(deserializer)?;\n///             let parts: Vec\u003c_\u003e = s.split('.').collect();\n///             Ok(Example(\n///                 parts[0].parse().map_err(D::Error::custom)?,\n///                 parts[1].parse().map_err(D::Error::custom)?,\n///             ))\n///         } else {\n///             let (x, y) = Deserialize::deserialize(deserializer)?;\n///             Ok(Example(x, y))\n///         }\n///     }\n/// }\n///\n/// fn main() {\n///     assert_tokens(\n///         \u0026Example(1, 0).compact(),\n///         \u0026[\n///             Token::Tuple { len: 2 },\n///             Token::U8(1),\n///             Token::U8(0),\n///             Token::TupleEnd,\n///         ],\n///     );\n///     assert_tokens(\u0026Example(1, 0).readable(), \u0026[Token::Str(\"1.0\")]);\n/// }\n/// ```\npub trait Configure {\n    /// Marks `self` as using `is_human_readable == true`\n    fn readable(self) -\u003e Readable\u003cSelf\u003e\n    where\n        Self: Sized,\n    {\n        Readable(self)\n    }\n    /// Marks `self` as using `is_human_readable == false`\n    fn compact(self) -\u003e Compact\u003cSelf\u003e\n    where\n        Self: Sized,\n    {\n        Compact(self)\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Configure for T {}\n\nimpl\u003cT: ?Sized\u003e Serialize for Readable\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.0.serialize(Readable(serializer))\n    }\n}\nimpl\u003cT: ?Sized\u003e Serialize for Compact\u003cT\u003e\nwhere\n    T: Serialize,\n{\n    #[inline]\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        self.0.serialize(Compact(serializer))\n    }\n}\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Readable\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(Readable(deserializer)).map(Readable)\n    }\n}\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for Compact\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(Compact(deserializer)).map(Compact)\n    }\n}\n\nimpl\u003c'de, T\u003e DeserializeSeed\u003c'de\u003e for Readable\u003cT\u003e\nwhere\n    T: DeserializeSeed\u003c'de\u003e,\n{\n    type Value = T::Value;\n\n    fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        self.0.deserialize(Readable(deserializer))\n    }\n}\nimpl\u003c'de, T\u003e DeserializeSeed\u003c'de\u003e for Compact\u003cT\u003e\nwhere\n    T: DeserializeSeed\u003c'de\u003e,\n{\n    type Value = T::Value;\n\n    fn deserialize\u003cD\u003e(self, deserializer: D) -\u003e Result\u003cSelf::Value, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        self.0.deserialize(Compact(deserializer))\n    }\n}\n\nmacro_rules! forward_method {\n    ($name: ident (self $(, $arg: ident : $arg_type: ty)* ) -\u003e $return_type: ty) =\u003e {\n        fn $name (self $(, $arg : $arg_type)* ) -\u003e $return_type {\n            (self.0).$name( $($arg),* )\n        }\n    };\n}\n\nmacro_rules! forward_serialize_methods {\n    ( $( $name: ident $arg_type: ty ),* ) =\u003e {\n        $(\n            forward_method!($name(self, v : $arg_type) -\u003e Result\u003cSelf::Ok, Self::Error\u003e);\n        )*\n    };\n}\n\nmacro_rules! impl_serializer {\n    ($wrapper:ident, $is_human_readable:expr) =\u003e {\n        impl\u003cS\u003e Serializer for $wrapper\u003cS\u003e\n        where\n            S: Serializer,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n\n            type SerializeSeq = $wrapper\u003cS::SerializeSeq\u003e;\n            type SerializeTuple = $wrapper\u003cS::SerializeTuple\u003e;\n            type SerializeTupleStruct = $wrapper\u003cS::SerializeTupleStruct\u003e;\n            type SerializeTupleVariant = $wrapper\u003cS::SerializeTupleVariant\u003e;\n            type SerializeMap = $wrapper\u003cS::SerializeMap\u003e;\n            type SerializeStruct = $wrapper\u003cS::SerializeStruct\u003e;\n            type SerializeStructVariant = $wrapper\u003cS::SerializeStructVariant\u003e;\n\n            fn is_human_readable(\u0026self) -\u003e bool {\n                $is_human_readable\n            }\n\n            forward_serialize_methods! {\n                serialize_bool bool,\n                serialize_i8 i8,\n                serialize_i16 i16,\n                serialize_i32 i32,\n                serialize_i64 i64,\n                serialize_u8 u8,\n                serialize_u16 u16,\n                serialize_u32 u32,\n                serialize_u64 u64,\n                serialize_f32 f32,\n                serialize_f64 f64,\n                serialize_char char,\n                serialize_str \u0026str,\n                serialize_bytes \u0026[u8],\n                serialize_unit_struct \u0026'static str\n\n            }\n\n            fn serialize_unit(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.serialize_unit()\n            }\n\n            fn serialize_unit_variant(\n                self,\n                name: \u0026'static str,\n                variant_index: u32,\n                variant: \u0026'static str,\n            ) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.serialize_unit_variant(name, variant_index, variant)\n            }\n\n            fn serialize_newtype_struct\u003cT: ?Sized\u003e(\n                self,\n                name: \u0026'static str,\n                value: \u0026T,\n            ) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_newtype_struct(name, \u0026$wrapper(value))\n            }\n\n            fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n                self,\n                name: \u0026'static str,\n                variant_index: u32,\n                variant: \u0026'static str,\n                value: \u0026T,\n            ) -\u003e Result\u003cS::Ok, S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0\n                    .serialize_newtype_variant(name, variant_index, variant, \u0026$wrapper(value))\n            }\n\n            fn serialize_none(self) -\u003e Result\u003cS::Ok, Self::Error\u003e {\n                self.0.serialize_none()\n            }\n\n            fn serialize_some\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003cS::Ok, Self::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_some(\u0026$wrapper(value))\n            }\n\n            fn serialize_seq(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeSeq, Self::Error\u003e {\n                self.0.serialize_seq(len).map($wrapper)\n            }\n\n            fn serialize_tuple(self, len: usize) -\u003e Result\u003cSelf::SerializeTuple, Self::Error\u003e {\n                self.0.serialize_tuple(len).map($wrapper)\n            }\n\n            fn serialize_tuple_struct(\n                self,\n                name: \u0026'static str,\n                len: usize,\n            ) -\u003e Result\u003cSelf::SerializeTupleStruct, Self::Error\u003e {\n                self.0.serialize_tuple_struct(name, len).map($wrapper)\n            }\n\n            fn serialize_tuple_variant(\n                self,\n                name: \u0026'static str,\n                variant_index: u32,\n                variant: \u0026'static str,\n                len: usize,\n            ) -\u003e Result\u003cSelf::SerializeTupleVariant, Self::Error\u003e {\n                self.0\n                    .serialize_tuple_variant(name, variant_index, variant, len)\n                    .map($wrapper)\n            }\n\n            fn serialize_map(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf::SerializeMap, Self::Error\u003e {\n                self.0.serialize_map(len).map($wrapper)\n            }\n\n            fn serialize_struct(\n                self,\n                name: \u0026'static str,\n                len: usize,\n            ) -\u003e Result\u003cSelf::SerializeStruct, Self::Error\u003e {\n                self.0.serialize_struct(name, len).map($wrapper)\n            }\n\n            fn serialize_struct_variant(\n                self,\n                name: \u0026'static str,\n                variant_index: u32,\n                variant: \u0026'static str,\n                len: usize,\n            ) -\u003e Result\u003cSelf::SerializeStructVariant, Self::Error\u003e {\n                self.0\n                    .serialize_struct_variant(name, variant_index, variant, len)\n                    .map($wrapper)\n            }\n        }\n\n        impl\u003cS\u003e SerializeSeq for $wrapper\u003cS\u003e\n        where\n            S: SerializeSeq,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_element(\u0026$wrapper(value))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n\n        impl\u003cS\u003e SerializeTuple for $wrapper\u003cS\u003e\n        where\n            S: SerializeTuple,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_element(\u0026$wrapper(value))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n\n        impl\u003cS\u003e SerializeTupleStruct for $wrapper\u003cS\u003e\n        where\n            S: SerializeTupleStruct,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_field(\u0026$wrapper(value))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n\n        impl\u003cS\u003e SerializeTupleVariant for $wrapper\u003cS\u003e\n        where\n            S: SerializeTupleVariant,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_field(\u0026$wrapper(value))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n\n        impl\u003cS\u003e SerializeMap for $wrapper\u003cS\u003e\n        where\n            S: SerializeMap,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_key(\u0026$wrapper(key))\n            }\n            fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_value(\u0026$wrapper(value))\n            }\n            fn serialize_entry\u003cK: ?Sized, V: ?Sized\u003e(\n                \u0026mut self,\n                key: \u0026K,\n                value: \u0026V,\n            ) -\u003e Result\u003c(), S::Error\u003e\n            where\n                K: Serialize,\n                V: Serialize,\n            {\n                self.0.serialize_entry(key, \u0026$wrapper(value))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n\n        impl\u003cS\u003e SerializeStruct for $wrapper\u003cS\u003e\n        where\n            S: SerializeStruct,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_field\u003cT: ?Sized\u003e(\n                \u0026mut self,\n                name: \u0026'static str,\n                field: \u0026T,\n            ) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_field(name, \u0026$wrapper(field))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n\n        impl\u003cS\u003e SerializeStructVariant for $wrapper\u003cS\u003e\n        where\n            S: SerializeStructVariant,\n        {\n            type Ok = S::Ok;\n            type Error = S::Error;\n            fn serialize_field\u003cT: ?Sized\u003e(\n                \u0026mut self,\n                name: \u0026'static str,\n                field: \u0026T,\n            ) -\u003e Result\u003c(), S::Error\u003e\n            where\n                T: Serialize,\n            {\n                self.0.serialize_field(name, \u0026$wrapper(field))\n            }\n            fn end(self) -\u003e Result\u003cS::Ok, S::Error\u003e {\n                self.0.end()\n            }\n        }\n    };\n}\n\nimpl_serializer!(Readable, true);\nimpl_serializer!(Compact, false);\n\nuse serde::de::{DeserializeSeed, EnumAccess, Error, MapAccess, SeqAccess, VariantAccess, Visitor};\n\nmacro_rules! forward_deserialize_methods {\n    ( $wrapper : ident ( $( $name: ident ),* ) ) =\u003e {\n        $(\n            fn $name\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                (self.0).$name($wrapper(visitor))\n            }\n        )*\n    };\n}\n\nmacro_rules! impl_deserializer {\n    ($wrapper:ident, $is_human_readable:expr) =\u003e {\n        impl\u003c'de, D\u003e Deserializer\u003c'de\u003e for $wrapper\u003cD\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            type Error = D::Error;\n\n            forward_deserialize_methods! {\n                $wrapper (\n                    deserialize_any,\n                    deserialize_bool,\n                    deserialize_u8,\n                    deserialize_u16,\n                    deserialize_u32,\n                    deserialize_u64,\n                    deserialize_i8,\n                    deserialize_i16,\n                    deserialize_i32,\n                    deserialize_i64,\n                    deserialize_f32,\n                    deserialize_f64,\n                    deserialize_char,\n                    deserialize_str,\n                    deserialize_string,\n                    deserialize_bytes,\n                    deserialize_byte_buf,\n                    deserialize_option,\n                    deserialize_unit,\n                    deserialize_seq,\n                    deserialize_map,\n                    deserialize_identifier,\n                    deserialize_ignored_any\n                )\n            }\n\n            fn deserialize_unit_struct\u003cV\u003e(\n                self,\n                name: \u0026'static str,\n                visitor: V,\n            ) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.deserialize_unit_struct(name, $wrapper(visitor))\n            }\n            fn deserialize_newtype_struct\u003cV\u003e(\n                self,\n                name: \u0026'static str,\n                visitor: V,\n            ) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.deserialize_newtype_struct(name, $wrapper(visitor))\n            }\n            fn deserialize_tuple\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.deserialize_tuple(len, $wrapper(visitor))\n            }\n            fn deserialize_tuple_struct\u003cV\u003e(\n                self,\n                name: \u0026'static str,\n                len: usize,\n                visitor: V,\n            ) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0\n                    .deserialize_tuple_struct(name, len, $wrapper(visitor))\n            }\n            fn deserialize_struct\u003cV\u003e(\n                self,\n                name: \u0026'static str,\n                fields: \u0026'static [\u0026'static str],\n                visitor: V,\n            ) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.deserialize_struct(name, fields, $wrapper(visitor))\n            }\n            fn deserialize_enum\u003cV\u003e(\n                self,\n                name: \u0026'static str,\n                variants: \u0026'static [\u0026'static str],\n                visitor: V,\n            ) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.deserialize_enum(name, variants, $wrapper(visitor))\n            }\n\n            fn is_human_readable(\u0026self) -\u003e bool {\n                $is_human_readable\n            }\n        }\n\n        impl\u003c'de, D\u003e Visitor\u003c'de\u003e for $wrapper\u003cD\u003e\n        where\n            D: Visitor\u003c'de\u003e,\n        {\n            type Value = D::Value;\n            fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                self.0.expecting(formatter)\n            }\n            fn visit_bool\u003cE\u003e(self, v: bool) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_bool(v)\n            }\n            fn visit_i8\u003cE\u003e(self, v: i8) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_i8(v)\n            }\n            fn visit_i16\u003cE\u003e(self, v: i16) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_i16(v)\n            }\n            fn visit_i32\u003cE\u003e(self, v: i32) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_i32(v)\n            }\n            fn visit_i64\u003cE\u003e(self, v: i64) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_i64(v)\n            }\n            fn visit_u8\u003cE\u003e(self, v: u8) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_u8(v)\n            }\n            fn visit_u16\u003cE\u003e(self, v: u16) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_u16(v)\n            }\n            fn visit_u32\u003cE\u003e(self, v: u32) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_u32(v)\n            }\n            fn visit_u64\u003cE\u003e(self, v: u64) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_u64(v)\n            }\n            fn visit_f32\u003cE\u003e(self, v: f32) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_f32(v)\n            }\n            fn visit_f64\u003cE\u003e(self, v: f64) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_f64(v)\n            }\n            fn visit_char\u003cE\u003e(self, v: char) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_char(v)\n            }\n            fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_str(v)\n            }\n            fn visit_borrowed_str\u003cE\u003e(self, v: \u0026'de str) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_borrowed_str(v)\n            }\n            fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_string(v)\n            }\n            fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_bytes(v)\n            }\n            fn visit_borrowed_bytes\u003cE\u003e(self, v: \u0026'de [u8]) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_borrowed_bytes(v)\n            }\n            fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_byte_buf(v)\n            }\n            fn visit_none\u003cE\u003e(self) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_none()\n            }\n            fn visit_some\u003cD2\u003e(self, deserializer: D2) -\u003e Result\u003cSelf::Value, D2::Error\u003e\n            where\n                D2: Deserializer\u003c'de\u003e,\n            {\n                self.0.visit_some($wrapper(deserializer))\n            }\n            fn visit_unit\u003cE\u003e(self) -\u003e Result\u003cD::Value, E\u003e\n            where\n                E: Error,\n            {\n                self.0.visit_unit()\n            }\n            fn visit_newtype_struct\u003cD2\u003e(self, deserializer: D2) -\u003e Result\u003cSelf::Value, D2::Error\u003e\n            where\n                D2: Deserializer\u003c'de\u003e,\n            {\n                self.0.visit_newtype_struct($wrapper(deserializer))\n            }\n            fn visit_seq\u003cV\u003e(self, seq: V) -\u003e Result\u003cD::Value, V::Error\u003e\n            where\n                V: SeqAccess\u003c'de\u003e,\n            {\n                self.0.visit_seq($wrapper(seq))\n            }\n            fn visit_map\u003cV\u003e(self, map: V) -\u003e Result\u003cD::Value, V::Error\u003e\n            where\n                V: MapAccess\u003c'de\u003e,\n            {\n                self.0.visit_map($wrapper(map))\n            }\n            fn visit_enum\u003cV\u003e(self, data: V) -\u003e Result\u003cD::Value, V::Error\u003e\n            where\n                V: EnumAccess\u003c'de\u003e,\n            {\n                self.0.visit_enum($wrapper(data))\n            }\n        }\n\n        impl\u003c'de, D\u003e SeqAccess\u003c'de\u003e for $wrapper\u003cD\u003e\n        where\n            D: SeqAccess\u003c'de\u003e,\n        {\n            type Error = D::Error;\n            fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, D::Error\u003e\n            where\n                T: DeserializeSeed\u003c'de\u003e,\n            {\n                self.0.next_element_seed($wrapper(seed))\n            }\n            fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n                self.0.size_hint()\n            }\n        }\n\n        impl\u003c'de, D\u003e MapAccess\u003c'de\u003e for $wrapper\u003cD\u003e\n        where\n            D: MapAccess\u003c'de\u003e,\n        {\n            type Error = D::Error;\n            fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, D::Error\u003e\n            where\n                K: DeserializeSeed\u003c'de\u003e,\n            {\n                self.0.next_key_seed($wrapper(seed))\n            }\n            fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: DeserializeSeed\u003c'de\u003e,\n            {\n                self.0.next_value_seed($wrapper(seed))\n            }\n            fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n                self.0.size_hint()\n            }\n        }\n\n        impl\u003c'de, D\u003e EnumAccess\u003c'de\u003e for $wrapper\u003cD\u003e\n        where\n            D: EnumAccess\u003c'de\u003e,\n        {\n            type Error = D::Error;\n            type Variant = $wrapper\u003cD::Variant\u003e;\n            fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n            where\n                V: DeserializeSeed\u003c'de\u003e,\n            {\n                self.0\n                    .variant_seed($wrapper(seed))\n                    .map(|(value, variant)| (value, $wrapper(variant)))\n            }\n        }\n\n        impl\u003c'de, D\u003e VariantAccess\u003c'de\u003e for $wrapper\u003cD\u003e\n        where\n            D: VariantAccess\u003c'de\u003e,\n        {\n            type Error = D::Error;\n            fn unit_variant(self) -\u003e Result\u003c(), D::Error\u003e {\n                self.0.unit_variant()\n            }\n            fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, D::Error\u003e\n            where\n                T: DeserializeSeed\u003c'de\u003e,\n            {\n                self.0.newtype_variant_seed($wrapper(seed))\n            }\n            fn tuple_variant\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.tuple_variant(len, $wrapper(visitor))\n            }\n            fn struct_variant\u003cV\u003e(\n                self,\n                fields: \u0026'static [\u0026'static str],\n                visitor: V,\n            ) -\u003e Result\u003cV::Value, D::Error\u003e\n            where\n                V: Visitor\u003c'de\u003e,\n            {\n                self.0.struct_variant(fields, $wrapper(visitor))\n            }\n        }\n    };\n}\n\nimpl_deserializer!(Readable, true);\nimpl_deserializer!(Compact, false);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","de.rs"],"content":"use serde::de::value::{MapAccessDeserializer, SeqAccessDeserializer};\nuse serde::de::{\n    self, Deserialize, DeserializeSeed, EnumAccess, IntoDeserializer, MapAccess, SeqAccess,\n    VariantAccess, Visitor,\n};\n\nuse error::Error;\nuse token::Token;\n\n#[derive(Debug)]\npub struct Deserializer\u003c'de\u003e {\n    tokens: \u0026'de [Token],\n}\n\nmacro_rules! assert_next_token {\n    ($de:expr, $expected:expr) =\u003e {\n        match $de.next_token_opt() {\n            Some(token) if token == $expected =\u003e {}\n            Some(other) =\u003e panic!(\n                \"expected Token::{} but deserialization wants Token::{}\",\n                other, $expected\n            ),\n            None =\u003e panic!(\n                \"end of tokens but deserialization wants Token::{}\",\n                $expected\n            ),\n        }\n    };\n}\n\nmacro_rules! unexpected {\n    ($token:expr) =\u003e {\n        panic!(\"deserialization did not expect this token: {}\", $token)\n    };\n}\n\nmacro_rules! end_of_tokens {\n    () =\u003e {\n        panic!(\"ran out of tokens to deserialize\")\n    };\n}\n\nimpl\u003c'de\u003e Deserializer\u003c'de\u003e {\n    pub fn new(tokens: \u0026'de [Token]) -\u003e Self {\n        Deserializer { tokens: tokens }\n    }\n\n    fn peek_token_opt(\u0026self) -\u003e Option\u003cToken\u003e {\n        self.tokens.first().cloned()\n    }\n\n    fn peek_token(\u0026self) -\u003e Token {\n        match self.peek_token_opt() {\n            Some(token) =\u003e token,\n            None =\u003e end_of_tokens!(),\n        }\n    }\n\n    pub fn next_token_opt(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        match self.tokens.split_first() {\n            Some((\u0026first, rest)) =\u003e {\n                self.tokens = rest;\n                Some(first)\n            }\n            None =\u003e None,\n        }\n    }\n\n    fn next_token(\u0026mut self) -\u003e Token {\n        match self.tokens.split_first() {\n            Some((\u0026first, rest)) =\u003e {\n                self.tokens = rest;\n                first\n            }\n            None =\u003e end_of_tokens!(),\n        }\n    }\n\n    pub fn remaining(\u0026self) -\u003e usize {\n        self.tokens.len()\n    }\n\n    fn visit_seq\u003cV\u003e(\n        \u0026mut self,\n        len: Option\u003cusize\u003e,\n        end: Token,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        let value = visitor.visit_seq(DeserializerSeqVisitor {\n            de: self,\n            len: len,\n            end: end,\n        })?;\n        assert_next_token!(self, end);\n        Ok(value)\n    }\n\n    fn visit_map\u003cV\u003e(\n        \u0026mut self,\n        len: Option\u003cusize\u003e,\n        end: Token,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        let value = visitor.visit_map(DeserializerMapVisitor {\n            de: self,\n            len: len,\n            end: end,\n        })?;\n        assert_next_token!(self, end);\n        Ok(value)\n    }\n}\n\nimpl\u003c'de, 'a\u003e de::Deserializer\u003c'de\u003e for \u0026'a mut Deserializer\u003c'de\u003e {\n    type Error = Error;\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf unit seq map identifier ignored_any\n    }\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        let token = self.next_token();\n        match token {\n            Token::Bool(v) =\u003e visitor.visit_bool(v),\n            Token::I8(v) =\u003e visitor.visit_i8(v),\n            Token::I16(v) =\u003e visitor.visit_i16(v),\n            Token::I32(v) =\u003e visitor.visit_i32(v),\n            Token::I64(v) =\u003e visitor.visit_i64(v),\n            Token::U8(v) =\u003e visitor.visit_u8(v),\n            Token::U16(v) =\u003e visitor.visit_u16(v),\n            Token::U32(v) =\u003e visitor.visit_u32(v),\n            Token::U64(v) =\u003e visitor.visit_u64(v),\n            Token::F32(v) =\u003e visitor.visit_f32(v),\n            Token::F64(v) =\u003e visitor.visit_f64(v),\n            Token::Char(v) =\u003e visitor.visit_char(v),\n            Token::Str(v) =\u003e visitor.visit_str(v),\n            Token::BorrowedStr(v) =\u003e visitor.visit_borrowed_str(v),\n            Token::String(v) =\u003e visitor.visit_string(v.to_owned()),\n            Token::Bytes(v) =\u003e visitor.visit_bytes(v),\n            Token::BorrowedBytes(v) =\u003e visitor.visit_borrowed_bytes(v),\n            Token::ByteBuf(v) =\u003e visitor.visit_byte_buf(v.to_vec()),\n            Token::None =\u003e visitor.visit_none(),\n            Token::Some =\u003e visitor.visit_some(self),\n            Token::Unit | Token::UnitStruct { .. } =\u003e visitor.visit_unit(),\n            Token::NewtypeStruct { .. } =\u003e visitor.visit_newtype_struct(self),\n            Token::Seq { len } =\u003e self.visit_seq(len, Token::SeqEnd, visitor),\n            Token::Tuple { len } =\u003e self.visit_seq(Some(len), Token::TupleEnd, visitor),\n            Token::TupleStruct { len, .. } =\u003e {\n                self.visit_seq(Some(len), Token::TupleStructEnd, visitor)\n            }\n            Token::Map { len } =\u003e self.visit_map(len, Token::MapEnd, visitor),\n            Token::Struct { len, .. } =\u003e self.visit_map(Some(len), Token::StructEnd, visitor),\n            Token::Enum { .. } =\u003e {\n                let variant = self.next_token();\n                let next = self.peek_token();\n                match (variant, next) {\n                    (Token::Str(variant), Token::Unit) =\u003e {\n                        self.next_token();\n                        visitor.visit_str(variant)\n                    }\n                    (Token::Bytes(variant), Token::Unit) =\u003e {\n                        self.next_token();\n                        visitor.visit_bytes(variant)\n                    }\n                    (Token::U32(variant), Token::Unit) =\u003e {\n                        self.next_token();\n                        visitor.visit_u32(variant)\n                    }\n                    (variant, Token::Unit) =\u003e unexpected!(variant),\n                    (variant, _) =\u003e {\n                        visitor.visit_map(EnumMapVisitor::new(self, variant, EnumFormat::Any))\n                    }\n                }\n            }\n            Token::UnitVariant { variant, .. } =\u003e visitor.visit_str(variant),\n            Token::NewtypeVariant { variant, .. } =\u003e visitor.visit_map(EnumMapVisitor::new(\n                self,\n                Token::Str(variant),\n                EnumFormat::Any,\n            )),\n            Token::TupleVariant { variant, .. } =\u003e visitor.visit_map(EnumMapVisitor::new(\n                self,\n                Token::Str(variant),\n                EnumFormat::Seq,\n            )),\n            Token::StructVariant { variant, .. } =\u003e visitor.visit_map(EnumMapVisitor::new(\n                self,\n                Token::Str(variant),\n                EnumFormat::Map,\n            )),\n            Token::SeqEnd\n            | Token::TupleEnd\n            | Token::TupleStructEnd\n            | Token::MapEnd\n            | Token::StructEnd\n            | Token::TupleVariantEnd\n            | Token::StructVariantEnd =\u003e {\n                unexpected!(token);\n            }\n        }\n    }\n\n    fn deserialize_option\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::Unit | Token::None =\u003e {\n                self.next_token();\n                visitor.visit_none()\n            }\n            Token::Some =\u003e {\n                self.next_token();\n                visitor.visit_some(self)\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_enum\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        _variants: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::Enum { name: n } if name == n =\u003e {\n                self.next_token();\n\n                visitor.visit_enum(DeserializerEnumVisitor { de: self })\n            }\n            Token::UnitVariant { name: n, .. }\n            | Token::NewtypeVariant { name: n, .. }\n            | Token::TupleVariant { name: n, .. }\n            | Token::StructVariant { name: n, .. }\n                if name == n =\u003e\n            {\n                visitor.visit_enum(DeserializerEnumVisitor { de: self })\n            }\n            _ =\u003e {\n                unexpected!(self.next_token());\n            }\n        }\n    }\n\n    fn deserialize_unit_struct\u003cV\u003e(self, name: \u0026'static str, visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::UnitStruct { .. } =\u003e {\n                assert_next_token!(self, Token::UnitStruct { name: name });\n                visitor.visit_unit()\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_newtype_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::NewtypeStruct { .. } =\u003e {\n                assert_next_token!(self, Token::NewtypeStruct { name: name });\n                visitor.visit_newtype_struct(self)\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_tuple\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::Unit | Token::UnitStruct { .. } =\u003e {\n                self.next_token();\n                visitor.visit_unit()\n            }\n            Token::Seq { .. } =\u003e {\n                self.next_token();\n                self.visit_seq(Some(len), Token::SeqEnd, visitor)\n            }\n            Token::Tuple { .. } =\u003e {\n                self.next_token();\n                self.visit_seq(Some(len), Token::TupleEnd, visitor)\n            }\n            Token::TupleStruct { .. } =\u003e {\n                self.next_token();\n                self.visit_seq(Some(len), Token::TupleStructEnd, visitor)\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_tuple_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        len: usize,\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::Unit =\u003e {\n                self.next_token();\n                visitor.visit_unit()\n            }\n            Token::UnitStruct { .. } =\u003e {\n                assert_next_token!(self, Token::UnitStruct { name: name });\n                visitor.visit_unit()\n            }\n            Token::Seq { .. } =\u003e {\n                self.next_token();\n                self.visit_seq(Some(len), Token::SeqEnd, visitor)\n            }\n            Token::Tuple { .. } =\u003e {\n                self.next_token();\n                self.visit_seq(Some(len), Token::TupleEnd, visitor)\n            }\n            Token::TupleStruct { len: n, .. } =\u003e {\n                assert_next_token!(self, Token::TupleStruct { name: name, len: n });\n                self.visit_seq(Some(len), Token::TupleStructEnd, visitor)\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn deserialize_struct\u003cV\u003e(\n        self,\n        name: \u0026'static str,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.peek_token() {\n            Token::Struct { len: n, .. } =\u003e {\n                assert_next_token!(self, Token::Struct { name: name, len: n });\n                self.visit_map(Some(fields.len()), Token::StructEnd, visitor)\n            }\n            Token::Map { .. } =\u003e {\n                self.next_token();\n                self.visit_map(Some(fields.len()), Token::MapEnd, visitor)\n            }\n            _ =\u003e self.deserialize_any(visitor),\n        }\n    }\n\n    fn is_human_readable(\u0026self) -\u003e bool {\n        panic!(\n            \"Types which have different human-readable and compact representations \\\n             must explicitly mark their test cases with `serde_test::Configure`\"\n        );\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nstruct DeserializerSeqVisitor\u003c'a, 'de: 'a\u003e {\n    de: \u0026'a mut Deserializer\u003c'de\u003e,\n    len: Option\u003cusize\u003e,\n    end: Token,\n}\n\nimpl\u003c'de, 'a\u003e SeqAccess\u003c'de\u003e for DeserializerSeqVisitor\u003c'a, 'de\u003e {\n    type Error = Error;\n\n    fn next_element_seed\u003cT\u003e(\u0026mut self, seed: T) -\u003e Result\u003cOption\u003cT::Value\u003e, Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        if self.de.peek_token_opt() == Some(self.end) {\n            return Ok(None);\n        }\n        self.len = self.len.map(|len| len.saturating_sub(1));\n        seed.deserialize(\u0026mut *self.de).map(Some)\n    }\n\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        self.len\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nstruct DeserializerMapVisitor\u003c'a, 'de: 'a\u003e {\n    de: \u0026'a mut Deserializer\u003c'de\u003e,\n    len: Option\u003cusize\u003e,\n    end: Token,\n}\n\nimpl\u003c'de, 'a\u003e MapAccess\u003c'de\u003e for DeserializerMapVisitor\u003c'a, 'de\u003e {\n    type Error = Error;\n\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n    {\n        if self.de.peek_token_opt() == Some(self.end) {\n            return Ok(None);\n        }\n        self.len = self.len.map(|len| len.saturating_sub(1));\n        seed.deserialize(\u0026mut *self.de).map(Some)\n    }\n\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(\u0026mut *self.de)\n    }\n\n    fn size_hint(\u0026self) -\u003e Option\u003cusize\u003e {\n        self.len\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nstruct DeserializerEnumVisitor\u003c'a, 'de: 'a\u003e {\n    de: \u0026'a mut Deserializer\u003c'de\u003e,\n}\n\nimpl\u003c'de, 'a\u003e EnumAccess\u003c'de\u003e for DeserializerEnumVisitor\u003c'a, 'de\u003e {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self), Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.de.peek_token() {\n            Token::UnitVariant { variant: v, .. }\n            | Token::NewtypeVariant { variant: v, .. }\n            | Token::TupleVariant { variant: v, .. }\n            | Token::StructVariant { variant: v, .. } =\u003e {\n                let de = v.into_deserializer();\n                let value = seed.deserialize(de)?;\n                Ok((value, self))\n            }\n            _ =\u003e {\n                let value = seed.deserialize(\u0026mut *self.de)?;\n                Ok((value, self))\n            }\n        }\n    }\n}\n\nimpl\u003c'de, 'a\u003e VariantAccess\u003c'de\u003e for DeserializerEnumVisitor\u003c'a, 'de\u003e {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Error\u003e {\n        match self.de.peek_token() {\n            Token::UnitVariant { .. } =\u003e {\n                self.de.next_token();\n                Ok(())\n            }\n            _ =\u003e Deserialize::deserialize(self.de),\n        }\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.de.peek_token() {\n            Token::NewtypeVariant { .. } =\u003e {\n                self.de.next_token();\n                seed.deserialize(self.de)\n            }\n            _ =\u003e seed.deserialize(self.de),\n        }\n    }\n\n    fn tuple_variant\u003cV\u003e(self, len: usize, visitor: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.de.peek_token() {\n            Token::TupleVariant { len: enum_len, .. } =\u003e {\n                let token = self.de.next_token();\n\n                if len == enum_len {\n                    self.de\n                        .visit_seq(Some(len), Token::TupleVariantEnd, visitor)\n                } else {\n                    unexpected!(token);\n                }\n            }\n            Token::Seq {\n                len: Some(enum_len),\n            } =\u003e {\n                let token = self.de.next_token();\n\n                if len == enum_len {\n                    self.de.visit_seq(Some(len), Token::SeqEnd, visitor)\n                } else {\n                    unexpected!(token);\n                }\n            }\n            _ =\u003e de::Deserializer::deserialize_any(self.de, visitor),\n        }\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        match self.de.peek_token() {\n            Token::StructVariant { len: enum_len, .. } =\u003e {\n                let token = self.de.next_token();\n\n                if fields.len() == enum_len {\n                    self.de\n                        .visit_map(Some(fields.len()), Token::StructVariantEnd, visitor)\n                } else {\n                    unexpected!(token);\n                }\n            }\n            Token::Map {\n                len: Some(enum_len),\n            } =\u003e {\n                let token = self.de.next_token();\n\n                if fields.len() == enum_len {\n                    self.de\n                        .visit_map(Some(fields.len()), Token::MapEnd, visitor)\n                } else {\n                    unexpected!(token);\n                }\n            }\n            _ =\u003e de::Deserializer::deserialize_any(self.de, visitor),\n        }\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nstruct EnumMapVisitor\u003c'a, 'de: 'a\u003e {\n    de: \u0026'a mut Deserializer\u003c'de\u003e,\n    variant: Option\u003cToken\u003e,\n    format: EnumFormat,\n}\n\nenum EnumFormat {\n    Seq,\n    Map,\n    Any,\n}\n\nimpl\u003c'a, 'de\u003e EnumMapVisitor\u003c'a, 'de\u003e {\n    fn new(de: \u0026'a mut Deserializer\u003c'de\u003e, variant: Token, format: EnumFormat) -\u003e Self {\n        EnumMapVisitor {\n            de: de,\n            variant: Some(variant),\n            format: format,\n        }\n    }\n}\n\nimpl\u003c'de, 'a\u003e MapAccess\u003c'de\u003e for EnumMapVisitor\u003c'a, 'de\u003e {\n    type Error = Error;\n\n    fn next_key_seed\u003cK\u003e(\u0026mut self, seed: K) -\u003e Result\u003cOption\u003cK::Value\u003e, Error\u003e\n    where\n        K: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.variant.take() {\n            Some(Token::Str(variant)) =\u003e seed.deserialize(variant.into_deserializer()).map(Some),\n            Some(Token::Bytes(variant)) =\u003e seed\n                .deserialize(BytesDeserializer { value: variant })\n                .map(Some),\n            Some(Token::U32(variant)) =\u003e seed.deserialize(variant.into_deserializer()).map(Some),\n            Some(other) =\u003e unexpected!(other),\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn next_value_seed\u003cV\u003e(\u0026mut self, seed: V) -\u003e Result\u003cV::Value, Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        match self.format {\n            EnumFormat::Seq =\u003e {\n                let value = {\n                    let visitor = DeserializerSeqVisitor {\n                        de: self.de,\n                        len: None,\n                        end: Token::TupleVariantEnd,\n                    };\n                    seed.deserialize(SeqAccessDeserializer::new(visitor))?\n                };\n                assert_next_token!(self.de, Token::TupleVariantEnd);\n                Ok(value)\n            }\n            EnumFormat::Map =\u003e {\n                let value = {\n                    let visitor = DeserializerMapVisitor {\n                        de: self.de,\n                        len: None,\n                        end: Token::StructVariantEnd,\n                    };\n                    seed.deserialize(MapAccessDeserializer::new(visitor))?\n                };\n                assert_next_token!(self.de, Token::StructVariantEnd);\n                Ok(value)\n            }\n            EnumFormat::Any =\u003e seed.deserialize(\u0026mut *self.de),\n        }\n    }\n}\n\nstruct BytesDeserializer {\n    value: \u0026'static [u8],\n}\n\nimpl\u003c'de\u003e de::Deserializer\u003c'de\u003e for BytesDeserializer {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: de::Visitor\u003c'de\u003e,\n    {\n        visitor.visit_bytes(self.value)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","error.rs"],"content":"use std::error;\nuse std::fmt::{self, Display};\n\nuse serde::{de, ser};\n\n#[derive(Clone, Debug)]\npub struct Error {\n    msg: String,\n}\n\nimpl ser::Error for Error {\n    fn custom\u003cT: Display\u003e(msg: T) -\u003e Self {\n        Error {\n            msg: msg.to_string(),\n        }\n    }\n}\n\nimpl de::Error for Error {\n    fn custom\u003cT: Display\u003e(msg: T) -\u003e Self {\n        Error {\n            msg: msg.to_string(),\n        }\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\u0026self.msg)\n    }\n}\n\nimpl error::Error for Error {\n    fn description(\u0026self) -\u003e \u0026str {\n        \u0026self.msg\n    }\n}\n\nimpl PartialEq\u003cstr\u003e for Error {\n    fn eq(\u0026self, other: \u0026str) -\u003e bool {\n        self.msg == other\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","lib.rs"],"content":"//! This crate provides a convenient concise way to write unit tests for\n//! implementations of [`Serialize`] and [`Deserialize`].\n//!\n//! [`Serialize`]: https://docs.serde.rs/serde/ser/trait.Serialize.html\n//! [`Deserialize`]: https://docs.serde.rs/serde/de/trait.Deserialize.html\n//!\n//! The `Serialize` impl for a value can be characterized by the sequence of\n//! [`Serializer`] calls that are made in the course of serializing the value,\n//! so `serde_test` provides a [`Token`] abstraction which corresponds roughly\n//! to `Serializer` method calls. There is an [`assert_ser_tokens`] function to\n//! test that a value serializes to a particular sequence of method calls, an\n//! [`assert_de_tokens`] function to test that a value can be deserialized from\n//! a particular sequence of method calls, and an [`assert_tokens`] function to\n//! test both directions. There are also functions to test expected failure\n//! conditions.\n//!\n//! [`Serializer`]: https://docs.serde.rs/serde/ser/trait.Serializer.html\n//! [`Token`]: https://docs.serde.rs/serde_test/enum.Token.html\n//! [`assert_ser_tokens`]: https://docs.serde.rs/serde_test/fn.assert_ser_tokens.html\n//! [`assert_de_tokens`]: https://docs.serde.rs/serde_test/fn.assert_de_tokens.html\n//! [`assert_tokens`]: https://docs.serde.rs/serde_test/fn.assert_tokens.html\n//!\n//! Here is an example from the [`linked-hash-map`] crate.\n//!\n//! [`linked-hash-map`]: https://github.com/contain-rs/linked-hash-map\n//!\n//! ```edition2018\n//! # const IGNORE: \u0026str = stringify! {\n//! use linked_hash_map::LinkedHashMap;\n//! # };\n//! use serde_test::{Token, assert_tokens};\n//!\n//! # use std::fmt;\n//! # use std::marker::PhantomData;\n//! #\n//! # use serde::ser::{Serialize, Serializer, SerializeMap};\n//! # use serde::de::{Deserialize, Deserializer, Visitor, MapAccess};\n//! #\n//! # // Dumb imitation of LinkedHashMap.\n//! # #[derive(PartialEq, Debug)]\n//! # struct LinkedHashMap\u003cK, V\u003e(Vec\u003c(K, V)\u003e);\n//! #\n//! # impl\u003cK, V\u003e LinkedHashMap\u003cK, V\u003e {\n//! #     fn new() -\u003e Self {\n//! #         LinkedHashMap(Vec::new())\n//! #     }\n//! #\n//! #     fn insert(\u0026mut self, k: K, v: V) {\n//! #         self.0.push((k, v));\n//! #     }\n//! # }\n//! #\n//! # impl\u003cK, V\u003e Serialize for LinkedHashMap\u003cK, V\u003e\n//! # where\n//! #     K: Serialize,\n//! #     V: Serialize,\n//! # {\n//! #     fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n//! #     where\n//! #         S: Serializer,\n//! #     {\n//! #         let mut map = serializer.serialize_map(Some(self.0.len()))?;\n//! #         for \u0026(ref k, ref v) in \u0026self.0 {\n//! #             map.serialize_entry(k, v)?;\n//! #         }\n//! #         map.end()\n//! #     }\n//! # }\n//! #\n//! # struct LinkedHashMapVisitor\u003cK, V\u003e(PhantomData\u003c(K, V)\u003e);\n//! #\n//! # impl\u003c'de, K, V\u003e Visitor\u003c'de\u003e for LinkedHashMapVisitor\u003cK, V\u003e\n//! # where\n//! #     K: Deserialize\u003c'de\u003e,\n//! #     V: Deserialize\u003c'de\u003e,\n//! # {\n//! #     type Value = LinkedHashMap\u003cK, V\u003e;\n//! #\n//! #     fn expecting(\u0026self, _: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n//! #         unimplemented!()\n//! #     }\n//! #\n//! #     fn visit_map\u003cM\u003e(self, mut access: M) -\u003e Result\u003cSelf::Value, M::Error\u003e\n//! #     where\n//! #         M: MapAccess\u003c'de\u003e,\n//! #     {\n//! #         let mut map = LinkedHashMap::new();\n//! #         while let Some((key, value)) = access.next_entry()? {\n//! #             map.insert(key, value);\n//! #         }\n//! #         Ok(map)\n//! #     }\n//! # }\n//! #\n//! # impl\u003c'de, K, V\u003e Deserialize\u003c'de\u003e for LinkedHashMap\u003cK, V\u003e\n//! # where\n//! #     K: Deserialize\u003c'de\u003e,\n//! #     V: Deserialize\u003c'de\u003e,\n//! # {\n//! #     fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n//! #     where\n//! #         D: Deserializer\u003c'de\u003e,\n//! #     {\n//! #         deserializer.deserialize_map(LinkedHashMapVisitor(PhantomData))\n//! #     }\n//! # }\n//! #\n//! #[test]\n//! # fn not_a_test_ser_de_empty() {}\n//! fn test_ser_de_empty() {\n//!     let map = LinkedHashMap::\u003cchar, u32\u003e::new();\n//!\n//!     assert_tokens(\u0026map, \u0026[\n//!         Token::Map { len: Some(0) },\n//!         Token::MapEnd,\n//!     ]);\n//! }\n//!\n//! #[test]\n//! # fn not_a_test_ser_de() {}\n//! fn test_ser_de() {\n//!     let mut map = LinkedHashMap::new();\n//!     map.insert('b', 20);\n//!     map.insert('a', 10);\n//!     map.insert('c', 30);\n//!\n//!     assert_tokens(\u0026map, \u0026[\n//!         Token::Map { len: Some(3) },\n//!         Token::Char('b'),\n//!         Token::I32(20),\n//!\n//!         Token::Char('a'),\n//!         Token::I32(10),\n//!\n//!         Token::Char('c'),\n//!         Token::I32(30),\n//!         Token::MapEnd,\n//!     ]);\n//! }\n//! #\n//! # fn main() {\n//! #     test_ser_de_empty();\n//! #     test_ser_de();\n//! # }\n//! ```\n\n#![doc(html_root_url = \"https://docs.rs/serde_test/1.0.100\")]\n#![cfg_attr(feature = \"cargo-clippy\", allow(renamed_and_removed_lints))]\n#![cfg_attr(feature = \"cargo-clippy\", deny(clippy, clippy_pedantic))]\n// Ignored clippy lints\n#![cfg_attr(feature = \"cargo-clippy\", allow(float_cmp))]\n// Ignored clippy_pedantic lints\n#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(\n        empty_line_after_outer_attr,\n        missing_docs_in_private_items,\n        module_name_repetitions,\n        redundant_field_names,\n        use_debug,\n        use_self\n    )\n)]\n\n#[macro_use]\nextern crate serde;\n\nmod de;\nmod error;\nmod ser;\n\nmod assert;\nmod configure;\nmod token;\n\npub use assert::{\n    assert_de_tokens, assert_de_tokens_error, assert_ser_tokens, assert_ser_tokens_error,\n    assert_tokens,\n};\npub use token::Token;\n\npub use configure::{Compact, Configure, Readable};\n\n// Not public API.\n#[doc(hidden)]\npub use de::Deserializer;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","ser.rs"],"content":"use serde::{ser, Serialize};\n\nuse error::Error;\nuse token::Token;\n\n/// A `Serializer` that ensures that a value serializes to a given list of\n/// tokens.\n#[derive(Debug)]\npub struct Serializer\u003c'a\u003e {\n    tokens: \u0026'a [Token],\n}\n\nimpl\u003c'a\u003e Serializer\u003c'a\u003e {\n    /// Creates the serializer.\n    pub fn new(tokens: \u0026'a [Token]) -\u003e Self {\n        Serializer { tokens: tokens }\n    }\n\n    /// Pulls the next token off of the serializer, ignoring it.\n    fn next_token(\u0026mut self) -\u003e Option\u003cToken\u003e {\n        if let Some((\u0026first, rest)) = self.tokens.split_first() {\n            self.tokens = rest;\n            Some(first)\n        } else {\n            None\n        }\n    }\n\n    pub fn remaining(\u0026self) -\u003e usize {\n        self.tokens.len()\n    }\n}\n\nmacro_rules! assert_next_token {\n    ($ser:expr, $expected:ident) =\u003e {\n        assert_next_token!($ser, stringify!($expected), Token::$expected, true);\n    };\n    ($ser:expr, $expected:ident($v:expr)) =\u003e {\n        assert_next_token!(\n            $ser,\n            format_args!(concat!(stringify!($expected), \"({:?})\"), $v),\n            Token::$expected(v),\n            v == $v\n        );\n    };\n    ($ser:expr, $expected:ident { $($k:ident),* }) =\u003e {\n        let compare = ($($k,)*);\n        let field_format = || {\n            use std::fmt::Write;\n            let mut buffer = String::new();\n            $(\n                write!(\u0026mut buffer, concat!(stringify!($k), \": {:?}, \"), $k).unwrap();\n            )*\n            buffer\n        };\n        assert_next_token!(\n            $ser,\n            format_args!(concat!(stringify!($expected), \" {{ {}}}\"), field_format()),\n            Token::$expected { $($k),* },\n            ($($k,)*) == compare\n        );\n    };\n    ($ser:expr, $expected:expr, $pat:pat, $guard:expr) =\u003e {\n        match $ser.next_token() {\n            Some($pat) if $guard =\u003e {}\n            Some(other) =\u003e {\n                panic!(\"expected Token::{} but serialized as {}\",\n                       $expected, other);\n            }\n            None =\u003e {\n                panic!(\"expected Token::{} after end of serialized tokens\",\n                       $expected);\n            }\n        }\n    };\n}\n\nimpl\u003c's, 'a\u003e ser::Serializer for \u0026's mut Serializer\u003c'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    type SerializeSeq = Self;\n    type SerializeTuple = Self;\n    type SerializeTupleStruct = Self;\n    type SerializeTupleVariant = Variant\u003c's, 'a\u003e;\n    type SerializeMap = Self;\n    type SerializeStruct = Self;\n    type SerializeStructVariant = Variant\u003c's, 'a\u003e;\n\n    fn serialize_bool(self, v: bool) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, Bool(v));\n        Ok(())\n    }\n\n    fn serialize_i8(self, v: i8) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, I8(v));\n        Ok(())\n    }\n\n    fn serialize_i16(self, v: i16) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, I16(v));\n        Ok(())\n    }\n\n    fn serialize_i32(self, v: i32) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, I32(v));\n        Ok(())\n    }\n\n    fn serialize_i64(self, v: i64) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, I64(v));\n        Ok(())\n    }\n\n    fn serialize_u8(self, v: u8) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, U8(v));\n        Ok(())\n    }\n\n    fn serialize_u16(self, v: u16) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, U16(v));\n        Ok(())\n    }\n\n    fn serialize_u32(self, v: u32) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, U32(v));\n        Ok(())\n    }\n\n    fn serialize_u64(self, v: u64) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, U64(v));\n        Ok(())\n    }\n\n    fn serialize_f32(self, v: f32) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, F32(v));\n        Ok(())\n    }\n\n    fn serialize_f64(self, v: f64) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, F64(v));\n        Ok(())\n    }\n\n    fn serialize_char(self, v: char) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, Char(v));\n        Ok(())\n    }\n\n    fn serialize_str(self, v: \u0026str) -\u003e Result\u003c(), Error\u003e {\n        match self.tokens.first() {\n            Some(\u0026Token::BorrowedStr(_)) =\u003e assert_next_token!(self, BorrowedStr(v)),\n            Some(\u0026Token::String(_)) =\u003e assert_next_token!(self, String(v)),\n            _ =\u003e assert_next_token!(self, Str(v)),\n        }\n        Ok(())\n    }\n\n    fn serialize_bytes(self, v: \u0026[u8]) -\u003e Result\u003c(), Self::Error\u003e {\n        match self.tokens.first() {\n            Some(\u0026Token::BorrowedBytes(_)) =\u003e assert_next_token!(self, BorrowedBytes(v)),\n            Some(\u0026Token::ByteBuf(_)) =\u003e assert_next_token!(self, ByteBuf(v)),\n            _ =\u003e assert_next_token!(self, Bytes(v)),\n        }\n        Ok(())\n    }\n\n    fn serialize_unit(self) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, Unit);\n        Ok(())\n    }\n\n    fn serialize_unit_struct(self, name: \u0026'static str) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, UnitStruct { name });\n        Ok(())\n    }\n\n    fn serialize_unit_variant(\n        self,\n        name: \u0026'static str,\n        _variant_index: u32,\n        variant: \u0026'static str,\n    ) -\u003e Result\u003c(), Error\u003e {\n        if self.tokens.first() == Some(\u0026Token::Enum { name: name }) {\n            self.next_token();\n            assert_next_token!(self, Str(variant));\n            assert_next_token!(self, Unit);\n        } else {\n            assert_next_token!(self, UnitVariant { name, variant });\n        }\n        Ok(())\n    }\n\n    fn serialize_newtype_struct\u003cT: ?Sized\u003e(self, name: \u0026'static str, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        assert_next_token!(self, NewtypeStruct { name });\n        value.serialize(self)\n    }\n\n    fn serialize_newtype_variant\u003cT: ?Sized\u003e(\n        self,\n        name: \u0026'static str,\n        _variant_index: u32,\n        variant: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        if self.tokens.first() == Some(\u0026Token::Enum { name: name }) {\n            self.next_token();\n            assert_next_token!(self, Str(variant));\n        } else {\n            assert_next_token!(self, NewtypeVariant { name, variant });\n        }\n        value.serialize(self)\n    }\n\n    fn serialize_none(self) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, None);\n        Ok(())\n    }\n\n    fn serialize_some\u003cT: ?Sized\u003e(self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        assert_next_token!(self, Some);\n        value.serialize(self)\n    }\n\n    fn serialize_seq(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        assert_next_token!(self, Seq { len });\n        Ok(self)\n    }\n\n    fn serialize_tuple(self, len: usize) -\u003e Result\u003cSelf, Error\u003e {\n        assert_next_token!(self, Tuple { len });\n        Ok(self)\n    }\n\n    fn serialize_tuple_struct(self, name: \u0026'static str, len: usize) -\u003e Result\u003cSelf, Error\u003e {\n        assert_next_token!(self, TupleStruct { name, len });\n        Ok(self)\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        name: \u0026'static str,\n        _variant_index: u32,\n        variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeTupleVariant, Error\u003e {\n        if self.tokens.first() == Some(\u0026Token::Enum { name: name }) {\n            self.next_token();\n            assert_next_token!(self, Str(variant));\n            let len = Some(len);\n            assert_next_token!(self, Seq { len });\n            Ok(Variant {\n                ser: self,\n                end: Token::SeqEnd,\n            })\n        } else {\n            assert_next_token!(self, TupleVariant { name, variant, len });\n            Ok(Variant {\n                ser: self,\n                end: Token::TupleVariantEnd,\n            })\n        }\n    }\n\n    fn serialize_map(self, len: Option\u003cusize\u003e) -\u003e Result\u003cSelf, Error\u003e {\n        assert_next_token!(self, Map { len });\n        Ok(self)\n    }\n\n    fn serialize_struct(self, name: \u0026'static str, len: usize) -\u003e Result\u003cSelf, Error\u003e {\n        assert_next_token!(self, Struct { name, len });\n        Ok(self)\n    }\n\n    fn serialize_struct_variant(\n        self,\n        name: \u0026'static str,\n        _variant_index: u32,\n        variant: \u0026'static str,\n        len: usize,\n    ) -\u003e Result\u003cSelf::SerializeStructVariant, Error\u003e {\n        if self.tokens.first() == Some(\u0026Token::Enum { name: name }) {\n            self.next_token();\n            assert_next_token!(self, Str(variant));\n            let len = Some(len);\n            assert_next_token!(self, Map { len });\n            Ok(Variant {\n                ser: self,\n                end: Token::MapEnd,\n            })\n        } else {\n            assert_next_token!(self, StructVariant { name, variant, len });\n            Ok(Variant {\n                ser: self,\n                end: Token::StructVariantEnd,\n            })\n        }\n    }\n\n    fn is_human_readable(\u0026self) -\u003e bool {\n        panic!(\n            \"Types which have different human-readable and compact representations \\\n             must explicitly mark their test cases with `serde_test::Configure`\"\n        );\n    }\n}\n\npub struct Variant\u003c's, 'a: 's\u003e {\n    ser: \u0026's mut Serializer\u003c'a\u003e,\n    end: Token,\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeSeq for \u0026's mut Serializer\u003c'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(\u0026mut **self)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, SeqEnd);\n        Ok(())\n    }\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeTuple for \u0026's mut Serializer\u003c'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_element\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(\u0026mut **self)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, TupleEnd);\n        Ok(())\n    }\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeTupleStruct for \u0026's mut Serializer\u003c'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(\u0026mut **self)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Error\u003e {\n        assert_next_token!(self, TupleStructEnd);\n        Ok(())\n    }\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeTupleVariant for Variant\u003c's, 'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(\u0026mut *self.ser)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Error\u003e {\n        match self.end {\n            Token::TupleVariantEnd =\u003e assert_next_token!(self.ser, TupleVariantEnd),\n            Token::SeqEnd =\u003e assert_next_token!(self.ser, SeqEnd),\n            _ =\u003e unreachable!(),\n        }\n        Ok(())\n    }\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeMap for \u0026's mut Serializer\u003c'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_key\u003cT: ?Sized\u003e(\u0026mut self, key: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        key.serialize(\u0026mut **self)\n    }\n\n    fn serialize_value\u003cT: ?Sized\u003e(\u0026mut self, value: \u0026T) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        value.serialize(\u0026mut **self)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Self::Error\u003e {\n        assert_next_token!(self, MapEnd);\n        Ok(())\n    }\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeStruct for \u0026's mut Serializer\u003c'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        key.serialize(\u0026mut **self)?;\n        value.serialize(\u0026mut **self)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Self::Error\u003e {\n        assert_next_token!(self, StructEnd);\n        Ok(())\n    }\n}\n\nimpl\u003c's, 'a\u003e ser::SerializeStructVariant for Variant\u003c's, 'a\u003e {\n    type Ok = ();\n    type Error = Error;\n\n    fn serialize_field\u003cT: ?Sized\u003e(\n        \u0026mut self,\n        key: \u0026'static str,\n        value: \u0026T,\n    ) -\u003e Result\u003c(), Self::Error\u003e\n    where\n        T: Serialize,\n    {\n        key.serialize(\u0026mut *self.ser)?;\n        value.serialize(\u0026mut *self.ser)\n    }\n\n    fn end(self) -\u003e Result\u003c(), Self::Error\u003e {\n        match self.end {\n            Token::StructVariantEnd =\u003e assert_next_token!(self.ser, StructVariantEnd),\n            Token::MapEnd =\u003e assert_next_token!(self.ser, MapEnd),\n            _ =\u003e unreachable!(),\n        }\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","serde_test","src","token.rs"],"content":"use std::fmt::{self, Debug, Display};\n\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum Token {\n    /// A serialized `bool`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u0026true, \u0026[Token::Bool(true)]);\n    /// ```\n    Bool(bool),\n\n    /// A serialized `i8`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260i8, \u0026[Token::I8(0)]);\n    /// ```\n    I8(i8),\n\n    /// A serialized `i16`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260i16, \u0026[Token::I16(0)]);\n    /// ```\n    I16(i16),\n\n    /// A serialized `i32`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260i32, \u0026[Token::I32(0)]);\n    /// ```\n    I32(i32),\n\n    /// A serialized `i64`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260i64, \u0026[Token::I64(0)]);\n    /// ```\n    I64(i64),\n\n    /// A serialized `u8`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260u8, \u0026[Token::U8(0)]);\n    /// ```\n    U8(u8),\n\n    /// A serialized `u16`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260u16, \u0026[Token::U16(0)]);\n    /// ```\n    U16(u16),\n\n    /// A serialized `u32`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260u32, \u0026[Token::U32(0)]);\n    /// ```\n    U32(u32),\n\n    /// A serialized `u64`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260u64, \u0026[Token::U64(0)]);\n    /// ```\n    U64(u64),\n\n    /// A serialized `f32`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260f32, \u0026[Token::F32(0.0)]);\n    /// ```\n    F32(f32),\n\n    /// A serialized `f64`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u00260f64, \u0026[Token::F64(0.0)]);\n    /// ```\n    F64(f64),\n\n    /// A serialized `char`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u0026'\\n', \u0026[Token::Char('\\n')]);\n    /// ```\n    Char(char),\n\n    /// A serialized `str`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let s = String::from(\"transient\");\n    /// assert_tokens(\u0026s, \u0026[Token::Str(\"transient\")]);\n    /// ```\n    Str(\u0026'static str),\n\n    /// A borrowed `str`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let s: \u0026str = \"borrowed\";\n    /// assert_tokens(\u0026s, \u0026[Token::BorrowedStr(\"borrowed\")]);\n    /// ```\n    BorrowedStr(\u0026'static str),\n\n    /// A serialized `String`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let s = String::from(\"owned\");\n    /// assert_tokens(\u0026s, \u0026[Token::String(\"owned\")]);\n    /// ```\n    String(\u0026'static str),\n\n    /// A serialized `[u8]`\n    Bytes(\u0026'static [u8]),\n\n    /// A borrowed `[u8]`.\n    BorrowedBytes(\u0026'static [u8]),\n\n    /// A serialized `ByteBuf`\n    ByteBuf(\u0026'static [u8]),\n\n    /// A serialized `Option\u003cT\u003e` containing none.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let opt = None::\u003cchar\u003e;\n    /// assert_tokens(\u0026opt, \u0026[Token::None]);\n    /// ```\n    None,\n\n    /// The header to a serialized `Option\u003cT\u003e` containing some value.\n    ///\n    /// The tokens of the value follow after this header.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let opt = Some('c');\n    /// assert_tokens(\u0026opt, \u0026[\n    ///     Token::Some,\n    ///     Token::Char('c'),\n    /// ]);\n    /// ```\n    Some,\n\n    /// A serialized `()`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// assert_tokens(\u0026(), \u0026[Token::Unit]);\n    /// ```\n    Unit,\n\n    /// A serialized unit struct of the given name.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// struct X;\n    ///\n    /// assert_tokens(\u0026X, \u0026[Token::UnitStruct { name: \"X\" }]);\n    /// # }\n    /// ```\n    UnitStruct { name: \u0026'static str },\n\n    /// A unit variant of an enum.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     A,\n    /// }\n    ///\n    /// let a = E::A;\n    /// assert_tokens(\u0026a, \u0026[Token::UnitVariant { name: \"E\", variant: \"A\" }]);\n    /// # }\n    /// ```\n    UnitVariant {\n        name: \u0026'static str,\n        variant: \u0026'static str,\n    },\n\n    /// The header to a serialized newtype struct of the given name.\n    ///\n    /// After this header is the value contained in the newtype struct.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// struct N(String);\n    ///\n    /// let n = N(\"newtype\".to_owned());\n    /// assert_tokens(\u0026n, \u0026[\n    ///     Token::NewtypeStruct { name: \"N\" },\n    ///     Token::String(\"newtype\"),\n    /// ]);\n    /// # }\n    /// ```\n    NewtypeStruct { name: \u0026'static str },\n\n    /// The header to a newtype variant of an enum.\n    ///\n    /// After this header is the value contained in the newtype variant.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     B(u8),\n    /// }\n    ///\n    /// let b = E::B(0);\n    /// assert_tokens(\u0026b, \u0026[\n    ///     Token::NewtypeVariant { name: \"E\", variant: \"B\" },\n    ///     Token::U8(0),\n    /// ]);\n    /// # }\n    /// ```\n    NewtypeVariant {\n        name: \u0026'static str,\n        variant: \u0026'static str,\n    },\n\n    /// The header to a sequence.\n    ///\n    /// After this header are the elements of the sequence, followed by\n    /// `SeqEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let vec = vec!['a', 'b', 'c'];\n    /// assert_tokens(\u0026vec, \u0026[\n    ///     Token::Seq { len: Some(3) },\n    ///     Token::Char('a'),\n    ///     Token::Char('b'),\n    ///     Token::Char('c'),\n    ///     Token::SeqEnd,\n    /// ]);\n    /// ```\n    Seq { len: Option\u003cusize\u003e },\n\n    /// An indicator of the end of a sequence.\n    SeqEnd,\n\n    /// The header to a tuple.\n    ///\n    /// After this header are the elements of the tuple, followed by `TupleEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// let tuple = ('a', 100);\n    /// assert_tokens(\u0026tuple, \u0026[\n    ///     Token::Tuple { len: 2 },\n    ///     Token::Char('a'),\n    ///     Token::I32(100),\n    ///     Token::TupleEnd,\n    /// ]);\n    /// ```\n    Tuple { len: usize },\n\n    /// An indicator of the end of a tuple.\n    TupleEnd,\n\n    /// The header to a tuple struct.\n    ///\n    /// After this header are the fields of the tuple struct, followed by\n    /// `TupleStructEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// struct T(u8, u8);\n    ///\n    /// let t = T(0, 0);\n    /// assert_tokens(\u0026t, \u0026[\n    ///     Token::TupleStruct { name: \"T\", len: 2 },\n    ///     Token::U8(0),\n    ///     Token::U8(0),\n    ///     Token::TupleStructEnd,\n    /// ]);\n    /// # }\n    /// ```\n    TupleStruct { name: \u0026'static str, len: usize },\n\n    /// An indicator of the end of a tuple struct.\n    TupleStructEnd,\n\n    /// The header to a tuple variant of an enum.\n    ///\n    /// After this header are the fields of the tuple variant, followed by\n    /// `TupleVariantEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     C(u8, u8),\n    /// }\n    ///\n    /// let c = E::C(0, 0);\n    /// assert_tokens(\u0026c, \u0026[\n    ///     Token::TupleVariant { name: \"E\", variant: \"C\", len: 2 },\n    ///     Token::U8(0),\n    ///     Token::U8(0),\n    ///     Token::TupleVariantEnd,\n    /// ]);\n    /// # }\n    /// ```\n    TupleVariant {\n        name: \u0026'static str,\n        variant: \u0026'static str,\n        len: usize,\n    },\n\n    /// An indicator of the end of a tuple variant.\n    TupleVariantEnd,\n\n    /// The header to a map.\n    ///\n    /// After this header are the entries of the map, followed by `MapEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert('A', 65);\n    /// map.insert('Z', 90);\n    ///\n    /// assert_tokens(\u0026map, \u0026[\n    ///     Token::Map { len: Some(2) },\n    ///     Token::Char('A'),\n    ///     Token::I32(65),\n    ///     Token::Char('Z'),\n    ///     Token::I32(90),\n    ///     Token::MapEnd,\n    /// ]);\n    /// ```\n    Map { len: Option\u003cusize\u003e },\n\n    /// An indicator of the end of a map.\n    MapEnd,\n\n    /// The header of a struct.\n    ///\n    /// After this header are the fields of the struct, followed by `StructEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// struct S {\n    ///     a: u8,\n    ///     b: u8,\n    /// }\n    ///\n    /// let s = S { a: 0, b: 0 };\n    /// assert_tokens(\u0026s, \u0026[\n    ///     Token::Struct { name: \"S\", len: 2 },\n    ///     Token::Str(\"a\"),\n    ///     Token::U8(0),\n    ///     Token::Str(\"b\"),\n    ///     Token::U8(0),\n    ///     Token::StructEnd,\n    /// ]);\n    /// # }\n    /// ```\n    Struct { name: \u0026'static str, len: usize },\n\n    /// An indicator of the end of a struct.\n    StructEnd,\n\n    /// The header of a struct variant of an enum.\n    ///\n    /// After this header are the fields of the struct variant, followed by\n    /// `StructVariantEnd`.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     D { d: u8 },\n    /// }\n    ///\n    /// let d = E::D { d: 0 };\n    /// assert_tokens(\u0026d, \u0026[\n    ///     Token::StructVariant { name: \"E\", variant: \"D\", len: 1 },\n    ///     Token::Str(\"d\"),\n    ///     Token::U8(0),\n    ///     Token::StructVariantEnd,\n    /// ]);\n    /// # }\n    /// ```\n    StructVariant {\n        name: \u0026'static str,\n        variant: \u0026'static str,\n        len: usize,\n    },\n\n    /// An indicator of the end of a struct variant.\n    StructVariantEnd,\n\n    /// The header to an enum of the given name.\n    ///\n    /// ```edition2018\n    /// # use serde::{Serialize, Deserialize};\n    /// # use serde_test::{assert_tokens, Token};\n    /// #\n    /// # fn main() {\n    /// #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    /// enum E {\n    ///     A,\n    ///     B(u8),\n    ///     C(u8, u8),\n    ///     D { d: u8 },\n    /// }\n    ///\n    /// let a = E::A;\n    /// assert_tokens(\u0026a, \u0026[\n    ///     Token::Enum { name: \"E\" },\n    ///     Token::Str(\"A\"),\n    ///     Token::Unit,\n    /// ]);\n    ///\n    /// let b = E::B(0);\n    /// assert_tokens(\u0026b, \u0026[\n    ///     Token::Enum { name: \"E\" },\n    ///     Token::Str(\"B\"),\n    ///     Token::U8(0),\n    /// ]);\n    ///\n    /// let c = E::C(0, 0);\n    /// assert_tokens(\u0026c, \u0026[\n    ///     Token::Enum { name: \"E\" },\n    ///     Token::Str(\"C\"),\n    ///     Token::Seq { len: Some(2) },\n    ///     Token::U8(0),\n    ///     Token::U8(0),\n    ///     Token::SeqEnd,\n    /// ]);\n    ///\n    /// let d = E::D { d: 0 };\n    /// assert_tokens(\u0026d, \u0026[\n    ///     Token::Enum { name: \"E\" },\n    ///     Token::Str(\"D\"),\n    ///     Token::Map { len: Some(1) },\n    ///     Token::Str(\"d\"),\n    ///     Token::U8(0),\n    ///     Token::MapEnd,\n    /// ]);\n    /// # }\n    /// ```\n    Enum { name: \u0026'static str },\n}\n\nimpl Display for Token {\n    fn fmt(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        Debug::fmt(self, formatter)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","no_std","src","main.rs"],"content":"#![feature(lang_items, start)]\n#![no_std]\n\n#[start]\nfn start(_argc: isize, _argv: *const *const u8) -\u003e isize {\n    0\n}\n\n#[lang = \"eh_personality\"]\n#[no_mangle]\npub extern \"C\" fn rust_eh_personality() {}\n\n#[panic_handler]\nfn panic(_info: \u0026core::panic::PanicInfo) -\u003e ! {\n    unsafe {\n        libc::abort();\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize)]\nstruct Unit;\n\n#[derive(Serialize, Deserialize)]\nstruct Newtype(u8);\n\n#[derive(Serialize, Deserialize)]\nstruct Tuple(u8, u8);\n\n#[derive(Serialize, Deserialize)]\nstruct Struct {\n    f: u8,\n}\n\n#[derive(Serialize, Deserialize)]\nenum Enum {\n    Unit,\n    Newtype(u8),\n    Tuple(u8, u8),\n    Struct { f: u8 },\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","bytes","mod.rs"],"content":"use serde::de::{Deserializer, Error, SeqAccess, Visitor};\nuse std::fmt;\n\npub fn deserialize\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003cVec\u003cu8\u003e, D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    deserializer.deserialize_byte_buf(ByteBufVisitor)\n}\n\nstruct ByteBufVisitor;\n\nimpl\u003c'de\u003e Visitor\u003c'de\u003e for ByteBufVisitor {\n    type Value = Vec\u003cu8\u003e;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"byte array\")\n    }\n\n    fn visit_seq\u003cV\u003e(self, mut visitor: V) -\u003e Result\u003cSelf::Value, V::Error\u003e\n    where\n        V: SeqAccess\u003c'de\u003e,\n    {\n        let mut values = Vec::new();\n        while let Some(value) = visitor.next_element()? {\n            values.push(value);\n        }\n        Ok(values)\n    }\n\n    fn visit_bytes\u003cE\u003e(self, v: \u0026[u8]) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v.to_vec())\n    }\n\n    fn visit_byte_buf\u003cE\u003e(self, v: Vec\u003cu8\u003e) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v.as_bytes().to_vec())\n    }\n\n    fn visit_string\u003cE\u003e(self, v: String) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: Error,\n    {\n        Ok(v.into_bytes())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","compiletest.rs"],"content":"#[cfg(not(target_os = \"emscripten\"))]\n#[rustversion::attr(not(nightly), ignore)]\n#[test]\nfn ui() {\n    let t = trybuild::TestCases::new();\n    t.compile_fail(\"tests/ui/**/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","macros","mod.rs"],"content":"macro_rules! btreeset {\n    () =\u003e {\n        BTreeSet::new()\n    };\n    ($($value:expr),+) =\u003e {\n        {\n            let mut set = BTreeSet::new();\n            $(set.insert($value);)+\n            set\n        }\n    }\n}\n\nmacro_rules! btreemap {\n    () =\u003e {\n        BTreeMap::new()\n    };\n    ($($key:expr =\u003e $value:expr),+) =\u003e {\n        {\n            let mut map = BTreeMap::new();\n            $(map.insert($key, $value);)+\n            map\n        }\n    }\n}\n\nmacro_rules! hashset {\n    () =\u003e {\n        HashSet::new()\n    };\n    ($($value:expr),+) =\u003e {\n        {\n            let mut set = HashSet::new();\n            $(set.insert($value);)+\n            set\n        }\n    };\n    ($hasher:ident @ $($value:expr),+) =\u003e {\n        {\n            use std::hash::BuildHasherDefault;\n            let mut set = HashSet::with_hasher(BuildHasherDefault::\u003c$hasher\u003e::default());\n            $(set.insert($value);)+\n            set\n        }\n    }\n}\n\nmacro_rules! hashmap {\n    () =\u003e {\n        HashMap::new()\n    };\n    ($($key:expr =\u003e $value:expr),+) =\u003e {\n        {\n            let mut map = HashMap::new();\n            $(map.insert($key, $value);)+\n            map\n        }\n    };\n    ($hasher:ident @ $($key:expr =\u003e $value:expr),+) =\u003e {\n        {\n            use std::hash::BuildHasherDefault;\n            let mut map = HashMap::with_hasher(BuildHasherDefault::\u003c$hasher\u003e::default());\n            $(map.insert($key, $value);)+\n            map\n        }\n    }\n}\n\nmacro_rules! seq_impl {\n    (seq $first:expr,) =\u003e {\n        seq_impl!(seq $first)\n    };\n    ($first:expr,) =\u003e {\n        seq_impl!($first)\n    };\n    (seq $first:expr) =\u003e {\n        $first.into_iter()\n    };\n    ($first:expr) =\u003e {\n        Some($first).into_iter()\n    };\n    (seq $first:expr , $( $elem: tt)*) =\u003e {\n        $first.into_iter().chain(seq!( $($elem)* ))\n    };\n    ($first:expr , $($elem: tt)*) =\u003e {\n        Some($first).into_iter().chain(seq!( $($elem)* ))\n    }\n}\nmacro_rules! seq {\n    ($($tt: tt)*) =\u003e {\n        seq_impl!($($tt)*).collect::\u003cVec\u003c_\u003e\u003e()\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_annotations.rs"],"content":"#![allow(clippy::cast_lossless, clippy::trivially_copy_pass_by_ref)]\n\nuse serde::de::{self, MapAccess, Unexpected, Visitor};\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\nuse std::collections::{BTreeMap, HashMap};\nuse std::convert::TryFrom;\nuse std::fmt;\nuse std::marker::PhantomData;\n\nuse serde_test::{\n    assert_de_tokens, assert_de_tokens_error, assert_ser_tokens, assert_ser_tokens_error,\n    assert_tokens, Token,\n};\n\ntrait MyDefault: Sized {\n    fn my_default() -\u003e Self;\n}\n\ntrait ShouldSkip: Sized {\n    fn should_skip(\u0026self) -\u003e bool;\n}\n\ntrait SerializeWith: Sized {\n    fn serialize_with\u003cS\u003e(\u0026self, ser: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer;\n}\n\ntrait DeserializeWith: Sized {\n    fn deserialize_with\u003c'de, D\u003e(de: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e;\n}\n\nimpl MyDefault for i32 {\n    fn my_default() -\u003e Self {\n        123\n    }\n}\n\nimpl ShouldSkip for i32 {\n    fn should_skip(\u0026self) -\u003e bool {\n        *self == 123\n    }\n}\n\nimpl SerializeWith for i32 {\n    fn serialize_with\u003cS\u003e(\u0026self, ser: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        if *self == 123 {\n            true.serialize(ser)\n        } else {\n            false.serialize(ser)\n        }\n    }\n}\n\nimpl DeserializeWith for i32 {\n    fn deserialize_with\u003c'de, D\u003e(de: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        if Deserialize::deserialize(de)? {\n            Ok(123)\n        } else {\n            Ok(2)\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct DefaultStruct\u003cA, B, C, D, E\u003e\nwhere\n    C: MyDefault,\n    E: MyDefault,\n{\n    a1: A,\n    #[serde(default)]\n    a2: B,\n    #[serde(default = \"MyDefault::my_default\")]\n    a3: C,\n    #[serde(skip_deserializing)]\n    a4: D,\n    #[serde(skip_deserializing, default = \"MyDefault::my_default\")]\n    a5: E,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct DefaultTupleStruct\u003cA, B, C\u003e(\n    A,\n    #[serde(default)] B,\n    #[serde(default = \"MyDefault::my_default\")] C,\n)\nwhere\n    C: MyDefault;\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct CollectOther {\n    a: u32,\n    b: u32,\n    #[serde(flatten)]\n    extra: HashMap\u003cString, u32\u003e,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct FlattenStructEnumWrapper {\n    #[serde(flatten)]\n    data: FlattenStructEnum,\n    #[serde(flatten)]\n    extra: HashMap\u003cString, String\u003e,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\nenum FlattenStructEnum {\n    InsertInteger { index: u32, value: u32 },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct FlattenStructTagContentEnumWrapper {\n    outer: u32,\n    #[serde(flatten)]\n    data: FlattenStructTagContentEnumNewtype,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct FlattenStructTagContentEnumNewtype(pub FlattenStructTagContentEnum);\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\", tag = \"type\", content = \"value\")]\nenum FlattenStructTagContentEnum {\n    InsertInteger { index: u32, value: u32 },\n    NewtypeVariant(FlattenStructTagContentEnumNewtypeVariant),\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct FlattenStructTagContentEnumNewtypeVariant {\n    value: u32,\n}\n\n#[test]\nfn test_default_struct() {\n    assert_de_tokens(\n        \u0026DefaultStruct {\n            a1: 1,\n            a2: 2,\n            a3: 3,\n            a4: 0,\n            a5: 123,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"DefaultStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a2\"),\n            Token::I32(2),\n            Token::Str(\"a3\"),\n            Token::I32(3),\n            Token::Str(\"a4\"),\n            Token::I32(4),\n            Token::Str(\"a5\"),\n            Token::I32(5),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DefaultStruct {\n            a1: 1,\n            a2: 0,\n            a3: 123,\n            a4: 0,\n            a5: 123,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"DefaultStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_default_tuple() {\n    assert_de_tokens(\n        \u0026DefaultTupleStruct(1, 2, 3),\n        \u0026[\n            Token::TupleStruct {\n                name: \"DefaultTupleStruct\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::I32(2),\n            Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DefaultTupleStruct(1, 0, 123),\n        \u0026[\n            Token::TupleStruct {\n                name: \"DefaultTupleStruct\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum DefaultStructVariant\u003cA, B, C, D, E\u003e\nwhere\n    C: MyDefault,\n    E: MyDefault,\n{\n    Struct {\n        a1: A,\n        #[serde(default)]\n        a2: B,\n        #[serde(default = \"MyDefault::my_default\")]\n        a3: C,\n        #[serde(skip_deserializing)]\n        a4: D,\n        #[serde(skip_deserializing, default = \"MyDefault::my_default\")]\n        a5: E,\n    },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum DefaultTupleVariant\u003cA, B, C\u003e\nwhere\n    C: MyDefault,\n{\n    Tuple(\n        A,\n        #[serde(default)] B,\n        #[serde(default = \"MyDefault::my_default\")] C,\n    ),\n}\n\n#[test]\nfn test_default_struct_variant() {\n    assert_de_tokens(\n        \u0026DefaultStructVariant::Struct {\n            a1: 1,\n            a2: 2,\n            a3: 3,\n            a4: 0,\n            a5: 123,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"DefaultStructVariant\",\n                variant: \"Struct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a2\"),\n            Token::I32(2),\n            Token::Str(\"a3\"),\n            Token::I32(3),\n            Token::Str(\"a4\"),\n            Token::I32(4),\n            Token::Str(\"a5\"),\n            Token::I32(5),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DefaultStructVariant::Struct {\n            a1: 1,\n            a2: 0,\n            a3: 123,\n            a4: 0,\n            a5: 123,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"DefaultStructVariant\",\n                variant: \"Struct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_default_tuple_variant() {\n    assert_de_tokens(\n        \u0026DefaultTupleVariant::Tuple(1, 2, 3),\n        \u0026[\n            Token::TupleVariant {\n                name: \"DefaultTupleVariant\",\n                variant: \"Tuple\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::I32(2),\n            Token::I32(3),\n            Token::TupleVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DefaultTupleVariant::Tuple(1, 0, 123),\n        \u0026[\n            Token::TupleVariant {\n                name: \"DefaultTupleVariant\",\n                variant: \"Tuple\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n// Does not implement std::default::Default.\n#[derive(Debug, PartialEq, Deserialize)]\nstruct NoStdDefault(i8);\n\nimpl MyDefault for NoStdDefault {\n    fn my_default() -\u003e Self {\n        NoStdDefault(123)\n    }\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct ContainsNoStdDefault\u003cA: MyDefault\u003e {\n    #[serde(default = \"MyDefault::my_default\")]\n    a: A,\n}\n\n// Tests that a struct field does not need to implement std::default::Default if\n// it is annotated with `default=...`.\n#[test]\nfn test_no_std_default() {\n    assert_de_tokens(\n        \u0026ContainsNoStdDefault {\n            a: NoStdDefault(123),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"ContainsNoStdDefault\",\n                len: 1,\n            },\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026ContainsNoStdDefault { a: NoStdDefault(8) },\n        \u0026[\n            Token::Struct {\n                name: \"ContainsNoStdDefault\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::NewtypeStruct {\n                name: \"NoStdDefault\",\n            },\n            Token::I8(8),\n            Token::StructEnd,\n        ],\n    );\n}\n\n// Does not implement Deserialize.\n#[derive(Debug, PartialEq)]\nstruct NotDeserializeStruct(i8);\n\nimpl Default for NotDeserializeStruct {\n    fn default() -\u003e Self {\n        NotDeserializeStruct(123)\n    }\n}\n\nimpl DeserializeWith for NotDeserializeStruct {\n    fn deserialize_with\u003c'de, D\u003e(_: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        panic!()\n    }\n}\n\n// Does not implement Deserialize.\n#[derive(Debug, PartialEq)]\nenum NotDeserializeEnum {\n    Trouble,\n}\n\nimpl MyDefault for NotDeserializeEnum {\n    fn my_default() -\u003e Self {\n        NotDeserializeEnum::Trouble\n    }\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct ContainsNotDeserialize\u003cA, B, C: DeserializeWith, E: MyDefault\u003e {\n    #[serde(skip_deserializing)]\n    a: A,\n    #[serde(skip_deserializing, default)]\n    b: B,\n    #[serde(deserialize_with = \"DeserializeWith::deserialize_with\", default)]\n    c: C,\n    #[serde(skip_deserializing, default = \"MyDefault::my_default\")]\n    e: E,\n}\n\n// Tests that a struct field does not need to implement Deserialize if it is\n// annotated with skip_deserializing, whether using the std Default or a\n// custom default.\n#[test]\nfn test_elt_not_deserialize() {\n    assert_de_tokens(\n        \u0026ContainsNotDeserialize {\n            a: NotDeserializeStruct(123),\n            b: NotDeserializeStruct(123),\n            c: NotDeserializeStruct(123),\n            e: NotDeserializeEnum::Trouble,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"ContainsNotDeserialize\",\n                len: 1,\n            },\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(deny_unknown_fields)]\nstruct DenyUnknown {\n    a1: i32,\n}\n\n#[test]\nfn test_ignore_unknown() {\n    // 'Default' allows unknown. Basic smoke test of ignore...\n    assert_de_tokens(\n        \u0026DefaultStruct {\n            a1: 1,\n            a2: 2,\n            a3: 3,\n            a4: 0,\n            a5: 123,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"DefaultStruct\",\n                len: 3,\n            },\n            Token::Str(\"whoops1\"),\n            Token::I32(2),\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"whoops2\"),\n            Token::Seq { len: Some(1) },\n            Token::I32(2),\n            Token::SeqEnd,\n            Token::Str(\"a2\"),\n            Token::I32(2),\n            Token::Str(\"whoops3\"),\n            Token::I32(2),\n            Token::Str(\"a3\"),\n            Token::I32(3),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens_error::\u003cDenyUnknown\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"DenyUnknown\",\n                len: 1,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"whoops\"),\n        ],\n        \"unknown field `whoops`, expected `a1`\",\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename = \"Superhero\")]\nstruct RenameStruct {\n    a1: i32,\n    #[serde(rename = \"a3\")]\n    a2: i32,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename(serialize = \"SuperheroSer\", deserialize = \"SuperheroDe\"))]\nstruct RenameStructSerializeDeserialize {\n    a1: i32,\n    #[serde(rename(serialize = \"a4\", deserialize = \"a5\"))]\n    a2: i32,\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\n#[serde(deny_unknown_fields)]\nstruct AliasStruct {\n    a1: i32,\n    #[serde(alias = \"a3\")]\n    a2: i32,\n    #[serde(alias = \"a5\", rename = \"a6\")]\n    a4: i32,\n}\n\n#[test]\nfn test_rename_struct() {\n    assert_tokens(\n        \u0026RenameStruct { a1: 1, a2: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"Superhero\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a3\"),\n            Token::I32(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026RenameStructSerializeDeserialize { a1: 1, a2: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"SuperheroSer\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a4\"),\n            Token::I32(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026RenameStructSerializeDeserialize { a1: 1, a2: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"SuperheroDe\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a5\"),\n            Token::I32(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026AliasStruct {\n            a1: 1,\n            a2: 2,\n            a4: 3,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"AliasStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a2\"),\n            Token::I32(2),\n            Token::Str(\"a5\"),\n            Token::I32(3),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026AliasStruct {\n            a1: 1,\n            a2: 2,\n            a4: 3,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"AliasStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a3\"),\n            Token::I32(2),\n            Token::Str(\"a6\"),\n            Token::I32(3),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_unknown_field_rename_struct() {\n    assert_de_tokens_error::\u003cAliasStruct\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"AliasStruct\",\n                len: 3,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::Str(\"a3\"),\n            Token::I32(2),\n            Token::Str(\"a4\"),\n            Token::I32(3),\n        ],\n        \"unknown field `a4`, expected one of `a1`, `a2`, `a6`\",\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(rename = \"Superhero\")]\nenum RenameEnum {\n    #[serde(rename = \"bruce_wayne\")]\n    Batman,\n    #[serde(rename = \"clark_kent\")]\n    Superman(i8),\n    #[serde(rename = \"diana_prince\")]\n    WonderWoman(i8, i8),\n    #[serde(rename = \"barry_allan\")]\n    Flash {\n        #[serde(rename = \"b\")]\n        a: i32,\n    },\n}\n\n#[derive(Debug, PartialEq, Deserialize, Serialize)]\n#[serde(rename(serialize = \"SuperheroSer\", deserialize = \"SuperheroDe\"))]\nenum RenameEnumSerializeDeserialize\u003cA\u003e {\n    #[serde(rename(serialize = \"dick_grayson\", deserialize = \"jason_todd\"))]\n    Robin {\n        a: i8,\n        #[serde(rename(serialize = \"c\"))]\n        #[serde(rename(deserialize = \"d\"))]\n        b: A,\n    },\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\n#[serde(deny_unknown_fields)]\nenum AliasEnum {\n    #[serde(rename = \"sailor_moon\", alias = \"usagi_tsukino\")]\n    SailorMoon {\n        a: i8,\n        #[serde(alias = \"c\")]\n        b: i8,\n        #[serde(alias = \"e\", rename = \"f\")]\n        d: i8,\n    },\n}\n\n#[test]\nfn test_rename_enum() {\n    assert_tokens(\n        \u0026RenameEnum::Batman,\n        \u0026[Token::UnitVariant {\n            name: \"Superhero\",\n            variant: \"bruce_wayne\",\n        }],\n    );\n\n    assert_tokens(\n        \u0026RenameEnum::Superman(0),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"Superhero\",\n                variant: \"clark_kent\",\n            },\n            Token::I8(0),\n        ],\n    );\n\n    assert_tokens(\n        \u0026RenameEnum::WonderWoman(0, 1),\n        \u0026[\n            Token::TupleVariant {\n                name: \"Superhero\",\n                variant: \"diana_prince\",\n                len: 2,\n            },\n            Token::I8(0),\n            Token::I8(1),\n            Token::TupleVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026RenameEnum::Flash { a: 1 },\n        \u0026[\n            Token::StructVariant {\n                name: \"Superhero\",\n                variant: \"barry_allan\",\n                len: 1,\n            },\n            Token::Str(\"b\"),\n            Token::I32(1),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026RenameEnumSerializeDeserialize::Robin {\n            a: 0,\n            b: String::new(),\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"SuperheroSer\",\n                variant: \"dick_grayson\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"c\"),\n            Token::Str(\"\"),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026RenameEnumSerializeDeserialize::Robin {\n            a: 0,\n            b: String::new(),\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"SuperheroDe\",\n                variant: \"jason_todd\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"d\"),\n            Token::Str(\"\"),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026AliasEnum::SailorMoon { a: 0, b: 1, d: 2 },\n        \u0026[\n            Token::StructVariant {\n                name: \"AliasEnum\",\n                variant: \"sailor_moon\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"b\"),\n            Token::I8(1),\n            Token::Str(\"e\"),\n            Token::I8(2),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026AliasEnum::SailorMoon { a: 0, b: 1, d: 2 },\n        \u0026[\n            Token::StructVariant {\n                name: \"AliasEnum\",\n                variant: \"usagi_tsukino\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"c\"),\n            Token::I8(1),\n            Token::Str(\"f\"),\n            Token::I8(2),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_unknown_field_rename_enum() {\n    assert_de_tokens_error::\u003cAliasEnum\u003e(\n        \u0026[Token::StructVariant {\n            name: \"AliasEnum\",\n            variant: \"SailorMoon\",\n            len: 3,\n        }],\n        \"unknown variant `SailorMoon`, expected `sailor_moon`\",\n    );\n\n    assert_de_tokens_error::\u003cAliasEnum\u003e(\n        \u0026[\n            Token::StructVariant {\n                name: \"AliasEnum\",\n                variant: \"usagi_tsukino\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::Str(\"c\"),\n            Token::I8(1),\n            Token::Str(\"d\"),\n            Token::I8(2),\n        ],\n        \"unknown field `d`, expected one of `a`, `b`, `f`\",\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SkipSerializingStruct\u003c'a, B, C\u003e\nwhere\n    C: ShouldSkip,\n{\n    a: \u0026'a i8,\n    #[serde(skip_serializing)]\n    b: B,\n    #[serde(skip_serializing_if = \"ShouldSkip::should_skip\")]\n    c: C,\n}\n\n#[test]\nfn test_skip_serializing_struct() {\n    let a = 1;\n    assert_ser_tokens(\n        \u0026SkipSerializingStruct { a: \u0026a, b: 2, c: 3 },\n        \u0026[\n            Token::Struct {\n                name: \"SkipSerializingStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"c\"),\n            Token::I32(3),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SkipSerializingStruct {\n            a: \u0026a,\n            b: 2,\n            c: 123,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"SkipSerializingStruct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SkipSerializingTupleStruct\u003c'a, B, C\u003e(\n    \u0026'a i8,\n    #[serde(skip_serializing)] B,\n    #[serde(skip_serializing_if = \"ShouldSkip::should_skip\")] C,\n)\nwhere\n    C: ShouldSkip;\n\n#[test]\nfn test_skip_serializing_tuple_struct() {\n    let a = 1;\n    assert_ser_tokens(\n        \u0026SkipSerializingTupleStruct(\u0026a, 2, 3),\n        \u0026[\n            Token::TupleStruct {\n                name: \"SkipSerializingTupleStruct\",\n                len: 2,\n            },\n            Token::I8(1),\n            Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SkipSerializingTupleStruct(\u0026a, 2, 123),\n        \u0026[\n            Token::TupleStruct {\n                name: \"SkipSerializingTupleStruct\",\n                len: 1,\n            },\n            Token::I8(1),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct SkipStruct\u003cB\u003e {\n    a: i8,\n    #[serde(skip)]\n    b: B,\n}\n\n#[test]\nfn test_skip_struct() {\n    assert_ser_tokens(\n        \u0026SkipStruct { a: 1, b: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"SkipStruct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026SkipStruct { a: 1, b: 0 },\n        \u0026[\n            Token::Struct {\n                name: \"SkipStruct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nenum SkipSerializingEnum\u003c'a, B, C\u003e\nwhere\n    C: ShouldSkip,\n{\n    Struct {\n        a: \u0026'a i8,\n        #[serde(skip_serializing)]\n        _b: B,\n        #[serde(skip_serializing_if = \"ShouldSkip::should_skip\")]\n        c: C,\n    },\n    Tuple(\n        \u0026'a i8,\n        #[serde(skip_serializing)] B,\n        #[serde(skip_serializing_if = \"ShouldSkip::should_skip\")] C,\n    ),\n}\n\n#[test]\nfn test_skip_serializing_enum() {\n    let a = 1;\n    assert_ser_tokens(\n        \u0026SkipSerializingEnum::Struct { a: \u0026a, _b: 2, c: 3 },\n        \u0026[\n            Token::StructVariant {\n                name: \"SkipSerializingEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"c\"),\n            Token::I32(3),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SkipSerializingEnum::Struct {\n            a: \u0026a,\n            _b: 2,\n            c: 123,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"SkipSerializingEnum\",\n                variant: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SkipSerializingEnum::Tuple(\u0026a, 2, 3),\n        \u0026[\n            Token::TupleVariant {\n                name: \"SkipSerializingEnum\",\n                variant: \"Tuple\",\n                len: 2,\n            },\n            Token::I8(1),\n            Token::I32(3),\n            Token::TupleVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SkipSerializingEnum::Tuple(\u0026a, 2, 123),\n        \u0026[\n            Token::TupleVariant {\n                name: \"SkipSerializingEnum\",\n                variant: \"Tuple\",\n                len: 1,\n            },\n            Token::I8(1),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq)]\nstruct NotSerializeStruct(i8);\n\n#[derive(Debug, PartialEq)]\nenum NotSerializeEnum {\n    Trouble,\n}\n\nimpl SerializeWith for NotSerializeEnum {\n    fn serialize_with\u003cS\u003e(\u0026self, ser: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        \"trouble\".serialize(ser)\n    }\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct ContainsNotSerialize\u003c'a, B, C, D\u003e\nwhere\n    B: 'a,\n    D: SerializeWith,\n{\n    a: \u0026'a Option\u003ci8\u003e,\n    #[serde(skip_serializing)]\n    b: \u0026'a B,\n    #[serde(skip_serializing)]\n    c: Option\u003cC\u003e,\n    #[serde(serialize_with = \"SerializeWith::serialize_with\")]\n    d: D,\n}\n\n#[test]\nfn test_elt_not_serialize() {\n    let a = 1;\n    assert_ser_tokens(\n        \u0026ContainsNotSerialize {\n            a: \u0026Some(a),\n            b: \u0026NotSerializeStruct(2),\n            c: Some(NotSerializeEnum::Trouble),\n            d: NotSerializeEnum::Trouble,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"ContainsNotSerialize\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::Some,\n            Token::I8(1),\n            Token::Str(\"d\"),\n            Token::Str(\"trouble\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SerializeWithStruct\u003c'a, B\u003e\nwhere\n    B: SerializeWith,\n{\n    a: \u0026'a i8,\n    #[serde(serialize_with = \"SerializeWith::serialize_with\")]\n    b: B,\n}\n\n#[test]\nfn test_serialize_with_struct() {\n    let a = 1;\n    assert_ser_tokens(\n        \u0026SerializeWithStruct { a: \u0026a, b: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"SerializeWithStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(false),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SerializeWithStruct { a: \u0026a, b: 123 },\n        \u0026[\n            Token::Struct {\n                name: \"SerializeWithStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nenum SerializeWithEnum\u003c'a, B\u003e\nwhere\n    B: SerializeWith,\n{\n    Struct {\n        a: \u0026'a i8,\n        #[serde(serialize_with = \"SerializeWith::serialize_with\")]\n        b: B,\n    },\n}\n\n#[test]\nfn test_serialize_with_enum() {\n    let a = 1;\n    assert_ser_tokens(\n        \u0026SerializeWithEnum::Struct { a: \u0026a, b: 2 },\n        \u0026[\n            Token::StructVariant {\n                name: \"SerializeWithEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(false),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026SerializeWithEnum::Struct { a: \u0026a, b: 123 },\n        \u0026[\n            Token::StructVariant {\n                name: \"SerializeWithEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum WithVariant {\n    #[serde(serialize_with = \"serialize_unit_variant_as_i8\")]\n    #[serde(deserialize_with = \"deserialize_i8_as_unit_variant\")]\n    Unit,\n\n    #[serde(serialize_with = \"SerializeWith::serialize_with\")]\n    #[serde(deserialize_with = \"DeserializeWith::deserialize_with\")]\n    Newtype(i32),\n\n    #[serde(serialize_with = \"serialize_variant_as_string\")]\n    #[serde(deserialize_with = \"deserialize_string_as_variant\")]\n    Tuple(String, u8),\n\n    #[serde(serialize_with = \"serialize_variant_as_string\")]\n    #[serde(deserialize_with = \"deserialize_string_as_variant\")]\n    Struct { f1: String, f2: u8 },\n}\n\nfn serialize_unit_variant_as_i8\u003cS\u003e(serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\nwhere\n    S: Serializer,\n{\n    serializer.serialize_i8(0)\n}\n\nfn deserialize_i8_as_unit_variant\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003c(), D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    let n = i8::deserialize(deserializer)?;\n    match n {\n        0 =\u003e Ok(()),\n        _ =\u003e Err(de::Error::invalid_value(Unexpected::Signed(n as i64), \u0026\"0\")),\n    }\n}\n\nfn serialize_variant_as_string\u003cS\u003e(f1: \u0026str, f2: \u0026u8, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\nwhere\n    S: Serializer,\n{\n    serializer.serialize_str(format!(\"{};{:?}\", f1, f2).as_str())\n}\n\nfn deserialize_string_as_variant\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003c(String, u8), D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    let s = String::deserialize(deserializer)?;\n    let mut pieces = s.split(';');\n    let f1 = match pieces.next() {\n        Some(x) =\u003e x,\n        None =\u003e return Err(de::Error::invalid_length(0, \u0026\"2\")),\n    };\n    let f2 = match pieces.next() {\n        Some(x) =\u003e x,\n        None =\u003e return Err(de::Error::invalid_length(1, \u0026\"2\")),\n    };\n    let f2 = match f2.parse() {\n        Ok(n) =\u003e n,\n        Err(_) =\u003e {\n            return Err(de::Error::invalid_value(\n                Unexpected::Str(f2),\n                \u0026\"an 8-bit signed integer\",\n            ));\n        }\n    };\n    Ok((f1.into(), f2))\n}\n\n#[test]\nfn test_serialize_with_variant() {\n    assert_ser_tokens(\n        \u0026WithVariant::Unit,\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Unit\",\n            },\n            Token::I8(0),\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026WithVariant::Newtype(123),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Newtype\",\n            },\n            Token::Bool(true),\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026WithVariant::Tuple(\"hello\".into(), 0),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Tuple\",\n            },\n            Token::Str(\"hello;0\"),\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026WithVariant::Struct {\n            f1: \"world\".into(),\n            f2: 1,\n        },\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Struct\",\n            },\n            Token::Str(\"world;1\"),\n        ],\n    );\n}\n\n#[test]\nfn test_deserialize_with_variant() {\n    assert_de_tokens(\n        \u0026WithVariant::Unit,\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Unit\",\n            },\n            Token::I8(0),\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026WithVariant::Newtype(123),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Newtype\",\n            },\n            Token::Bool(true),\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026WithVariant::Tuple(\"hello\".into(), 0),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Tuple\",\n            },\n            Token::Str(\"hello;0\"),\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026WithVariant::Struct {\n            f1: \"world\".into(),\n            f2: 1,\n        },\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"WithVariant\",\n                variant: \"Struct\",\n            },\n            Token::Str(\"world;1\"),\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct DeserializeWithStruct\u003cB\u003e\nwhere\n    B: DeserializeWith,\n{\n    a: i8,\n    #[serde(deserialize_with = \"DeserializeWith::deserialize_with\")]\n    b: B,\n}\n\n#[test]\nfn test_deserialize_with_struct() {\n    assert_de_tokens(\n        \u0026DeserializeWithStruct { a: 1, b: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"DeserializeWithStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(false),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DeserializeWithStruct { a: 1, b: 123 },\n        \u0026[\n            Token::Struct {\n                name: \"DeserializeWithStruct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nenum DeserializeWithEnum\u003cB\u003e\nwhere\n    B: DeserializeWith,\n{\n    Struct {\n        a: i8,\n        #[serde(deserialize_with = \"DeserializeWith::deserialize_with\")]\n        b: B,\n    },\n}\n\n#[test]\nfn test_deserialize_with_enum() {\n    assert_de_tokens(\n        \u0026DeserializeWithEnum::Struct { a: 1, b: 2 },\n        \u0026[\n            Token::StructVariant {\n                name: \"DeserializeWithEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(false),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DeserializeWithEnum::Struct { a: 1, b: 123 },\n        \u0026[\n            Token::StructVariant {\n                name: \"DeserializeWithEnum\",\n                variant: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_missing_renamed_field_struct() {\n    assert_de_tokens_error::\u003cRenameStruct\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"Superhero\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::StructEnd,\n        ],\n        \"missing field `a3`\",\n    );\n\n    assert_de_tokens_error::\u003cRenameStructSerializeDeserialize\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"SuperheroDe\",\n                len: 2,\n            },\n            Token::Str(\"a1\"),\n            Token::I32(1),\n            Token::StructEnd,\n        ],\n        \"missing field `a5`\",\n    );\n}\n\n#[test]\nfn test_missing_renamed_field_enum() {\n    assert_de_tokens_error::\u003cRenameEnum\u003e(\n        \u0026[\n            Token::StructVariant {\n                name: \"Superhero\",\n                variant: \"barry_allan\",\n                len: 1,\n            },\n            Token::StructVariantEnd,\n        ],\n        \"missing field `b`\",\n    );\n\n    assert_de_tokens_error::\u003cRenameEnumSerializeDeserialize\u003ci8\u003e\u003e(\n        \u0026[\n            Token::StructVariant {\n                name: \"SuperheroDe\",\n                variant: \"jason_todd\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::I8(0),\n            Token::StructVariantEnd,\n        ],\n        \"missing field `d`\",\n    );\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nenum InvalidLengthEnum {\n    A(i32, i32, i32),\n    B(#[serde(skip_deserializing)] i32, i32, i32),\n}\n\n#[test]\nfn test_invalid_length_enum() {\n    assert_de_tokens_error::\u003cInvalidLengthEnum\u003e(\n        \u0026[\n            Token::TupleVariant {\n                name: \"InvalidLengthEnum\",\n                variant: \"A\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::TupleVariantEnd,\n        ],\n        \"invalid length 1, expected tuple variant InvalidLengthEnum::A with 3 elements\",\n    );\n    assert_de_tokens_error::\u003cInvalidLengthEnum\u003e(\n        \u0026[\n            Token::TupleVariant {\n                name: \"InvalidLengthEnum\",\n                variant: \"B\",\n                len: 3,\n            },\n            Token::I32(1),\n            Token::TupleVariantEnd,\n        ],\n        \"invalid length 1, expected tuple variant InvalidLengthEnum::B with 2 elements\",\n    );\n}\n\n#[derive(Clone, Serialize, Deserialize, PartialEq, Debug)]\n#[serde(into = \"EnumToU32\", from = \"EnumToU32\")]\nstruct StructFromEnum(Option\u003cu32\u003e);\n\nimpl Into\u003cEnumToU32\u003e for StructFromEnum {\n    fn into(self) -\u003e EnumToU32 {\n        match self {\n            StructFromEnum(v) =\u003e v.into(),\n        }\n    }\n}\n\nimpl From\u003cEnumToU32\u003e for StructFromEnum {\n    fn from(v: EnumToU32) -\u003e Self {\n        StructFromEnum(v.into())\n    }\n}\n\n#[derive(Clone, Serialize, Deserialize, PartialEq, Debug)]\n#[serde(into = \"Option\u003cu32\u003e\", from = \"Option\u003cu32\u003e\")]\nenum EnumToU32 {\n    One,\n    Two,\n    Three,\n    Four,\n    Nothing,\n}\n\nimpl Into\u003cOption\u003cu32\u003e\u003e for EnumToU32 {\n    fn into(self) -\u003e Option\u003cu32\u003e {\n        match self {\n            EnumToU32::One =\u003e Some(1),\n            EnumToU32::Two =\u003e Some(2),\n            EnumToU32::Three =\u003e Some(3),\n            EnumToU32::Four =\u003e Some(4),\n            EnumToU32::Nothing =\u003e None,\n        }\n    }\n}\n\nimpl From\u003cOption\u003cu32\u003e\u003e for EnumToU32 {\n    fn from(v: Option\u003cu32\u003e) -\u003e Self {\n        match v {\n            Some(1) =\u003e EnumToU32::One,\n            Some(2) =\u003e EnumToU32::Two,\n            Some(3) =\u003e EnumToU32::Three,\n            Some(4) =\u003e EnumToU32::Four,\n            _ =\u003e EnumToU32::Nothing,\n        }\n    }\n}\n\n#[derive(Clone, Deserialize, PartialEq, Debug)]\n#[serde(try_from = \"u32\")]\nenum TryFromU32 {\n    One,\n    Two,\n}\n\nimpl TryFrom\u003cu32\u003e for TryFromU32 {\n    type Error = String;\n\n    fn try_from(value: u32) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match value {\n            1 =\u003e Ok(TryFromU32::One),\n            2 =\u003e Ok(TryFromU32::Two),\n            _ =\u003e Err(\"out of range\".to_owned()),\n        }\n    }\n}\n\n#[test]\nfn test_from_into_traits() {\n    assert_ser_tokens(\u0026EnumToU32::One, \u0026[Token::Some, Token::U32(1)]);\n    assert_ser_tokens(\u0026EnumToU32::Nothing, \u0026[Token::None]);\n    assert_de_tokens(\u0026EnumToU32::Two, \u0026[Token::Some, Token::U32(2)]);\n    assert_ser_tokens(\u0026StructFromEnum(Some(5)), \u0026[Token::None]);\n    assert_ser_tokens(\u0026StructFromEnum(None), \u0026[Token::None]);\n    assert_de_tokens(\u0026StructFromEnum(Some(2)), \u0026[Token::Some, Token::U32(2)]);\n    assert_de_tokens(\u0026TryFromU32::Two, \u0026[Token::U32(2)]);\n    assert_de_tokens_error::\u003cTryFromU32\u003e(\u0026[Token::U32(5)], \"out of range\");\n}\n\n#[test]\nfn test_collect_other() {\n    let mut extra = HashMap::new();\n    extra.insert(\"c\".into(), 3);\n    assert_tokens(\n        \u0026CollectOther { a: 1, b: 2, extra },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::U32(1),\n            Token::Str(\"b\"),\n            Token::U32(2),\n            Token::Str(\"c\"),\n            Token::U32(3),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_struct_enum() {\n    let mut extra = HashMap::new();\n    extra.insert(\"extra_key\".into(), \"extra value\".into());\n    let change_request = FlattenStructEnumWrapper {\n        data: FlattenStructEnum::InsertInteger {\n            index: 0,\n            value: 42,\n        },\n        extra,\n    };\n    assert_de_tokens(\n        \u0026change_request,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"insert_integer\"),\n            Token::Map { len: None },\n            Token::Str(\"index\"),\n            Token::U32(0),\n            Token::Str(\"value\"),\n            Token::U32(42),\n            Token::MapEnd,\n            Token::Str(\"extra_key\"),\n            Token::Str(\"extra value\"),\n            Token::MapEnd,\n        ],\n    );\n    assert_ser_tokens(\n        \u0026change_request,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"insert_integer\"),\n            Token::Struct {\n                len: 2,\n                name: \"insert_integer\",\n            },\n            Token::Str(\"index\"),\n            Token::U32(0),\n            Token::Str(\"value\"),\n            Token::U32(42),\n            Token::StructEnd,\n            Token::Str(\"extra_key\"),\n            Token::Str(\"extra value\"),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_struct_tag_content_enum() {\n    let change_request = FlattenStructTagContentEnumWrapper {\n        outer: 42,\n        data: FlattenStructTagContentEnumNewtype(FlattenStructTagContentEnum::InsertInteger {\n            index: 0,\n            value: 42,\n        }),\n    };\n    assert_de_tokens(\n        \u0026change_request,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::U32(42),\n            Token::Str(\"type\"),\n            Token::Str(\"insert_integer\"),\n            Token::Str(\"value\"),\n            Token::Map { len: None },\n            Token::Str(\"index\"),\n            Token::U32(0),\n            Token::Str(\"value\"),\n            Token::U32(42),\n            Token::MapEnd,\n            Token::MapEnd,\n        ],\n    );\n    assert_ser_tokens(\n        \u0026change_request,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::U32(42),\n            Token::Str(\"type\"),\n            Token::Str(\"insert_integer\"),\n            Token::Str(\"value\"),\n            Token::Struct {\n                len: 2,\n                name: \"insert_integer\",\n            },\n            Token::Str(\"index\"),\n            Token::U32(0),\n            Token::Str(\"value\"),\n            Token::U32(42),\n            Token::StructEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_struct_tag_content_enum_newtype() {\n    let change_request = FlattenStructTagContentEnumWrapper {\n        outer: 42,\n        data: FlattenStructTagContentEnumNewtype(FlattenStructTagContentEnum::NewtypeVariant(\n            FlattenStructTagContentEnumNewtypeVariant { value: 23 },\n        )),\n    };\n    assert_de_tokens(\n        \u0026change_request,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::U32(42),\n            Token::Str(\"type\"),\n            Token::Str(\"newtype_variant\"),\n            Token::Str(\"value\"),\n            Token::Map { len: None },\n            Token::Str(\"value\"),\n            Token::U32(23),\n            Token::MapEnd,\n            Token::MapEnd,\n        ],\n    );\n    assert_ser_tokens(\n        \u0026change_request,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::U32(42),\n            Token::Str(\"type\"),\n            Token::Str(\"newtype_variant\"),\n            Token::Str(\"value\"),\n            Token::Struct {\n                len: 1,\n                name: \"FlattenStructTagContentEnumNewtypeVariant\",\n            },\n            Token::Str(\"value\"),\n            Token::U32(23),\n            Token::StructEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_unknown_field_in_flatten() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct Outer {\n        dummy: String,\n        #[serde(flatten)]\n        inner: Inner,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Inner {\n        foo: HashMap\u003cString, u32\u003e,\n    }\n\n    assert_de_tokens_error::\u003cOuter\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"Outer\",\n                len: 1,\n            },\n            Token::Str(\"dummy\"),\n            Token::Str(\"23\"),\n            Token::Str(\"foo\"),\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::U32(1),\n            Token::Str(\"b\"),\n            Token::U32(2),\n            Token::MapEnd,\n            Token::Str(\"bar\"),\n            Token::U32(23),\n            Token::StructEnd,\n        ],\n        \"unknown field `bar`\",\n    );\n}\n\n#[test]\nfn test_complex_flatten() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Outer {\n        y: u32,\n        #[serde(flatten)]\n        first: First,\n        #[serde(flatten)]\n        second: Second,\n        z: u32,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct First {\n        a: u32,\n        b: bool,\n        c: Vec\u003cString\u003e,\n        d: String,\n        e: Option\u003cu64\u003e,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Second {\n        f: u32,\n    }\n\n    assert_de_tokens(\n        \u0026Outer {\n            y: 0,\n            first: First {\n                a: 1,\n                b: true,\n                c: vec![\"a\".into(), \"b\".into()],\n                d: \"c\".into(),\n                e: Some(2),\n            },\n            second: Second { f: 3 },\n            z: 4,\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"y\"),\n            Token::U32(0),\n            Token::Str(\"a\"),\n            Token::U32(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::Str(\"c\"),\n            Token::Seq { len: Some(2) },\n            Token::Str(\"a\"),\n            Token::Str(\"b\"),\n            Token::SeqEnd,\n            Token::Str(\"d\"),\n            Token::Str(\"c\"),\n            Token::Str(\"e\"),\n            Token::U64(2),\n            Token::Str(\"f\"),\n            Token::U32(3),\n            Token::Str(\"z\"),\n            Token::U32(4),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026Outer {\n            y: 0,\n            first: First {\n                a: 1,\n                b: true,\n                c: vec![\"a\".into(), \"b\".into()],\n                d: \"c\".into(),\n                e: Some(2),\n            },\n            second: Second { f: 3 },\n            z: 4,\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"y\"),\n            Token::U32(0),\n            Token::Str(\"a\"),\n            Token::U32(1),\n            Token::Str(\"b\"),\n            Token::Bool(true),\n            Token::Str(\"c\"),\n            Token::Seq { len: Some(2) },\n            Token::Str(\"a\"),\n            Token::Str(\"b\"),\n            Token::SeqEnd,\n            Token::Str(\"d\"),\n            Token::Str(\"c\"),\n            Token::Str(\"e\"),\n            Token::Some,\n            Token::U64(2),\n            Token::Str(\"f\"),\n            Token::U32(3),\n            Token::Str(\"z\"),\n            Token::U32(4),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_map_twice() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    struct Outer {\n        #[serde(flatten)]\n        first: BTreeMap\u003cString, String\u003e,\n        #[serde(flatten)]\n        between: Inner,\n        #[serde(flatten)]\n        second: BTreeMap\u003cString, String\u003e,\n    }\n\n    #[derive(Debug, PartialEq, Deserialize)]\n    struct Inner {\n        y: String,\n    }\n\n    assert_de_tokens(\n        \u0026Outer {\n            first: {\n                let mut first = BTreeMap::new();\n                first.insert(\"x\".to_owned(), \"X\".to_owned());\n                first.insert(\"y\".to_owned(), \"Y\".to_owned());\n                first\n            },\n            between: Inner { y: \"Y\".to_owned() },\n            second: {\n                let mut second = BTreeMap::new();\n                second.insert(\"x\".to_owned(), \"X\".to_owned());\n                second\n            },\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"x\"),\n            Token::Str(\"X\"),\n            Token::Str(\"y\"),\n            Token::Str(\"Y\"),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_unsupported_type() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Outer {\n        outer: String,\n        #[serde(flatten)]\n        inner: String,\n    }\n\n    assert_ser_tokens_error(\n        \u0026Outer {\n            outer: \"foo\".into(),\n            inner: \"bar\".into(),\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::Str(\"foo\"),\n        ],\n        \"can only flatten structs and maps (got a string)\",\n    );\n    assert_de_tokens_error::\u003cOuter\u003e(\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"outer\"),\n            Token::Str(\"foo\"),\n            Token::Str(\"a\"),\n            Token::Str(\"b\"),\n            Token::MapEnd,\n        ],\n        \"can only flatten structs and maps\",\n    );\n}\n\n#[test]\nfn test_non_string_keys() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct TestStruct {\n        name: String,\n        age: u32,\n        #[serde(flatten)]\n        mapping: HashMap\u003cu32, u32\u003e,\n    }\n\n    let mut mapping = HashMap::new();\n    mapping.insert(0, 42);\n    assert_tokens(\n        \u0026TestStruct {\n            name: \"peter\".into(),\n            age: 3,\n            mapping,\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"name\"),\n            Token::Str(\"peter\"),\n            Token::Str(\"age\"),\n            Token::U32(3),\n            Token::U32(0),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_lifetime_propagation_for_flatten() {\n    #[derive(Deserialize, Serialize, Debug, PartialEq)]\n    struct A\u003cT\u003e {\n        #[serde(flatten)]\n        t: T,\n    }\n\n    #[derive(Deserialize, Serialize, Debug, PartialEq)]\n    struct B\u003c'a\u003e {\n        #[serde(flatten, borrow)]\n        t: HashMap\u003c\u0026'a str, u32\u003e,\n    }\n\n    #[derive(Deserialize, Serialize, Debug, PartialEq)]\n    struct C\u003c'a\u003e {\n        #[serde(flatten, borrow)]\n        t: HashMap\u003c\u0026'a [u8], u32\u003e,\n    }\n\n    let mut owned_map = HashMap::new();\n    owned_map.insert(\"x\".to_string(), 42u32);\n    assert_tokens(\n        \u0026A { t: owned_map },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"x\"),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n\n    let mut borrowed_map = HashMap::new();\n    borrowed_map.insert(\"x\", 42u32);\n    assert_ser_tokens(\n        \u0026B {\n            t: borrowed_map.clone(),\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::BorrowedStr(\"x\"),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026B { t: borrowed_map },\n        \u0026[\n            Token::Map { len: None },\n            Token::BorrowedStr(\"x\"),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n\n    let mut borrowed_map = HashMap::new();\n    borrowed_map.insert(\u0026b\"x\"[..], 42u32);\n    assert_ser_tokens(\n        \u0026C {\n            t: borrowed_map.clone(),\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Seq { len: Some(1) },\n            Token::U8(120),\n            Token::SeqEnd,\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026C { t: borrowed_map },\n        \u0026[\n            Token::Map { len: None },\n            Token::BorrowedBytes(b\"x\"),\n            Token::U32(42),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_enum_newtype() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct S {\n        #[serde(flatten)]\n        flat: E,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    enum E {\n        Q(HashMap\u003cString, String\u003e),\n    }\n\n    let e = E::Q({\n        let mut map = HashMap::new();\n        map.insert(\"k\".to_owned(), \"v\".to_owned());\n        map\n    });\n    let s = S { flat: e };\n\n    assert_tokens(\n        \u0026s,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"Q\"),\n            Token::Map { len: Some(1) },\n            Token::Str(\"k\"),\n            Token::Str(\"v\"),\n            Token::MapEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_internally_tagged() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct S {\n        #[serde(flatten)]\n        x: X,\n        #[serde(flatten)]\n        y: Y,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"typeX\")]\n    enum X {\n        A { a: i32 },\n        B { b: i32 },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"typeY\")]\n    enum Y {\n        C { c: i32 },\n        D { d: i32 },\n    }\n\n    let s = S {\n        x: X::B { b: 1 },\n        y: Y::D { d: 2 },\n    };\n\n    assert_tokens(\n        \u0026s,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"typeX\"),\n            Token::Str(\"B\"),\n            Token::Str(\"b\"),\n            Token::I32(1),\n            Token::Str(\"typeY\"),\n            Token::Str(\"D\"),\n            Token::Str(\"d\"),\n            Token::I32(2),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_externally_tagged_enum_containing_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        \u0026data,\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"Data\",\n                variant: \"A\",\n            },\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_enum_containing_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"t\")]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        \u0026data,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"t\"),\n            Token::Str(\"A\"),\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_adjacently_tagged_enum_containing_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        \u0026data,\n        \u0026[\n            Token::Struct {\n                name: \"Data\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"A\"),\n            Token::Str(\"c\"),\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_enum_containing_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(untagged)]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        \u0026data,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_untagged_enum() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Outer {\n        #[serde(flatten)]\n        inner: Inner,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(untagged)]\n    enum Inner {\n        Variant { a: i32 },\n    }\n\n    let data = Outer {\n        inner: Inner::Variant { a: 0 },\n    };\n\n    assert_tokens(\n        \u0026data,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_option() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Outer {\n        #[serde(flatten)]\n        inner1: Option\u003cInner1\u003e,\n        #[serde(flatten)]\n        inner2: Option\u003cInner2\u003e,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Inner1 {\n        inner1: i32,\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Inner2 {\n        inner2: i32,\n    }\n\n    assert_tokens(\n        \u0026Outer {\n            inner1: Some(Inner1 { inner1: 1 }),\n            inner2: Some(Inner2 { inner2: 2 }),\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"inner1\"),\n            Token::I32(1),\n            Token::Str(\"inner2\"),\n            Token::I32(2),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer {\n            inner1: Some(Inner1 { inner1: 1 }),\n            inner2: None,\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"inner1\"),\n            Token::I32(1),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer {\n            inner1: None,\n            inner2: Some(Inner2 { inner2: 2 }),\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"inner2\"),\n            Token::I32(2),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer {\n            inner1: None,\n            inner2: None,\n        },\n        \u0026[Token::Map { len: None }, Token::MapEnd],\n    );\n}\n\n#[test]\nfn test_transparent_struct() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(transparent)]\n    struct Transparent {\n        #[serde(skip)]\n        a: bool,\n        b: u32,\n        #[serde(skip)]\n        c: bool,\n        d: PhantomData\u003c()\u003e,\n    }\n\n    assert_tokens(\n        \u0026Transparent {\n            a: false,\n            b: 1,\n            c: false,\n            d: PhantomData,\n        },\n        \u0026[Token::U32(1)],\n    );\n}\n\n#[test]\nfn test_transparent_tuple_struct() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(transparent)]\n    struct Transparent(\n        #[serde(skip)] bool,\n        u32,\n        #[serde(skip)] bool,\n        PhantomData\u003c()\u003e,\n    );\n\n    assert_tokens(\u0026Transparent(false, 1, false, PhantomData), \u0026[Token::U32(1)]);\n}\n\n#[test]\nfn test_internally_tagged_unit_enum_with_unknown_fields() {\n    #[derive(Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"t\")]\n    enum Data {\n        A,\n    }\n\n    let data = Data::A;\n\n    assert_de_tokens(\n        \u0026data,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"t\"),\n            Token::Str(\"A\"),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flattened_internally_tagged_unit_enum_with_unknown_fields() {\n    #[derive(Deserialize, PartialEq, Debug)]\n    struct S {\n        #[serde(flatten)]\n        x: X,\n        #[serde(flatten)]\n        y: Y,\n    }\n\n    #[derive(Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"typeX\")]\n    enum X {\n        A,\n    }\n\n    #[derive(Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"typeY\")]\n    enum Y {\n        B { c: u32 },\n    }\n\n    let s = S {\n        x: X::A,\n        y: Y::B { c: 0 },\n    };\n\n    assert_de_tokens(\n        \u0026s,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"typeX\"),\n            Token::Str(\"A\"),\n            Token::Str(\"typeY\"),\n            Token::Str(\"B\"),\n            Token::Str(\"c\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_flatten_any_after_flatten_struct() {\n    #[derive(PartialEq, Debug)]\n    struct Any;\n\n    impl\u003c'de\u003e Deserialize\u003c'de\u003e for Any {\n        fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            struct AnyVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for AnyVisitor {\n                type Value = Any;\n\n                fn expecting(\u0026self, _formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    unimplemented!()\n                }\n\n                fn visit_map\u003cM\u003e(self, mut map: M) -\u003e Result\u003cSelf::Value, M::Error\u003e\n                where\n                    M: MapAccess\u003c'de\u003e,\n                {\n                    while let Some((Any, Any)) = map.next_entry()? {}\n                    Ok(Any)\n                }\n            }\n\n            deserializer.deserialize_any(AnyVisitor)\n        }\n    }\n\n    #[derive(Deserialize, PartialEq, Debug)]\n    struct Outer {\n        #[serde(flatten)]\n        inner: Inner,\n        #[serde(flatten)]\n        extra: Any,\n    }\n\n    #[derive(Deserialize, PartialEq, Debug)]\n    struct Inner {\n        inner: i32,\n    }\n\n    let s = Outer {\n        inner: Inner { inner: 0 },\n        extra: Any,\n    };\n\n    assert_de_tokens(\n        \u0026s,\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"inner\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_borrow.rs"],"content":"use serde::{Deserialize, Deserializer};\nuse serde_test::{assert_de_tokens, assert_de_tokens_error, Token};\n\nuse std::borrow::Cow;\n\n#[test]\nfn test_borrowed_str() {\n    assert_de_tokens(\u0026\"borrowed\", \u0026[Token::BorrowedStr(\"borrowed\")]);\n}\n\n#[test]\nfn test_borrowed_str_from_string() {\n    assert_de_tokens_error::\u003c\u0026str\u003e(\n        \u0026[Token::String(\"borrowed\")],\n        \"invalid type: string \\\"borrowed\\\", expected a borrowed string\",\n    );\n}\n\n#[test]\nfn test_borrowed_str_from_str() {\n    assert_de_tokens_error::\u003c\u0026str\u003e(\n        \u0026[Token::Str(\"borrowed\")],\n        \"invalid type: string \\\"borrowed\\\", expected a borrowed string\",\n    );\n}\n\n#[test]\nfn test_string_from_borrowed_str() {\n    assert_de_tokens(\u0026\"owned\".to_owned(), \u0026[Token::BorrowedStr(\"owned\")]);\n}\n\n#[test]\nfn test_borrowed_bytes() {\n    assert_de_tokens(\u0026\u0026b\"borrowed\"[..], \u0026[Token::BorrowedBytes(b\"borrowed\")]);\n}\n\n#[test]\nfn test_borrowed_bytes_from_bytebuf() {\n    assert_de_tokens_error::\u003c\u0026[u8]\u003e(\n        \u0026[Token::ByteBuf(b\"borrowed\")],\n        \"invalid type: byte array, expected a borrowed byte array\",\n    );\n}\n\n#[test]\nfn test_borrowed_bytes_from_bytes() {\n    assert_de_tokens_error::\u003c\u0026[u8]\u003e(\n        \u0026[Token::Bytes(b\"borrowed\")],\n        \"invalid type: byte array, expected a borrowed byte array\",\n    );\n}\n\n#[test]\nfn test_tuple() {\n    assert_de_tokens(\n        \u0026(\"str\", \u0026b\"bytes\"[..]),\n        \u0026[\n            Token::Tuple { len: 2 },\n            Token::BorrowedStr(\"str\"),\n            Token::BorrowedBytes(b\"bytes\"),\n            Token::TupleEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_struct() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    struct Borrowing\u003c'a, 'b\u003e {\n        bs: \u0026'a str,\n        bb: \u0026'b [u8],\n    }\n\n    assert_de_tokens(\n        \u0026Borrowing {\n            bs: \"str\",\n            bb: b\"bytes\",\n        },\n        \u0026[\n            Token::Struct {\n                name: \"Borrowing\",\n                len: 2,\n            },\n            Token::BorrowedStr(\"bs\"),\n            Token::BorrowedStr(\"str\"),\n            Token::BorrowedStr(\"bb\"),\n            Token::BorrowedBytes(b\"bytes\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_cow() {\n    #[derive(Deserialize)]\n    struct Cows\u003c'a, 'b\u003e {\n        copied: Cow\u003c'a, str\u003e,\n\n        #[serde(borrow)]\n        borrowed: Cow\u003c'b, str\u003e,\n    }\n\n    let tokens = \u0026[\n        Token::Struct {\n            name: \"Cows\",\n            len: 2,\n        },\n        Token::Str(\"copied\"),\n        Token::BorrowedStr(\"copied\"),\n        Token::Str(\"borrowed\"),\n        Token::BorrowedStr(\"borrowed\"),\n        Token::StructEnd,\n    ];\n\n    let mut de = serde_test::Deserializer::new(tokens);\n    let cows = Cows::deserialize(\u0026mut de).unwrap();\n\n    match cows.copied {\n        Cow::Owned(ref s) if s == \"copied\" =\u003e {}\n        _ =\u003e panic!(\"expected a copied string\"),\n    }\n\n    match cows.borrowed {\n        Cow::Borrowed(\"borrowed\") =\u003e {}\n        _ =\u003e panic!(\"expected a borrowed string\"),\n    }\n}\n\n#[test]\nfn test_lifetimes() {\n    #[derive(Deserialize)]\n    struct Cows\u003c'a, 'b\u003e {\n        _copied: Cow\u003c'a, str\u003e,\n\n        #[serde(borrow)]\n        _borrowed: Cow\u003c'b, str\u003e,\n    }\n\n    // Tests that `'de: 'a` is not required by the Deserialize impl.\n    fn _cows_lifetimes\u003c'de: 'b, 'a, 'b, D\u003e(deserializer: D) -\u003e Cows\u003c'a, 'b\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Deserialize::deserialize(deserializer).unwrap()\n    }\n\n    #[derive(Deserialize)]\n    struct Wrap\u003c'a, 'b\u003e {\n        #[serde(borrow = \"'b\")]\n        _cows: Cows\u003c'a, 'b\u003e,\n    }\n\n    // Tests that `'de: 'a` is not required by the Deserialize impl.\n    fn _wrap_lifetimes\u003c'de: 'b, 'a, 'b, D\u003e(deserializer: D) -\u003e Wrap\u003c'a, 'b\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        Deserialize::deserialize(deserializer).unwrap()\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_de.rs"],"content":"#![allow(clippy::decimal_literal_representation, clippy::unreadable_literal)]\n#![cfg_attr(feature = \"unstable\", feature(never_type))]\n\nuse std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\nuse std::default::Default;\nuse std::ffi::{CStr, CString, OsString};\nuse std::fmt::Debug;\nuse std::net;\nuse std::num::Wrapping;\nuse std::ops::Bound;\nuse std::path::{Path, PathBuf};\nuse std::rc::{Rc, Weak as RcWeak};\nuse std::sync::atomic::{\n    AtomicBool, AtomicI16, AtomicI32, AtomicI8, AtomicIsize, AtomicU16, AtomicU32, AtomicU8,\n    AtomicUsize, Ordering,\n};\nuse std::sync::{Arc, Weak as ArcWeak};\nuse std::time::{Duration, UNIX_EPOCH};\n\n#[cfg(target_arch = \"x86_64\")]\nuse std::sync::atomic::{AtomicI64, AtomicU64};\n\nuse fnv::FnvHasher;\nuse serde::de::DeserializeOwned;\nuse serde::{Deserialize, Deserializer};\nuse serde_test::{assert_de_tokens, assert_de_tokens_error, Configure, Token};\n\n#[macro_use]\nmod macros;\n\n//////////////////////////////////////////////////////////////////////////\n\n#[derive(Copy, Clone, PartialEq, Debug, Deserialize)]\nstruct UnitStruct;\n\n#[derive(PartialEq, Debug, Deserialize)]\nstruct NewtypeStruct(i32);\n\n#[derive(PartialEq, Debug, Deserialize)]\nstruct TupleStruct(i32, i32, i32);\n\n#[derive(PartialEq, Debug, Deserialize)]\nstruct Struct {\n    a: i32,\n    b: i32,\n    #[serde(skip_deserializing)]\n    c: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(deny_unknown_fields)]\nstruct StructDenyUnknown {\n    a: i32,\n    #[serde(skip_deserializing)]\n    b: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(default)]\nstruct StructDefault\u003cT\u003e {\n    a: i32,\n    b: T,\n}\n\nimpl Default for StructDefault\u003cString\u003e {\n    fn default() -\u003e Self {\n        StructDefault {\n            a: 100,\n            b: \"default\".to_string(),\n        }\n    }\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\nstruct StructSkipAll {\n    #[serde(skip_deserializing)]\n    a: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(default)]\nstruct StructSkipDefault {\n    #[serde(skip_deserializing)]\n    a: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(default)]\nstruct StructSkipDefaultGeneric\u003cT\u003e {\n    #[serde(skip_deserializing)]\n    t: T,\n}\n\nimpl Default for StructSkipDefault {\n    fn default() -\u003e Self {\n        StructSkipDefault { a: 16 }\n    }\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\n#[serde(deny_unknown_fields)]\nstruct StructSkipAllDenyUnknown {\n    #[serde(skip_deserializing)]\n    a: i32,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\nenum Enum {\n    #[allow(dead_code)]\n    #[serde(skip_deserializing)]\n    Skipped,\n    Unit,\n    Simple(i32),\n    Seq(i32, i32, i32),\n    Map {\n        a: i32,\n        b: i32,\n        c: i32,\n    },\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\nenum EnumSkipAll {\n    #[allow(dead_code)]\n    #[serde(skip_deserializing)]\n    Skipped,\n}\n\n#[derive(PartialEq, Debug, Deserialize)]\nenum EnumOther {\n    Unit,\n    #[serde(other)]\n    Other,\n}\n\n#[derive(PartialEq, Debug)]\nstruct IgnoredAny;\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for IgnoredAny {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        serde::de::IgnoredAny::deserialize(deserializer)?;\n        Ok(IgnoredAny)\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nmacro_rules! declare_tests {\n    (\n        $readable:tt\n        $($name:ident { $($value:expr =\u003e $tokens:expr,)+ })+\n    ) =\u003e {\n        $(\n            #[test]\n            fn $name() {\n                $(\n                    // Test ser/de roundtripping\n                    assert_de_tokens(\u0026$value.$readable(), $tokens);\n\n                    // Test that the tokens are ignorable\n                    assert_de_tokens_ignore($tokens);\n                )+\n            }\n        )+\n    };\n\n    ($(\n        $(#[$cfg:meta])*\n        $name:ident { $($value:expr =\u003e $tokens:expr,)+ }\n    )+) =\u003e {\n        $(\n            $(#[$cfg])*\n            #[test]\n            fn $name() {\n                $(\n                    // Test ser/de roundtripping\n                    assert_de_tokens(\u0026$value, $tokens);\n\n                    // Test that the tokens are ignorable\n                    assert_de_tokens_ignore($tokens);\n                )+\n            }\n        )+\n    }\n}\n\nmacro_rules! declare_error_tests {\n    ($($name:ident\u003c$target:ty\u003e { $tokens:expr, $expected:expr, })+) =\u003e {\n        $(\n            #[test]\n            fn $name() {\n                assert_de_tokens_error::\u003c$target\u003e($tokens, $expected);\n            }\n        )+\n    }\n}\n\n#[derive(Debug)]\nstruct SkipPartialEq\u003cT\u003e(T);\n\nimpl\u003c'de, T\u003e Deserialize\u003c'de\u003e for SkipPartialEq\u003cT\u003e\nwhere\n    T: Deserialize\u003c'de\u003e,\n{\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(deserializer).map(SkipPartialEq)\n    }\n}\n\nimpl\u003cT\u003e PartialEq for SkipPartialEq\u003cT\u003e {\n    fn eq(\u0026self, _other: \u0026Self) -\u003e bool {\n        true\n    }\n}\n\nfn assert_de_tokens_ignore(ignorable_tokens: \u0026[Token]) {\n    #[derive(PartialEq, Debug, Deserialize)]\n    struct IgnoreBase {\n        a: i32,\n    }\n\n    // Embed the tokens to be ignored in the normal token\n    // stream for an IgnoreBase type\n    let concated_tokens: Vec\u003cToken\u003e = vec![\n        Token::Map { len: Some(2) },\n        Token::Str(\"a\"),\n        Token::I32(1),\n        Token::Str(\"ignored\"),\n    ]\n    .into_iter()\n    .chain(ignorable_tokens.to_vec().into_iter())\n    .chain(vec![Token::MapEnd].into_iter())\n    .collect();\n\n    let mut de = serde_test::Deserializer::new(\u0026concated_tokens);\n    let base = IgnoreBase::deserialize(\u0026mut de).unwrap();\n    assert_eq!(base, IgnoreBase { a: 1 });\n}\n\n//////////////////////////////////////////////////////////////////////////\n\ndeclare_tests! {\n    test_bool {\n        true =\u003e \u0026[Token::Bool(true)],\n        false =\u003e \u0026[Token::Bool(false)],\n    }\n    test_isize {\n        0isize =\u003e \u0026[Token::I8(0)],\n        0isize =\u003e \u0026[Token::I16(0)],\n        0isize =\u003e \u0026[Token::I32(0)],\n        0isize =\u003e \u0026[Token::I64(0)],\n        0isize =\u003e \u0026[Token::U8(0)],\n        0isize =\u003e \u0026[Token::U16(0)],\n        0isize =\u003e \u0026[Token::U32(0)],\n        0isize =\u003e \u0026[Token::U64(0)],\n    }\n    test_ints {\n        0i8 =\u003e \u0026[Token::I8(0)],\n        0i16 =\u003e \u0026[Token::I16(0)],\n        0i32 =\u003e \u0026[Token::I32(0)],\n        0i64 =\u003e \u0026[Token::I64(0)],\n    }\n    test_uints {\n        0u8 =\u003e \u0026[Token::U8(0)],\n        0u16 =\u003e \u0026[Token::U16(0)],\n        0u32 =\u003e \u0026[Token::U32(0)],\n        0u64 =\u003e \u0026[Token::U64(0)],\n    }\n    test_floats {\n        0f32 =\u003e \u0026[Token::F32(0.)],\n        0f64 =\u003e \u0026[Token::F64(0.)],\n    }\n    #[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n    test_small_int_to_128 {\n        1i128 =\u003e \u0026[Token::I8(1)],\n        1i128 =\u003e \u0026[Token::I16(1)],\n        1i128 =\u003e \u0026[Token::I32(1)],\n        1i128 =\u003e \u0026[Token::I64(1)],\n\n        1i128 =\u003e \u0026[Token::U8(1)],\n        1i128 =\u003e \u0026[Token::U16(1)],\n        1i128 =\u003e \u0026[Token::U32(1)],\n        1i128 =\u003e \u0026[Token::U64(1)],\n\n        1u128 =\u003e \u0026[Token::I8(1)],\n        1u128 =\u003e \u0026[Token::I16(1)],\n        1u128 =\u003e \u0026[Token::I32(1)],\n        1u128 =\u003e \u0026[Token::I64(1)],\n\n        1u128 =\u003e \u0026[Token::U8(1)],\n        1u128 =\u003e \u0026[Token::U16(1)],\n        1u128 =\u003e \u0026[Token::U32(1)],\n        1u128 =\u003e \u0026[Token::U64(1)],\n    }\n    test_char {\n        'a' =\u003e \u0026[Token::Char('a')],\n        'a' =\u003e \u0026[Token::Str(\"a\")],\n        'a' =\u003e \u0026[Token::String(\"a\")],\n    }\n    test_string {\n        \"abc\".to_owned() =\u003e \u0026[Token::Str(\"abc\")],\n        \"abc\".to_owned() =\u003e \u0026[Token::String(\"abc\")],\n        \"a\".to_owned() =\u003e \u0026[Token::Char('a')],\n    }\n    test_option {\n        None::\u003ci32\u003e =\u003e \u0026[Token::Unit],\n        None::\u003ci32\u003e =\u003e \u0026[Token::None],\n        Some(1) =\u003e \u0026[\n            Token::Some,\n            Token::I32(1),\n        ],\n    }\n    test_result {\n        Ok::\u003ci32, i32\u003e(0) =\u003e \u0026[\n            Token::Enum { name: \"Result\" },\n            Token::Str(\"Ok\"),\n            Token::I32(0),\n        ],\n        Err::\u003ci32, i32\u003e(1) =\u003e \u0026[\n            Token::Enum { name: \"Result\" },\n            Token::Str(\"Err\"),\n            Token::I32(1),\n        ],\n    }\n    test_unit {\n        () =\u003e \u0026[Token::Unit],\n    }\n    test_unit_struct {\n        UnitStruct =\u003e \u0026[Token::Unit],\n        UnitStruct =\u003e \u0026[\n            Token::UnitStruct { name: \"UnitStruct\" },\n        ],\n    }\n    test_newtype_struct {\n        NewtypeStruct(1) =\u003e \u0026[\n            Token::NewtypeStruct { name: \"NewtypeStruct\" },\n            Token::I32(1),\n        ],\n    }\n    test_tuple_struct {\n        TupleStruct(1, 2, 3) =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n        TupleStruct(1, 2, 3) =\u003e \u0026[\n            Token::Seq { len: None },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n        TupleStruct(1, 2, 3) =\u003e \u0026[\n            Token::TupleStruct { name: \"TupleStruct\", len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n        TupleStruct(1, 2, 3) =\u003e \u0026[\n            Token::TupleStruct { name: \"TupleStruct\", len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n    }\n    test_btreeset {\n        BTreeSet::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        btreeset![btreeset![], btreeset![1], btreeset![2, 3]] =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::Seq { len: Some(0) },\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(1) },\n                    Token::I32(1),\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(2) },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::SeqEnd,\n            Token::SeqEnd,\n        ],\n        BTreeSet::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n    }\n    test_hashset {\n        HashSet::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        hashset![1, 2, 3] =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n        HashSet::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n        hashset![FnvHasher @ 1, 2, 3] =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n    }\n    test_vec {\n        Vec::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        vec![vec![], vec![1], vec![2, 3]] =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::Seq { len: Some(0) },\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(1) },\n                    Token::I32(1),\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(2) },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::SeqEnd,\n            Token::SeqEnd,\n        ],\n        Vec::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n    }\n    test_array {\n        [0; 0] =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        [0; 0] =\u003e \u0026[\n            Token::Tuple { len: 0 },\n            Token::TupleEnd,\n        ],\n        ([0; 0], [1], [2, 3]) =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::Seq { len: Some(0) },\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(1) },\n                    Token::I32(1),\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(2) },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::SeqEnd,\n            Token::SeqEnd,\n        ],\n        ([0; 0], [1], [2, 3]) =\u003e \u0026[\n            Token::Tuple { len: 3 },\n                Token::Tuple { len: 0 },\n                Token::TupleEnd,\n\n                Token::Tuple { len: 1 },\n                    Token::I32(1),\n                Token::TupleEnd,\n\n                Token::Tuple { len: 2 },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::TupleEnd,\n            Token::TupleEnd,\n        ],\n        [0; 0] =\u003e \u0026[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n    }\n    test_tuple {\n        (1,) =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n                Token::I32(1),\n            Token::SeqEnd,\n        ],\n        (1, 2, 3) =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n        (1,) =\u003e \u0026[\n            Token::Tuple { len: 1 },\n                Token::I32(1),\n            Token::TupleEnd,\n        ],\n        (1, 2, 3) =\u003e \u0026[\n            Token::Tuple { len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleEnd,\n        ],\n    }\n    test_btreemap {\n        BTreeMap::\u003cisize, isize\u003e::new() =\u003e \u0026[\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n        ],\n        btreemap![1 =\u003e 2] =\u003e \u0026[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        btreemap![1 =\u003e 2, 3 =\u003e 4] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::I32(2),\n\n                Token::I32(3),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n        btreemap![1 =\u003e btreemap![], 2 =\u003e btreemap![3 =\u003e 4, 5 =\u003e 6]] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::Map { len: Some(0) },\n                Token::MapEnd,\n\n                Token::I32(2),\n                Token::Map { len: Some(2) },\n                    Token::I32(3),\n                    Token::I32(4),\n\n                    Token::I32(5),\n                    Token::I32(6),\n                Token::MapEnd,\n            Token::MapEnd,\n        ],\n        BTreeMap::\u003cisize, isize\u003e::new() =\u003e \u0026[\n            Token::Struct { name: \"Anything\", len: 0 },\n            Token::StructEnd,\n        ],\n    }\n    test_hashmap {\n        HashMap::\u003cisize, isize\u003e::new() =\u003e \u0026[\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n        ],\n        hashmap![1 =\u003e 2] =\u003e \u0026[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        hashmap![1 =\u003e 2, 3 =\u003e 4] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::I32(2),\n\n                Token::I32(3),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n        hashmap![1 =\u003e hashmap![], 2 =\u003e hashmap![3 =\u003e 4, 5 =\u003e 6]] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::Map { len: Some(0) },\n                Token::MapEnd,\n\n                Token::I32(2),\n                Token::Map { len: Some(2) },\n                    Token::I32(3),\n                    Token::I32(4),\n\n                    Token::I32(5),\n                    Token::I32(6),\n                Token::MapEnd,\n            Token::MapEnd,\n        ],\n        HashMap::\u003cisize, isize\u003e::new() =\u003e \u0026[\n            Token::Struct { name: \"Anything\", len: 0 },\n            Token::StructEnd,\n        ],\n        hashmap![FnvHasher @ 1 =\u003e 2, 3 =\u003e 4] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::I32(2),\n\n                Token::I32(3),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n    }\n    test_struct {\n        Struct { a: 1, b: 2, c: 0 } =\u003e \u0026[\n            Token::Map { len: Some(3) },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        Struct { a: 1, b: 2, c: 0 } =\u003e \u0026[\n            Token::Map { len: Some(3) },\n                Token::U32(0),\n                Token::I32(1),\n\n                Token::U32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        Struct { a: 1, b: 2, c: 0 } =\u003e \u0026[\n            Token::Struct { name: \"Struct\", len: 2 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n            Token::StructEnd,\n        ],\n        Struct { a: 1, b: 2, c: 0 } =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_struct_with_skip {\n        Struct { a: 1, b: 2, c: 0 } =\u003e \u0026[\n            Token::Map { len: Some(3) },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n\n                Token::Str(\"c\"),\n                Token::I32(3),\n\n                Token::Str(\"d\"),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n        Struct { a: 1, b: 2, c: 0 } =\u003e \u0026[\n            Token::Struct { name: \"Struct\", len: 2 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n\n                Token::Str(\"c\"),\n                Token::I32(3),\n\n                Token::Str(\"d\"),\n                Token::I32(4),\n            Token::StructEnd,\n        ],\n    }\n    test_struct_skip_all {\n        StructSkipAll { a: 0 } =\u003e \u0026[\n            Token::Struct { name: \"StructSkipAll\", len: 0 },\n            Token::StructEnd,\n        ],\n        StructSkipAll { a: 0 } =\u003e \u0026[\n            Token::Struct { name: \"StructSkipAll\", len: 0 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n            Token::StructEnd,\n        ],\n    }\n    test_struct_skip_default {\n        StructSkipDefault { a: 16 } =\u003e \u0026[\n            Token::Struct { name: \"StructSkipDefault\", len: 0 },\n            Token::StructEnd,\n        ],\n    }\n    test_struct_skip_all_deny_unknown {\n        StructSkipAllDenyUnknown { a: 0 } =\u003e \u0026[\n            Token::Struct { name: \"StructSkipAllDenyUnknown\", len: 0 },\n            Token::StructEnd,\n        ],\n    }\n    test_struct_default {\n        StructDefault { a: 50, b: \"overwritten\".to_string() } =\u003e \u0026[\n            Token::Struct { name: \"StructDefault\", len: 2 },\n                Token::Str(\"a\"),\n                Token::I32(50),\n\n                Token::Str(\"b\"),\n                Token::String(\"overwritten\"),\n            Token::StructEnd,\n        ],\n        StructDefault { a: 100, b: \"default\".to_string() } =\u003e \u0026[\n            Token::Struct { name: \"StructDefault\",  len: 2 },\n            Token::StructEnd,\n        ],\n    }\n    test_enum_unit {\n        Enum::Unit =\u003e \u0026[\n            Token::UnitVariant { name: \"Enum\", variant: \"Unit\" },\n        ],\n    }\n    test_enum_simple {\n        Enum::Simple(1) =\u003e \u0026[\n            Token::NewtypeVariant { name: \"Enum\", variant: \"Simple\" },\n            Token::I32(1),\n        ],\n    }\n    test_enum_seq {\n        Enum::Seq(1, 2, 3) =\u003e \u0026[\n            Token::TupleVariant { name: \"Enum\", variant: \"Seq\", len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleVariantEnd,\n        ],\n    }\n    test_enum_map {\n        Enum::Map { a: 1, b: 2, c: 3 } =\u003e \u0026[\n            Token::StructVariant { name: \"Enum\", variant: \"Map\", len: 3 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n\n                Token::Str(\"c\"),\n                Token::I32(3),\n            Token::StructVariantEnd,\n        ],\n    }\n    test_enum_unit_usize {\n        Enum::Unit =\u003e \u0026[\n            Token::Enum { name: \"Enum\" },\n            Token::U32(0),\n            Token::Unit,\n        ],\n    }\n    test_enum_unit_bytes {\n        Enum::Unit =\u003e \u0026[\n            Token::Enum { name: \"Enum\" },\n            Token::Bytes(b\"Unit\"),\n            Token::Unit,\n        ],\n    }\n    test_enum_other_unit {\n        EnumOther::Unit =\u003e \u0026[\n            Token::Enum { name: \"EnumOther\" },\n            Token::Str(\"Unit\"),\n            Token::Unit,\n        ],\n    }\n    test_enum_other {\n        EnumOther::Other =\u003e \u0026[\n            Token::Enum { name: \"EnumOther\" },\n            Token::Str(\"Foo\"),\n            Token::Unit,\n        ],\n    }\n    test_box {\n        Box::new(0i32) =\u003e \u0026[Token::I32(0)],\n    }\n    test_boxed_slice {\n        Box::new([0, 1, 2]) =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n            Token::I32(0),\n            Token::I32(1),\n            Token::I32(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_duration {\n        Duration::new(1, 2) =\u003e \u0026[\n            Token::Struct { name: \"Duration\", len: 2 },\n                Token::Str(\"secs\"),\n                Token::U64(1),\n\n                Token::Str(\"nanos\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n        Duration::new(1, 2) =\u003e \u0026[\n            Token::Seq { len: Some(2) },\n                Token::I64(1),\n                Token::I64(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_system_time {\n        UNIX_EPOCH + Duration::new(1, 2) =\u003e \u0026[\n            Token::Struct { name: \"SystemTime\", len: 2 },\n                Token::Str(\"secs_since_epoch\"),\n                Token::U64(1),\n\n                Token::Str(\"nanos_since_epoch\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n        UNIX_EPOCH + Duration::new(1, 2) =\u003e \u0026[\n            Token::Seq { len: Some(2) },\n                Token::I64(1),\n                Token::I64(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_range {\n        1u32..2u32 =\u003e \u0026[\n            Token::Struct { name: \"Range\", len: 2 },\n                Token::Str(\"start\"),\n                Token::U32(1),\n\n                Token::Str(\"end\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n        1u32..2u32 =\u003e \u0026[\n            Token::Seq { len: Some(2) },\n                Token::U64(1),\n                Token::U64(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_range_inclusive {\n        1u32..=2u32 =\u003e \u0026[\n            Token::Struct { name: \"RangeInclusive\", len: 2 },\n                Token::Str(\"start\"),\n                Token::U32(1),\n\n                Token::Str(\"end\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n        1u32..=2u32 =\u003e \u0026[\n            Token::Seq { len: Some(2) },\n                Token::U64(1),\n                Token::U64(2),\n            Token::SeqEnd,\n        ],\n    }\n    test_bound {\n        Bound::Unbounded::\u003c()\u003e =\u003e \u0026[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Unbounded\"),\n            Token::Unit,\n        ],\n        Bound::Included(0) =\u003e \u0026[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Included\"),\n            Token::U8(0),\n        ],\n        Bound::Excluded(0) =\u003e \u0026[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Excluded\"),\n            Token::U8(0),\n        ],\n    }\n    test_path {\n        Path::new(\"/usr/local/lib\") =\u003e \u0026[\n            Token::BorrowedStr(\"/usr/local/lib\"),\n        ],\n    }\n    test_path_buf {\n        PathBuf::from(\"/usr/local/lib\") =\u003e \u0026[\n            Token::String(\"/usr/local/lib\"),\n        ],\n    }\n    test_cstring {\n        CString::new(\"abc\").unwrap() =\u003e \u0026[\n            Token::Bytes(b\"abc\"),\n        ],\n    }\n    test_rc {\n        Rc::new(true) =\u003e \u0026[\n            Token::Bool(true),\n        ],\n    }\n    test_rc_weak_some {\n        SkipPartialEq(RcWeak::\u003cbool\u003e::new()) =\u003e \u0026[\n            Token::Some,\n            Token::Bool(true),\n        ],\n    }\n    test_rc_weak_none {\n        SkipPartialEq(RcWeak::\u003cbool\u003e::new()) =\u003e \u0026[\n            Token::None,\n        ],\n    }\n    test_arc {\n        Arc::new(true) =\u003e \u0026[\n            Token::Bool(true),\n        ],\n    }\n    test_arc_weak_some {\n        SkipPartialEq(ArcWeak::\u003cbool\u003e::new()) =\u003e \u0026[\n            Token::Some,\n            Token::Bool(true),\n        ],\n    }\n    test_arc_weak_none {\n        SkipPartialEq(ArcWeak::\u003cbool\u003e::new()) =\u003e \u0026[\n            Token::None,\n        ],\n    }\n    test_wrapping {\n        Wrapping(1usize) =\u003e \u0026[\n            Token::U32(1),\n        ],\n        Wrapping(1usize) =\u003e \u0026[\n            Token::U64(1),\n        ],\n    }\n    test_rc_dst {\n        Rc::\u003cstr\u003e::from(\"s\") =\u003e \u0026[\n            Token::Str(\"s\"),\n        ],\n        Rc::\u003c[bool]\u003e::from(\u0026[true][..]) =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n    }\n    test_arc_dst {\n        Arc::\u003cstr\u003e::from(\"s\") =\u003e \u0026[\n            Token::Str(\"s\"),\n        ],\n        Arc::\u003c[bool]\u003e::from(\u0026[true][..]) =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n    }\n    test_ignored_any {\n        IgnoredAny =\u003e \u0026[\n            Token::Str(\"s\"),\n        ],\n        IgnoredAny =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n        IgnoredAny =\u003e \u0026[\n            Token::Enum { name: \"E\" },\n            Token::Str(\"Rust\"),\n            Token::Unit,\n        ],\n    }\n}\n\ndeclare_tests! {\n    readable\n\n    test_net_ipv4addr_readable {\n        \"1.2.3.4\".parse::\u003cnet::Ipv4Addr\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4\")],\n    }\n    test_net_ipv6addr_readable {\n        \"::1\".parse::\u003cnet::Ipv6Addr\u003e().unwrap() =\u003e \u0026[Token::Str(\"::1\")],\n    }\n    test_net_ipaddr_readable {\n        \"1.2.3.4\".parse::\u003cnet::IpAddr\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4\")],\n    }\n    test_net_socketaddr_readable {\n        \"1.2.3.4:1234\".parse::\u003cnet::SocketAddr\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4:1234\")],\n        \"1.2.3.4:1234\".parse::\u003cnet::SocketAddrV4\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4:1234\")],\n        \"[::1]:1234\".parse::\u003cnet::SocketAddrV6\u003e().unwrap() =\u003e \u0026[Token::Str(\"[::1]:1234\")],\n    }\n}\n\ndeclare_tests! {\n    compact\n\n    test_net_ipv4addr_compact {\n        net::Ipv4Addr::from(*b\"1234\") =\u003e \u0026seq![\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd\n        ],\n    }\n    test_net_ipv6addr_compact {\n        net::Ipv6Addr::from(*b\"1234567890123456\") =\u003e \u0026seq![\n            Token::Tuple { len: 4 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd\n        ],\n    }\n    test_net_ipaddr_compact {\n        net::IpAddr::from(*b\"1234\") =\u003e \u0026seq![\n            Token::NewtypeVariant { name: \"IpAddr\", variant: \"V4\" },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd\n        ],\n    }\n    test_net_socketaddr_compact {\n        net::SocketAddr::from((*b\"1234567890123456\", 1234)) =\u003e \u0026seq![\n            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V6\" },\n\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd\n        ],\n        net::SocketAddr::from((*b\"1234\", 1234)) =\u003e \u0026seq![\n            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V4\" },\n\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd\n        ],\n        net::SocketAddrV4::new(net::Ipv4Addr::from(*b\"1234\"), 1234) =\u003e \u0026seq![\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd\n        ],\n        net::SocketAddrV6::new(net::Ipv6Addr::from(*b\"1234567890123456\"), 1234, 0, 0) =\u003e \u0026seq![\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd\n        ],\n    }\n}\n\n#[cfg(feature = \"unstable\")]\ndeclare_tests! {\n    test_never_result {\n        Ok::\u003cu8, !\u003e(0) =\u003e \u0026[\n            Token::NewtypeVariant { name: \"Result\", variant: \"Ok\" },\n            Token::U8(0),\n        ],\n    }\n}\n\n#[cfg(unix)]\n#[test]\nfn test_osstring() {\n    use std::os::unix::ffi::OsStringExt;\n\n    let value = OsString::from_vec(vec![1, 2, 3]);\n    let tokens = [\n        Token::Enum { name: \"OsString\" },\n        Token::Str(\"Unix\"),\n        Token::Seq { len: Some(2) },\n        Token::U8(1),\n        Token::U8(2),\n        Token::U8(3),\n        Token::SeqEnd,\n    ];\n\n    assert_de_tokens(\u0026value, \u0026tokens);\n    assert_de_tokens_ignore(\u0026tokens);\n}\n\n#[cfg(windows)]\n#[test]\nfn test_osstring() {\n    use std::os::windows::ffi::OsStringExt;\n\n    let value = OsString::from_wide(\u0026[1, 2, 3]);\n    let tokens = [\n        Token::Enum { name: \"OsString\" },\n        Token::Str(\"Windows\"),\n        Token::Seq { len: Some(2) },\n        Token::U16(1),\n        Token::U16(2),\n        Token::U16(3),\n        Token::SeqEnd,\n    ];\n\n    assert_de_tokens(\u0026value, \u0026tokens);\n    assert_de_tokens_ignore(\u0026tokens);\n}\n\n#[test]\nfn test_cstr() {\n    assert_de_tokens::\u003cBox\u003cCStr\u003e\u003e(\n        \u0026CString::new(\"abc\").unwrap().into_boxed_c_str(),\n        \u0026[Token::Bytes(b\"abc\")],\n    );\n}\n\n#[test]\nfn test_cstr_internal_null() {\n    assert_de_tokens_error::\u003cBox\u003cCStr\u003e\u003e(\n        \u0026[Token::Bytes(b\"a\\0c\")],\n        \"nul byte found in provided data at position: 1\",\n    );\n}\n\n#[test]\nfn test_cstr_internal_null_end() {\n    assert_de_tokens_error::\u003cBox\u003cCStr\u003e\u003e(\n        \u0026[Token::Bytes(b\"ac\\0\")],\n        \"nul byte found in provided data at position: 2\",\n    );\n}\n\n#[cfg(feature = \"unstable\")]\n#[test]\nfn test_never_type() {\n    assert_de_tokens_error::\u003c!\u003e(\u0026[], \"cannot deserialize `!`\");\n\n    assert_de_tokens_error::\u003cResult\u003cu8, !\u003e\u003e(\n        \u0026[Token::NewtypeVariant {\n            name: \"Result\",\n            variant: \"Err\",\n        }],\n        \"cannot deserialize `!`\",\n    );\n}\n\n#[test]\nfn test_atomics() {\n    fn test\u003cL, A, T\u003e(load: L, val: T, token: Token)\n    where\n        L: Fn(\u0026A, Ordering) -\u003e T,\n        A: DeserializeOwned,\n        T: PartialEq + Debug,\n    {\n        let tokens = \u0026[token];\n        let mut de = serde_test::Deserializer::new(tokens);\n        match A::deserialize(\u0026mut de) {\n            Ok(v) =\u003e {\n                let loaded = load(\u0026v, Ordering::SeqCst);\n                assert_eq!(val, loaded);\n            }\n            Err(e) =\u003e panic!(\"tokens failed to deserialize: {}\", e),\n        };\n        if de.remaining() \u003e 0 {\n            panic!(\"{} remaining tokens\", de.remaining());\n        }\n    }\n\n    test(AtomicBool::load, true, Token::Bool(true));\n    test(AtomicI8::load, -127, Token::I8(-127i8));\n    test(AtomicI16::load, -510, Token::I16(-510i16));\n    test(AtomicI32::load, -131072, Token::I32(-131072i32));\n    test(AtomicIsize::load, -131072isize, Token::I32(-131072));\n    test(AtomicU8::load, 127, Token::U8(127u8));\n    test(AtomicU16::load, 510u16, Token::U16(510u16));\n    test(AtomicU32::load, 131072u32, Token::U32(131072u32));\n    test(AtomicUsize::load, 131072usize, Token::U32(131072));\n\n    #[cfg(target_arch = \"x86_64\")]\n    {\n        test(AtomicI64::load, -8589934592, Token::I64(-8589934592));\n        test(AtomicU64::load, 8589934592u64, Token::U64(8589934592));\n    }\n}\n\ndeclare_error_tests! {\n    test_unknown_field\u003cStructDenyUnknown\u003e {\n        \u0026[\n            Token::Struct { name: \"StructDenyUnknown\", len: 1 },\n                Token::Str(\"a\"),\n                Token::I32(0),\n\n                Token::Str(\"d\"),\n        ],\n        \"unknown field `d`, expected `a`\",\n    }\n    test_skipped_field_is_unknown\u003cStructDenyUnknown\u003e {\n        \u0026[\n            Token::Struct { name: \"StructDenyUnknown\", len: 1 },\n                Token::Str(\"b\"),\n        ],\n        \"unknown field `b`, expected `a`\",\n    }\n    test_skip_all_deny_unknown\u003cStructSkipAllDenyUnknown\u003e {\n        \u0026[\n            Token::Struct { name: \"StructSkipAllDenyUnknown\", len: 0 },\n                Token::Str(\"a\"),\n        ],\n        \"unknown field `a`, there are no fields\",\n    }\n    test_unknown_variant\u003cEnum\u003e {\n        \u0026[\n            Token::UnitVariant { name: \"Enum\", variant: \"Foo\" },\n        ],\n        \"unknown variant `Foo`, expected one of `Unit`, `Simple`, `Seq`, `Map`\",\n    }\n    test_enum_skipped_variant\u003cEnum\u003e {\n        \u0026[\n            Token::UnitVariant { name: \"Enum\", variant: \"Skipped\" },\n        ],\n        \"unknown variant `Skipped`, expected one of `Unit`, `Simple`, `Seq`, `Map`\",\n    }\n    test_enum_skip_all\u003cEnumSkipAll\u003e {\n        \u0026[\n            Token::UnitVariant { name: \"EnumSkipAll\", variant: \"Skipped\" },\n        ],\n        \"unknown variant `Skipped`, there are no variants\",\n    }\n    test_duplicate_field_struct\u003cStruct\u003e {\n        \u0026[\n            Token::Map { len: Some(3) },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"a\"),\n        ],\n        \"duplicate field `a`\",\n    }\n    test_duplicate_field_enum\u003cEnum\u003e {\n        \u0026[\n            Token::StructVariant { name: \"Enum\", variant: \"Map\", len: 3 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"a\"),\n        ],\n        \"duplicate field `a`\",\n    }\n    test_enum_out_of_range\u003cEnum\u003e {\n        \u0026[\n            Token::Enum { name: \"Enum\" },\n            Token::U32(4),\n            Token::Unit,\n        ],\n        \"invalid value: integer `4`, expected variant index 0 \u003c= i \u003c 4\",\n    }\n    test_short_tuple\u003c(u8, u8, u8)\u003e {\n        \u0026[\n            Token::Tuple { len: 1 },\n            Token::U8(1),\n            Token::TupleEnd,\n        ],\n        \"invalid length 1, expected a tuple of size 3\",\n    }\n    test_short_array\u003c[u8; 3]\u003e {\n        \u0026[\n            Token::Seq { len: Some(1) },\n            Token::U8(1),\n            Token::SeqEnd,\n        ],\n        \"invalid length 1, expected an array of length 3\",\n    }\n    test_cstring_internal_null\u003cCString\u003e {\n        \u0026[\n            Token::Bytes(b\"a\\0c\"),\n        ],\n        \"nul byte found in provided data at position: 1\",\n    }\n    test_cstring_internal_null_end\u003cCString\u003e {\n        \u0026[\n            Token::Bytes(b\"ac\\0\"),\n        ],\n        \"nul byte found in provided data at position: 2\",\n    }\n    test_unit_from_empty_seq\u003c()\u003e {\n        \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected unit\",\n    }\n    test_unit_from_empty_seq_without_len\u003c()\u003e {\n        \u0026[\n            Token::Seq { len: None },\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected unit\",\n    }\n    test_unit_from_tuple_struct\u003c()\u003e {\n        \u0026[\n            Token::TupleStruct { name: \"Anything\", len: 0 },\n            Token::TupleStructEnd,\n        ],\n        \"invalid type: sequence, expected unit\",\n    }\n    test_string_from_unit\u003cString\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a string\",\n    }\n    test_btreeset_from_unit\u003cBTreeSet\u003cisize\u003e\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_btreeset_from_unit_struct\u003cBTreeSet\u003cisize\u003e\u003e {\n        \u0026[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_hashset_from_unit\u003cHashSet\u003cisize\u003e\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_hashset_from_unit_struct\u003cHashSet\u003cisize\u003e\u003e {\n        \u0026[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_vec_from_unit\u003cVec\u003cisize\u003e\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_vec_from_unit_struct\u003cVec\u003cisize\u003e\u003e {\n        \u0026[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a sequence\",\n    }\n    test_zero_array_from_unit\u003c[isize; 0]\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected an empty array\",\n    }\n    test_zero_array_from_unit_struct\u003c[isize; 0]\u003e {\n        \u0026[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected an empty array\",\n    }\n    test_btreemap_from_unit\u003cBTreeMap\u003cisize, isize\u003e\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a map\",\n    }\n    test_btreemap_from_unit_struct\u003cBTreeMap\u003cisize, isize\u003e\u003e {\n        \u0026[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a map\",\n    }\n    test_hashmap_from_unit\u003cHashMap\u003cisize, isize\u003e\u003e {\n        \u0026[\n            Token::Unit,\n        ],\n        \"invalid type: unit value, expected a map\",\n    }\n    test_hashmap_from_unit_struct\u003cHashMap\u003cisize, isize\u003e\u003e {\n        \u0026[\n            Token::UnitStruct { name: \"Anything\" },\n        ],\n        \"invalid type: unit value, expected a map\",\n    }\n    test_bool_from_string\u003cbool\u003e {\n        \u0026[\n            Token::Str(\"false\"),\n        ],\n        \"invalid type: string \\\"false\\\", expected a boolean\",\n    }\n    test_number_from_string\u003cisize\u003e {\n        \u0026[\n            Token::Str(\"1\"),\n        ],\n        \"invalid type: string \\\"1\\\", expected isize\",\n    }\n    test_integer_from_float\u003cisize\u003e {\n        \u0026[\n            Token::F32(0.0),\n        ],\n        \"invalid type: floating point `0`, expected isize\",\n    }\n    test_unit_struct_from_seq\u003cUnitStruct\u003e {\n        \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected unit struct UnitStruct\",\n    }\n    test_wrapping_overflow\u003cWrapping\u003cu16\u003e\u003e {\n        \u0026[\n            Token::U32(65_536),\n        ],\n        \"invalid value: integer `65536`, expected u16\",\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_gen.rs"],"content":"// These just test that serde_derive is able to produce code that compiles\n// successfully when there are a variety of generics and non-(de)serializable\n// types involved.\n\n#![deny(warnings)]\n#![cfg_attr(feature = \"unstable\", feature(non_ascii_idents))]\n#![allow(clippy::trivially_copy_pass_by_ref)]\n\nuse serde::de::DeserializeOwned;\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\n\nuse std::borrow::Cow;\nuse std::marker::PhantomData;\nuse std::option::Option as StdOption;\nuse std::result::Result as StdResult;\n\n// Try to trip up the generated code if it fails to use fully qualified paths.\n#[allow(dead_code)]\nstruct Result;\n#[allow(dead_code)]\nstruct Ok;\n#[allow(dead_code)]\nstruct Err;\n#[allow(dead_code)]\nstruct Option;\n#[allow(dead_code)]\nstruct Some;\n#[allow(dead_code)]\nstruct None;\n\n//////////////////////////////////////////////////////////////////////////\n\n#[test]\nfn test_gen() {\n    #[derive(Serialize, Deserialize)]\n    struct With\u003cT\u003e {\n        t: T,\n        #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n        x: X,\n    }\n    assert::\u003cWith\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct WithTogether\u003cT\u003e {\n        t: T,\n        #[serde(with = \"both_x\")]\n        x: X,\n    }\n    assert::\u003cWithTogether\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct WithRef\u003c'a, T: 'a\u003e {\n        #[serde(skip_deserializing)]\n        t: StdOption\u003c\u0026'a T\u003e,\n        #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n        x: X,\n    }\n    assert::\u003cWithRef\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct PhantomX {\n        x: PhantomData\u003cX\u003e,\n    }\n    assert::\u003cPhantomX\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct PhantomT\u003cT\u003e {\n        t: PhantomData\u003cT\u003e,\n    }\n    assert::\u003cPhantomT\u003cX\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct NoBounds\u003cT\u003e {\n        t: T,\n        option: StdOption\u003cT\u003e,\n        boxed: Box\u003cT\u003e,\n        option_boxed: StdOption\u003cBox\u003cT\u003e\u003e,\n    }\n    assert::\u003cNoBounds\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    enum EnumWith\u003cT\u003e {\n        Unit,\n        Newtype(#[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")] X),\n        Tuple(\n            T,\n            #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")] X,\n        ),\n        Struct {\n            t: T,\n            #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n            x: X,\n        },\n    }\n    assert::\u003cEnumWith\u003ci32\u003e\u003e();\n\n    #[derive(Serialize)]\n    struct MultipleRef\u003c'a, 'b, 'c, T\u003e\n    where\n        T: 'c,\n        'c: 'b,\n        'b: 'a,\n    {\n        t: T,\n        rrrt: \u0026'a \u0026'b \u0026'c T,\n    }\n    assert_ser::\u003cMultipleRef\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct Newtype(#[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")] X);\n    assert::\u003cNewtype\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct Tuple\u003cT\u003e(\n        T,\n        #[serde(serialize_with = \"ser_x\", deserialize_with = \"de_x\")] X,\n    );\n    assert::\u003cTuple\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    enum TreeNode\u003cD\u003e {\n        Split {\n            left: Box\u003cTreeNode\u003cD\u003e\u003e,\n            right: Box\u003cTreeNode\u003cD\u003e\u003e,\n        },\n        Leaf {\n            data: D,\n        },\n    }\n    assert::\u003cTreeNode\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct ListNode\u003cD\u003e {\n        data: D,\n        next: Box\u003cListNode\u003cD\u003e\u003e,\n    }\n    assert::\u003cListNode\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct RecursiveA {\n        b: Box\u003cRecursiveB\u003e,\n    }\n    assert::\u003cRecursiveA\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    enum RecursiveB {\n        A(RecursiveA),\n    }\n    assert::\u003cRecursiveB\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct RecursiveGenericA\u003cT\u003e {\n        t: T,\n        b: Box\u003cRecursiveGenericB\u003cT\u003e\u003e,\n    }\n    assert::\u003cRecursiveGenericA\u003ci32\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    enum RecursiveGenericB\u003cT\u003e {\n        T(T),\n        A(RecursiveGenericA\u003cT\u003e),\n    }\n    assert::\u003cRecursiveGenericB\u003ci32\u003e\u003e();\n\n    #[derive(Serialize)]\n    struct OptionStatic\u003c'a\u003e {\n        a: StdOption\u003c\u0026'a str\u003e,\n        b: StdOption\u003c\u0026'static str\u003e,\n    }\n    assert_ser::\u003cOptionStatic\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound = \"D: SerializeWith + DeserializeWith\")]\n    struct WithTraits1\u003cD, E\u003e {\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\"\n        )]\n        d: D,\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\",\n            bound = \"E: SerializeWith + DeserializeWith\"\n        )]\n        e: E,\n    }\n    assert::\u003cWithTraits1\u003cX, X\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound(serialize = \"D: SerializeWith\", deserialize = \"D: DeserializeWith\"))]\n    struct WithTraits2\u003cD, E\u003e {\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\"\n        )]\n        d: D,\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            bound(serialize = \"E: SerializeWith\")\n        )]\n        #[serde(\n            deserialize_with = \"DeserializeWith::deserialize_with\",\n            bound(deserialize = \"E: DeserializeWith\")\n        )]\n        e: E,\n    }\n    assert::\u003cWithTraits2\u003cX, X\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound = \"D: SerializeWith + DeserializeWith\")]\n    enum VariantWithTraits1\u003cD, E\u003e {\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\"\n        )]\n        D(D),\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\",\n            bound = \"E: SerializeWith + DeserializeWith\"\n        )]\n        E(E),\n    }\n    assert::\u003cVariantWithTraits1\u003cX, X\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound(serialize = \"D: SerializeWith\", deserialize = \"D: DeserializeWith\"))]\n    enum VariantWithTraits2\u003cD, E\u003e {\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            deserialize_with = \"DeserializeWith::deserialize_with\"\n        )]\n        D(D),\n        #[serde(\n            serialize_with = \"SerializeWith::serialize_with\",\n            bound(serialize = \"E: SerializeWith\")\n        )]\n        #[serde(\n            deserialize_with = \"DeserializeWith::deserialize_with\",\n            bound(deserialize = \"E: DeserializeWith\")\n        )]\n        E(E),\n    }\n    assert::\u003cVariantWithTraits2\u003cX, X\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct CowStr\u003c'a\u003e(Cow\u003c'a, str\u003e);\n    assert::\u003cCowStr\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(bound(deserialize = \"T::Owned: DeserializeOwned\"))]\n    struct CowT\u003c'a, T: ?Sized + 'a + ToOwned\u003e(Cow\u003c'a, T\u003e);\n    assert::\u003cCowT\u003cstr\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct EmptyStruct {}\n    assert::\u003cEmptyStruct\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    enum EmptyEnumVariant {\n        EmptyStruct {},\n    }\n    assert::\u003cEmptyEnumVariant\u003e();\n\n    #[cfg(feature = \"unstable\")]\n    #[derive(Serialize, Deserialize)]\n    struct NonAsciiIdents {\n        :  f64,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct EmptyBraced {}\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct EmptyBracedDenyUnknown {}\n\n    #[derive(Serialize, Deserialize)]\n    struct BracedSkipAll {\n        #[serde(skip_deserializing)]\n        f: u8,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct BracedSkipAllDenyUnknown {\n        #[serde(skip_deserializing)]\n        f: u8,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct EmptyTuple();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct EmptyTupleDenyUnknown();\n\n    #[derive(Serialize, Deserialize)]\n    struct TupleSkipAll(#[serde(skip_deserializing)] u8);\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct TupleSkipAllDenyUnknown(#[serde(skip_deserializing)] u8);\n\n    #[derive(Serialize, Deserialize)]\n    enum EmptyEnum {}\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    enum EmptyEnumDenyUnknown {}\n\n    #[derive(Serialize, Deserialize)]\n    enum EnumSkipAll {\n        #[serde(skip_deserializing)]\n        #[allow(dead_code)]\n        Variant,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    enum EmptyVariants {\n        Braced {},\n        Tuple(),\n        BracedSkip {\n            #[serde(skip_deserializing)]\n            f: u8,\n        },\n        TupleSkip(#[serde(skip_deserializing)] u8),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    enum EmptyVariantsDenyUnknown {\n        Braced {},\n        Tuple(),\n        BracedSkip {\n            #[serde(skip_deserializing)]\n            f: u8,\n        },\n        TupleSkip(#[serde(skip_deserializing)] u8),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct UnitDenyUnknown;\n\n    #[derive(Serialize, Deserialize)]\n    struct EmptyArray {\n        empty: [X; 0],\n    }\n\n    enum Or\u003cA, B\u003e {\n        A(A),\n        B(B),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(untagged, remote = \"Or\")]\n    enum OrDef\u003cA, B\u003e {\n        A(A),\n        B(B),\n    }\n\n    struct Str\u003c'a\u003e(\u0026'a str);\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(remote = \"Str\")]\n    struct StrDef\u003c'a\u003e(\u0026'a str);\n\n    #[derive(Serialize, Deserialize)]\n    struct Remote\u003c'a\u003e {\n        #[serde(with = \"OrDef\")]\n        or: Or\u003cu8, bool\u003e,\n        #[serde(borrow, with = \"StrDef\")]\n        s: Str\u003c'a\u003e,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    enum BorrowVariant\u003c'a\u003e {\n        #[serde(borrow, with = \"StrDef\")]\n        S(Str\u003c'a\u003e),\n    }\n\n    mod vis {\n        use serde::{Deserialize, Serialize};\n\n        pub struct S;\n\n        #[derive(Serialize, Deserialize)]\n        #[serde(remote = \"S\")]\n        pub struct SDef;\n    }\n\n    // This would not work if SDef::serialize / deserialize are private.\n    #[derive(Serialize, Deserialize)]\n    struct RemoteVisibility {\n        #[serde(with = \"vis::SDef\")]\n        s: vis::S,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(remote = \"Self\")]\n    struct RemoteSelf;\n\n    #[derive(Serialize, Deserialize)]\n    enum ExternallyTaggedVariantWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Newtype(X),\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Tuple(String, u8),\n\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Struct1 { x: X },\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Struct { f1: String, f2: u8 },\n\n        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n        #[allow(dead_code)]\n        Unit,\n    }\n    assert_ser::\u003cExternallyTaggedVariantWith\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(tag = \"t\")]\n    enum InternallyTaggedVariantWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Newtype(X),\n\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Struct1 { x: X },\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Struct { f1: String, f2: u8 },\n\n        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n        #[allow(dead_code)]\n        Unit,\n    }\n    assert_ser::\u003cInternallyTaggedVariantWith\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum AdjacentlyTaggedVariantWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Newtype(X),\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Tuple(String, u8),\n\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Struct1 { x: X },\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Struct { f1: String, f2: u8 },\n\n        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n        #[allow(dead_code)]\n        Unit,\n    }\n    assert_ser::\u003cAdjacentlyTaggedVariantWith\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum UntaggedVariantWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Newtype(X),\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Tuple(String, u8),\n\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        #[allow(dead_code)]\n        Struct1 { x: X },\n\n        #[serde(serialize_with = \"serialize_some_other_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n        #[allow(dead_code)]\n        Struct { f1: String, f2: u8 },\n\n        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n        #[allow(dead_code)]\n        Unit,\n    }\n    assert_ser::\u003cUntaggedVariantWith\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct FlattenWith {\n        #[serde(flatten, serialize_with = \"ser_x\", deserialize_with = \"de_x\")]\n        x: X,\n    }\n    assert::\u003cFlattenWith\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(deny_unknown_fields)]\n    struct FlattenDenyUnknown\u003cT\u003e {\n        #[serde(flatten)]\n        t: T,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct StaticStrStruct\u003c'a\u003e {\n        a: \u0026'a str,\n        b: \u0026'static str,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct StaticStrTupleStruct\u003c'a\u003e(\u0026'a str, \u0026'static str);\n\n    #[derive(Serialize, Deserialize)]\n    struct StaticStrNewtypeStruct(\u0026'static str);\n\n    #[derive(Serialize, Deserialize)]\n    enum StaticStrEnum\u003c'a\u003e {\n        Struct { a: \u0026'a str, b: \u0026'static str },\n        Tuple(\u0026'a str, \u0026'static str),\n        Newtype(\u0026'static str),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct SkippedStaticStr {\n        #[serde(skip_deserializing)]\n        skipped: \u0026'static str,\n        other: isize,\n    }\n    assert::\u003cSkippedStaticStr\u003e();\n\n    macro_rules! T {\n        () =\u003e {\n            ()\n        };\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct TypeMacro\u003cT\u003e {\n        mac: T!(),\n        marker: PhantomData\u003cT\u003e,\n    }\n    assert::\u003cTypeMacro\u003cX\u003e\u003e();\n\n    #[derive(Serialize)]\n    struct BigArray {\n        #[serde(serialize_with = \"\u003c[_]\u003e::serialize\")]\n        array: [u8; 256],\n    }\n    assert_ser::\u003cBigArray\u003e();\n\n    trait AssocSerde {\n        type Assoc;\n    }\n\n    struct NoSerdeImpl;\n    impl AssocSerde for NoSerdeImpl {\n        type Assoc = u32;\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct AssocDerive\u003cT: AssocSerde\u003e {\n        assoc: T::Assoc,\n    }\n\n    assert::\u003cAssocDerive\u003cNoSerdeImpl\u003e\u003e();\n\n    #[derive(Serialize, Deserialize)]\n    struct AssocDeriveMulti\u003cS, T: AssocSerde\u003e {\n        s: S,\n        assoc: T::Assoc,\n    }\n\n    assert::\u003cAssocDeriveMulti\u003ci32, NoSerdeImpl\u003e\u003e();\n\n    #[derive(Serialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum EmptyAdjacentlyTagged {\n        #[allow(dead_code)]\n        Struct {},\n        #[allow(dead_code)]\n        Tuple(),\n    }\n\n    assert_ser::\u003cEmptyAdjacentlyTagged\u003e();\n\n    mod restricted {\n        mod inner {\n            use serde::{Deserialize, Serialize};\n\n            #[derive(Serialize, Deserialize)]\n            struct Restricted {\n                pub(super) a: usize,\n                pub(in super::inner) b: usize,\n            }\n        }\n    }\n\n    #[derive(Deserialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum AdjacentlyTaggedVoid {}\n\n    #[derive(Serialize, Deserialize)]\n    enum SkippedVariant\u003cT\u003e {\n        #[serde(skip)]\n        #[allow(dead_code)]\n        T(T),\n        Unit,\n    }\n\n    assert::\u003cSkippedVariant\u003cX\u003e\u003e();\n\n    #[derive(Deserialize)]\n    struct ImpliciltyBorrowedOption\u003c'a\u003e {\n        option: std::option::Option\u003c\u0026'a str\u003e,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum UntaggedNewtypeVariantWith {\n        Newtype(\n            #[serde(serialize_with = \"ser_x\")]\n            #[serde(deserialize_with = \"de_x\")]\n            X,\n        ),\n    }\n\n    #[derive(Serialize, Deserialize)]\n    #[serde(transparent)]\n    struct TransparentWith {\n        #[serde(serialize_with = \"ser_x\")]\n        #[serde(deserialize_with = \"de_x\")]\n        x: X,\n    }\n\n    #[derive(Deserialize)]\n    #[serde(untagged)]\n    enum UntaggedWithBorrow\u003c'a\u003e {\n        Single(#[serde(borrow)] RelObject\u003c'a\u003e),\n        Many(#[serde(borrow)] Vec\u003cRelObject\u003c'a\u003e\u003e),\n    }\n\n    #[derive(Deserialize)]\n    struct RelObject\u003c'a\u003e {\n        ty: \u0026'a str,\n        id: String,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct FlattenSkipSerializing\u003cT\u003e {\n        #[serde(flatten, skip_serializing)]\n        #[allow(dead_code)]\n        flat: T,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct FlattenSkipSerializingIf\u003cT\u003e {\n        #[serde(flatten, skip_serializing_if = \"StdOption::is_none\")]\n        flat: StdOption\u003cT\u003e,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct FlattenSkipDeserializing\u003cT\u003e {\n        #[serde(flatten, skip_deserializing)]\n        flat: T,\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nfn assert\u003cT: Serialize + DeserializeOwned\u003e() {}\nfn assert_ser\u003cT: Serialize\u003e() {}\n\ntrait SerializeWith {\n    fn serialize_with\u003cS: Serializer\u003e(_: \u0026Self, _: S) -\u003e StdResult\u003cS::Ok, S::Error\u003e;\n}\n\ntrait DeserializeWith: Sized {\n    fn deserialize_with\u003c'de, D: Deserializer\u003c'de\u003e\u003e(_: D) -\u003e StdResult\u003cSelf, D::Error\u003e;\n}\n\n// Implements neither Serialize nor Deserialize\npub struct X;\n\npub fn ser_x\u003cS: Serializer\u003e(_: \u0026X, _: S) -\u003e StdResult\u003cS::Ok, S::Error\u003e {\n    unimplemented!()\n}\n\npub fn de_x\u003c'de, D: Deserializer\u003c'de\u003e\u003e(_: D) -\u003e StdResult\u003cX, D::Error\u003e {\n    unimplemented!()\n}\n\nmod both_x {\n    pub use super::{de_x as deserialize, ser_x as serialize};\n}\n\nimpl SerializeWith for X {\n    fn serialize_with\u003cS: Serializer\u003e(_: \u0026Self, _: S) -\u003e StdResult\u003cS::Ok, S::Error\u003e {\n        unimplemented!()\n    }\n}\n\nimpl DeserializeWith for X {\n    fn deserialize_with\u003c'de, D: Deserializer\u003c'de\u003e\u003e(_: D) -\u003e StdResult\u003cSelf, D::Error\u003e {\n        unimplemented!()\n    }\n}\n\npub fn serialize_some_unit_variant\u003cS\u003e(_: S) -\u003e StdResult\u003cS::Ok, S::Error\u003e\nwhere\n    S: Serializer,\n{\n    unimplemented!()\n}\n\npub fn deserialize_some_unit_variant\u003c'de, D\u003e(_: D) -\u003e StdResult\u003c(), D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    unimplemented!()\n}\n\npub fn serialize_some_other_variant\u003cS\u003e(_: \u0026str, _: \u0026u8, _: S) -\u003e StdResult\u003cS::Ok, S::Error\u003e\nwhere\n    S: Serializer,\n{\n    unimplemented!()\n}\n\npub fn deserialize_some_other_variant\u003c'de, D\u003e(_: D) -\u003e StdResult\u003c(String, u8), D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    unimplemented!()\n}\n\npub fn is_zero(n: \u0026u8) -\u003e bool {\n    *n == 0\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_identifier.rs"],"content":"use serde::Deserialize;\nuse serde_test::{assert_de_tokens, Token};\n\n#[test]\nfn test_variant_identifier() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(variant_identifier)]\n    enum V {\n        Aaa,\n        Bbb,\n    }\n\n    assert_de_tokens(\u0026V::Aaa, \u0026[Token::U8(0)]);\n    assert_de_tokens(\u0026V::Aaa, \u0026[Token::U16(0)]);\n    assert_de_tokens(\u0026V::Aaa, \u0026[Token::U32(0)]);\n    assert_de_tokens(\u0026V::Aaa, \u0026[Token::U64(0)]);\n    assert_de_tokens(\u0026V::Aaa, \u0026[Token::Str(\"Aaa\")]);\n    assert_de_tokens(\u0026V::Aaa, \u0026[Token::Bytes(b\"Aaa\")]);\n}\n\n#[test]\nfn test_field_identifier() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(field_identifier, rename_all = \"snake_case\")]\n    enum F {\n        Aaa,\n        Bbb,\n    }\n\n    assert_de_tokens(\u0026F::Aaa, \u0026[Token::Str(\"aaa\")]);\n    assert_de_tokens(\u0026F::Aaa, \u0026[Token::Bytes(b\"aaa\")]);\n}\n\n#[test]\nfn test_unit_fallthrough() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(field_identifier, rename_all = \"snake_case\")]\n    enum F {\n        Aaa,\n        Bbb,\n        #[serde(other)]\n        Other,\n    }\n\n    assert_de_tokens(\u0026F::Other, \u0026[Token::Str(\"x\")]);\n}\n\n#[test]\nfn test_newtype_fallthrough() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(field_identifier, rename_all = \"snake_case\")]\n    enum F {\n        Aaa,\n        Bbb,\n        Other(String),\n    }\n\n    assert_de_tokens(\u0026F::Other(\"x\".to_owned()), \u0026[Token::Str(\"x\")]);\n}\n\n#[test]\nfn test_newtype_fallthrough_generic() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    #[serde(field_identifier, rename_all = \"snake_case\")]\n    enum F\u003cT\u003e {\n        Aaa,\n        Bbb,\n        Other(T),\n    }\n\n    assert_de_tokens(\u0026F::Other(\"x\".to_owned()), \u0026[Token::Str(\"x\")]);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_ignored_any.rs"],"content":"use serde::de::value::{Error, MapDeserializer, SeqDeserializer};\nuse serde::de::{\n    DeserializeSeed, EnumAccess, IgnoredAny, IntoDeserializer, VariantAccess, Visitor,\n};\nuse serde::{forward_to_deserialize_any, Deserialize, Deserializer};\n\n#[derive(PartialEq, Debug, Deserialize)]\nenum Target {\n    Unit,\n    Newtype(i32),\n    Tuple(i32, i32),\n    Struct { a: i32 },\n}\n\nstruct Enum(\u0026'static str);\n\nimpl\u003c'de\u003e Deserializer\u003c'de\u003e for Enum {\n    type Error = Error;\n\n    fn deserialize_any\u003cV\u003e(self, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        visitor.visit_enum(self)\n    }\n\n    forward_to_deserialize_any! {\n        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n        tuple_struct map struct enum identifier ignored_any\n    }\n}\n\nimpl\u003c'de\u003e EnumAccess\u003c'de\u003e for Enum {\n    type Error = Error;\n    type Variant = Self;\n\n    fn variant_seed\u003cV\u003e(self, seed: V) -\u003e Result\u003c(V::Value, Self::Variant), Self::Error\u003e\n    where\n        V: DeserializeSeed\u003c'de\u003e,\n    {\n        let v = seed.deserialize(self.0.into_deserializer())?;\n        Ok((v, self))\n    }\n}\n\nimpl\u003c'de\u003e VariantAccess\u003c'de\u003e for Enum {\n    type Error = Error;\n\n    fn unit_variant(self) -\u003e Result\u003c(), Self::Error\u003e {\n        Ok(())\n    }\n\n    fn newtype_variant_seed\u003cT\u003e(self, seed: T) -\u003e Result\u003cT::Value, Self::Error\u003e\n    where\n        T: DeserializeSeed\u003c'de\u003e,\n    {\n        seed.deserialize(10i32.into_deserializer())\n    }\n\n    fn tuple_variant\u003cV\u003e(self, _len: usize, visitor: V) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        let seq = SeqDeserializer::new(vec![1i32, 2].into_iter());\n        visitor.visit_seq(seq)\n    }\n\n    fn struct_variant\u003cV\u003e(\n        self,\n        _fields: \u0026'static [\u0026'static str],\n        visitor: V,\n    ) -\u003e Result\u003cV::Value, Self::Error\u003e\n    where\n        V: Visitor\u003c'de\u003e,\n    {\n        let map = MapDeserializer::new(vec![(\"a\", 10i32)].into_iter());\n        visitor.visit_map(map)\n    }\n}\n\n#[test]\nfn test_deserialize_enum() {\n    // First just make sure the Deserializer impl works\n    assert_eq!(Target::Unit, Target::deserialize(Enum(\"Unit\")).unwrap());\n    assert_eq!(\n        Target::Newtype(10),\n        Target::deserialize(Enum(\"Newtype\")).unwrap()\n    );\n    assert_eq!(\n        Target::Tuple(1, 2),\n        Target::deserialize(Enum(\"Tuple\")).unwrap()\n    );\n    assert_eq!(\n        Target::Struct { a: 10 },\n        Target::deserialize(Enum(\"Struct\")).unwrap()\n    );\n\n    // Now try IgnoredAny\n    IgnoredAny::deserialize(Enum(\"Unit\")).unwrap();\n    IgnoredAny::deserialize(Enum(\"Newtype\")).unwrap();\n    IgnoredAny::deserialize(Enum(\"Tuple\")).unwrap();\n    IgnoredAny::deserialize(Enum(\"Struct\")).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_macros.rs"],"content":"#![deny(trivial_numeric_casts)]\n#![allow(clippy::redundant_field_names)]\n\nmod bytes;\n\nuse serde::{Deserialize, Serialize};\nuse serde_test::{\n    assert_de_tokens, assert_de_tokens_error, assert_ser_tokens, assert_tokens, Token,\n};\n\nuse std::collections::BTreeMap;\nuse std::marker::PhantomData;\n\n// That tests that the derived Serialize implementation doesn't trigger\n// any warning about `serializer` not being used, in case of empty enums.\n#[derive(Serialize)]\n#[allow(dead_code)]\n#[deny(unused_variables)]\nenum Void {}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct NamedUnit;\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SerNamedTuple\u003c'a, 'b, A: 'a, B: 'b, C\u003e(\u0026'a A, \u0026'b mut B, C);\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct DeNamedTuple\u003cA, B, C\u003e(A, B, C);\n\n#[derive(Debug, PartialEq, Serialize)]\nstruct SerNamedMap\u003c'a, 'b, A: 'a, B: 'b, C\u003e {\n    a: \u0026'a A,\n    b: \u0026'b mut B,\n    c: C,\n}\n\n#[derive(Debug, PartialEq, Deserialize)]\nstruct DeNamedMap\u003cA, B, C\u003e {\n    a: A,\n    b: B,\n    c: C,\n}\n\n#[derive(Debug, PartialEq, Serialize)]\nenum SerEnum\u003c'a, B: 'a, C: 'a, D\u003e\nwhere\n    D: 'a,\n{\n    Unit,\n    Seq(i8, B, \u0026'a C, \u0026'a mut D),\n    Map { a: i8, b: B, c: \u0026'a C, d: \u0026'a mut D },\n\n    // Make sure we can support more than one variant.\n    _Unit2,\n    _Seq2(i8, B, \u0026'a C, \u0026'a mut D),\n    _Map2 { a: i8, b: B, c: \u0026'a C, d: \u0026'a mut D },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum DeEnum\u003cB, C, D\u003e {\n    Unit,\n    Seq(i8, B, C, D),\n    Map { a: i8, b: B, c: C, d: D },\n\n    // Make sure we can support more than one variant.\n    _Unit2,\n    _Seq2(i8, B, C, D),\n    _Map2 { a: i8, b: B, c: C, d: D },\n}\n\n#[derive(Serialize)]\nenum Lifetimes\u003c'a\u003e {\n    LifetimeSeq(\u0026'a i32),\n    NoLifetimeSeq(i32),\n    LifetimeMap { a: \u0026'a i32 },\n    NoLifetimeMap { a: i32 },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub struct GenericStruct\u003cT\u003e {\n    x: T,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub struct GenericNewTypeStruct\u003cT\u003e(T);\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub struct GenericTupleStruct\u003cT, U\u003e(T, U);\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\npub enum GenericEnum\u003cT, U\u003e {\n    Unit,\n    NewType(T),\n    Seq(T, U),\n    Map { x: T, y: U },\n}\n\ntrait AssociatedType {\n    type X;\n}\n\nimpl AssociatedType for i32 {\n    type X = i32;\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct DefaultTyParam\u003cT: AssociatedType\u003cX = i32\u003e = i32\u003e {\n    phantom: PhantomData\u003cT\u003e,\n}\n\n#[test]\nfn test_named_unit() {\n    assert_tokens(\u0026NamedUnit, \u0026[Token::UnitStruct { name: \"NamedUnit\" }]);\n}\n\n#[test]\nfn test_ser_named_tuple() {\n    let a = 5;\n    let mut b = 6;\n    let c = 7;\n    assert_ser_tokens(\n        \u0026SerNamedTuple(\u0026a, \u0026mut b, c),\n        \u0026[\n            Token::TupleStruct {\n                name: \"SerNamedTuple\",\n                len: 3,\n            },\n            Token::I32(5),\n            Token::I32(6),\n            Token::I32(7),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_de_named_tuple() {\n    assert_de_tokens(\n        \u0026DeNamedTuple(5, 6, 7),\n        \u0026[\n            Token::Seq { len: Some(3) },\n            Token::I32(5),\n            Token::I32(6),\n            Token::I32(7),\n            Token::SeqEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026DeNamedTuple(5, 6, 7),\n        \u0026[\n            Token::TupleStruct {\n                name: \"DeNamedTuple\",\n                len: 3,\n            },\n            Token::I32(5),\n            Token::I32(6),\n            Token::I32(7),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_ser_named_map() {\n    let a = 5;\n    let mut b = 6;\n    let c = 7;\n\n    assert_ser_tokens(\n        \u0026SerNamedMap {\n            a: \u0026a,\n            b: \u0026mut b,\n            c: c,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"SerNamedMap\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I32(5),\n            Token::Str(\"b\"),\n            Token::I32(6),\n            Token::Str(\"c\"),\n            Token::I32(7),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_de_named_map() {\n    assert_de_tokens(\n        \u0026DeNamedMap { a: 5, b: 6, c: 7 },\n        \u0026[\n            Token::Struct {\n                name: \"DeNamedMap\",\n                len: 3,\n            },\n            Token::Str(\"a\"),\n            Token::I32(5),\n            Token::Str(\"b\"),\n            Token::I32(6),\n            Token::Str(\"c\"),\n            Token::I32(7),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_ser_enum_unit() {\n    assert_ser_tokens(\n        \u0026SerEnum::Unit::\u003cu32, u32, u32\u003e,\n        \u0026[Token::UnitVariant {\n            name: \"SerEnum\",\n            variant: \"Unit\",\n        }],\n    );\n}\n\n#[test]\nfn test_ser_enum_seq() {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let mut d = 4;\n\n    assert_ser_tokens(\n        \u0026SerEnum::Seq(a, b, \u0026c, \u0026mut d),\n        \u0026[\n            Token::TupleVariant {\n                name: \"SerEnum\",\n                variant: \"Seq\",\n                len: 4,\n            },\n            Token::I8(1),\n            Token::I32(2),\n            Token::I32(3),\n            Token::I32(4),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_ser_enum_map() {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let mut d = 4;\n\n    assert_ser_tokens(\n        \u0026SerEnum::Map {\n            a: a,\n            b: b,\n            c: \u0026c,\n            d: \u0026mut d,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"SerEnum\",\n                variant: \"Map\",\n                len: 4,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::I32(2),\n            Token::Str(\"c\"),\n            Token::I32(3),\n            Token::Str(\"d\"),\n            Token::I32(4),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_de_enum_unit() {\n    assert_tokens(\n        \u0026DeEnum::Unit::\u003cu32, u32, u32\u003e,\n        \u0026[Token::UnitVariant {\n            name: \"DeEnum\",\n            variant: \"Unit\",\n        }],\n    );\n}\n\n#[test]\nfn test_de_enum_seq() {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let d = 4;\n\n    assert_tokens(\n        \u0026DeEnum::Seq(a, b, c, d),\n        \u0026[\n            Token::TupleVariant {\n                name: \"DeEnum\",\n                variant: \"Seq\",\n                len: 4,\n            },\n            Token::I8(1),\n            Token::I32(2),\n            Token::I32(3),\n            Token::I32(4),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_de_enum_map() {\n    let a = 1;\n    let b = 2;\n    let c = 3;\n    let d = 4;\n\n    assert_tokens(\n        \u0026DeEnum::Map {\n            a: a,\n            b: b,\n            c: c,\n            d: d,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"DeEnum\",\n                variant: \"Map\",\n                len: 4,\n            },\n            Token::Str(\"a\"),\n            Token::I8(1),\n            Token::Str(\"b\"),\n            Token::I32(2),\n            Token::Str(\"c\"),\n            Token::I32(3),\n            Token::Str(\"d\"),\n            Token::I32(4),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_lifetimes() {\n    let value = 5;\n\n    assert_ser_tokens(\n        \u0026Lifetimes::LifetimeSeq(\u0026value),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"Lifetimes\",\n                variant: \"LifetimeSeq\",\n            },\n            Token::I32(5),\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026Lifetimes::NoLifetimeSeq(5),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"Lifetimes\",\n                variant: \"NoLifetimeSeq\",\n            },\n            Token::I32(5),\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026Lifetimes::LifetimeMap { a: \u0026value },\n        \u0026[\n            Token::StructVariant {\n                name: \"Lifetimes\",\n                variant: \"LifetimeMap\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I32(5),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_ser_tokens(\n        \u0026Lifetimes::NoLifetimeMap { a: 5 },\n        \u0026[\n            Token::StructVariant {\n                name: \"Lifetimes\",\n                variant: \"NoLifetimeMap\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::I32(5),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_struct() {\n    assert_tokens(\n        \u0026GenericStruct { x: 5u32 },\n        \u0026[\n            Token::Struct {\n                name: \"GenericStruct\",\n                len: 1,\n            },\n            Token::Str(\"x\"),\n            Token::U32(5),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_newtype_struct() {\n    assert_tokens(\n        \u0026GenericNewTypeStruct(5u32),\n        \u0026[\n            Token::NewtypeStruct {\n                name: \"GenericNewTypeStruct\",\n            },\n            Token::U32(5),\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_newtype_struct() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum E {\n        Newtype(GenericNewTypeStruct\u003cu32\u003e),\n        Null,\n    }\n\n    assert_tokens(\n        \u0026E::Newtype(GenericNewTypeStruct(5u32)),\n        \u0026[\n            Token::NewtypeStruct {\n                name: \"GenericNewTypeStruct\",\n            },\n            Token::U32(5),\n        ],\n    );\n}\n\n#[test]\nfn test_adjacently_tagged_newtype_struct() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum E {\n        Newtype(GenericNewTypeStruct\u003cu32\u003e),\n        Null,\n    }\n\n    assert_de_tokens(\n        \u0026E::Newtype(GenericNewTypeStruct(5u32)),\n        \u0026[\n            Token::Struct { name: \"E\", len: 2 },\n            Token::Str(\"c\"),\n            Token::NewtypeStruct {\n                name: \"GenericNewTypeStruct\",\n            },\n            Token::U32(5),\n            Token::Str(\"t\"),\n            Token::Str(\"Newtype\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_tuple_struct() {\n    assert_tokens(\n        \u0026GenericTupleStruct(5u32, 6u32),\n        \u0026[\n            Token::TupleStruct {\n                name: \"GenericTupleStruct\",\n                len: 2,\n            },\n            Token::U32(5),\n            Token::U32(6),\n            Token::TupleStructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_enum_unit() {\n    assert_tokens(\n        \u0026GenericEnum::Unit::\u003cu32, u32\u003e,\n        \u0026[Token::UnitVariant {\n            name: \"GenericEnum\",\n            variant: \"Unit\",\n        }],\n    );\n}\n\n#[test]\nfn test_generic_enum_newtype() {\n    assert_tokens(\n        \u0026GenericEnum::NewType::\u003cu32, u32\u003e(5),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"GenericEnum\",\n                variant: \"NewType\",\n            },\n            Token::U32(5),\n        ],\n    );\n}\n\n#[test]\nfn test_generic_enum_seq() {\n    assert_tokens(\n        \u0026GenericEnum::Seq::\u003cu32, u32\u003e(5, 6),\n        \u0026[\n            Token::TupleVariant {\n                name: \"GenericEnum\",\n                variant: \"Seq\",\n                len: 2,\n            },\n            Token::U32(5),\n            Token::U32(6),\n            Token::TupleVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_generic_enum_map() {\n    assert_tokens(\n        \u0026GenericEnum::Map::\u003cu32, u32\u003e { x: 5, y: 6 },\n        \u0026[\n            Token::StructVariant {\n                name: \"GenericEnum\",\n                variant: \"Map\",\n                len: 2,\n            },\n            Token::Str(\"x\"),\n            Token::U32(5),\n            Token::Str(\"y\"),\n            Token::U32(6),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_default_ty_param() {\n    assert_tokens(\n        \u0026DefaultTyParam::\u003ci32\u003e {\n            phantom: PhantomData,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"DefaultTyParam\",\n                len: 1,\n            },\n            Token::Str(\"phantom\"),\n            Token::UnitStruct {\n                name: \"PhantomData\",\n            },\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_enum_state_field() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    enum SomeEnum {\n        Key { key: char, state: bool },\n    }\n\n    assert_tokens(\n        \u0026SomeEnum::Key {\n            key: 'a',\n            state: true,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"SomeEnum\",\n                variant: \"Key\",\n                len: 2,\n            },\n            Token::Str(\"key\"),\n            Token::Char('a'),\n            Token::Str(\"state\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum Untagged {\n        A { a: u8 },\n        B { b: u8 },\n        C,\n        D(u8),\n        E(String),\n        F(u8, u8),\n    }\n\n    assert_tokens(\n        \u0026Untagged::A { a: 1 },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Untagged::B { b: 2 },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"b\"),\n            Token::U8(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_tokens(\u0026Untagged::C, \u0026[Token::Unit]);\n\n    assert_tokens(\u0026Untagged::D(4), \u0026[Token::U8(4)]);\n    assert_tokens(\u0026Untagged::E(\"e\".to_owned()), \u0026[Token::Str(\"e\")]);\n\n    assert_tokens(\n        \u0026Untagged::F(1, 2),\n        \u0026[\n            Token::Tuple { len: 2 },\n            Token::U8(1),\n            Token::U8(2),\n            Token::TupleEnd,\n        ],\n    );\n\n    assert_de_tokens_error::\u003cUntagged\u003e(\n        \u0026[Token::None],\n        \"data did not match any variant of untagged enum Untagged\",\n    );\n\n    assert_de_tokens_error::\u003cUntagged\u003e(\n        \u0026[Token::Tuple { len: 1 }, Token::U8(1), Token::TupleEnd],\n        \"data did not match any variant of untagged enum Untagged\",\n    );\n\n    assert_de_tokens_error::\u003cUntagged\u003e(\n        \u0026[\n            Token::Tuple { len: 3 },\n            Token::U8(1),\n            Token::U8(2),\n            Token::U8(3),\n            Token::TupleEnd,\n        ],\n        \"data did not match any variant of untagged enum Untagged\",\n    );\n}\n\n#[test]\nfn test_internally_tagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Newtype(BTreeMap\u003cString, String\u003e);\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Struct {\n        f: u8,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    enum InternallyTagged {\n        A { a: u8 },\n        B,\n        C(BTreeMap\u003cString, String\u003e),\n        D(Newtype),\n        E(Struct),\n    }\n\n    assert_tokens(\n        \u0026InternallyTagged::A { a: 1 },\n        \u0026[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"A\"),\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::A { a: 1 },\n        \u0026[\n            Token::Seq { len: Some(2) },\n            Token::Str(\"A\"),\n            Token::U8(1),\n            Token::SeqEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026InternallyTagged::B,\n        \u0026[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 1,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"B\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::B,\n        \u0026[Token::Seq { len: Some(1) }, Token::Str(\"B\"), Token::SeqEnd],\n    );\n\n    assert_tokens(\n        \u0026InternallyTagged::C(BTreeMap::new()),\n        \u0026[\n            Token::Map { len: Some(1) },\n            Token::Str(\"type\"),\n            Token::Str(\"C\"),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens_error::\u003cInternallyTagged\u003e(\n        \u0026[\n            Token::Seq { len: Some(2) },\n            Token::Str(\"C\"),\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected a map\",\n    );\n\n    assert_tokens(\n        \u0026InternallyTagged::D(Newtype(BTreeMap::new())),\n        \u0026[\n            Token::Map { len: Some(1) },\n            Token::Str(\"type\"),\n            Token::Str(\"D\"),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026InternallyTagged::E(Struct { f: 6 }),\n        \u0026[\n            Token::Struct {\n                name: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"E\"),\n            Token::Str(\"f\"),\n            Token::U8(6),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::E(Struct { f: 6 }),\n        \u0026[\n            Token::Seq { len: Some(2) },\n            Token::Str(\"E\"),\n            Token::U8(6),\n            Token::SeqEnd,\n        ],\n    );\n\n    assert_de_tokens_error::\u003cInternallyTagged\u003e(\n        \u0026[Token::Map { len: Some(0) }, Token::MapEnd],\n        \"missing field `type`\",\n    );\n\n    assert_de_tokens_error::\u003cInternallyTagged\u003e(\n        \u0026[\n            Token::Map { len: Some(1) },\n            Token::Str(\"type\"),\n            Token::Str(\"Z\"),\n            Token::MapEnd,\n        ],\n        \"unknown variant `Z`, expected one of `A`, `B`, `C`, `D`, `E`\",\n    );\n}\n\n#[test]\nfn test_internally_tagged_bytes() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    #[serde(tag = \"type\")]\n    enum InternallyTagged {\n        String {\n            string: String,\n        },\n        Bytes {\n            #[serde(with = \"bytes\")]\n            bytes: Vec\u003cu8\u003e,\n        },\n    }\n\n    assert_de_tokens(\n        \u0026InternallyTagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"String\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"String\"),\n            Token::Str(\"string\"),\n            Token::Str(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"String\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"String\"),\n            Token::Str(\"string\"),\n            Token::String(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"String\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"String\"),\n            Token::Str(\"string\"),\n            Token::Bytes(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"String\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"String\"),\n            Token::Str(\"string\"),\n            Token::ByteBuf(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::Str(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::String(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::Bytes(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::ByteBuf(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026InternallyTagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Bytes\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Bytes\"),\n            Token::Str(\"bytes\"),\n            Token::Seq { len: Some(1) },\n            Token::U8(0),\n            Token::SeqEnd,\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_struct_variant_containing_unit_variant() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    pub enum Level {\n        Info,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"action\")]\n    pub enum Message {\n        Log { level: Level },\n    }\n\n    assert_de_tokens(\n        \u0026Message::Log { level: Level::Info },\n        \u0026[\n            Token::Struct {\n                name: \"Message\",\n                len: 2,\n            },\n            Token::Str(\"action\"),\n            Token::Str(\"Log\"),\n            Token::Str(\"level\"),\n            Token::BorrowedStr(\"Info\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_borrow() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    pub enum Input\u003c'a\u003e {\n        Package { name: \u0026'a str },\n    }\n\n    assert_tokens(\n        \u0026Input::Package { name: \"borrowed\" },\n        \u0026[\n            Token::Struct {\n                name: \"Input\",\n                len: 2,\n            },\n            Token::BorrowedStr(\"type\"),\n            Token::BorrowedStr(\"Package\"),\n            Token::BorrowedStr(\"name\"),\n            Token::BorrowedStr(\"borrowed\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_adjacently_tagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum AdjacentlyTagged\u003cT\u003e {\n        Unit,\n        Newtype(T),\n        Tuple(u8, u8),\n        Struct { f: u8 },\n    }\n\n    // unit with no content\n    assert_ser_tokens(\n        \u0026AdjacentlyTagged::Unit::\u003cu8\u003e,\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 1,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // unit with no content\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Unit::\u003cu8\u003e,\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // unit with tag first\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Unit::\u003cu8\u003e,\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::StructEnd,\n        ],\n    );\n\n    // unit with content first\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Unit::\u003cu8\u003e,\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // unit with excess content (f, g, h)\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Unit::\u003cu8\u003e,\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"f\"),\n            Token::Unit,\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"g\"),\n            Token::Unit,\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"h\"),\n            Token::Unit,\n            Token::StructEnd,\n        ],\n    );\n\n    // newtype with tag first\n    assert_tokens(\n        \u0026AdjacentlyTagged::Newtype::\u003cu8\u003e(1),\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Newtype\"),\n            Token::Str(\"c\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    // newtype with content first\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Newtype::\u003cu8\u003e(1),\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::U8(1),\n            Token::Str(\"t\"),\n            Token::Str(\"Newtype\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // tuple with tag first\n    assert_tokens(\n        \u0026AdjacentlyTagged::Tuple::\u003cu8\u003e(1, 1),\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Tuple\"),\n            Token::Str(\"c\"),\n            Token::Tuple { len: 2 },\n            Token::U8(1),\n            Token::U8(1),\n            Token::TupleEnd,\n            Token::StructEnd,\n        ],\n    );\n\n    // tuple with content first\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Tuple::\u003cu8\u003e(1, 1),\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Tuple { len: 2 },\n            Token::U8(1),\n            Token::U8(1),\n            Token::TupleEnd,\n            Token::Str(\"t\"),\n            Token::Str(\"Tuple\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // struct with tag first\n    assert_tokens(\n        \u0026AdjacentlyTagged::Struct::\u003cu8\u003e { f: 1 },\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Struct\"),\n            Token::Str(\"c\"),\n            Token::Struct {\n                name: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"f\"),\n            Token::U8(1),\n            Token::StructEnd,\n            Token::StructEnd,\n        ],\n    );\n\n    // struct with content first\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Struct::\u003cu8\u003e { f: 1 },\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Struct {\n                name: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"f\"),\n            Token::U8(1),\n            Token::StructEnd,\n            Token::Str(\"t\"),\n            Token::Str(\"Struct\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_adjacently_tagged_enum_deny_unknown_fields() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\", deny_unknown_fields)]\n    enum AdjacentlyTagged {\n        Unit,\n    }\n\n    assert_de_tokens(\n        \u0026AdjacentlyTagged::Unit,\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens_error::\u003cAdjacentlyTagged\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"h\"),\n        ],\n        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#,\n    );\n\n    assert_de_tokens_error::\u003cAdjacentlyTagged\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"h\"),\n        ],\n        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#,\n    );\n\n    assert_de_tokens_error::\u003cAdjacentlyTagged\u003e(\n        \u0026[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"h\"),\n        ],\n        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#,\n    );\n}\n\n#[test]\nfn test_enum_in_internally_tagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    enum Outer {\n        Inner(Inner),\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    enum Inner {\n        Unit,\n        Newtype(u8),\n        Tuple(u8, u8),\n        Struct { f: u8 },\n    }\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Unit),\n        \u0026[\n            Token::Map { len: Some(2) },\n            Token::Str(\"type\"),\n            Token::Str(\"Inner\"),\n            Token::Str(\"Unit\"),\n            Token::Unit,\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Newtype(1)),\n        \u0026[\n            Token::Map { len: Some(2) },\n            Token::Str(\"type\"),\n            Token::Str(\"Inner\"),\n            Token::Str(\"Newtype\"),\n            Token::U8(1),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Tuple(1, 1)),\n        \u0026[\n            Token::Map { len: Some(2) },\n            Token::Str(\"type\"),\n            Token::Str(\"Inner\"),\n            Token::Str(\"Tuple\"),\n            Token::TupleStruct {\n                name: \"Tuple\",\n                len: 2,\n            },\n            Token::U8(1),\n            Token::U8(1),\n            Token::TupleStructEnd,\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Struct { f: 1 }),\n        \u0026[\n            Token::Map { len: Some(2) },\n            Token::Str(\"type\"),\n            Token::Str(\"Inner\"),\n            Token::Str(\"Struct\"),\n            Token::Struct {\n                name: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"f\"),\n            Token::U8(1),\n            Token::StructEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_struct() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    pub struct Struct {\n        a: u8,\n    }\n\n    assert_tokens(\n        \u0026Struct { a: 1 },\n        \u0026[\n            Token::Struct {\n                name: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"type\"),\n            Token::Str(\"Struct\"),\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Struct { a: 1 },\n        \u0026[\n            Token::Struct {\n                name: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_braced_struct_with_zero_fields() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"type\")]\n    struct S {}\n\n    assert_tokens(\n        \u0026S {},\n        \u0026[\n            Token::Struct { name: \"S\", len: 1 },\n            Token::Str(\"type\"),\n            Token::Str(\"S\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_internally_tagged_struct_with_flattened_field() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"tag_struct\")]\n    pub struct Struct {\n        #[serde(flatten)]\n        pub flat: Enum,\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"tag_enum\", content = \"content\")]\n    pub enum Enum {\n        A(u64),\n    }\n\n    assert_tokens(\n        \u0026Struct { flat: Enum::A(0) },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"tag_struct\"),\n            Token::Str(\"Struct\"),\n            Token::Str(\"tag_enum\"),\n            Token::Str(\"A\"),\n            Token::Str(\"content\"),\n            Token::U64(0),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Struct { flat: Enum::A(0) },\n        \u0026[\n            Token::Map { len: None },\n            Token::Str(\"tag_enum\"),\n            Token::Str(\"A\"),\n            Token::Str(\"content\"),\n            Token::U64(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_enum_with_flattened_integer_key() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    pub enum Untagged {\n        Variant {\n            #[serde(flatten)]\n            map: BTreeMap\u003cu64, String\u003e,\n        },\n    }\n\n    assert_tokens(\n        \u0026Untagged::Variant {\n            map: {\n                let mut map = BTreeMap::new();\n                map.insert(100, \"BTreeMap\".to_owned());\n                map\n            },\n        },\n        \u0026[\n            Token::Map { len: None },\n            Token::U64(100),\n            Token::Str(\"BTreeMap\"),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_enum_in_untagged_enum() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum Outer {\n        Inner(Inner),\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    enum Inner {\n        Unit,\n        Newtype(u8),\n        Tuple(u8, u8),\n        Struct { f: u8 },\n    }\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Unit),\n        \u0026[Token::UnitVariant {\n            name: \"Inner\",\n            variant: \"Unit\",\n        }],\n    );\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Newtype(1)),\n        \u0026[\n            Token::NewtypeVariant {\n                name: \"Inner\",\n                variant: \"Newtype\",\n            },\n            Token::U8(1),\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Tuple(1, 1)),\n        \u0026[\n            Token::TupleVariant {\n                name: \"Inner\",\n                variant: \"Tuple\",\n                len: 2,\n            },\n            Token::U8(1),\n            Token::U8(1),\n            Token::TupleVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026Outer::Inner(Inner::Struct { f: 1 }),\n        \u0026[\n            Token::StructVariant {\n                name: \"Inner\",\n                variant: \"Struct\",\n                len: 1,\n            },\n            Token::Str(\"f\"),\n            Token::U8(1),\n            Token::StructVariantEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_bytes() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    #[serde(untagged)]\n    enum Untagged {\n        String {\n            string: String,\n        },\n        Bytes {\n            #[serde(with = \"bytes\")]\n            bytes: Vec\u003cu8\u003e,\n        },\n    }\n\n    assert_de_tokens(\n        \u0026Untagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"string\"),\n            Token::Str(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"string\"),\n            Token::String(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"string\"),\n            Token::Bytes(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::String {\n            string: \"\\0\".to_owned(),\n        },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"string\"),\n            Token::ByteBuf(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::Str(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::String(\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::Bytes(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::ByteBuf(b\"\\0\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        \u0026Untagged::Bytes { bytes: vec![0] },\n        \u0026[\n            Token::Struct {\n                name: \"Untagged\",\n                len: 1,\n            },\n            Token::Str(\"bytes\"),\n            Token::Seq { len: Some(1) },\n            Token::U8(0),\n            Token::SeqEnd,\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_rename_all() {\n    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n    #[serde(rename_all = \"snake_case\")]\n    enum E {\n        #[serde(rename_all = \"camelCase\")]\n        Serialize {\n            serialize: bool,\n            serialize_seq: bool,\n        },\n        #[serde(rename_all = \"kebab-case\")]\n        SerializeSeq {\n            serialize: bool,\n            serialize_seq: bool,\n        },\n        #[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\n        SerializeMap {\n            serialize: bool,\n            serialize_seq: bool,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n    #[serde(rename_all = \"PascalCase\")]\n    struct S {\n        serialize: bool,\n        serialize_seq: bool,\n    }\n\n    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n    #[serde(rename_all = \"SCREAMING-KEBAB-CASE\")]\n    struct ScreamingKebab {\n        serialize: bool,\n        serialize_seq: bool,\n    }\n\n    assert_tokens(\n        \u0026E::Serialize {\n            serialize: true,\n            serialize_seq: true,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"E\",\n                variant: \"serialize\",\n                len: 2,\n            },\n            Token::Str(\"serialize\"),\n            Token::Bool(true),\n            Token::Str(\"serializeSeq\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026E::SerializeSeq {\n            serialize: true,\n            serialize_seq: true,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"E\",\n                variant: \"serialize_seq\",\n                len: 2,\n            },\n            Token::Str(\"serialize\"),\n            Token::Bool(true),\n            Token::Str(\"serialize-seq\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026E::SerializeMap {\n            serialize: true,\n            serialize_seq: true,\n        },\n        \u0026[\n            Token::StructVariant {\n                name: \"E\",\n                variant: \"serialize_map\",\n                len: 2,\n            },\n            Token::Str(\"SERIALIZE\"),\n            Token::Bool(true),\n            Token::Str(\"SERIALIZE_SEQ\"),\n            Token::Bool(true),\n            Token::StructVariantEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026S {\n            serialize: true,\n            serialize_seq: true,\n        },\n        \u0026[\n            Token::Struct { name: \"S\", len: 2 },\n            Token::Str(\"Serialize\"),\n            Token::Bool(true),\n            Token::Str(\"SerializeSeq\"),\n            Token::Bool(true),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_tokens(\n        \u0026ScreamingKebab {\n            serialize: true,\n            serialize_seq: true,\n        },\n        \u0026[\n            Token::Struct {\n                name: \"ScreamingKebab\",\n                len: 2,\n            },\n            Token::Str(\"SERIALIZE\"),\n            Token::Bool(true),\n            Token::Str(\"SERIALIZE-SEQ\"),\n            Token::Bool(true),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn test_untagged_newtype_variant_containing_unit_struct_not_map() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Unit;\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(untagged)]\n    enum Message {\n        Unit(Unit),\n        Map(BTreeMap\u003cString, String\u003e),\n    }\n\n    assert_tokens(\n        \u0026Message::Map(BTreeMap::new()),\n        \u0026[Token::Map { len: Some(0) }, Token::MapEnd],\n    );\n}\n\n#[test]\nfn test_internally_tagged_newtype_variant_containing_unit_struct() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Info;\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"topic\")]\n    enum Message {\n        Info(Info),\n    }\n\n    assert_tokens(\n        \u0026Message::Info(Info),\n        \u0026[\n            Token::Map { len: Some(1) },\n            Token::Str(\"topic\"),\n            Token::Str(\"Info\"),\n            Token::MapEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_remote.rs"],"content":"#![allow(clippy::redundant_field_names)]\n\nuse serde::{Deserialize, Serialize};\n\nmod remote {\n    pub struct Unit;\n\n    pub struct PrimitivePriv(u8);\n\n    pub struct PrimitivePub(pub u8);\n\n    pub struct NewtypePriv(Unit);\n\n    pub struct NewtypePub(pub Unit);\n\n    pub struct TuplePriv(u8, Unit);\n\n    pub struct TuplePub(pub u8, pub Unit);\n\n    pub struct StructPriv {\n        a: u8,\n        b: Unit,\n    }\n\n    pub struct StructPub {\n        pub a: u8,\n        pub b: Unit,\n    }\n\n    impl PrimitivePriv {\n        pub fn new(a: u8) -\u003e Self {\n            PrimitivePriv(a)\n        }\n\n        pub fn get(\u0026self) -\u003e u8 {\n            self.0\n        }\n    }\n\n    impl NewtypePriv {\n        pub fn new(a: Unit) -\u003e Self {\n            NewtypePriv(a)\n        }\n\n        pub fn get(\u0026self) -\u003e \u0026Unit {\n            \u0026self.0\n        }\n    }\n\n    impl TuplePriv {\n        pub fn new(a: u8, b: Unit) -\u003e Self {\n            TuplePriv(a, b)\n        }\n\n        pub fn first(\u0026self) -\u003e u8 {\n            self.0\n        }\n\n        pub fn second(\u0026self) -\u003e \u0026Unit {\n            \u0026self.1\n        }\n    }\n\n    impl StructPriv {\n        pub fn new(a: u8, b: Unit) -\u003e Self {\n            StructPriv { a: a, b: b }\n        }\n\n        pub fn a(\u0026self) -\u003e u8 {\n            self.a\n        }\n\n        pub fn b(\u0026self) -\u003e \u0026Unit {\n            \u0026self.b\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize)]\nstruct Test {\n    #[serde(with = \"UnitDef\")]\n    unit: remote::Unit,\n\n    #[serde(with = \"PrimitivePrivDef\")]\n    primitive_priv: remote::PrimitivePriv,\n\n    #[serde(with = \"PrimitivePubDef\")]\n    primitive_pub: remote::PrimitivePub,\n\n    #[serde(with = \"NewtypePrivDef\")]\n    newtype_priv: remote::NewtypePriv,\n\n    #[serde(with = \"NewtypePubDef\")]\n    newtype_pub: remote::NewtypePub,\n\n    #[serde(with = \"TuplePrivDef\")]\n    tuple_priv: remote::TuplePriv,\n\n    #[serde(with = \"TuplePubDef\")]\n    tuple_pub: remote::TuplePub,\n\n    #[serde(with = \"StructPrivDef\")]\n    struct_priv: remote::StructPriv,\n\n    #[serde(with = \"StructPubDef\")]\n    struct_pub: remote::StructPub,\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::Unit\")]\nstruct UnitDef;\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::PrimitivePriv\")]\nstruct PrimitivePrivDef(#[serde(getter = \"remote::PrimitivePriv::get\")] u8);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::PrimitivePub\")]\nstruct PrimitivePubDef(u8);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::NewtypePriv\")]\nstruct NewtypePrivDef(#[serde(getter = \"remote::NewtypePriv::get\", with = \"UnitDef\")] remote::Unit);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::NewtypePub\")]\nstruct NewtypePubDef(#[serde(with = \"UnitDef\")] remote::Unit);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::TuplePriv\")]\nstruct TuplePrivDef(\n    #[serde(getter = \"remote::TuplePriv::first\")] u8,\n    #[serde(getter = \"remote::TuplePriv::second\", with = \"UnitDef\")] remote::Unit,\n);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::TuplePub\")]\nstruct TuplePubDef(u8, #[serde(with = \"UnitDef\")] remote::Unit);\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::StructPriv\")]\nstruct StructPrivDef {\n    #[serde(getter = \"remote::StructPriv::a\")]\n    a: u8,\n\n    #[serde(getter = \"remote::StructPriv::b\")]\n    #[serde(with = \"UnitDef\")]\n    b: remote::Unit,\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::StructPub\")]\nstruct StructPubDef {\n    a: u8,\n\n    #[serde(with = \"UnitDef\")]\n    b: remote::Unit,\n}\n\nimpl From\u003cPrimitivePrivDef\u003e for remote::PrimitivePriv {\n    fn from(def: PrimitivePrivDef) -\u003e Self {\n        remote::PrimitivePriv::new(def.0)\n    }\n}\n\nimpl From\u003cNewtypePrivDef\u003e for remote::NewtypePriv {\n    fn from(def: NewtypePrivDef) -\u003e Self {\n        remote::NewtypePriv::new(def.0)\n    }\n}\n\nimpl From\u003cTuplePrivDef\u003e for remote::TuplePriv {\n    fn from(def: TuplePrivDef) -\u003e Self {\n        remote::TuplePriv::new(def.0, def.1)\n    }\n}\n\nimpl From\u003cStructPrivDef\u003e for remote::StructPriv {\n    fn from(def: StructPrivDef) -\u003e Self {\n        remote::StructPriv::new(def.a, def.b)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_roundtrip.rs"],"content":"use serde_test::{assert_tokens, Configure, Token};\n\nuse std::net;\n\n#[macro_use]\n#[allow(unused_macros)]\nmod macros;\n\n#[test]\nfn ip_addr_roundtrip() {\n    assert_tokens(\n        \u0026net::IpAddr::from(*b\"1234\").compact(),\n        \u0026seq![\n            Token::NewtypeVariant { name: \"IpAddr\", variant: \"V4\" },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n        ],\n    );\n}\n\n#[test]\nfn socket_addr_roundtrip() {\n    assert_tokens(\n        \u0026net::SocketAddr::from((*b\"1234567890123456\", 1234)).compact(),\n        \u0026seq![\n            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V6\" },\n\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_ser.rs"],"content":"#![allow(clippy::unreadable_literal)]\n#![cfg_attr(feature = \"unstable\", feature(never_type))]\n\nuse std::cell::RefCell;\nuse std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\nuse std::ffi::CString;\nuse std::mem;\nuse std::net;\nuse std::num::Wrapping;\nuse std::ops::Bound;\nuse std::path::{Path, PathBuf};\nuse std::rc::{Rc, Weak as RcWeak};\nuse std::sync::atomic::{\n    AtomicBool, AtomicI16, AtomicI32, AtomicI8, AtomicIsize, AtomicU16, AtomicU32, AtomicU8,\n    AtomicUsize,\n};\nuse std::sync::{Arc, Weak as ArcWeak};\nuse std::time::{Duration, UNIX_EPOCH};\n\n#[cfg(unix)]\nuse std::str;\n#[cfg(target_arch = \"x86_64\")]\nuse std::sync::atomic::{AtomicI64, AtomicU64};\n\nuse fnv::FnvHasher;\nuse serde::Serialize;\nuse serde_test::{assert_ser_tokens, assert_ser_tokens_error, Configure, Token};\n\n#[macro_use]\nmod macros;\n\n//////////////////////////////////////////////////////////////////////////\n\n#[derive(Serialize)]\nstruct UnitStruct;\n\n#[derive(Serialize)]\nstruct TupleStruct(i32, i32, i32);\n\n#[derive(Serialize)]\nstruct Struct {\n    a: i32,\n    b: i32,\n    c: i32,\n}\n\n#[derive(Serialize, PartialEq, Debug)]\nenum Enum {\n    Unit,\n    One(i32),\n    Seq(i32, i32),\n    Map {\n        a: i32,\n        b: i32,\n    },\n    #[serde(skip_serializing)]\n    SkippedUnit,\n    #[serde(skip_serializing)]\n    SkippedOne(i32),\n    #[serde(skip_serializing)]\n    SkippedSeq(i32, i32),\n    #[serde(skip_serializing)]\n    SkippedMap {\n        _a: i32,\n        _b: i32,\n    },\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nmacro_rules! declare_tests {\n    (\n        $readable:tt\n        $($name:ident { $($value:expr =\u003e $tokens:expr,)+ })+\n    ) =\u003e {\n        $(\n            #[test]\n            fn $name() {\n                $(\n                    assert_ser_tokens(\u0026$value.$readable(), $tokens);\n                )+\n            }\n        )+\n    };\n\n    ($($name:ident { $($value:expr =\u003e $tokens:expr,)+ })+) =\u003e {\n        $(\n            #[test]\n            fn $name() {\n                $(\n                    assert_ser_tokens(\u0026$value, $tokens);\n                )+\n            }\n        )+\n    }\n}\n\ndeclare_tests! {\n    test_unit {\n        () =\u003e \u0026[Token::Unit],\n    }\n    test_bool {\n        true =\u003e \u0026[Token::Bool(true)],\n        false =\u003e \u0026[Token::Bool(false)],\n    }\n    test_isizes {\n        0i8 =\u003e \u0026[Token::I8(0)],\n        0i16 =\u003e \u0026[Token::I16(0)],\n        0i32 =\u003e \u0026[Token::I32(0)],\n        0i64 =\u003e \u0026[Token::I64(0)],\n    }\n    test_usizes {\n        0u8 =\u003e \u0026[Token::U8(0)],\n        0u16 =\u003e \u0026[Token::U16(0)],\n        0u32 =\u003e \u0026[Token::U32(0)],\n        0u64 =\u003e \u0026[Token::U64(0)],\n    }\n    test_floats {\n        0f32 =\u003e \u0026[Token::F32(0.)],\n        0f64 =\u003e \u0026[Token::F64(0.)],\n    }\n    test_char {\n        'a' =\u003e \u0026[Token::Char('a')],\n    }\n    test_str {\n        \"abc\" =\u003e \u0026[Token::Str(\"abc\")],\n        \"abc\".to_owned() =\u003e \u0026[Token::Str(\"abc\")],\n    }\n    test_option {\n        None::\u003ci32\u003e =\u003e \u0026[Token::None],\n        Some(1) =\u003e \u0026[\n            Token::Some,\n            Token::I32(1),\n        ],\n    }\n    test_result {\n        Ok::\u003ci32, i32\u003e(0) =\u003e \u0026[\n            Token::NewtypeVariant { name: \"Result\", variant: \"Ok\" },\n            Token::I32(0),\n        ],\n        Err::\u003ci32, i32\u003e(1) =\u003e \u0026[\n            Token::NewtypeVariant { name: \"Result\", variant: \"Err\" },\n            Token::I32(1),\n        ],\n    }\n    test_slice {\n        \u0026[0][..0] =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        \u0026[1, 2, 3][..] =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::SeqEnd,\n        ],\n    }\n    test_array {\n        [0; 0] =\u003e \u0026[\n            Token::Tuple { len: 0 },\n            Token::TupleEnd,\n        ],\n        [1, 2, 3] =\u003e \u0026[\n            Token::Tuple { len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleEnd,\n        ],\n    }\n    test_vec {\n        Vec::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        vec![vec![], vec![1], vec![2, 3]] =\u003e \u0026[\n            Token::Seq { len: Some(3) },\n                Token::Seq { len: Some(0) },\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(1) },\n                    Token::I32(1),\n                Token::SeqEnd,\n\n                Token::Seq { len: Some(2) },\n                    Token::I32(2),\n                    Token::I32(3),\n                Token::SeqEnd,\n            Token::SeqEnd,\n        ],\n    }\n    test_btreeset {\n        BTreeSet::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        btreeset![1] =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n                Token::I32(1),\n            Token::SeqEnd,\n        ],\n    }\n    test_hashset {\n        HashSet::\u003cisize\u003e::new() =\u003e \u0026[\n            Token::Seq { len: Some(0) },\n            Token::SeqEnd,\n        ],\n        hashset![1] =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n                Token::I32(1),\n            Token::SeqEnd,\n        ],\n        hashset![FnvHasher @ 1] =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n                Token::I32(1),\n            Token::SeqEnd,\n        ],\n    }\n    test_tuple {\n        (1,) =\u003e \u0026[\n            Token::Tuple { len: 1 },\n                Token::I32(1),\n            Token::TupleEnd,\n        ],\n        (1, 2, 3) =\u003e \u0026[\n            Token::Tuple { len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleEnd,\n        ],\n    }\n    test_btreemap {\n        btreemap![1 =\u003e 2] =\u003e \u0026[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        btreemap![1 =\u003e 2, 3 =\u003e 4] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::I32(2),\n\n                Token::I32(3),\n                Token::I32(4),\n            Token::MapEnd,\n        ],\n        btreemap![1 =\u003e btreemap![], 2 =\u003e btreemap![3 =\u003e 4, 5 =\u003e 6]] =\u003e \u0026[\n            Token::Map { len: Some(2) },\n                Token::I32(1),\n                Token::Map { len: Some(0) },\n                Token::MapEnd,\n\n                Token::I32(2),\n                Token::Map { len: Some(2) },\n                    Token::I32(3),\n                    Token::I32(4),\n\n                    Token::I32(5),\n                    Token::I32(6),\n                Token::MapEnd,\n            Token::MapEnd,\n        ],\n    }\n    test_hashmap {\n        HashMap::\u003cisize, isize\u003e::new() =\u003e \u0026[\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n        ],\n        hashmap![1 =\u003e 2] =\u003e \u0026[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n        hashmap![FnvHasher @ 1 =\u003e 2] =\u003e \u0026[\n            Token::Map { len: Some(1) },\n                Token::I32(1),\n                Token::I32(2),\n            Token::MapEnd,\n        ],\n    }\n    test_unit_struct {\n        UnitStruct =\u003e \u0026[Token::UnitStruct { name: \"UnitStruct\" }],\n    }\n    test_tuple_struct {\n        TupleStruct(1, 2, 3) =\u003e \u0026[\n            Token::TupleStruct { name: \"TupleStruct\", len: 3 },\n                Token::I32(1),\n                Token::I32(2),\n                Token::I32(3),\n            Token::TupleStructEnd,\n        ],\n    }\n    test_struct {\n        Struct { a: 1, b: 2, c: 3 } =\u003e \u0026[\n            Token::Struct { name: \"Struct\", len: 3 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n\n                Token::Str(\"c\"),\n                Token::I32(3),\n            Token::StructEnd,\n        ],\n    }\n    test_enum {\n        Enum::Unit =\u003e \u0026[Token::UnitVariant { name: \"Enum\", variant: \"Unit\" }],\n        Enum::One(42) =\u003e \u0026[Token::NewtypeVariant { name: \"Enum\", variant: \"One\" }, Token::I32(42)],\n        Enum::Seq(1, 2) =\u003e \u0026[\n            Token::TupleVariant { name: \"Enum\", variant: \"Seq\", len: 2 },\n                Token::I32(1),\n                Token::I32(2),\n            Token::TupleVariantEnd,\n        ],\n        Enum::Map { a: 1, b: 2 } =\u003e \u0026[\n            Token::StructVariant { name: \"Enum\", variant: \"Map\", len: 2 },\n                Token::Str(\"a\"),\n                Token::I32(1),\n\n                Token::Str(\"b\"),\n                Token::I32(2),\n            Token::StructVariantEnd,\n        ],\n    }\n    test_box {\n        Box::new(0i32) =\u003e \u0026[Token::I32(0)],\n    }\n    test_boxed_slice {\n        Box::new([0, 1, 2]) =\u003e \u0026[\n            Token::Tuple { len: 3 },\n            Token::I32(0),\n            Token::I32(1),\n            Token::I32(2),\n            Token::TupleEnd,\n        ],\n    }\n    test_duration {\n        Duration::new(1, 2) =\u003e \u0026[\n            Token::Struct { name: \"Duration\", len: 2 },\n                Token::Str(\"secs\"),\n                Token::U64(1),\n\n                Token::Str(\"nanos\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n    }\n    test_system_time {\n        UNIX_EPOCH + Duration::new(1, 200) =\u003e \u0026[\n            Token::Struct { name: \"SystemTime\", len: 2 },\n                Token::Str(\"secs_since_epoch\"),\n                Token::U64(1),\n\n                Token::Str(\"nanos_since_epoch\"),\n                Token::U32(200),\n            Token::StructEnd,\n        ],\n    }\n    test_range {\n        1u32..2u32 =\u003e \u0026[\n            Token::Struct { name: \"Range\", len: 2 },\n                Token::Str(\"start\"),\n                Token::U32(1),\n\n                Token::Str(\"end\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n    }\n    test_range_inclusive {\n        1u32..=2u32 =\u003e \u0026[\n            Token::Struct { name: \"RangeInclusive\", len: 2 },\n                Token::Str(\"start\"),\n                Token::U32(1),\n\n                Token::Str(\"end\"),\n                Token::U32(2),\n            Token::StructEnd,\n        ],\n    }\n    test_bound {\n        Bound::Unbounded::\u003c()\u003e =\u003e \u0026[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Unbounded\"),\n            Token::Unit,\n        ],\n        Bound::Included(0u8) =\u003e \u0026[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Included\"),\n            Token::U8(0),\n        ],\n        Bound::Excluded(0u8) =\u003e \u0026[\n            Token::Enum { name: \"Bound\" },\n            Token::Str(\"Excluded\"),\n            Token::U8(0),\n        ],\n    }\n    test_path {\n        Path::new(\"/usr/local/lib\") =\u003e \u0026[\n            Token::Str(\"/usr/local/lib\"),\n        ],\n    }\n    test_path_buf {\n        PathBuf::from(\"/usr/local/lib\") =\u003e \u0026[\n            Token::Str(\"/usr/local/lib\"),\n        ],\n    }\n    test_cstring {\n        CString::new(\"abc\").unwrap() =\u003e \u0026[\n            Token::Bytes(b\"abc\"),\n        ],\n    }\n    test_cstr {\n        (\u0026*CString::new(\"abc\").unwrap()) =\u003e \u0026[\n            Token::Bytes(b\"abc\"),\n        ],\n    }\n    test_rc {\n        Rc::new(true) =\u003e \u0026[\n            Token::Bool(true),\n        ],\n    }\n    test_rc_weak_some {\n        {\n            let rc = Rc::new(true);\n            mem::forget(rc.clone());\n            Rc::downgrade(\u0026rc)\n        } =\u003e \u0026[\n            Token::Some,\n            Token::Bool(true),\n        ],\n    }\n    test_rc_weak_none {\n        RcWeak::\u003cbool\u003e::new() =\u003e \u0026[\n            Token::None,\n        ],\n    }\n    test_arc {\n        Arc::new(true) =\u003e \u0026[\n            Token::Bool(true),\n        ],\n    }\n    test_arc_weak_some {\n        {\n            let arc = Arc::new(true);\n            mem::forget(arc.clone());\n            Arc::downgrade(\u0026arc)\n        } =\u003e \u0026[\n            Token::Some,\n            Token::Bool(true),\n        ],\n    }\n    test_arc_weak_none {\n        ArcWeak::\u003cbool\u003e::new() =\u003e \u0026[\n            Token::None,\n        ],\n    }\n    test_wrapping {\n        Wrapping(1usize) =\u003e \u0026[\n            Token::U64(1),\n        ],\n    }\n    test_rc_dst {\n        Rc::\u003cstr\u003e::from(\"s\") =\u003e \u0026[\n            Token::Str(\"s\"),\n        ],\n        Rc::\u003c[bool]\u003e::from(\u0026[true][..]) =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n    }\n    test_arc_dst {\n        Arc::\u003cstr\u003e::from(\"s\") =\u003e \u0026[\n            Token::Str(\"s\"),\n        ],\n        Arc::\u003c[bool]\u003e::from(\u0026[true][..]) =\u003e \u0026[\n            Token::Seq { len: Some(1) },\n            Token::Bool(true),\n            Token::SeqEnd,\n        ],\n    }\n    test_fmt_arguments {\n        format_args!(\"{}{}\", 1, 'a') =\u003e \u0026[\n            Token::Str(\"1a\"),\n        ],\n    }\n    test_atomic {\n        AtomicBool::new(false) =\u003e \u0026[Token::Bool(false)],\n        AtomicBool::new(true) =\u003e \u0026[Token::Bool(true)],\n        AtomicI8::new(63i8) =\u003e \u0026[Token::I8(63i8)],\n        AtomicI16::new(-318i16) =\u003e \u0026[Token::I16(-318i16)],\n        AtomicI32::new(65792i32) =\u003e \u0026[Token::I32(65792i32)],\n        AtomicIsize::new(-65792isize) =\u003e \u0026[Token::I64(-65792i64)],\n        AtomicU8::new(192u8) =\u003e \u0026[Token::U8(192u8)],\n        AtomicU16::new(510u16) =\u003e \u0026[Token::U16(510u16)],\n        AtomicU32::new(131072u32) =\u003e \u0026[Token::U32(131072u32)],\n        AtomicUsize::new(655360usize) =\u003e \u0026[Token::U64(655360u64)],\n    }\n}\n\n#[cfg(target_arch = \"x86_64\")]\ndeclare_tests! {\n    test_atomic64 {\n        AtomicI64::new(-4295032832i64) =\u003e \u0026[Token::I64(-4295032832i64)],\n        AtomicU64::new(12884901888u64) =\u003e \u0026[Token::U64(12884901888u64)],\n    }\n}\n\ndeclare_tests! {\n    readable\n\n    test_net_ipv4addr_readable {\n        \"1.2.3.4\".parse::\u003cnet::Ipv4Addr\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4\")],\n    }\n    test_net_ipv6addr_readable {\n        \"::1\".parse::\u003cnet::Ipv6Addr\u003e().unwrap() =\u003e \u0026[Token::Str(\"::1\")],\n    }\n    test_net_ipaddr_readable {\n        \"1.2.3.4\".parse::\u003cnet::IpAddr\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4\")],\n    }\n    test_net_socketaddr_readable {\n        \"1.2.3.4:1234\".parse::\u003cnet::SocketAddr\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4:1234\")],\n        \"1.2.3.4:1234\".parse::\u003cnet::SocketAddrV4\u003e().unwrap() =\u003e \u0026[Token::Str(\"1.2.3.4:1234\")],\n        \"[::1]:1234\".parse::\u003cnet::SocketAddrV6\u003e().unwrap() =\u003e \u0026[Token::Str(\"[::1]:1234\")],\n    }\n}\n\ndeclare_tests! {\n    compact\n\n    test_net_ipv4addr_compact {\n        net::Ipv4Addr::from(*b\"1234\") =\u003e \u0026seq![\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n        ],\n    }\n    test_net_ipv6addr_compact {\n        net::Ipv6Addr::from(*b\"1234567890123456\") =\u003e \u0026seq![\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n        ],\n    }\n    test_net_ipaddr_compact {\n        net::IpAddr::from(*b\"1234\") =\u003e \u0026seq![\n            Token::NewtypeVariant { name: \"IpAddr\", variant: \"V4\" },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n        ],\n    }\n    test_net_socketaddr_compact {\n        net::SocketAddr::from((*b\"1234567890123456\", 1234)) =\u003e \u0026seq![\n            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V6\" },\n\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd,\n        ],\n        net::SocketAddrV4::new(net::Ipv4Addr::from(*b\"1234\"), 1234) =\u003e \u0026seq![\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 4 },\n            seq b\"1234\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd,\n        ],\n        net::SocketAddrV6::new(net::Ipv6Addr::from(*b\"1234567890123456\"), 1234, 0, 0) =\u003e \u0026seq![\n            Token::Tuple { len: 2 },\n\n            Token::Tuple { len: 16 },\n            seq b\"1234567890123456\".iter().map(|\u0026b| Token::U8(b)),\n            Token::TupleEnd,\n\n            Token::U16(1234),\n            Token::TupleEnd,\n        ],\n    }\n}\n\n#[cfg(feature = \"unstable\")]\ndeclare_tests! {\n    test_never_result {\n        Ok::\u003cu8, !\u003e(0) =\u003e \u0026[\n            Token::NewtypeVariant { name: \"Result\", variant: \"Ok\" },\n            Token::U8(0),\n        ],\n    }\n}\n\n#[test]\n#[cfg(unix)]\nfn test_cannot_serialize_paths() {\n    let path = unsafe { str::from_utf8_unchecked(b\"Hello \\xF0\\x90\\x80World\") };\n    assert_ser_tokens_error(\n        \u0026Path::new(path),\n        \u0026[],\n        \"path contains invalid UTF-8 characters\",\n    );\n\n    let mut path_buf = PathBuf::new();\n    path_buf.push(path);\n\n    assert_ser_tokens_error(\u0026path_buf, \u0026[], \"path contains invalid UTF-8 characters\");\n}\n\n#[test]\nfn test_cannot_serialize_mutably_borrowed_ref_cell() {\n    let ref_cell = RefCell::new(42);\n    let _reference = ref_cell.borrow_mut();\n    assert_ser_tokens_error(\u0026ref_cell, \u0026[], \"already mutably borrowed\");\n}\n\n#[test]\nfn test_enum_skipped() {\n    assert_ser_tokens_error(\n        \u0026Enum::SkippedUnit,\n        \u0026[],\n        \"the enum variant Enum::SkippedUnit cannot be serialized\",\n    );\n    assert_ser_tokens_error(\n        \u0026Enum::SkippedOne(42),\n        \u0026[],\n        \"the enum variant Enum::SkippedOne cannot be serialized\",\n    );\n    assert_ser_tokens_error(\n        \u0026Enum::SkippedSeq(1, 2),\n        \u0026[],\n        \"the enum variant Enum::SkippedSeq cannot be serialized\",\n    );\n    assert_ser_tokens_error(\n        \u0026Enum::SkippedMap { _a: 1, _b: 2 },\n        \u0026[],\n        \"the enum variant Enum::SkippedMap cannot be serialized\",\n    );\n}\n\n#[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n#[test]\nfn test_integer128() {\n    assert_ser_tokens_error(\u00261i128, \u0026[], \"i128 is not supported\");\n\n    assert_ser_tokens_error(\u00261u128, \u0026[], \"u128 is not supported\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_serde_path.rs"],"content":"#[test]\nfn test_gen_custom_serde() {\n    #[derive(serde::Serialize, serde::Deserialize)]\n    #[serde(crate = \"fake_serde\")]\n    struct Foo;\n\n    // Would be overlapping if serde::Serialize were implemented\n    impl AssertNotSerdeSerialize for Foo {}\n    // Would be overlapping if serde::Deserialize were implemented\n    impl\u003c'a\u003e AssertNotSerdeDeserialize\u003c'a\u003e for Foo {}\n\n    fake_serde::assert::\u003cFoo\u003e();\n}\n\nmod fake_serde {\n    pub use serde::*;\n\n    pub fn assert\u003cT\u003e()\n    where\n        T: Serialize,\n        T: for\u003c'a\u003e Deserialize\u003c'a\u003e,\n    {\n    }\n\n    pub trait Serialize {\n        fn serialize\u003cS: Serializer\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e;\n    }\n\n    pub trait Deserialize\u003c'a\u003e: Sized {\n        fn deserialize\u003cD: Deserializer\u003c'a\u003e\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e;\n    }\n}\n\ntrait AssertNotSerdeSerialize {}\n\nimpl\u003cT: serde::Serialize\u003e AssertNotSerdeSerialize for T {}\n\ntrait AssertNotSerdeDeserialize\u003c'a\u003e {}\n\nimpl\u003c'a, T: serde::Deserialize\u003c'a\u003e\u003e AssertNotSerdeDeserialize\u003c'a\u003e for T {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_unstable.rs"],"content":"#![deny(warnings)]\n\n// This test target is convoluted with the actual #[test] in a separate file to\n// get it so that the stable compiler does not need to parse the code of the\n// test. If the test were written with #[cfg(feature = \"unstable\")] #[test]\n// right here, the stable compiler would fail to parse those raw identifiers\n// even if the cfg were not enabled.\n#[cfg(feature = \"unstable\")]\nmod unstable;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","test_value.rs"],"content":"use serde::de::value::{self, MapAccessDeserializer};\nuse serde::de::{IntoDeserializer, MapAccess, Visitor};\nuse serde::{Deserialize, Deserializer};\nuse serde_test::{assert_de_tokens, Token};\nuse std::fmt;\n\n#[test]\nfn test_u32_to_enum() {\n    #[derive(Deserialize, Debug, PartialEq)]\n    enum E {\n        A,\n        B,\n    }\n\n    let deserializer = IntoDeserializer::\u003cvalue::Error\u003e::into_deserializer(1u32);\n    let e: E = E::deserialize(deserializer).unwrap();\n    assert_eq!(E::B, e);\n}\n\n#[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n#[test]\nfn test_integer128() {\n    let de_u128 = IntoDeserializer::\u003cvalue::Error\u003e::into_deserializer(1u128);\n    let de_i128 = IntoDeserializer::\u003cvalue::Error\u003e::into_deserializer(1i128);\n\n    // u128 to u128\n    assert_eq!(1u128, u128::deserialize(de_u128).unwrap());\n\n    // u128 to i128\n    assert_eq!(1i128, i128::deserialize(de_u128).unwrap());\n\n    // i128 to u128\n    assert_eq!(1u128, u128::deserialize(de_i128).unwrap());\n\n    // i128 to i128\n    assert_eq!(1i128, i128::deserialize(de_i128).unwrap());\n}\n\n#[test]\nfn test_map_access_to_enum() {\n    #[derive(PartialEq, Debug)]\n    struct Potential(PotentialKind);\n\n    #[derive(PartialEq, Debug, Deserialize)]\n    enum PotentialKind {\n        Airebo(Airebo),\n    }\n\n    #[derive(PartialEq, Debug, Deserialize)]\n    struct Airebo {\n        lj_sigma: f64,\n    }\n\n    impl\u003c'de\u003e Deserialize\u003c'de\u003e for Potential {\n        fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cSelf, D::Error\u003e\n        where\n            D: Deserializer\u003c'de\u003e,\n        {\n            struct PotentialVisitor;\n\n            impl\u003c'de\u003e Visitor\u003c'de\u003e for PotentialVisitor {\n                type Value = Potential;\n\n                fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                    write!(formatter, \"a map\")\n                }\n\n                fn visit_map\u003cA\u003e(self, map: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\n                where\n                    A: MapAccess\u003c'de\u003e,\n                {\n                    Deserialize::deserialize(MapAccessDeserializer::new(map)).map(Potential)\n                }\n            }\n\n            deserializer.deserialize_any(PotentialVisitor)\n        }\n    }\n\n    let expected = Potential(PotentialKind::Airebo(Airebo { lj_sigma: 14.0 }));\n\n    assert_de_tokens(\n        \u0026expected,\n        \u0026[\n            Token::Map { len: Some(1) },\n            Token::Str(\"Airebo\"),\n            Token::Map { len: Some(1) },\n            Token::Str(\"lj_sigma\"),\n            Token::F64(14.0),\n            Token::MapEnd,\n            Token::MapEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","bad_lifetimes.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test\u003c'a\u003e {\n    #[serde(borrow = \"zzz\")]\n    s: \u0026'a str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","duplicate_lifetime.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test\u003c'a\u003e {\n    #[serde(borrow = \"'a + 'a\")]\n    s: \u0026'a str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","duplicate_variant.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Str\u003c'a\u003e(\u0026'a str);\n\n#[derive(Deserialize)]\nenum Test\u003c'a\u003e {\n    #[serde(borrow)]\n    S(#[serde(borrow)] Str\u003c'a\u003e),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","empty_lifetimes.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test\u003c'a\u003e {\n    #[serde(borrow = \"\")]\n    s: \u0026'a str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","no_lifetimes.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test {\n    #[serde(borrow)]\n    s: String,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","struct_variant.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Str\u003c'a\u003e(\u0026'a str);\n\n#[derive(Deserialize)]\nenum Test\u003c'a\u003e {\n    #[serde(borrow)]\n    S { s: Str\u003c'a\u003e },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","borrow","wrong_lifetime.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct Test\u003c'a\u003e {\n    #[serde(borrow = \"'b\")]\n    s: \u0026'a str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","adjacent-tag.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"conflict\", content = \"conflict\")]\nenum E {\n    A,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","flatten-newtype-struct.rs"],"content":"use serde_derive::Serialize;\n\nuse std::collections::HashMap;\n\n#[derive(Serialize)]\nstruct Foo(#[serde(flatten)] HashMap\u003cString, String\u003e);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","flatten-tuple-struct.rs"],"content":"use serde_derive::Serialize;\n\nuse std::collections::HashMap;\n\n#[derive(Serialize)]\nstruct Foo(u32, #[serde(flatten)] HashMap\u003cString, String\u003e);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","from-try-from.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(from = \"u64\", try_from = \"u64\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","internal-tag-alias.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"conflict\")]\nenum E {\n    A {\n        #[serde(alias = \"conflict\")]\n        x: (),\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","conflict","internal-tag.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"conflict\")]\nenum E {\n    A {\n        #[serde(rename = \"conflict\")]\n        x: (),\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","default-attribute","enum.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default)]\nenum E {\n    S { f: u8 },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","default-attribute","enum_path.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default = \"default_e\")]\nenum E {\n    S { f: u8 },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","default-attribute","nameless_struct_fields.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default)]\nstruct T(u8, u8);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","default-attribute","nameless_struct_fields_path.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default = \"default_t\")]\nstruct T(u8, u8);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","rename-and-ser.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = \"x\", serialize = \"y\")]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","rename-ser-rename-ser.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(serialize = \"x\"), rename(serialize = \"y\"))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","rename-ser-rename.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(serialize = \"x\"))]\n    #[serde(rename = \"y\")]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","rename-ser-ser.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(serialize = \"x\", serialize = \"y\"))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","two-rename-ser.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(serialize = \"x\"))]\n    #[serde(rename(serialize = \"y\"))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","duplicate-attribute","with-and-serialize-with.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(with = \"w\", serialize_with = \"s\")]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","content-no-tag.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(content = \"c\")]\nenum E {\n    A(u8),\n    B(String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","internal-tuple-variant.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"type\")]\nenum E {\n    Tuple(u8, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","untagged-and-adjacent.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(untagged)]\n#[serde(tag = \"t\", content = \"c\")]\nenum E {\n    A(u8),\n    B(String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","untagged-and-content.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(untagged)]\n#[serde(content = \"c\")]\nenum E {\n    A(u8),\n    B(String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","untagged-and-internal.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(untagged)]\n#[serde(tag = \"type\")]\nenum E {\n    A(u8),\n    B(String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","enum-representation","untagged-struct.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(untagged)]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","boolean.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = true)]\n    boolean: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","byte_character.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = b'a')]\n    byte_character: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","byte_string.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = b\"byte string\")]\n    byte_string: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","character.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = 'a')]\n    character: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","float.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = 3.14)]\n    float: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","expected-string","integer.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = 100)]\n    integer: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","both.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier, variant_identifier)]\nenum F {\n    A,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","field_struct.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","field_tuple.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    B(u8, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","newtype_not_last.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    Other(String),\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","not_unit.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    #[serde(other)]\n    Other(u8, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","other_not_last.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    #[serde(other)]\n    Other,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","other_untagged.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(untagged)]\nenum F {\n    #[serde(other)]\n    Other,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","other_variant.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(variant_identifier)]\nenum F {\n    #[serde(other)]\n    Other,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","variant_struct.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(variant_identifier)]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","identifier","variant_tuple.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(variant_identifier)]\nenum F {\n    A,\n    B(u8, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","malformed","bound.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(bound(unknown))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","malformed","rename.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename(unknown))]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","precondition","deserialize_de_lifetime.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct S\u003c'de\u003e {\n    s: \u0026'de str,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","precondition","deserialize_dst.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nstruct S {\n    string: String,\n    slice: [u8],\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","precondition","serialize_field_identifier.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","precondition","serialize_variant_identifier.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(variant_identifier)]\nenum F {\n    A,\n    B,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","bad_getter.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub struct S {\n        a: u8,\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    #[serde(getter = \"~~~\")]\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","bad_remote.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub struct S {\n        a: u8,\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"~~~\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","enum_getter.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub enum E {\n        A { a: u8 },\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::E\")]\npub enum E {\n    A {\n        #[serde(getter = \"get_a\")]\n        a: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","missing_field.rs"],"content":"use serde_derive::{Serialize, Deserialize};\n\nmod remote {\n    pub struct S {\n        pub a: u8,\n        pub b: u8,\n    }\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","nonremote_getter.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(getter = \"S::get\")]\n    a: u8,\n}\n\nimpl S {\n    fn get(\u0026self) -\u003e u8 {\n        self.a\n    }\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","unknown_field.rs"],"content":"use serde_derive::{Serialize, Deserialize};\n\nmod remote {\n    pub struct S {\n        pub a: u8,\n    }\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    b: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","wrong_de.rs"],"content":"use serde_derive::Deserialize;\n\nmod remote {\n    pub struct S(pub u16);\n}\n\n#[derive(Deserialize)]\n#[serde(remote = \"remote::S\")]\nstruct S(u8);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","wrong_getter.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub struct S {\n        a: u8,\n    }\n\n    impl S {\n        pub fn get(\u0026self) -\u003e u16 {\n            self.a as u16\n        }\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    #[serde(getter = \"remote::S::get\")]\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","remote","wrong_ser.rs"],"content":"use serde_derive::Serialize;\n\nmod remote {\n    pub struct S {\n        pub a: u16,\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::S\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","rename","container_unknown_rename_rule.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(rename_all = \"abc\")]\nstruct S {\n    name: u8,\n    long_name: u8,\n    very_long_name: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","rename","variant_unknown_rename_rule.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum S {\n    #[serde(rename_all = \"abc\")]\n    V {\n        name: u8,\n        long_name: u8,\n        very_long_name: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","struct-representation","internally-tagged-tuple.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"type\")]\nstruct S(u8, u8);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","struct-representation","internally-tagged-unit.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(tag = \"type\")]\nstruct U;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","at_most_one.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nstruct S {\n    a: u8,\n    b: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","de_at_least_one.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(transparent)]\nstruct S {\n    #[serde(skip)]\n    a: u8,\n    #[serde(default)]\n    b: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","enum.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nenum E {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","ser_at_least_one.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nstruct S {\n    #[serde(skip)]\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","unit_struct.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","with_from.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent, from = \"u64\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","with_into.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent, into = \"u64\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","transparent","with_try_from.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent, try_from = \"u64\")]\nstruct S {\n    a: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","type-attribute","from.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(from = \"Option\u003cT\")]\nenum TestOne {\n    Testing,\n    One,\n    Two,\n    Three,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","type-attribute","into.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(into = \"Option\u003cT\")]\nenum TestOne {\n    Testing,\n    One,\n    Two,\n    Three,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","type-attribute","try_from.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(try_from = \"Option\u003cT\")]\nenum TestOne {\n    Testing,\n    One,\n    Two,\n    Three,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unexpected-literal","container.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(\"literal\")]\nstruct S;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unexpected-literal","field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(\"literal\")]\n    x: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unexpected-literal","variant.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum E {\n    #[serde(\"literal\")]\n    V,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unknown-attribute","container.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(abc = \"xyz\")]\nstruct A {\n    x: u32,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unknown-attribute","field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct C {\n    #[serde(abc = \"xyz\")]\n    x: u32,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unknown-attribute","variant.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum E {\n    #[serde(abc = \"xyz\")]\n    V,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unsupported","union_de.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nunion Union {\n    x: u8,\n    y: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","unsupported","union_ser.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nunion Union {\n    x: u8,\n    y: (),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_de_newtype_field.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nenum Enum {\n    #[serde(deserialize_with = \"deserialize_some_newtype_variant\")]\n    Newtype(#[serde(skip_deserializing)] String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_de_struct_field.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nenum Enum {\n    #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n    Struct {\n        #[serde(skip_deserializing)]\n        f1: String,\n        f2: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_de_tuple_field.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nenum Enum {\n    #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n    Tuple(#[serde(skip_deserializing)] String, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_de_whole_variant.rs"],"content":"use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\nenum Enum {\n    #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n    #[serde(skip_deserializing)]\n    Unit,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_newtype_field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n    Newtype(#[serde(skip_serializing)] String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_newtype_field_if.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n    Newtype(#[serde(skip_serializing_if = \"always\")] String),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_struct_field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_other_variant\")]\n    Struct {\n        #[serde(skip_serializing)]\n        f1: String,\n        f2: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_struct_field_if.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n    Struct {\n        #[serde(skip_serializing_if = \"always\")]\n        f1: String,\n        f2: u8,\n    },\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_tuple_field.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_other_variant\")]\n    Tuple(#[serde(skip_serializing)] String, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_tuple_field_if.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_other_variant\")]\n    Tuple(#[serde(skip_serializing_if = \"always\")] String, u8),\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","ui","with-variant","skip_ser_whole_variant.rs"],"content":"use serde_derive::Serialize;\n\n#[derive(Serialize)]\nenum Enum {\n    #[serde(serialize_with = \"serialize_some_unit_variant\")]\n    #[serde(skip_serializing)]\n    Unit,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","serde","test_suite","tests","unstable","mod.rs"],"content":"use serde::{Deserialize, Serialize};\nuse serde_test::{assert_tokens, Token};\n\n#[test]\nfn test_raw_identifiers() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[allow(non_camel_case_types)]\n    enum r#type {\n        r#type { r#type: () },\n    }\n\n    assert_tokens(\n        \u0026r#type::r#type { r#type: () },\n        \u0026[\n            Token::StructVariant {\n                name: \"type\",\n                variant: \"type\",\n                len: 1,\n            },\n            Token::Str(\"type\"),\n            Token::Unit,\n            Token::StructVariantEnd,\n        ],\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","src","impls.rs"],"content":"use crate::{OpenapiSchema, OpenapiType};\n#[cfg(feature = \"chrono\")]\nuse chrono::{offset::TimeZone, Date, DateTime, NaiveDate, NaiveDateTime};\nuse indexmap::{IndexMap, IndexSet};\nuse openapiv3::{\n\tAdditionalProperties, ArrayType, IntegerType, NumberFormat, NumberType, ObjectType, ReferenceOr, SchemaKind,\n\tStringFormat, StringType, Type, VariantOrUnknownOrEmpty\n};\nuse serde_json::Value;\nuse std::{\n\tcollections::{BTreeMap, BTreeSet, HashMap, HashSet},\n\thash::BuildHasher,\n\tnum::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize}\n};\n#[cfg(feature = \"uuid\")]\nuse uuid::Uuid;\n\nmacro_rules! impl_openapi_type {\n\t($($ty:ident $(\u003c$($generic:ident : $bound:path),+\u003e)*),* =\u003e $schema:expr) =\u003e {\n\t\t$(\n\t\t\timpl $(\u003c$($generic : $bound),+\u003e)* OpenapiType for $ty $(\u003c$($generic),+\u003e)* {\n\t\t\t\tfn schema() -\u003e OpenapiSchema {\n\t\t\t\t\t$schema\n\t\t\t\t}\n\t\t\t}\n\t\t)*\n\t};\n}\n\ntype Unit = ();\nimpl_openapi_type!(Unit =\u003e {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Object(ObjectType {\n\t\tadditional_properties: Some(AdditionalProperties::Any(false)),\n\t\t..Default::default()\n\t})))\n});\n\nimpl_openapi_type!(Value =\u003e {\n\tOpenapiSchema {\n\t\tnullable: true,\n\t\tdescription: None,\n\t\tname: None,\n\t\tschema: SchemaKind::Any(Default::default()),\n\t\tdependencies: Default::default()\n\t}\n});\n\nimpl_openapi_type!(bool =\u003e OpenapiSchema::new(SchemaKind::Type(Type::Boolean {})));\n\n#[inline]\nfn int_schema(minimum: Option\u003ci64\u003e, bits: Option\u003ci64\u003e) -\u003e OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Integer(IntegerType {\n\t\tminimum,\n\t\tformat: bits\n\t\t\t.map(|bits| VariantOrUnknownOrEmpty::Unknown(format!(\"int{}\", bits)))\n\t\t\t.unwrap_or(VariantOrUnknownOrEmpty::Empty),\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(isize =\u003e int_schema(None, None));\nimpl_openapi_type!(i8 =\u003e int_schema(None, Some(8)));\nimpl_openapi_type!(i16 =\u003e int_schema(None, Some(16)));\nimpl_openapi_type!(i32 =\u003e int_schema(None, Some(32)));\nimpl_openapi_type!(i64 =\u003e int_schema(None, Some(64)));\nimpl_openapi_type!(i128 =\u003e int_schema(None, Some(128)));\n\nimpl_openapi_type!(usize =\u003e int_schema(Some(0), None));\nimpl_openapi_type!(u8 =\u003e int_schema(Some(0), Some(8)));\nimpl_openapi_type!(u16 =\u003e int_schema(Some(0), Some(16)));\nimpl_openapi_type!(u32 =\u003e int_schema(Some(0), Some(32)));\nimpl_openapi_type!(u64 =\u003e int_schema(Some(0), Some(64)));\nimpl_openapi_type!(u128 =\u003e int_schema(Some(0), Some(128)));\n\nimpl_openapi_type!(NonZeroUsize =\u003e int_schema(Some(1), None));\nimpl_openapi_type!(NonZeroU8 =\u003e int_schema(Some(1), Some(8)));\nimpl_openapi_type!(NonZeroU16 =\u003e int_schema(Some(1), Some(16)));\nimpl_openapi_type!(NonZeroU32 =\u003e int_schema(Some(1), Some(32)));\nimpl_openapi_type!(NonZeroU64 =\u003e int_schema(Some(1), Some(64)));\nimpl_openapi_type!(NonZeroU128 =\u003e int_schema(Some(1), Some(128)));\n\n#[inline]\nfn float_schema(format: NumberFormat) -\u003e OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::Number(NumberType {\n\t\tformat: VariantOrUnknownOrEmpty::Item(format),\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(f32 =\u003e float_schema(NumberFormat::Float));\nimpl_openapi_type!(f64 =\u003e float_schema(NumberFormat::Double));\n\n#[inline]\nfn str_schema(format: VariantOrUnknownOrEmpty\u003cStringFormat\u003e) -\u003e OpenapiSchema {\n\tOpenapiSchema::new(SchemaKind::Type(Type::String(StringType {\n\t\tformat,\n\t\t..Default::default()\n\t})))\n}\n\nimpl_openapi_type!(String, str =\u003e str_schema(VariantOrUnknownOrEmpty::Empty));\n\n#[cfg(feature = \"chrono\")]\nimpl_openapi_type!(Date\u003cT: TimeZone\u003e, NaiveDate =\u003e {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::Date))\n});\n\n#[cfg(feature = \"chrono\")]\nimpl_openapi_type!(DateTime\u003cT: TimeZone\u003e, NaiveDateTime =\u003e {\n\tstr_schema(VariantOrUnknownOrEmpty::Item(StringFormat::DateTime))\n});\n\n#[cfg(feature = \"uuid\")]\nimpl_openapi_type!(Uuid =\u003e {\n\tstr_schema(VariantOrUnknownOrEmpty::Unknown(\"uuid\".to_owned()))\n});\n\nimpl_openapi_type!(Option\u003cT: OpenapiType\u003e =\u003e {\n\tlet schema = T::schema();\n\tlet mut dependencies = schema.dependencies.clone();\n\tlet schema = match schema.name.clone() {\n\t\tSome(name) =\u003e {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\tSchemaKind::AllOf { all_of: vec![reference] }\n\t\t},\n\t\tNone =\u003e schema.schema\n\t};\n\n\tOpenapiSchema {\n\t\tnullable: true,\n\t\tname: None,\n\t\tdescription: None,\n\t\tschema,\n\t\tdependencies\n\t}\n});\n\n#[inline]\nfn array_schema\u003cT: OpenapiType\u003e(unique_items: bool) -\u003e OpenapiSchema {\n\tlet schema = T::schema();\n\tlet mut dependencies = schema.dependencies.clone();\n\n\tlet items = match schema.name.clone() {\n\t\tSome(name) =\u003e {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\treference\n\t\t},\n\t\tNone =\u003e ReferenceOr::Item(Box::new(schema.into_schema()))\n\t};\n\n\tOpenapiSchema {\n\t\tnullable: false,\n\t\tname: None,\n\t\tdescription: None,\n\t\tschema: SchemaKind::Type(Type::Array(ArrayType {\n\t\t\titems,\n\t\t\tmin_items: None,\n\t\t\tmax_items: None,\n\t\t\tunique_items\n\t\t})),\n\t\tdependencies\n\t}\n}\n\nimpl_openapi_type!(Vec\u003cT: OpenapiType\u003e =\u003e array_schema::\u003cT\u003e(false));\nimpl_openapi_type!(BTreeSet\u003cT: OpenapiType\u003e, IndexSet\u003cT: OpenapiType\u003e, HashSet\u003cT: OpenapiType, S: BuildHasher\u003e =\u003e {\n\tarray_schema::\u003cT\u003e(true)\n});\n\n#[inline]\nfn map_schema\u003cK: OpenapiType, T: OpenapiType\u003e() -\u003e OpenapiSchema {\n\tlet key_schema = K::schema();\n\tlet mut dependencies = key_schema.dependencies.clone();\n\n\tlet keys = match key_schema.name.clone() {\n\t\tSome(name) =\u003e {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, key_schema);\n\t\t\treference\n\t\t},\n\t\tNone =\u003e ReferenceOr::Item(Box::new(key_schema.into_schema()))\n\t};\n\n\tlet schema = T::schema();\n\tdependencies.extend(schema.dependencies.iter().map(|(k, v)| (k.clone(), v.clone())));\n\n\tlet items = Box::new(match schema.name.clone() {\n\t\tSome(name) =\u003e {\n\t\t\tlet reference = ReferenceOr::Reference {\n\t\t\t\treference: format!(\"#/components/schemas/{}\", name)\n\t\t\t};\n\t\t\tdependencies.insert(name, schema);\n\t\t\treference\n\t\t},\n\t\tNone =\u003e ReferenceOr::Item(schema.into_schema())\n\t});\n\n\tlet mut properties = IndexMap::new();\n\tproperties.insert(\"default\".to_owned(), keys);\n\n\tOpenapiSchema {\n\t\tnullable: false,\n\t\tname: None,\n\t\tdescription: None,\n\t\tschema: SchemaKind::Type(Type::Object(ObjectType {\n\t\t\tproperties,\n\t\t\trequired: vec![\"default\".to_owned()],\n\t\t\tadditional_properties: Some(AdditionalProperties::Schema(items)),\n\t\t\t..Default::default()\n\t\t})),\n\t\tdependencies\n\t}\n}\n\nimpl_openapi_type!(\n\tBTreeMap\u003cK: OpenapiType, T: OpenapiType\u003e,\n\tIndexMap\u003cK: OpenapiType, T: OpenapiType\u003e,\n\tHashMap\u003cK: OpenapiType, T: OpenapiType, S: BuildHasher\u003e\n\t=\u003e map_schema::\u003cK, T\u003e()\n);\n","traces":[{"line":22,"address":[305040,304864,305232,305136,305328,304944],"length":1,"stats":{"Line":43},"fn_name":"schema"},{"line":32,"address":[319766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[319706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[319751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[291551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[291450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[291459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[291481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[291544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[320202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[320311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[320375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[320455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[320535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[320615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[320695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[320775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[320855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[320951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[321047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[321143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[321239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[304871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[304951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[305047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[305143],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[305239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[305335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[321335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[321383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[304599],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[291959],"length":1,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[308615],"length":1,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[305486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[341722],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[341803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[341830,341928],"length":1,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[341857,341935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[342168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[341983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[342220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[342402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[341882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[342770],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[342651],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[342663],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[342675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[342723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[347610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[444244],"length":1,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[315816],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":82,"coverable":97},{"path":["/","home","runner","work","openapi_type","openapi_type","src","lib.rs"],"content":"#![warn(missing_debug_implementations, rust_2018_idioms)]\n#![forbid(unsafe_code)]\n#![cfg_attr(feature = \"cargo-clippy\", allow(clippy::tabs_in_doc_comments))]\n#![doc = r##\"\nThis crate gives static type information for primitives and commonly used types from the standard\nlibrary and a few other commonly used libraries like `chrono` and `uuid`. Also, it provides a\nderive macro for structs and enums to gain access to their static type information at runtime.\n\nThe core of this crate is the [`OpenapiType`] trait. It has one static function,\n[`schema`](OpenapiType::schema), which returns an [`OpenapiSchema`]. This assembles the static\ntype information in a way that is convenient to use for a generated OpenAPI specification, but\ncan also be utilized in other use cases as well.\n\n# Custom Types\nTo gain access to the static type information of your custom types at runtime, the easiest way\nis to use the derive macro:\n\n```rust\n# use openapi_type::OpenapiType;\n#[derive(OpenapiType)]\nstruct FooBar {\n\tfoo: String,\n\tbar: u64\n}\n# let schema = FooBar::schema().into_schema();\n# let schema_json = serde_json::to_value(\u0026schema).unwrap();\n# assert_eq!(schema_json, serde_json::json!({\n#   \"type\": \"object\",\n#   \"title\": \"FooBar\",\n#   \"properties\": {\n#     \"foo\": {\n#       \"type\": \"string\"\n#     },\n#     \"bar\": {\n#       \"type\": \"integer\",\n#       \"format\": \"int64\",\n#       \"minimum\": 0\n#     }\n#   },\n#   \"required\": [\"foo\", \"bar\"]\n# }));\n```\n\n# OpenAPI specification\nUsing above type, running `FooBar::schema().into_schema()` yields\n\n```yaml\ntype: object\ntitle: FooBar\nproperties:\n  foo:\n    type: string\n  bar:\n    type: integer\n    format: int64\n    minimum: 0\nrequired:\n  - foo\n  - bar\n```\n\nNote, however, that this is not sufficient for more complex types. If one of your structs fields\nis a type that has a name (that is, `Type::schema().name` is not `None`), above schema will contain\na reference to that schema. Therefore, always remember to put the\n[`dependencies`](OpenapiSchema::dependencies) into the specification alongside the type you are\ninterested in.\n\"##]\n\npub use indexmap;\npub use openapi_type_derive::OpenapiType;\npub use openapiv3 as openapi;\n\nmod impls;\n#[doc(hidden)]\npub mod private;\n\nuse indexmap::IndexMap;\nuse openapi::{Schema, SchemaData, SchemaKind};\n\n/// This struct is used to generate the OpenAPI specification for a particular type. It is already\n/// made available for all primitives and some other types from the rust standard library, and\n/// you can also make your own types provide one through the [OpenapiType] trait and derive macro.\n///\n/// Note that this struct is marked non-exhaustive. This means that new attributes might be added\n/// at any point in time without a breaking change. The only way to obtain a value is through the\n/// [OpenapiSchema::new] method.\n#[derive(Debug, Clone, PartialEq)]\n#[non_exhaustive]\npub struct OpenapiSchema {\n\t/// The name of this schema. If it is None, the schema will be inlined.\n\tpub name: Option\u003cString\u003e,\n\t/// The description of this schema. Optional and only makes sense when a [name] is set as well.\n\tpub description: Option\u003cString\u003e,\n\t/// Whether this particular schema is nullable. Note that there is no guarantee that this will\n\t/// make it into the final specification, it might just be interpreted as a hint to make it\n\t/// an optional parameter.\n\tpub nullable: bool,\n\t/// The actual OpenAPI schema.\n\tpub schema: SchemaKind,\n\t/// Other schemas that this schema depends on. They will be included in the final OpenAPI Spec\n\t/// along with this schema.\n\tpub dependencies: IndexMap\u003cString, OpenapiSchema\u003e\n}\n\nimpl OpenapiSchema {\n\t/// Create a new schema that has no name.\n\tpub fn new(schema: SchemaKind) -\u003e Self {\n\t\tSelf {\n\t\t\tname: None,\n\t\t\tdescription: None,\n\t\t\tnullable: false,\n\t\t\tschema,\n\t\t\tdependencies: IndexMap::new()\n\t\t}\n\t}\n\n\t/// Convert this schema to a [Schema] that can be serialized to the OpenAPI Spec.\n\tpub fn into_schema(self) -\u003e Schema {\n\t\tSchema {\n\t\t\tschema_data: SchemaData {\n\t\t\t\tnullable: self.nullable,\n\t\t\t\ttitle: self.name,\n\t\t\t\tdescription: self.description,\n\t\t\t\t..Default::default()\n\t\t\t},\n\t\t\tschema_kind: self.schema\n\t\t}\n\t}\n}\n\n/**\nThis trait needs to be implemented by every type that is being used in the OpenAPI Spec. It gives\naccess to the [OpenapiSchema] of this type. It is provided for primitive types, String and the\nlike. For use on your own types, there is a derive macro:\n\n```\n# #[macro_use] extern crate openapi_type_derive;\n#\n#[derive(OpenapiType)]\nstruct MyResponse {\n\tmessage: String\n}\n```\n*/\npub trait OpenapiType {\n\tfn schema() -\u003e OpenapiSchema;\n}\n\nimpl\u003c'a, T: ?Sized + OpenapiType\u003e OpenapiType for \u0026'a T {\n\tfn schema() -\u003e OpenapiSchema {\n\t\tT::schema()\n\t}\n}\n","traces":[{"line":107,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":118,"address":[968384,969028],"length":1,"stats":{"Line":4},"fn_name":"into_schema"},{"line":120,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","runner","work","openapi_type","openapi_type","src","private.rs"],"content":"use crate::OpenapiSchema;\nuse indexmap::IndexMap;\n\npub type Dependencies = IndexMap\u003cString, OpenapiSchema\u003e;\n\npub fn add_dependencies(dependencies: \u0026mut Dependencies, other: \u0026mut Dependencies) {\n\twhile let Some((dep_name, dep_schema)) = other.pop() {\n\t\tif !dependencies.contains_key(\u0026dep_name) {\n\t\t\tdependencies.insert(dep_name, dep_schema);\n\t\t}\n\t}\n}\n","traces":[{"line":6,"address":[302141,301712],"length":1,"stats":{"Line":2},"fn_name":"add_dependencies"},{"line":7,"address":[301829,302118,301745],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[302080,301916,302063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[302073,301939],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":4},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","custom_types.rs"],"content":"#![allow(dead_code)]\nuse openapi_type::OpenapiType;\n\nmacro_rules! test_type {\n\t($ty:ty = $json:tt) =\u003e {\n\t\tpaste::paste! {\n\t\t\t#[test]\n\t\t\tfn [\u003c $ty:lower \u003e]() {\n\t\t\t\tlet schema = \u003c$ty as OpenapiType\u003e::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(\u0026schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t}\n\t\t}\n\t};\n}\n\n#[derive(OpenapiType)]\nstruct UnitStruct;\ntest_type!(UnitStruct = {\n\t\"type\": \"object\",\n\t\"title\": \"UnitStruct\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\nstruct SimpleStruct {\n\tfoo: String,\n\tbar: isize\n}\ntest_type!(SimpleStruct = {\n\t\"type\": \"object\",\n\t\"title\": \"SimpleStruct\",\n\t\"properties\": {\n\t\t\"foo\": {\n\t\t\t\"type\": \"string\"\n\t\t},\n\t\t\"bar\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"foo\", \"bar\"]\n});\n\n#[derive(OpenapiType)]\n#[openapi(rename = \"FooBar\")]\nstruct StructRename;\ntest_type!(StructRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FooBar\",\n\t\"additionalProperties\": false\n});\n\n#[derive(OpenapiType)]\nenum EnumWithoutFields {\n\tSuccess,\n\tError\n}\ntest_type!(EnumWithoutFields = {\n\t\"type\": \"string\",\n\t\"title\": \"EnumWithoutFields\",\n\t\"enum\": [\n\t\t\"Success\",\n\t\t\"Error\"\n\t]\n});\n\n#[derive(OpenapiType)]\nenum EnumWithOneField {\n\tSuccess { value: isize }\n}\ntest_type!(EnumWithOneField = {\n\t\"type\": \"object\",\n\t\"title\": \"EnumWithOneField\",\n\t\"properties\": {\n\t\t\"Success\": {\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"value\": {\n\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"value\"]\n\t\t}\n\t},\n\t\"required\": [\"Success\"]\n});\n\n#[derive(OpenapiType)]\nenum EnumWithFields {\n\tSuccess { value: isize },\n\tError { msg: String }\n}\ntest_type!(EnumWithFields = {\n\t\"title\": \"EnumWithFields\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Success\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Success\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Error\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"msg\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"msg\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Error\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\nenum EnumExternallyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumExternallyTagged = {\n\t\"title\": \"EnumExternallyTagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"Success\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"Success\"]\n\t}, {\n\t\t\"type\": \"string\",\n\t\t\"enum\": [\"Empty\", \"Error\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\n#[openapi(tag = \"ty\")]\nenum EnumInternallyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumInternallyTagged = {\n\t\"title\": \"EnumInternallyTagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t},\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Success\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\", \"ty\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Empty\", \"Error\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\n#[openapi(tag = \"ty\", content = \"ct\")]\nenum EnumAdjacentlyTagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumAdjacentlyTagged = {\n\t\"title\": \"EnumAdjacentlyTagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Success\"]\n\t\t\t},\n\t\t\t\"ct\": {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\", \"ct\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"ty\": {\n\t\t\t\t\"type\": \"string\",\n\t\t\t\t\"enum\": [\"Empty\", \"Error\"]\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"ty\"]\n\t}]\n});\n\n#[derive(OpenapiType)]\n#[openapi(untagged)]\nenum EnumUntagged {\n\tSuccess { value: isize },\n\tEmpty,\n\tError\n}\ntest_type!(EnumUntagged = {\n\t\"title\": \"EnumUntagged\",\n\t\"oneOf\": [{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"value\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"required\": [\"value\"]\n\t}, {\n\t\t\"type\": \"object\",\n\t\t\"additionalProperties\": false\n\t}]\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","custom_types_attrs.rs"],"content":"#![allow(dead_code)]\nuse openapi_type::OpenapiType;\n\nmacro_rules! test_type {\n\t($ty:ty = $json:tt) =\u003e {\n\t\tpaste::paste! {\n\t\t\t#[test]\n\t\t\tfn [\u003c $ty:lower \u003e]() {\n\t\t\t\tlet schema = \u003c$ty as OpenapiType\u003e::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(\u0026schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t}\n\t\t}\n\t};\n}\n\n/// Very cool struct!\n#[derive(OpenapiType)]\nstruct ContainerDoc {\n\t/// Very important!\n\tfoo: String\n}\ntest_type!(ContainerDoc = {\n\t\"type\": \"object\",\n\t\"title\": \"ContainerDoc\",\n\t\"description\": \"Very cool struct!\",\n\t\"properties\": {\n\t\t\"foo\": {\n\t\t\t\"type\": \"string\",\n\t\t\t\"description\": \"Very important!\"\n\t\t}\n\t},\n\t\"required\": [\"foo\"]\n});\n\n#[derive(OpenapiType)]\n#[openapi(rename = \"FooBar\")]\nstruct ContainerRename;\ntest_type!(ContainerRename = {\n\t\"type\": \"object\",\n\t\"title\": \"FooBar\",\n\t\"additionalProperties\": false\n});\n\nmacro_rules! test_rename_all {\n\t(rename_all = $rename_all:literal, foo_bar = $foo_bar:literal) =\u003e {\n\t\tpaste::paste! {\n\t\t\t#[derive(OpenapiType, serde::Serialize)]\n\t\t\t#[openapi(rename = \"FooBar\")]\n\t\t\t#[serde(rename_all = $rename_all)]\n\t\t\t#[allow(non_camel_case_types, non_snake_case)]\n\t\t\tstruct [\u003c ContainerRenameAll_ $rename_all \u003e] {\n\t\t\t\tfoo_bar: Option\u003c\u0026'static str\u003e,\n\t\t\t}\n\t\t\ttest_type!([\u003c ContainerRenameAll_ $rename_all \u003e] = {\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"title\": \"FooBar\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t$foo_bar: {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t});\n\t\t\t#[test]\n\t\t\tfn [\u003c containerrenameall_ $rename_all:lower _serde \u003e]() {\n\t\t\t\tlet value = [\u003c ContainerRenameAll_ $rename_all \u003e] {\n\t\t\t\t\tfoo_bar: Some(\"foo_bar\"),\n\t\t\t\t};\n\t\t\t\tlet json = serde_json::to_value(\u0026value).unwrap();\n\t\t\t\tlet expected = serde_json::json!({\n\t\t\t\t\t$foo_bar: \"foo_bar\",\n\t\t\t\t});\n\t\t\t\tpretty_assertions::assert_eq!(json, expected);\n\t\t\t}\n\t\t}\n\t};\n}\n\ntest_rename_all!(rename_all = \"lowercase\", foo_bar = \"foo_bar\");\ntest_rename_all!(rename_all = \"UPPERCASE\", foo_bar = \"FOO_BAR\");\ntest_rename_all!(rename_all = \"PascalCase\", foo_bar = \"FooBar\");\ntest_rename_all!(rename_all = \"camelCase\", foo_bar = \"fooBar\");\ntest_rename_all!(rename_all = \"snake_case\", foo_bar = \"foo_bar\");\ntest_rename_all!(rename_all = \"SCREAMING_SNAKE_CASE\", foo_bar = \"FOO_BAR\");\ntest_rename_all!(rename_all = \"kebab-case\", foo_bar = \"foo-bar\");\ntest_rename_all!(rename_all = \"SCREAMING-KEBAB-CASE\", foo_bar = \"FOO-BAR\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","enum_with_no_variants.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nenum Foo {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","not_openapitype.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo {\n\tbar: Bar\n}\n\nstruct Bar;\n\nfn main() {\n\tFoo::schema();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","not_openapitype_generics.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo\u003cT\u003e {\n\tbar: T\n}\n\nstruct Bar;\n\nfn main() {\n\t\u003cFoo\u003cBar\u003e\u003e::schema();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","tuple_struct.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nstruct Foo(i64, i64);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","tuple_variant.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nenum Foo {\n\tPair(i64, i64)\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","union.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\nunion Foo {\n\tsigned: i64,\n\tunsigned: u64\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","fail","unknown_attribute.rs"],"content":"use openapi_type::OpenapiType;\n\n#[derive(OpenapiType)]\n#[openapi(pizza)]\nstruct Foo;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","std_types.rs"],"content":"#[cfg(feature = \"chrono\")]\nuse chrono::{Date, DateTime, FixedOffset, NaiveDate, NaiveDateTime, Utc};\nuse indexmap::{IndexMap, IndexSet};\nuse openapi_type::OpenapiType;\nuse serde_json::Value;\nuse std::{\n\tcollections::{BTreeMap, BTreeSet, HashMap, HashSet},\n\tnum::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize}\n};\n#[cfg(feature = \"uuid\")]\nuse uuid::Uuid;\n\nmacro_rules! test_type {\n\t($($ty:ident $(\u003c$($generic:ident),+\u003e)*),* = $json:tt) =\u003e {\n\t\tpaste::paste! { $(\n\t\t\t#[test]\n\t\t\tfn [\u003c $ty:lower $($(_ $generic:lower)+)* \u003e]() {\n\t\t\t\tlet schema = \u003c$ty $(\u003c$($generic),+\u003e)* as OpenapiType\u003e::schema();\n\t\t\t\tlet schema = openapi_type::OpenapiSchema::into_schema(schema);\n\t\t\t\tlet schema_json = serde_json::to_value(\u0026schema).unwrap();\n\t\t\t\tlet expected = serde_json::json!($json);\n\t\t\t\tpretty_assertions::assert_eq!(schema_json, expected);\n\t\t\t}\n\t\t)* }\n\t};\n}\n\ntype Unit = ();\ntest_type!(Unit = {\n\t\"type\": \"object\",\n\t\"additionalProperties\": false\n});\n\ntest_type!(Value = {\n\t\"nullable\": true\n});\n\ntest_type!(bool = {\n\t\"type\": \"boolean\"\n});\n\n// ### integer types\n\ntest_type!(isize = {\n\t\"type\": \"integer\"\n});\n\ntest_type!(usize = {\n\t\"type\": \"integer\",\n\t\"minimum\": 0\n});\n\ntest_type!(i8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\"\n});\n\ntest_type!(u8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\",\n\t\"minimum\": 0\n});\n\ntest_type!(i16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\"\n});\n\ntest_type!(u16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\",\n\t\"minimum\": 0\n});\n\ntest_type!(i32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\"\n});\n\ntest_type!(u32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\",\n\t\"minimum\": 0\n});\n\ntest_type!(i64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\"\n});\n\ntest_type!(u64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\",\n\t\"minimum\": 0\n});\n\ntest_type!(i128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\"\n});\n\ntest_type!(u128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\",\n\t\"minimum\": 0\n});\n\n// ### non-zero integer types\n\ntest_type!(NonZeroUsize = {\n\t\"type\": \"integer\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU8 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int8\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU16 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int16\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU32 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int32\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU64 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int64\",\n\t\"minimum\": 1\n});\n\ntest_type!(NonZeroU128 = {\n\t\"type\": \"integer\",\n\t\"format\": \"int128\",\n\t\"minimum\": 1\n});\n\n// ### floats\n\ntest_type!(f32 = {\n\t\"type\": \"number\",\n\t\"format\": \"float\"\n});\n\ntest_type!(f64 = {\n\t\"type\": \"number\",\n\t\"format\": \"double\"\n});\n\n// ### string\n\ntest_type!(String = {\n\t\"type\": \"string\"\n});\n\n#[cfg(feature = \"uuid\")]\ntest_type!(Uuid = {\n\t\"type\": \"string\",\n\t\"format\": \"uuid\"\n});\n\n// ### date/time\n\n#[cfg(feature = \"chrono\")]\ntest_type!(Date\u003cFixedOffset\u003e, Date\u003cUtc\u003e, NaiveDate = {\n\t\"type\": \"string\",\n\t\"format\": \"date\"\n});\n\n#[cfg(feature = \"chrono\")]\ntest_type!(DateTime\u003cFixedOffset\u003e, DateTime\u003cUtc\u003e, NaiveDateTime = {\n\t\"type\": \"string\",\n\t\"format\": \"date-time\"\n});\n\n// ### some std types\n\ntest_type!(Option\u003cString\u003e = {\n\t\"type\": \"string\",\n\t\"nullable\": true\n});\n\ntest_type!(Vec\u003cString\u003e = {\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"string\"\n\t}\n});\n\ntest_type!(BTreeSet\u003cString\u003e, IndexSet\u003cString\u003e, HashSet\u003cString\u003e = {\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"string\"\n\t},\n\t\"uniqueItems\": true\n});\n\ntest_type!(BTreeMap\u003cisize, String\u003e, IndexMap\u003cisize, String\u003e, HashMap\u003cisize, String\u003e = {\n\t\"type\": \"object\",\n\t\"properties\": {\n\t\t\"default\": {\n\t\t\t\"type\": \"integer\"\n\t\t}\n\t},\n\t\"required\": [\"default\"],\n\t\"additionalProperties\": {\n\t\t\"type\": \"string\"\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","openapi_type","openapi_type","tests","trybuild.rs"],"content":"use trybuild::TestCases;\n\n#[test]\nfn trybuild() {\n\tlet t = TestCases::new();\n\tt.compile_fail(\"tests/fail/*.rs\");\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>